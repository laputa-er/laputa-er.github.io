<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="构造系统," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="诞生：1977
1 GNU Make 编程语言GNU Make 语言可以堪称是由 3 种单独的编程语言整合而成，分别是

文件依赖：这是一种基于规则的语法，用来描述文件之间的依赖关系。

1myprog: prog.c lib.c

Shell 命令：这是封装在每条规则之中的 shell 命令清单，如果发现规则对应的标的文件“过期”了，就执行相应的 shell 命令。

123cp myfile">
<meta property="og:type" content="article">
<meta property="og:title" content="SBS_06 Make">
<meta property="og:url" content="http://laputa-er.github.io/2017/02/13/SBS_06 Make/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="诞生：1977
1 GNU Make 编程语言GNU Make 语言可以堪称是由 3 种单独的编程语言整合而成，分别是

文件依赖：这是一种基于规则的语法，用来描述文件之间的依赖关系。

1myprog: prog.c lib.c

Shell 命令：这是封装在每条规则之中的 shell 命令清单，如果发现规则对应的标的文件“过期”了，就执行相应的 shell 命令。

123cp myfile">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/CC65EAA8-844D-4C1E-9D39-F69302AB2232.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/58DB091B-B53C-44F7-A4FC-08F1C2495228.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/618FBFA5-B926-482E-8385-01C96C88A858.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/64A00628-C75E-481A-B21C-42122EB3B7A2.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/4BF1FB3B-F143-471A-9711-9A0AADE9F732.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/B26F6B55-26A7-46BB-A49D-ADF85FBEA46F.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/DAE6E76E-FFA0-4067-A28A-8A9ABF1D7083.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/32441DCC-E092-40BB-930F-AE1005D5E51B.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/822F7514-D4E2-4A0F-B2BE-F5C5F3B649C3.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/2A4A5092-50A0-4D26-94E6-196CD62B606E.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/19CFF532-32E7-42D3-87D7-C26F388C70CC.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/B612B82D-4D36-46E0-AE4B-BC595952CAC8.png">
<meta property="og:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/69A824BA-56FE-45BD-B0D5-3307DFE2CB8B.png">
<meta property="og:updated_time" content="2017-02-12T17:28:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SBS_06 Make">
<meta name="twitter:description" content="诞生：1977
1 GNU Make 编程语言GNU Make 语言可以堪称是由 3 种单独的编程语言整合而成，分别是

文件依赖：这是一种基于规则的语法，用来描述文件之间的依赖关系。

1myprog: prog.c lib.c

Shell 命令：这是封装在每条规则之中的 shell 命令清单，如果发现规则对应的标的文件“过期”了，就执行相应的 shell 命令。

123cp myfile">
<meta name="twitter:image" content="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/CC65EAA8-844D-4C1E-9D39-F69302AB2232.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/2017/02/13/SBS_06 Make/"/>

  <title> SBS_06 Make | Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?898688f51c5a3d6b37dd23e04441e5bd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SBS_06 Make
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-13T00:03:42+08:00" content="2017-02-13">
              2017-02-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/深入理解软件构造系统-原理与最佳实践/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解软件构造系统-原理与最佳实践</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/13/SBS_06 Make/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/13/SBS_06 Make/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>诞生：1977</p>
<h1 id="1-GNU-Make-编程语言"><a href="#1-GNU-Make-编程语言" class="headerlink" title="1 GNU Make 编程语言"></a>1 GNU Make 编程语言</h1><p>GNU Make 语言可以堪称是由 3 种单独的编程语言整合而成，分别是</p>
<ul>
<li>文件依赖：这是一种基于规则的语法，用来描述文件之间的依赖关系。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myprog: prog.c lib.c</span><br></pre></td></tr></table></figure>
<ul>
<li>Shell 命令：这是封装在每条规则之中的 shell 命令清单，如果发现规则对应的标的文件“过期”了，就执行相应的 shell 命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp myfile yourfile &amp;&amp; cp myfile1 yourfile1</span><br><span class="line">md5 &lt; myfile &gt;&gt;yourfile</span><br><span class="line">touch yourfile.done</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串处理：这是用来操作 CNU Make 变量的语言，例如把变量当作值的列表来处理。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARS := $(sort $(filter srcs-% cflags-%, $(.VARIABLES)))</span><br></pre></td></tr></table></figure>
<h2 id="1-1-makefile-规则：用来建立依赖关系图"><a href="#1-1-makefile-规则：用来建立依赖关系图" class="headerlink" title="1.1 makefile 规则：用来建立依赖关系图"></a>1.1 makefile 规则：用来建立依赖关系图</h2><p><strong>说明：</strong>规则的实际执行状况是由<code>依赖关系图</code>和<code>源文件和标的文件的时间戳</code>共同决定了。而依赖关系图是根据标的文件名的匹配来实现的，事实上，标的文件可以包含通配符和变量名，因此对匹配规则的查找定位并不总是那么简单。</p>
<h3 id="makefile-规则语法"><a href="#makefile-规则语法" class="headerlink" title="makefile 规则语法"></a>makefile 规则语法</h3><p><strong>说明：</strong>一个 makefile 中包含多个规则，每个规则描述如何根据若干<code>预备输入文件</code>(prerequisites)，生成特定的<code>标的文件</code>(target)。</p>
<p>规则的最基本形式是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标的：预备输入文件</span><br><span class="line">[tab]shell命令序列</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖关系图"><a href="#依赖关系图" class="headerlink" title="依赖关系图"></a>依赖关系图</h3><p><strong>说明：</strong>依赖关系图决定了某个或某些文件的更新后，哪些规则会被重新执行。</p>
<p>举例说明</p>
<p><strong>目录关系</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── calc.c</span><br><span class="line">    ├── mult.c</span><br><span class="line">    ├── numbers.h</span><br><span class="line">    └── sub.c</span><br></pre></td></tr></table></figure>
<p><strong>程序结构</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/CC65EAA8-844D-4C1E-9D39-F69302AB2232.png" alt=""></p>
<p><strong>依赖关系图</strong><br>连线代表依赖关系，依赖的标的可以是<code>源文件</code>、<code>中间文件</code> 甚至是 <code>其它规则</code>。</p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/58DB091B-B53C-44F7-A4FC-08F1C2495228.png" alt=""></p>
<p><strong>规则描述文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">calculator: add.o calc.o mult.o sub.o</span><br><span class="line">	gcc -g -o calculator add.o calc.o mult.o sub.o</span><br><span class="line">add.o: add.c numbers.h</span><br><span class="line">	gcc -g -c add.c</span><br><span class="line">calc.o: calc.c numbers.h</span><br><span class="line">	gcc -g -c calc.c</span><br><span class="line">mult.o: mult.c numbers.h</span><br><span class="line">	gcc -g -c mult.c</span><br><span class="line">sub.o: sub.c numbers.h</span><br><span class="line">	gcc -g -c sub.c</span><br></pre></td></tr></table></figure>
<h2 id="1-2-makefile-规则的类型"><a href="#1-2-makefile-规则的类型" class="headerlink" title="1.2 makefile 规则的类型"></a>1.2 makefile 规则的类型</h2><p>GNU Make 是一种灵活而强大的语言，包含许多用来表达文件间关系的语法特性。下面就介绍几种常用的</p>
<h3 id="1-2-1-多个标的文件"><a href="#1-2-1-多个标的文件" class="headerlink" title="1.2.1 多个标的文件"></a>1.2.1 多个标的文件</h3><p><strong>说明：</strong> 规则的左边可以有多个标的。<br><strong>应用：</strong> 当左边的多个标的文件有同样的<code>预备文件集合</code>，并且可以由相同的 <code>shell 命令列表</code>生成，就可以用这种快捷语法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file1.o file2.o: <span class="built_in">source</span>1.c <span class="built_in">source</span>2.c <span class="built_in">source</span>3.c</span><br><span class="line">	shell命令列表</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-没有预备文件的规则"><a href="#1-2-2-没有预备文件的规则" class="headerlink" title="1.2.2 没有预备文件的规则"></a>1.2.2 没有预备文件的规则</h3><p><strong>应用：</strong>有时你像定义一个不依赖任何预备文件的标的文件，就可以用这种语法，来定义不与实际磁盘文件关联的<code>伪标的文件</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONE: <span class="built_in">help</span> <span class="comment"># 该指令确保 GNU Make 知道 help 与磁盘文件无关</span></span><br><span class="line"><span class="built_in">help</span>: <span class="comment"># 显示开发人员可以使用的命令清单</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">"Usage: make all ARCH=[i386|mips]"</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">"       make clean"</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-有文件名模式的规则"><a href="#1-2-3-有文件名模式的规则" class="headerlink" title="1.2.3 有文件名模式的规则"></a>1.2.3 有文件名模式的规则</h3><p><strong>说明：</strong> 通过使用通配符<code>%</code>，一些相似的规则可以合并成一条规则，举例来说</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">calculator: add.o calc.o mult.o sub.o</span><br><span class="line">	gcc -g -o calculator add.o calc.o mult.o sub.o</span><br><span class="line">add.o: add.c numbers.h</span><br><span class="line">	gcc -g -c add.c</span><br><span class="line">calc.o: calc.c numbers.h</span><br><span class="line">	gcc -g -c calc.c</span><br><span class="line">mult.o: mult.c numbers.h</span><br><span class="line">	gcc -g -c mult.c</span><br><span class="line">sub.o: sub.c numbers.h</span><br><span class="line">	gcc -g -c sub.c</span><br></pre></td></tr></table></figure>
<p>上面的例子中，每个目标文件都依赖于相应的 C 语言文件。规则的标的部分，本质上就是一种匹配语法。通过通配符的匹配方式简化上面的案例，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calculator: add.o calc.o mult.o sub.o</span><br><span class="line">	gcc -g -o calculator add.o calc.o mult.o sub.o</span><br><span class="line">%.o: %.c <span class="comment"># 标的文件以 .o 结尾，预备文件以 .c 结尾，且二者的开否字符（柄， stem）完全相同</span></span><br><span class="line">	gcc -g -c $^</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-只适用于某些文件的规则"><a href="#1-2-4-只适用于某些文件的规则" class="headerlink" title="1.2.4 只适用于某些文件的规则"></a>1.2.4 只适用于某些文件的规则</h3><p><strong>说明：</strong>  就是在为上一节的匹配设置匹配范围。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calculator: add.o calc.o mult.o sub.o</span><br><span class="line">	gcc -g -o calculator add.o calc.o mult.o sub.o</span><br><span class="line">add.o calc.o mult.o sub.o: %.o: %.c <span class="comment"># 指定匹配的清单，缩小匹配的范围，匹配的清单建议使用变量</span></span><br><span class="line">	gcc -g -c $^</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-有相同标文件的多个匹配"><a href="#1-2-5-有相同标文件的多个匹配" class="headerlink" title="1.2.5 有相同标文件的多个匹配"></a>1.2.5 有相同标文件的多个匹配</h3><p><strong>说明：</strong> 虽然可以在一个规则行中，定义标的文件对应的多个预备文件，单如果把他们切分成多个规则，常常更有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calculator: add.o calc.o mult.o sub.o</span><br><span class="line">	gcc -g -o calculator add.o calc.o mult.o sub.o</span><br><span class="line">add.o calc.o mult.o sub.o: %.o: %.c</span><br><span class="line">	gcc -g -c $^</span><br><span class="line">%.o: numbers.h <span class="comment"># 用来补充预备文件</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-makefile-变量"><a href="#1-3-makefile-变量" class="headerlink" title="1.3 makefile 变量"></a>1.3 makefile 变量</h2><h3 id="1-3-1-基本用法"><a href="#1-3-1-基本用法" class="headerlink" title="1.3.1 基本用法"></a>1.3.1 基本用法</h3><p><strong>说明：</strong> GNU Make 变量与其它编程语言的变量类似，但有一些独特的行为特征。规则如下</p>
<ul>
<li>变量的值是通过赋值获得的，赋值有多重形式。</li>
<li>访问变量值的语法是 <code>$(X)</code>。</li>
<li>所有变量都是字符串型，且没有所谓的变量声明，变量第一次赋值就是变量的定义过程。</li>
<li>变量是全局类型。</li>
<li>变量名可以包含大小写字母、数组和标点符号（例如 @、^、&lt; 和 &gt;）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIRST := Hello there</span><br><span class="line">SECOND := World <span class="comment"># components go here</span></span><br><span class="line">MESSAGE := $(FIRST) $(SECOND)</span><br><span class="line">FILES := add.c sub.c mult.c</span><br><span class="line">$(info $(MESSAGE) - The files are $(FILES)) // $(info …) <span class="comment"># Hello there World - The files are add.c sub.c mult.c</span></span><br></pre></td></tr></table></figure>
<p>其中， $(info …) 指令用于在输出设备上显示消息。</p>
<h3 id="1-3-2-赋值语句"><a href="#1-3-2-赋值语句" class="headerlink" title="1.3.2 赋值语句"></a>1.3.2 赋值语句</h3><p><strong>说明：</strong> 有 3 种赋值语句类型</p>
<h4 id="1-立即求值"><a href="#1-立即求值" class="headerlink" title="(1) 立即求值"></a>(1) 立即求值</h4><p><strong>操作符：</strong> :=<br><strong>说明：</strong>赋值语句的右边经过完全求值，形成常量字符串，然后赋值给左边的变量。<br><strong>应用：</strong> 最现代的编程语言在其赋值语句中，都使用这种立即求值方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FIRST := Hello there</span><br><span class="line">SECOND := World</span><br><span class="line">MESSAGE := $(FIRST) $(SECOND)</span><br></pre></td></tr></table></figure>
<h4 id="2-延迟求值"><a href="#2-延迟求值" class="headerlink" title="(2) 延迟求值"></a>(2) 延迟求值</h4><p><strong>操作符：</strong> =<br><strong>说明：</strong> 不是立即将其转换为常量字符串，而是知道实际使用变量时再进行求值。<br><strong>应用：</strong> 这一特性看上去有点怪异，但这种先定义变量然后再修改其中个别部分的能力，在某些情况下很有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">CCOMP = $(CC) $(CFLAGS) <span class="comment"># 延迟求值</span></span><br><span class="line">$(info Compiler is $(CCOMP))</span><br><span class="line">CC := i386-linux-gcc</span><br><span class="line">$(info Compiler is $(CCOMP)) <span class="comment"># i386-linux-gcc -g</span></span><br></pre></td></tr></table></figure>
<h4 id="3-条件赋值"><a href="#3-条件赋值" class="headerlink" title="(3) 条件赋值"></a>(3) 条件赋值</h4><p><strong>操作符：</strong>?=<br><strong>说明：</strong> 如果变量没有值，才会真正执行赋值，否则什么也不做。<br><strong>应用：</strong>在将另一个 makefile 引入到自己的 makefile 中，不能确定父文件是否定义了某个变量的情况下，这一特性就很有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -g</span><br><span class="line">CFLAGS ?= -O <span class="comment"># 由于 CFLAGS 已经有了，因此这步赋值会被忽略</span></span><br></pre></td></tr></table></figure>
<h2 id="1-4-内置变量和规则"><a href="#1-4-内置变量和规则" class="headerlink" title="1.4 内置变量和规则"></a>1.4 内置变量和规则</h2><h3 id="1-4-1-自动变量"><a href="#1-4-1-自动变量" class="headerlink" title="1.4.1 自动变量"></a>1.4.1 自动变量</h3><p><strong>解释：</strong> 内置的变量，变量的值根据随处的环境自动设定，因而称为<code>自动变量 (automatic variable)</code>。</p>
<p>列举几个自动变量|值|应用场景<br>—|—|—<br>$@|当前规则的<code>标的文件名</code>|当规则使用通配符来匹配标的文件名时，用这个自动变量非常方便，无须把任何具体文件名硬编码在规则中。<br>$&lt;|规则的第一个预备文件名|和 $@ 配合使用，应用于使用了通配符的场景。<br>$^|规则中所有预备文件的完整清单（各文件名之间以空格隔开）|和 $@ 配合使用，应用于使用了通配符的场景。<br>$(@D)|标的文件所在目录的绝对路径|当诸如 <code>mkdir</code> 等 shell 命令需要操作标的文件所在目录时，这个自动变量时很有用的。<br>$(@F)|同$@，标的文件的文件名|自动插入标的文件名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c numbers.h</span><br><span class="line">	gcc -g -o <span class="variable">$@</span> $&lt;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-内置规则"><a href="#1-4-2-内置规则" class="headerlink" title="1.4.2 内置规则"></a>1.4.2 内置规则</h3><h4 id="1-通配符规则"><a href="#1-通配符规则" class="headerlink" title="(1) 通配符规则"></a>(1) 通配符规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.o calc.o mult.o sub.o</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := </span><br><span class="line">OBJS := $(SRCS:.c = .o)</span><br><span class="line"></span><br><span class="line">$(PROG):$(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -o <span class="variable">$@</span> $^</span><br><span class="line">$(OBJS): numbers.h</span><br><span class="line"><span class="comment"># 内置规则 --- 通配符规则，所有目标文件的生成都匹配到这条规则</span></span><br><span class="line">$(OBJS): %.o: %.c</span><br><span class="line">	$(CC) $(CFLAGS) -o <span class="variable">$@</span> -c $&lt;</span><br></pre></td></tr></table></figure>
<h4 id="2-隐式规则"><a href="#2-隐式规则" class="headerlink" title="(2) 隐式规则"></a>(2) 隐式规则</h4><p><strong>说明：</strong>所有指定如何将 c 源文件编译成目标文件的规则，都可以从 makefile 中去掉，因为隐士规则已经处理了这种情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.o calc.o mult.o sub.o</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">OBJS := $(SRCS:.c = .o)</span><br><span class="line"></span><br><span class="line">$(PROG): $(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -o  <span class="variable">$@</span> $^</span><br><span class="line">$(OBJS): numbers.h</span><br></pre></td></tr></table></figure>
<h2 id="1-5-数据结构与函数"><a href="#1-5-数据结构与函数" class="headerlink" title="1.5 数据结构与函数"></a>1.5 数据结构与函数</h2><p><strong>说明：</strong> 所有GNU Make 变量都是字符串类型，但 GNU Make 提供了许多特性使字符串表达数字、列表、结构等其它数据类型。</p>
<h3 id="1-5-1-字符串处理函数"><a href="#1-5-1-字符串处理函数" class="headerlink" title="1.5.1 字符串处理函数"></a>1.5.1 字符串处理函数</h3><p>常用的字符串处理函数|功能描述<br>—|—<br>words|对于给定的输入列表，返回列表中单词（以空格区分）的个数<br>word|对于给定的输入列表，从中摘取出第 n 个单词（下标从0开始）<br>filter|返回列表中与特定模式相匹配的单词，常用语筛选中与特定文件名模式相匹配的文件子集<br>patsubst|对于类表中的每个单词，将于特定模式相匹配的单词替换成指定的样子（%表示单词中不变的部分）<br>addprefix|为列表中的每个单词附加一个前缀字符串<br>foreach|读取列表中每个单词，并生成新列表（映射表达式可由 GNU Make 中的任何函数调用组成）<br>dir|对于给定的文件的绝对路径，返回其中的目录部分<br>nodir|对于给定的文件的绝对路径，返回文件名部分<br>shell|执行 shell 命令，并以字符串形式返回命令的输出结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PROG_NAME := my-calculator <span class="comment"># 普通字符串</span></span><br><span class="line">LIST_OF_SRCS := calc.c main.c math.h lib.c <span class="comment"># 列表</span></span><br><span class="line">COLORS := red FF000 green 00FF00 blue 0000FF purple FF00FF <span class="comment"># 字典</span></span><br><span class="line">ORDERS := 100 green cups 200 blue plates <span class="comment"># 结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># words</span></span><br><span class="line">NUM_FILES := $(words $(LIST_OF_SRCS)) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># word</span></span><br><span class="line">SECOND_FILE := $(word 2, $(LIST_OF_SRCS)) <span class="comment"># main.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter</span></span><br><span class="line">C_SRCS := $(filter %.c, $(LIST_OF_SRCS)) <span class="comment"># calc.c main.c lib.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># patsubst</span></span><br><span class="line">OBJECTS := $(patsubst %.c,%.o, $(C_SRCS)) <span class="comment"># calc.o main.o lib.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># addprefix</span></span><br><span class="line">OBJ_LIST := $(addprefix objs/, $(OBJECTS)) <span class="comment"># objs/calc.o objs/main.o objs/lib.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foreach</span></span><br><span class="line">OBJ_LIST_2 := $(foreach file, $(OBJECTS), objs/$(file)) <span class="comment"># objs/calc.o objs/main.o objs/lib.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir</span></span><br><span class="line">DEFN_PATH := src/headers/idl/interface.idl</span><br><span class="line">DEFN_DIR := $(dir $(DEFN_PATH)) <span class="comment"># src/headers/idl/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># notdir</span></span><br><span class="line">DEFN_BASENAME := $(notdir $(DEFN_PATH)) <span class="comment"># interface.idl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell</span></span><br><span class="line">PASSWD_OWNER := $(word 3, $(shell ls <span class="_">-l</span> /etc/passwd)) <span class="comment"># root</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-GNU-Make-宏"><a href="#1-5-2-GNU-Make-宏" class="headerlink" title="1.5.2 GNU Make 宏"></a>1.5.2 GNU Make 宏</h3><p><strong>说明：</strong> CNU Make 也有宏这一概念，定义宏和定义变量类似。通过宏，可以为复杂的 GNU Make 表达式命名，并向表达式传递参数。<br><strong>应用：</strong> 利用宏编写自己的 GNU Make 函数，有效地扩展基础语言。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义宏：查看文件的大小</span></span><br><span class="line">file_size = $(word 5, $(shell ls <span class="_">-l</span> $(1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用宏</span></span><br><span class="line">PASSWD_SIZE := $(call file_size,/etc/passwd) <span class="comment"># 5925</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-define-指令"><a href="#1-5-2-define-指令" class="headerlink" title="1.5.2 define 指令"></a>1.5.2 define 指令</h3><p><strong>说明：</strong> 用来定义一个 shell 命令的封装序列。<br><strong>应用：</strong> 在 GNU Make 规则中指定要执行的 shell 命令时，就不必每次都写出这些命令，而是通过调用封住序列的形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 define 定义一个 shell 命令的封装序列 start-banner</span></span><br><span class="line">define start-banner</span><br><span class="line">	@<span class="built_in">echo</span> ==============</span><br><span class="line">	@<span class="built_in">echo</span> Starting build</span><br><span class="line">	@<span class="built_in">echo</span> ==============</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all:</span><br><span class="line">	<span class="comment"># 调用 start-banner</span></span><br><span class="line">	$(start-banner)</span><br><span class="line">	$(MAKE) -C lib1</span><br></pre></td></tr></table></figure>
<h2 id="1-6-理解构造程序执行流程"><a href="#1-6-理解构造程序执行流程" class="headerlink" title="1.6 理解构造程序执行流程"></a>1.6 理解构造程序执行流程</h2><h3 id="1-6-1-make-命令调用后"><a href="#1-6-1-make-命令调用后" class="headerlink" title="1.6.1 make 命令调用后"></a>1.6.1 make 命令调用后</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/618FBFA5-B926-482E-8385-01C96C88A858.png" alt=""></p>
<p>强调一下，变量在第一阶段赋值，shell 命令在第二阶段执行！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X := Hello World</span><br><span class="line"><span class="built_in">print</span>:</span><br><span class="line">	<span class="built_in">echo</span> X is $(X) <span class="comment"># Goodbye</span></span><br><span class="line">X := Goodbye</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-文件包含和条件编译"><a href="#1-6-2-文件包含和条件编译" class="headerlink" title="1.6.2 文件包含和条件编译"></a>1.6.2 文件包含和条件编译</h3><p><strong>说明：</strong> GNU Make 提供了一些特性，使我们对更灵活地使用调整构造过程 ，它们是</p>
<ul>
<li>文件包含（类似 c 语言的文件包含）</li>
<li>条件编译（类似 c 语言的条件编译）</li>
</ul>
<p>它们都在第一阶段，也就是 makefile 解析阶段，就会被处理。</p>
<p><em>文件包含</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILES := src1.c src2.c</span><br><span class="line">include prog.mk <span class="comment"># 将 prog.mk 的内容插入到这里</span></span><br><span class="line">src.1.o src.2.o: src.h</span><br></pre></td></tr></table></figure>
<p><em>条件编译</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -DPATH</span><br><span class="line">ifdef DEBUG</span><br><span class="line">	CFLAGS += -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	CFLAGS += -o</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="1-6-3-依赖关系图生成算法"><a href="#1-6-3-依赖关系图生成算法" class="headerlink" title="1.6.3 依赖关系图生成算法"></a>1.6.3 依赖关系图生成算法</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/64A00628-C75E-481A-B21C-42122EB3B7A2.png" alt=""></p>
<h2 id="1-7-进一步阅读资料"><a href="#1-7-进一步阅读资料" class="headerlink" title="1.7 进一步阅读资料"></a>1.7 进一步阅读资料</h2><p><a href="http://www.gnu.org/software/make/" target="_blank" rel="external">在线文档</a><br>入门级指导-Mecklenburg,Robert.2005.《Managing Project with GNU Make》.Sebastopol,CA:O’Reilly<br><a href="http://gmsl.sourceforge.net/" target="_blank" rel="external">GMU Make 标准库</a></p>
<h1 id="2-现实世界的构造系统场景"><a href="#2-现实世界的构造系统场景" class="headerlink" title="2 现实世界的构造系统场景"></a>2 现实世界的构造系统场景</h1><h2 id="2-1-源代码放在单个目录中"><a href="#2-1-源代码放在单个目录中" class="headerlink" title="2.1 源代码放在单个目录中"></a>2.1 源代码放在单个目录中</h2><h3 id="方案1：最简单"><a href="#方案1：最简单" class="headerlink" title="方案1：最简单"></a>方案1：最简单</h3><p><strong>说明：</strong> 对规模较小的项目来说比较常见。如果要增加新的源代码，只要追加到 SRCS 变量即可。<br><strong>缺点：</strong> 当源代码中引入了头文件的情况发生变化时，比如增加了新的头文件或不在需要某个头文件等，需要大量手工调整。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.c calc.c mult.c sub.c</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">$(PROG):$(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -o <span class="variable">$@</span> $^</span><br><span class="line">$(OBJS): numbers.h</span><br></pre></td></tr></table></figure>
<h3 id="方案2（方案1的改进版）：自动检查头文件"><a href="#方案2（方案1的改进版）：自动检查头文件" class="headerlink" title="方案2（方案1的改进版）：自动检查头文件"></a>方案2（方案1的改进版）：自动检查头文件</h3><p><strong>说明：</strong>  自动检查头文件，对源文件进行扫描，并计算出正确的依赖关系集合。</p>
<p>这个方案涉及到两个之前没有提到的知识点，先对其简要说明，如下</p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p><strong>-MM 选项</strong><br>功能： 针对输入的源文件，返回其引用的 .c 或 .h 文件的清单。<br>应用：*这个清单可以作为一条规则直接应用到 makefile 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MM -g calc.c <span class="comment"># calc.o: calc.c numbers.h</span></span><br></pre></td></tr></table></figure>
<p><strong>-include、sinclude  、include 的区别</strong><br>说明： 如果指示符 include 指定的文件不是以斜线开始（绝对路径，如 /usr/src/Makefile… ），而且当前目录下也不存在此文件；make将根据文件名试图在以下几个目录下查找：首先，查找使用命令行选项<code>-I</code>或者<code>—include-dir</code>指定的目录，如果找到指定的文件，则使用这个文件；否则继续依此搜索以下几个目录（如果其存在）： /usr/gnu/include 、 /usr/local/include 和 /usr/include 。</p>
<p>当在这些目录下都没有找到 include 指定的文件时，make 将会提示一个包含文件未找到的告警提示，但是不会立刻退出。而是继续处理Makefile的后续内容。当完成读取整个 makefile 后，make 将试图使用规则来创建通过指示符 include 指定的但未找到的文件，当不能创建它时（没有创建这个文件的规则），make将提示致命错误并退出。</p>
<p>通常我们在 makefile 中可使用 -include 来代替 include ，来忽略由于包含文件不存在或者无法创建时的错误提示（<code>-</code>的意思是告诉 make ，忽略此操作的错误，make 继续执行）。像下边那样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-include FILENAMES...</span><br></pre></td></tr></table></figure>
<p>使用这种方式时，当所要包含的文件不存在时不会有错误提示，make 也不会退出；除此之外，和第一种方式效果相同。以下是这两种方式的比较：</p>
<ul>
<li>使用 <code>include FILENAMES…</code>，make 程序处理时，如果 <code>FILENAMES</code> 列表中的任何一个文件不能正常读取而且不存在一个创建此文件的规则时 make 程序将会提示错误并退出。</li>
<li>使用<code>-include FILENAMES...</code>的情况是，当所包含的文件不存在或者不存在一个规则去创建它，make 程序会继续执行，只有真正由于不能正确完成终极目标的重建时（某些必需的目标无法在当前已读取的 makefile 文件内容中找到正确的重建规则），才会提示致命错误并退出。</li>
</ul>
<p>为了和其它的make程序进行兼容。也可以使用 sinclude 来代替 -include （GNU所支持的方式）。</p>
<p><strong>linux 命令：sed</strong><br> <a href="http://man.linuxde.net/sed" target="_blank" rel="external">sed命令_Linux sed 命令用法详解：功能强大的流式文本编辑器</a></p>
<p>比如，下面使用 sed 把 <code>calc.o: calc.c numbers.h</code> 转换为了 <code>calc.o calc.h: calc.c numbers.h</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MM -g calc.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; <span class="variable">$@</span> <span class="comment"># calc.o calc.h: calc.c numbers.h</span></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a href="https://github.com/laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY/tree/master/part2/06_make/0602_scene/scene1_single_dir/src" target="_blank" rel="external">SOFTWARE_BUILD_SYSTEM_STUDY/part2/06_make/0602_scene/scene1_single_dir/src at master · laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY · GitHub</a><br>通过下面的 makefile，每当 .c 文件或 .h 文件发生变化，都会重新生成 .d 文件，而 .d 包含源文件对头文件的依赖规则描述。由于通过  <code>-include</code> 引入了所有的 .d 文件，也就更新了依赖关系图，从而实现了依赖关系的自动更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.c calc.c mult.c sub.c</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">OBJS := $(SRCS:.c = .o)</span><br><span class="line"></span><br><span class="line">$(PROG):$(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -o <span class="variable">$@</span> $^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将包含依赖信息的 .d 文件都包含进来</span></span><br><span class="line">-include $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有 .d 文件都会匹配到这个规则来生成</span></span><br><span class="line">%.d: %.c</span><br><span class="line">	$(CC) -MM $(CFLAGS) $&lt; | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h3 id="方案3：使用-makedepend-命令"><a href="#方案3：使用-makedepend-命令" class="headerlink" title="方案3：使用 makedepend 命令"></a>方案3：使用 makedepend 命令</h3><p><strong>说明：</strong> 该工具本质上本质上与 <code>gcc -MM</code> 类似，但它自带用来分析 c 源文件的扫描程序（而非依赖编译器本身）。</p>
<h2 id="2-2-源代码放在多个目录中"><a href="#2-2-源代码放在多个目录中" class="headerlink" title="2.2 源代码放在多个目录中"></a>2.2 源代码放在多个目录中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── calc <span class="comment"># 主程序源码</span></span><br><span class="line">│   └── calc.c</span><br><span class="line">├── libmath <span class="comment"># 静态库源码</span></span><br><span class="line">│   ├── clock.c</span><br><span class="line">│   ├── letter.c</span><br><span class="line">│   ├── libmath.a</span><br><span class="line">│   └── numbers.c</span><br><span class="line">└── libprint <span class="comment"># 静态库源码</span></span><br><span class="line">    ├── banner.c</span><br><span class="line">    ├── center.c</span><br><span class="line">    ├── libprint.a</span><br><span class="line">    └── normal.c</span><br></pre></td></tr></table></figure>
<p>需要的进行如下所示的构造过程。</p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/4BF1FB3B-F143-471A-9711-9A0AADE9F732.png" alt=""></p>
<h3 id="1-方案-a：最简单"><a href="#1-方案-a：最简单" class="headerlink" title="(1) 方案 a：最简单"></a>(1) 方案 a：最简单</h3><p><strong>说明：</strong> 以单个目录中的方案为基础编写 makefile ，需要文件都带有目录路径。<br><strong>应用：</strong> 对简单程序来说正常有效，但对大型程序难以使用。</p>
<p>下面给出我对这种方案的实现。先看下 makefile 文件<br><a href="https://github.com/laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY/tree/master/part2/06_make/0602_scene/scene2_mult_dir_a/src" target="_blank" rel="external">SOFTWARE_BUILD_SYSTEM_STUDY/part2/06_make/0602_scene/scene2_mult_dir_a/src at master · laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY · GitHub</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 静态库</span></span><br><span class="line">LIBMATH := libmath/libmath.a</span><br><span class="line">LIBPRINT := libprint/libprint.a</span><br><span class="line"></span><br><span class="line"># 源文件</span><br><span class="line">CALC_LIST := calc/calc.c</span><br><span class="line">LIBPRINT_LIST := libprint/banner.c libprint/center.c libprint/normal.c</span><br><span class="line">LIBMATH_LIST := libmath/clock.c libmath/letter.c libmath/numbers.c</span><br><span class="line"></span><br><span class="line"># 目标文件</span><br><span class="line">CALC_OBJS := $(CALC_LIST:.c=.o)</span><br><span class="line">LIBMATH_OBJS := $(LIBMATH_LIST:.c=.o)</span><br><span class="line">LIBPRINT_OBJS := $(LIBPRINT_LIST:.c=.o)</span><br><span class="line"></span><br><span class="line"># 可执行程序</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line">C_FLAGS := -g</span><br><span class="line">LIB_COMMAND := ar -rs</span><br><span class="line"></span><br><span class="line"># 规则</span><br><span class="line">$(PROG):$(CALC_OBJS) $(LIBMATH) $(LIBPRINT) # 链接</span><br><span class="line">	$(CC) $(CFLAGS) -o $@ $^</span><br><span class="line">$(LIBMATH):$(LIBMATH_OBJS) # 静态库 libmath</span><br><span class="line">	$(LIB_COMMAND) $@ $^</span><br><span class="line">$(LIBPRINT):$(LIBPRINT_OBJS) # 静态库 libprint</span><br><span class="line">	$(LIB_COMMAND) $@ $^</span><br><span class="line"></span><br><span class="line">%.o:%.c # 所有目标文件</span><br><span class="line">	$(CC) -c -o $@ $^</span><br><span class="line">clean:</span><br><span class="line">	rm $(CALC_OBJS) $(LIBMATH_OBJS) $(LIBPRINT_OBJS) $(PROG) $(LIBMATH) $(LIBPRINT)</span><br></pre></td></tr></table></figure>
<p>最后看下实际构造情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ make</span><br><span class="line">gcc -c -o calc/calc.o calc/calc.c</span><br><span class="line">gcc -c -o libmath/clock.o libmath/clock.c</span><br><span class="line">gcc -c -o libmath/letter.o libmath/letter.c</span><br><span class="line">gcc -c -o libmath/numbers.o libmath/numbers.c</span><br><span class="line">ar -rs libmath/libmath.a libmath/clock.o libmath/letter.o libmath/numbers.o</span><br><span class="line">gcc -c -o libprint/banner.o libprint/banner.c</span><br><span class="line">gcc -c -o libprint/center.o libprint/center.c</span><br><span class="line">gcc -c -o libprint/normal.o libprint/normal.c</span><br><span class="line">ar -rs libprint/libprint.a libprint/banner.o libprint/center.o libprint/normal.o</span><br><span class="line">gcc  -o calculator calc/calc.o libmath/libmath.a libprint/libprint.a</span><br><span class="line"></span><br><span class="line">➜  src git:(master) ✗ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── calc</span><br><span class="line">│   ├── calc.c</span><br><span class="line">│   └── calc.o</span><br><span class="line">├── calculator</span><br><span class="line">├── libmath</span><br><span class="line">│   ├── clock.c</span><br><span class="line">│   ├── clock.o</span><br><span class="line">│   ├── letter.c</span><br><span class="line">│   ├── letter.o</span><br><span class="line">│   ├── libmath.a</span><br><span class="line">│   ├── numbers.c</span><br><span class="line">│   └── numbers.o</span><br><span class="line">└── libprint</span><br><span class="line">    ├── banner.c</span><br><span class="line">    ├── banner.o</span><br><span class="line">    ├── center.c</span><br><span class="line">    ├── center.o</span><br><span class="line">    ├── libprint.a</span><br><span class="line">    ├── normal.c</span><br><span class="line">    └── normal.o</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong> </p>
<ul>
<li>依赖关系难以生成。比如如果要像但目录方案那样自动检测头文件依赖情况，就会需要生成 .d 文件。然而 .d 文件中的规则会缺少路径名，像这样 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.o: libmath/clock.c libmath/math.h</span><br></pre></td></tr></table></figure>
<p>因此还需要进一步处理才能应用到 makefile 中，从而增加了难度。</p>
<ul>
<li><p>多个开发人员围绕单个 makefile 的冲突。</p>
</li>
<li><p>无法对程序进行分解。</p>
</li>
</ul>
<h3 id="2-方案-b：迭代式-make-操作"><a href="#2-方案-b：迭代式-make-操作" class="headerlink" title="(2) 方案 b：迭代式 make 操作"></a>(2) 方案 b：迭代式 make 操作</h3><p><strong>说明：</strong> 在每个源文件目录中放一个不同的 makefile ，并用一个高层次 makefile 迭代式地调用每个下级目录的 makefile。<br><strong>应用：</strong>软件业中一种常见的解决方案。</p>
<p><strong>优点</strong> </p>
<ul>
<li>容易理解。</li>
<li>每个 makefile 都只需要列出当前目录的文件。</li>
<li>在需要时，如果需要对源树的其它部分进行构造，每个 makefile 还可以迭代式地调用其它 makefile。</li>
<li>在 makefile 中，列出长路径是不必要的，因为所有文件引用都是指向当前目录。</li>
<li>减少了开发人员之间围绕 makefile 修改所产生的冲突。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果要对部分进行构造，由于每个 makefile 都在单独的进程实例中执行，各自都维护了一个自己的依赖关系图，所有进程都不知道完整的依赖关系图。因此要么每次都全部重新构造造成冗余，要么就可能链接了其它目录过期的文件。</li>
<li>顶层 makefile 必须保证子 makefile 的执行顺序正确，目录关系清晰，规模较小的程序还可以实现，但难以应对几百个目录的规模和复杂的顺序需求。</li>
</ul>
<p>下面给出这种方案的一个实现。<br><a href="https://github.com/laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY/tree/master/part2/06_make/0602_scene/scene2_mult_dir_b/src" target="_blank" rel="external">SOFTWARE_BUILD_SYSTEM_STUDY/part2/06_make/0602_scene/scene2_mult_dir_b/src at master · laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY · GitHub</a></p>
<h4 id="Makefile-文件分布情况"><a href="#Makefile-文件分布情况" class="headerlink" title="Makefile 文件分布情况"></a>Makefile 文件分布情况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── calc</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── calc.c</span><br><span class="line">│   └── calculator</span><br><span class="line">├── libmath</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── clock.c</span><br><span class="line">│   ├── letter.c</span><br><span class="line">│   ├── math.h</span><br><span class="line">│   └── numbers.c</span><br><span class="line">└── libprint</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── banner.c</span><br><span class="line">    ├── center.c</span><br><span class="line">    ├── normal.c</span><br><span class="line">    └── printers.h</span><br></pre></td></tr></table></figure>
<h4 id="Makefile-详情"><a href="#Makefile-详情" class="headerlink" title="Makefile 详情"></a>Makefile 详情</h4><p><em>顶层 makefile</em> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################</span></span><br><span class="line"><span class="comment"># 顶层的 makefile</span></span><br><span class="line"><span class="comment">################</span></span><br><span class="line">.PHONY: all clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须以正确的顺序对其它 makefile 进行相应的迭代式调用</span></span><br><span class="line">all:</span><br><span class="line">	$(MAKE) -C libmath</span><br><span class="line">	$(MAKE) -C libprint</span><br><span class="line">	$(MAKE) -C calc</span><br><span class="line">clean:</span><br><span class="line">	rm -rf &#123;calc,libmath,libprint&#125;/*&#123;d,o,a&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>make -C 文件夹名</code>，会调用相应文件夹下的 Makefile。</p>
<p><em>calc/Makefile</em></p>
<ul>
<li>编译源文件</li>
<li>链接静态库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRCS := calc.c</span><br><span class="line">PROG := calculator</span><br><span class="line">LIBS := ../libmath/libmath.a ../libprint/libprint.a</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">$(PROG): $(OBJS) $(LIBS)</span><br><span class="line">	$(CC) -o <span class="variable">$@</span> $^</span><br></pre></td></tr></table></figure>
<p><em>libmath/Makefile</em></p>
<ul>
<li>编译源文件</li>
<li>创建静态库 libmath.a</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRCS := calc.c</span><br><span class="line">PROG := calculator</span><br><span class="line">LIBS := ../libmath/libmath.a ../libprint/libprint.a</span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -g</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">$(PROG): $(OBJS) $(LIBS)</span><br><span class="line">	$(CC) -o <span class="variable">$@</span> $^</span><br></pre></td></tr></table></figure>
<p><em>libprint/Makefile</em></p>
<ul>
<li>编译源文件</li>
<li>创建静态库 libprint.b</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SRCS =clock.c letter.c numbers.c</span><br><span class="line">LIB = libmath.a</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">$(LIB): $(OBJS)</span><br><span class="line">	$(AR) -rs $(LIB) $(OBJS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将包含依赖信息的 .d 文件都包含进来</span></span><br><span class="line">-include $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有 .d 文件都会匹配到这个规则来生成</span></span><br><span class="line">%.d: %.c</span><br><span class="line">	$(CC) -MM $(CFLAGS) $&lt; | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h4 id="实际的构建过程"><a href="#实际的构建过程" class="headerlink" title="实际的构建过程"></a>实际的构建过程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ make</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/usr/bin/make -C libmath</span><br><span class="line">gcc -MM -g numbers.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; numbers.d</span><br><span class="line">gcc -MM -g letter.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; letter.d</span><br><span class="line">gcc -MM -g clock.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; clock.d</span><br><span class="line">gcc -g   -c -o clock.o clock.c</span><br><span class="line">gcc -g   -c -o letter.o letter.c</span><br><span class="line">gcc -g   -c -o numbers.o numbers.c</span><br><span class="line">ar -rs libmath.a clock.o letter.o numbers.o</span><br><span class="line">ar: creating archive libmath.a</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/usr/bin/make -C libprint</span><br><span class="line">gcc -MM -g normal.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; normal.d</span><br><span class="line">gcc -MM -g center.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; center.d</span><br><span class="line">gcc -MM -g banner.c | sed <span class="string">'s#\(.*\)\.o: #\1.o \1\.d: #g'</span> &gt; banner.d</span><br><span class="line">gcc -g   -c -o banner.o banner.c</span><br><span class="line">gcc -g   -c -o center.o center.c</span><br><span class="line">gcc -g   -c -o normal.o normal.c</span><br><span class="line">ar -rs libprint.a banner.o center.o normal.o</span><br><span class="line">ar: creating archive libprint.a</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/usr/bin/make -C calc</span><br><span class="line">gcc -g   -c -o calc.o calc.c</span><br><span class="line">gcc -o calculator calc.o ../libmath/libmath.a ../libprint/libprint.a</span><br><span class="line"></span><br><span class="line">➜  src git:(master) ✗ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── calc</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── calc.c</span><br><span class="line">│   ├── calc.o</span><br><span class="line">│   └── calculator</span><br><span class="line">├── libmath</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── clock.c</span><br><span class="line">│   ├── clock.d</span><br><span class="line">│   ├── clock.o</span><br><span class="line">│   ├── letter.c</span><br><span class="line">│   ├── letter.d</span><br><span class="line">│   ├── letter.o</span><br><span class="line">│   ├── libmath.a</span><br><span class="line">│   ├── math.h</span><br><span class="line">│   ├── numbers.c</span><br><span class="line">│   ├── numbers.d</span><br><span class="line">│   └── numbers.o</span><br><span class="line">└── libprint</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── banner.c</span><br><span class="line">    ├── banner.d</span><br><span class="line">    ├── banner.o</span><br><span class="line">    ├── center.c</span><br><span class="line">    ├── center.d</span><br><span class="line">    ├── center.o</span><br><span class="line">    ├── libprint.a</span><br><span class="line">    ├── normal.c</span><br><span class="line">    ├── normal.d</span><br><span class="line">    ├── normal.o</span><br><span class="line">    └── printers.h</span><br><span class="line"></span><br><span class="line">3 directories, 29 files</span><br></pre></td></tr></table></figure>
<h3 id="3-方案-c：包含式-make"><a href="#3-方案-c：包含式-make" class="headerlink" title="(3) 方案 c：包含式 make"></a>(3) 方案 c：包含式 make</h3><p><strong>说明：</strong> 吸收迭代式 Make 方法的良好经验，通过使用框架替代大量独立的 makefile 文件，确保只有一个 GNU Make 进程实例在执行。这样依赖，就可以充分利用 GNU Make 依赖关系体系的全部能力，不会丢失重要的依赖关系。</p>
<p><strong>优点</strong></p>
<ul>
<li>只有一个 GNU Make 进程实例在运行，启动速度更快。</li>
<li>每个目录仍然只有一个 makefile 来描述本目录文件的构造过程。这样就可以对每个目录的构造描述进行封装，减少修改 makefile 引起的冲突。</li>
<li>有完整的依赖关系图，尖山了产生不正确构造结果的机会。</li>
<li>不存在迭代式 Make 调用顺序的问题。</li>
</ul>
<p><strong>缺点：</strong> 增加了构造系统的复杂性，需要开发人员具备丰富的构造经验。</p>
<p>示例， <a href="https://github.com/laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY/tree/master/part2/06_make/0602_scene/scene2_mult_dir_c/src" target="_blank" rel="external">SOFTWARE_BUILD_SYSTEM_STUDY/part2/06_make/0602_scene/scene2_mult_dir_c/src at master · laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY · GitHub</a></p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/B26F6B55-26A7-46BB-A49D-ADF85FBEA46F.png" alt=""><br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/DAE6E76E-FFA0-4067-A28A-8A9ABF1D7083.png" alt=""><br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/32441DCC-E092-40BB-930F-AE1005D5E51B.png" alt=""></p>
<p><strong>全功能构造系统</strong><br>上面的例子仅仅是为了说明包含式 make 方案的核心，要做出一个全功能的构造系统，需要增加一下功能。</p>
<ul>
<li>用来定义目标文件、源文件和头文件之间依赖关系的 GNU Make 代码（最好使用自动依赖关系分析）。</li>
<li>用来编译代码的规则（需要覆盖内置的 c 编译规则）</li>
<li>用来把目标文件链接成静态程序库的代码。</li>
<li>用来链接形成最终可执行程序的代码（可能编译不知一个程序）。</li>
<li>从子目录启动 GNU Make 进程的能力（目前只有一个 makefile 位于顶层 src 目录）。</li>
<li>对多种 CPU 架构的编译支持。</li>
<li>C  编译器标志参数可以用在文件级别，而不是目录级别（即每个文件都可以使用不同的 C 编译器标志参数）。</li>
<li>能够从上级目录向子目录继承编译器参数。</li>
<li>…</li>
</ul>
<p><strong>建议：</strong> 如果要实现一整套，绝对要做好时间预算。可以参考已有的实现，以他们为起点继续扩展。</p>
<h2 id="2-3-定义新的编译工具"><a href="#2-3-定义新的编译工具" class="headerlink" title="2.3 定义新的编译工具"></a>2.3 定义新的编译工具</h2><p><strong>说明：</strong> 如果编译过程中需要加入其它编译器来辅助编译过程，需要 Makefile 中提供对额外的构造过程的支持。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>构造过程中使用一种假想的的编译器 mathcomp 。</p>
<table>
<thead>
<tr>
<th>mathcomp 编译器参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>输入 .math 文件，生成对其它文件片段 .mathinc 的依赖信息，这些构造信息可以存储在 .dl 文件中。</td>
</tr>
<tr>
<td>-c</td>
<td>输入 .math 文件，生成 .c 文件。</td>
</tr>
<tr>
<td>-j</td>
<td>输入.math 文件，生成 .java 文件。</td>
</tr>
</tbody>
</table>
<p>其中 -d 生成的 .dl 文件内容类似下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equations.dl equations.c: equations.math equ1.mathinc equ2.mathinc</span><br></pre></td></tr></table></figure>
<p><strong>项目目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── calculator.c</span><br><span class="line">    ├── equ1.mathinc</span><br><span class="line">    ├── equ2.mathinc</span><br><span class="line">    └── equations.math</span><br></pre></td></tr></table></figure>
<p><strong>构造过程</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/822F7514-D4E2-4A0F-B2BE-F5C5F3B649C3.png" alt=""></p>
<p><strong>依赖关系图</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/2A4A5092-50A0-4D26-94E6-196CD62B606E.png" alt=""></p>
<p><em>Makefile</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># 1. 一份源文件清单，以 .math 文本格式保存，由 mathcomp 编译器读取。</span></span><br><span class="line"><span class="comment"># 2. 一套 GNU Make 规则，其中描述了如何把 .math 文件编译成 .c 文件。</span></span><br><span class="line"><span class="comment"># 3. 一种新的依赖关系文件（后缀名为 .dl），其中记录了 .math 文件与其所依赖的 .mathinc 文件之间的关系。</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathcomp 的绝对路径（不依赖 $PATH 变量是否正确设置）</span></span><br><span class="line">MATHCOMP := /tools/bin/mathcomp</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># .math 源文件清单</span></span><br><span class="line">MATHSRC := equtions.math</span><br><span class="line"></span><br><span class="line">CSRC := calculator.c</span><br><span class="line">PROG := calculator</span><br><span class="line">OBJS := $(CSRC:.c=.o) $(MATHSRC:.math=.o)</span><br><span class="line">$(PROG): $(OBJS)</span><br><span class="line">	$(CC) -o <span class="variable">$@</span> $^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 .c 文件的依赖关系规则</span></span><br><span class="line">%.c: %.math</span><br><span class="line">	$(MATHCOMP) -c $&lt;</span><br><span class="line"></span><br><span class="line">-include $(CSRC:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入.math 对 .mathinc 的依赖</span></span><br><span class="line">-include $(MATHSRC:.math=.dl)</span><br><span class="line"></span><br><span class="line">%.d: %c</span><br><span class="line">	@$(CC) -MM $(CPPFLAGS) $&lt; | sed <span class="string">'s#\(.*\)\.o: #\1.o \1.d: #g'</span> &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过生成所包含的其它片段的情况，实现自动依赖检测</span></span><br><span class="line">%.dl: %.math</span><br><span class="line">	<span class="built_in">echo</span> -n <span class="string">"<span class="variable">$@</span> <span class="variable">$(*F)</span>.c: "</span> &gt; <span class="variable">$@</span>; \</span><br><span class="line">	$(MATHCOMP) <span class="_">-d</span> $&lt; &gt;&gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-针对多个变量进行构造"><a href="#2-4-针对多个变量进行构造" class="headerlink" title="2.4 针对多个变量进行构造"></a>2.4 针对多个变量进行构造</h2><p><a href="http://www.jianshu.com/p/f044c14777c5" target="_blank" rel="external">如何在Mac上做嵌入式开发？ - 简书</a><br><a href="https://launchpad.net/gcc-arm-embedded" target="_blank" rel="external">GNU ARM Embedded Toolchain in Launchpad</a></p>
<p>举例如下，通过设置 $(PLATFORM) 的值来实现的多目标树构造系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── add.c</span><br><span class="line">├── calc.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── numbers.h</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>
<h3 id="交叉构造过程示意图"><a href="#交叉构造过程示意图" class="headerlink" title="交叉构造过程示意图"></a>交叉构造过程示意图</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/19CFF532-32E7-42D3-87D7-C26F388C70CC.png" alt=""></p>
<h3 id="依赖关系图-1"><a href="#依赖关系图-1" class="headerlink" title="依赖关系图"></a>依赖关系图</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/B612B82D-4D36-46E0-AE4B-BC595952CAC8.png" alt=""></p>
<h3 id="Makefile-实现"><a href="#Makefile-实现" class="headerlink" title="Makefile 实现"></a>Makefile 实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.c calc.c mult.c sub.c</span><br><span class="line">PROG := calculator</span><br><span class="line">CFLAGS := -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供了 PLATFORM 默认值，用户不在命令行指定的话，默认 i386(其实也可以用 = ，因为在命令行定义的任何变量都会自动覆盖 make file中的值)</span></span><br><span class="line">PLATFORM ?= i386</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有效平台列表</span></span><br><span class="line">VALID_PLATFORMS := i386 powerpc alpha</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 $(PLATFORM) 的值的有效性进行检验，如果不在有效平台列表中，则显示相应的错误提示</span></span><br><span class="line">ifeq ($(filter $(PLATFORM), $(VALID_PLATFORMS)),)</span><br><span class="line">	$(error Invalid PLATFORM: $(PLATFORM))</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将不同架构平台的目标文件放在与架构关联的目录中</span></span><br><span class="line">OBJDIR := obj/$(PLATFORM)</span><br><span class="line"><span class="comment"># 确保对应架构的目标文件的存放目录存在</span></span><br><span class="line">$(shell mkdir -p $(OBJDIR))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用合适的编译器</span></span><br><span class="line">CC := gcc-$(PLATFORM)</span><br><span class="line"><span class="comment"># 目标文件清单</span></span><br><span class="line">OBJS := $(addprefix $(OBJDIR)/, $(SRCS:.c=.o))</span><br><span class="line"></span><br><span class="line">$(OBJDIR)/$(PROG): $(OBJS)</span><br><span class="line">	gcc $(CFLAGS) -o <span class="variable">$@</span> $^</span><br><span class="line"></span><br><span class="line">$(OBJDIR)/%o: %c</span><br><span class="line">	gcc -c -o <span class="variable">$@</span> $&lt;</span><br><span class="line"></span><br><span class="line">$(OBJS): numbers.h</span><br><span class="line"></span><br><span class="line">.PHONY = clean</span><br><span class="line">clean:</span><br><span class="line">	rm -rf obj</span><br></pre></td></tr></table></figure>
<h3 id="世纪构造过程"><a href="#世纪构造过程" class="headerlink" title="世纪构造过程"></a>世纪构造过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜  scene4_mult_var git:(master) ✗ make</span><br><span class="line">gcc -c -o obj/i386/add.o add.c</span><br><span class="line">gcc -c -o obj/i386/calc.o calc.c</span><br><span class="line">gcc -c -o obj/i386/mult.o mult.c</span><br><span class="line">gcc -c -o obj/i386/sub.o sub.c</span><br><span class="line">gcc -g -o obj/i386/calculator obj/i386/add.o obj/i386/calc.o obj/i386/mult.o obj/i386/sub.o</span><br><span class="line">➜  scene4_mult_var git:(master) ✗ make PLATFORM=powerpc</span><br><span class="line">gcc -c -o obj/powerpc/add.o add.c</span><br><span class="line">gcc -c -o obj/powerpc/calc.o calc.c</span><br><span class="line">gcc -c -o obj/powerpc/mult.o mult.c</span><br><span class="line">gcc -c -o obj/powerpc/sub.o sub.c</span><br><span class="line">gcc -g -o obj/powerpc/calculator obj/powerpc/add.o obj/powerpc/calc.o obj/powerpc/mult.o obj/powerpc/sub.o</span><br><span class="line">➜  scene4_mult_var git:(master) ✗ make PLATFORM=alpha</span><br><span class="line">gcc -c -o obj/alpha/add.o add.c</span><br><span class="line">gcc -c -o obj/alpha/calc.o calc.c</span><br><span class="line">gcc -c -o obj/alpha/mult.o mult.c</span><br><span class="line">gcc -c -o obj/alpha/sub.o sub.c</span><br><span class="line">gcc -g -o obj/alpha/calculator obj/alpha/add.o obj/alpha/calc.o obj/alpha/mult.o obj/alpha/sub.o</span><br><span class="line">➜  scene4_mult_var git:(master) ✗ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── calc.c</span><br><span class="line">├── makefile</span><br><span class="line">├── mult.c</span><br><span class="line">├── numbers.h</span><br><span class="line">├── obj</span><br><span class="line">│   ├── alpha</span><br><span class="line">│   │   ├── add.o</span><br><span class="line">│   │   ├── calc.o</span><br><span class="line">│   │   ├── calculator</span><br><span class="line">│   │   ├── mult.o</span><br><span class="line">│   │   └── sub.o</span><br><span class="line">│   ├── i386</span><br><span class="line">│   │   ├── add.o</span><br><span class="line">│   │   ├── calc.o</span><br><span class="line">│   │   ├── calculator</span><br><span class="line">│   │   ├── mult.o</span><br><span class="line">│   │   └── sub.o</span><br><span class="line">│   └── powerpc</span><br><span class="line">│       ├── add.o</span><br><span class="line">│       ├── calc.o</span><br><span class="line">│       ├── calculator</span><br><span class="line">│       ├── mult.o</span><br><span class="line">│       └── sub.o</span><br><span class="line">└── sub.c</span><br><span class="line"></span><br><span class="line">4 directories, 21 files</span><br></pre></td></tr></table></figure>
<h2 id="2-5-清除构造树"><a href="#2-5-清除构造树" class="headerlink" title="2.5 清除构造树"></a>2.5 清除构造树</h2><p><strong>说明：</strong> 清除操作必须仅针对构造过程中生成的文件，采用那种方式取决于构造系统的工作机制。</p>
<h3 id="迭代式-Make-系统"><a href="#迭代式-Make-系统" class="headerlink" title="迭代式 Make 系统"></a>迭代式 Make 系统</h3><p><strong>清除机制：</strong> 每个 makefile 都负责生成本目录的目标文件，因此，它也应当负责清除本目录中的目标文件。</p>
<p>例如,  <a href="https://github.com/laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY/tree/master/part2/06_make/0602_scene/scene2_mult_dir_b/src" target="_blank" rel="external">SOFTWARE_BUILD_SYSTEM_STUDY/part2/06_make/0602_scene/scene2_mult_dir_b/src at master · laputa-er/SOFTWARE_BUILD_SYSTEM_STUDY · GitHub</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    ├── Makefile <span class="comment">#</span></span><br><span class="line">    ├── calc</span><br><span class="line">    │   ├── Makefile</span><br><span class="line">    │   ├── calc.c</span><br><span class="line">    │   └── calculator</span><br><span class="line">    ├── libmath</span><br><span class="line">    │   ├── Makefile</span><br><span class="line">    │   ├── clock.c</span><br><span class="line">    │   ├── letter.c</span><br><span class="line">    │   ├── math.h</span><br><span class="line">    │   └── numbers.c</span><br><span class="line">    └── libprint</span><br><span class="line">        ├── Makefile</span><br><span class="line">        ├── banner.c</span><br><span class="line">        ├── center.c</span><br><span class="line">        ├── normal.c</span><br><span class="line">        └── printers.h</span><br></pre></td></tr></table></figure>
<p><em>顶层 makefile： 执行每个子目录下的 Makefile 的 clean 规则</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean: </span><br><span class="line">	$(MAKE) -C libmath clean</span><br><span class="line">	$(MAKE) -C libprint clean</span><br><span class="line">	$(MAKE) -C calc clean</span><br></pre></td></tr></table></figure>
<p><em>以 <code>libmath/Makefile</code>为例，子目录下的 Makefile 定义实际清除文件的规则</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">	rm <span class="_">-f</span> $(OBJS) $(LIB)</span><br></pre></td></tr></table></figure>
<p>实际清除过程如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ make clean</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/usr/bin/make -C libmath clean</span><br><span class="line">rm <span class="_">-f</span> clock.o letter.o numbers.o libmath.a *.d</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/usr/bin/make -C libprint clean</span><br><span class="line">rm <span class="_">-f</span> banner.o center.o normal.o libprint.a *.d</span><br><span class="line">/Applications/Xcode.a</span><br></pre></td></tr></table></figure>
<h3 id="包含式-Make-系统"><a href="#包含式-Make-系统" class="headerlink" title="包含式 Make 系统"></a>包含式 Make 系统</h3><p><strong>清除机制：</strong> 由于拥有已编译的源文件的完整清单，因此也知道目标文件的完整集合。即便是更复杂的情况，也可以通过一些代码逻辑记录文件名，并过滤出需要删除的文件的路径，今儿将他们集中清除。</p>
<p><strong>好的实践：</strong> 下面给出一些清除构造系统的好的原则</p>
<ul>
<li>clean 标的定义好后，先完全构造，然后测地清除，比对下文件列表，确保没有遗漏。</li>
<li>最好把所有生成的文件保存在特定的目录，而不是源文件目录中，从而简化清除实现。</li>
</ul>
<h2 id="2-6-对不正确的构造结果进行调试"><a href="#2-6-对不正确的构造结果进行调试" class="headerlink" title="2.6 对不正确的构造结果进行调试"></a>2.6 对不正确的构造结果进行调试</h2><h3 id="GNU-Make-提供了一些调试选项"><a href="#GNU-Make-提供了一些调试选项" class="headerlink" title="GNU Make 提供了一些调试选项"></a>GNU Make 提供了一些调试选项</h3><table>
<thead>
<tr>
<th>调试选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>make -n</td>
<td>显示要执行的 shell 命令清单，但不实际执行这些命令。</td>
</tr>
<tr>
<td>make -p</td>
<td>显示 GNU Make 内部数据库的内容。其中包括每个 makefile 中定义的规则和变量的完整清单，以及 GNU Make 的内置规则。其中还记录了行号信息，有注意轻松追踪到各种定义所在的位置。</td>
</tr>
<tr>
<td>make -d</td>
<td>显示 GNU Make 的模式匹配算法在解析和执行 makefile 过程中形成的跟踪日志。这些输出信息会非常冗长，但其中提供了你需要知道的一切。</td>
</tr>
</tbody>
</table>
<h3 id="打印调试-warning"><a href="#打印调试-warning" class="headerlink" title="打印调试 - $(warning)"></a>打印调试 - $(warning)</h3><p><strong>说明：</strong> 使用 <code>$(warning)</code>函数，在程序输出中显示有用的信息。<br><strong>返回值：</strong> 不返回任何值，因此可以插到 makefile 中允许出现函数的任何地方。</p>
<p>例如， </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── calc.c</span><br><span class="line">├── makefile</span><br><span class="line">├── mult.c</span><br><span class="line">├── numbers.h</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>
<p>makefile 如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SRCS := add.c calc.c mult.c sub.c</span><br><span class="line">PROG := calculator</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在变量定义中使用 $(warning) 函数，结合延迟赋值 = ，当系统调用该变量时显示适当消息</span></span><br><span class="line">CFLAGS = $(warning Accessing CFLAGS) -g <span class="comment"># CFLAGS := -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则下的 shell 列表是调用 $(SHELL)变量表示的 shell 程序执行的，因此任何规则下的 shell 列表的执行都会触发打印信息</span></span><br><span class="line">SHELL = $(warning Target is <span class="variable">$@</span>) /bin/sh</span><br><span class="line"></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">$(PROG):$(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -o <span class="variable">$@</span> $^</span><br><span class="line">$(OBJS): numbers.h</span><br><span class="line">clean:</span><br><span class="line">	rm $(PROG) $(OBJS) $(SRCS:.c=.d)</span><br></pre></td></tr></table></figure>
<p>构造时输出信息如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: Accessing CFLAGS</span><br><span class="line">makefile:9: Target is add.o</span><br><span class="line">gcc  -g    -c -o add.o add.c</span><br><span class="line">make: Accessing CFLAGS</span><br><span class="line">makefile:9: Target is calc.o</span><br><span class="line">gcc  -g    -c -o calc.o calc.c</span><br><span class="line">make: Accessing CFLAGS</span><br><span class="line">makefile:9: Target is mult.o</span><br><span class="line">gcc  -g    -c -o mult.o mult.c</span><br><span class="line">make: Accessing CFLAGS</span><br><span class="line">makefile:9: Target is sub.o</span><br><span class="line">gcc  -g    -c -o sub.o sub.c</span><br><span class="line">makefile:14: Accessing CFLAGS</span><br><span class="line">makefile:14: Target is calculator</span><br><span class="line">gcc  -g  -o calculator add.o calc.o mult.o sub.o</span><br></pre></td></tr></table></figure>
<h3 id="第三方调试工具"><a href="#第三方调试工具" class="headerlink" title="第三方调试工具"></a>第三方调试工具</h3><p><strong>说明：</strong> 在调试复杂的 makefile 时，可以考虑使用第三方工具，比如  <a href="http://gmd.sourceforget.net" target="_blank" rel="external">GNU Make Debugger</a></p>
<ul>
<li>可以交互式地打印变量</li>
<li>找出变量是如何定义的</li>
<li>对特定的 makefile  规则设置断点</li>
</ul>
<h1 id="3-赞扬和批评"><a href="#3-赞扬和批评" class="headerlink" title="3 赞扬和批评"></a>3 赞扬和批评</h1><h2 id="3-1-赞扬"><a href="#3-1-赞扬" class="headerlink" title="3.1 赞扬"></a>3.1 赞扬</h2><ul>
<li>得到广泛支持</li>
<li>运行速度极快</li>
<li>采用可移植语法</li>
<li>提供全功能的编程语言</li>
<li>有史以来第一种构造工具</li>
</ul>
<h2 id="3-2-批评"><a href="#3-2-批评" class="headerlink" title="3.2 批评"></a>3.2 批评</h2><ul>
<li>语言设计前后不一致</li>
<li>没有标准框架</li>
<li>缺乏可移植性</li>
<li>调试困难</li>
<li>语言完整性与易用性的权衡</li>
</ul>
<h2 id="3-3-评价"><a href="#3-3-评价" class="headerlink" title="3.3 评价"></a>3.3 评价</h2><p><strong>质量指标</strong></p>
<ul>
<li>易用性： 差</li>
<li>正确性：差</li>
<li>性能：优</li>
<li>可伸缩性：优</li>
</ul>
<p><strong>原则</strong></p>
<ul>
<li>c/c++：对于已经使用 Make 构系统的旧有软件，可以考虑使用 GNU Make 。单如果要为 c/c++ 软件编写一套全新的构造系统，应到首选 SCons 或 CMake 。</li>
<li>java: ant</li>
<li>c# : MS Build</li>
</ul>
<p><strong>注意：</strong> 这些标准都是主观的。</p>
<h1 id="4-其他类似工具"><a href="#4-其他类似工具" class="headerlink" title="4 其他类似工具"></a>4 其他类似工具</h1><h2 id="4-1-Berkeley-Make-工具"><a href="#4-1-Berkeley-Make-工具" class="headerlink" title="4.1 Berkeley Make 工具"></a>4.1 Berkeley Make 工具</h2><p><strong>诞生：</strong> 20 世纪 70 年代。<br><strong>应用平台：</strong>  BSD 系统（包括其它变体 BSD 系统）。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/SBS_06%20Make/69A824BA-56FE-45BD-B0D5-3307DFE2CB8B.png" alt=""></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>说明：</strong> 与 GNU Make 基本相同，差异体主要体现在一下两点<br>区别|Berkeley Maker| GNU Make<br>—|—|—<br> 对变量的操作方式|使用函数|使用修饰符<br>是否支持条件和循环|是|否</p>
<p><em>修饰符（modifiers）</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件名序列中取出各个文件名的后缀</span></span><br><span class="line">$(MY_VAR:E) <span class="comment"># $(suffix $(MY_VAR))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件名徐磊中取出各个文件的目录部分</span></span><br><span class="line">$(MY_VAR:H) <span class="comment"># $(dir $(MY_VAR))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以指定模式过滤字符串中的单词，过滤出符合模式的单词</span></span><br><span class="line">$(MY_VAR:M&lt;模式&gt;) <span class="comment"># $(filter &lt;模式&gt;,$(MY_VAR))</span></span><br></pre></td></tr></table></figure>
<p><em>条件和循环</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 这个 makefile 的执行结果是各字目录中所有 Sub.mk 文件都被包含到顶层 makefile 中。</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line">SUBDIRS = application database libraries storage</span><br><span class="line">ALLTARGS = </span><br><span class="line"></span><br><span class="line">.for SUBDIR <span class="keyword">in</span> $(SUBDIRS)</span><br><span class="line">SUBMK = $(SUBDIR)/Sub.mk</span><br><span class="line">.if exists($(SUBMK))</span><br><span class="line">.include <span class="string">"<span class="variable">$(SUBMK)</span>"</span></span><br><span class="line">ALLTARGS += make-$(SUBDIR)</span><br><span class="line">.endif</span><br><span class="line">.endfor</span><br><span class="line"></span><br><span class="line">all: $(ALLTARGS)</span><br><span class="line">	@<span class="built_in">echo</span> All targets up to date</span><br></pre></td></tr></table></figure>
<h2 id="4-2-NMake"><a href="#4-2-NMake" class="headerlink" title="4.2  NMake"></a>4.2  NMake</h2><p><strong>说明：</strong> 是 Make 的另一种变体，一般是微软 Visual Studio 的组成部分。<br><strong>应用：</strong> 开发人员使用 Visual Studio 图形化用户界面完成日常开发工作，而 NMake则更多用于面向批处理的、从命令行执行的任务，例如软件大包。由于微软 MS Build 工具，NMake 用得更少了。<br><strong>语法：</strong> NMake 提供了与 GNU Male 和 Berkeley Make 相同的基本语法，特别是在规则和变量的定义方面。但其 shell 命令明显是面向 Windows 命令提示符的，而且使用 Visual Studio 的编译工具。</p>
<h2 id="4-3-ElectricAccelerator-和-Spark-Build"><a href="#4-3-ElectricAccelerator-和-Spark-Build" class="headerlink" title="4.3 ElectricAccelerator 和 Spark Build"></a>4.3 ElectricAccelerator 和 Spark Build</h2><p><strong>说明：</strong> 来自 <code>Electric Cloud</code> 公司的两款产品。</p>
<h3 id="ElectricAccelerator"><a href="#ElectricAccelerator" class="headerlink" title="ElectricAccelerator"></a>ElectricAccelerator</h3><p><strong>说明：</strong> 商业化工具，可以加速软件构造过程。<br><strong>原理：</strong> 通过把任务分发给网络集群中的多个 CPU ，并协调各项任务对磁盘文件的访问，确保它们按照正确顺序执行。从而实现加速目的。<br><strong>应用：</strong> 可以解析 GNU Make 和 NMake 语法，因此旧有构造系统的用户可以利用这一工具，花少量代价实现性能大幅增长。</p>
<h3 id="Spark-Build"><a href="#Spark-Build" class="headerlink" title="Spark Build"></a>Spark Build</h3><p><strong>说明：</strong> ElectricAccelerator 的功能缩水版，用来解决 GNU Make 的一些基础缺陷。<br><strong>原理：</strong> 通过生成依赖关系数据库，记录构造过程的有用信息，方便构造过程分析。<br><strong>应用：</strong> 在调试诸如依赖挂你或构造速度慢等 makefile 问题时，能够发挥特别有用的用途。<br><strong>扩展：</strong> Spark Build Insight 是配合使用的一个图形户工具，利用 Sparl Build 生成的信息可生成整个构造过程的总体视图。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/构造系统/" rel="tag">#构造系统</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/09/SBS_01 构造系统概述/" rel="next" title="SBS_01 构造系统概述">
                <i class="fa fa-chevron-left"></i> SBS_01 构造系统概述
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/13/c++远征06之模板篇/" rel="prev" title="c++远征06之模板篇">
                c++远征06之模板篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/13/SBS_06 Make/"
           data-title="SBS_06 Make" data-url="http://laputa-er.github.io/2017/02/13/SBS_06 Make/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">155</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-GNU-Make-编程语言"><span class="nav-text">1 GNU Make 编程语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-makefile-规则：用来建立依赖关系图"><span class="nav-text">1.1 makefile 规则：用来建立依赖关系图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile-规则语法"><span class="nav-text">makefile 规则语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖关系图"><span class="nav-text">依赖关系图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-makefile-规则的类型"><span class="nav-text">1.2 makefile 规则的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-多个标的文件"><span class="nav-text">1.2.1 多个标的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-没有预备文件的规则"><span class="nav-text">1.2.2 没有预备文件的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-有文件名模式的规则"><span class="nav-text">1.2.3 有文件名模式的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-只适用于某些文件的规则"><span class="nav-text">1.2.4 只适用于某些文件的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5-有相同标文件的多个匹配"><span class="nav-text">1.2.5 有相同标文件的多个匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-makefile-变量"><span class="nav-text">1.3 makefile 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-基本用法"><span class="nav-text">1.3.1 基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-赋值语句"><span class="nav-text">1.3.2 赋值语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-立即求值"><span class="nav-text">(1) 立即求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-延迟求值"><span class="nav-text">(2) 延迟求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-条件赋值"><span class="nav-text">(3) 条件赋值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-内置变量和规则"><span class="nav-text">1.4 内置变量和规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-自动变量"><span class="nav-text">1.4.1 自动变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-内置规则"><span class="nav-text">1.4.2 内置规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-通配符规则"><span class="nav-text">(1) 通配符规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-隐式规则"><span class="nav-text">(2) 隐式规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-数据结构与函数"><span class="nav-text">1.5 数据结构与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-字符串处理函数"><span class="nav-text">1.5.1 字符串处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-GNU-Make-宏"><span class="nav-text">1.5.2 GNU Make 宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-define-指令"><span class="nav-text">1.5.2 define 指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-理解构造程序执行流程"><span class="nav-text">1.6 理解构造程序执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-make-命令调用后"><span class="nav-text">1.6.1 make 命令调用后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-文件包含和条件编译"><span class="nav-text">1.6.2 文件包含和条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-依赖关系图生成算法"><span class="nav-text">1.6.3 依赖关系图生成算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-进一步阅读资料"><span class="nav-text">1.7 进一步阅读资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-现实世界的构造系统场景"><span class="nav-text">2 现实世界的构造系统场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-源代码放在单个目录中"><span class="nav-text">2.1 源代码放在单个目录中</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方案1：最简单"><span class="nav-text">方案1：最简单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案2（方案1的改进版）：自动检查头文件"><span class="nav-text">方案2（方案1的改进版）：自动检查头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备知识"><span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案3：使用-makedepend-命令"><span class="nav-text">方案3：使用 makedepend 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-源代码放在多个目录中"><span class="nav-text">2.2 源代码放在多个目录中</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-方案-a：最简单"><span class="nav-text">(1) 方案 a：最简单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-方案-b：迭代式-make-操作"><span class="nav-text">(2) 方案 b：迭代式 make 操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Makefile-文件分布情况"><span class="nav-text">Makefile 文件分布情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Makefile-详情"><span class="nav-text">Makefile 详情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实际的构建过程"><span class="nav-text">实际的构建过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方案-c：包含式-make"><span class="nav-text">(3) 方案 c：包含式 make</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-定义新的编译工具"><span class="nav-text">2.3 定义新的编译工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-针对多个变量进行构造"><span class="nav-text">2.4 针对多个变量进行构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉构造过程示意图"><span class="nav-text">交叉构造过程示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖关系图-1"><span class="nav-text">依赖关系图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Makefile-实现"><span class="nav-text">Makefile 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#世纪构造过程"><span class="nav-text">世纪构造过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-清除构造树"><span class="nav-text">2.5 清除构造树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代式-Make-系统"><span class="nav-text">迭代式 Make 系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包含式-Make-系统"><span class="nav-text">包含式 Make 系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-对不正确的构造结果进行调试"><span class="nav-text">2.6 对不正确的构造结果进行调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GNU-Make-提供了一些调试选项"><span class="nav-text">GNU Make 提供了一些调试选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印调试-warning"><span class="nav-text">打印调试 - $(warning)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三方调试工具"><span class="nav-text">第三方调试工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-赞扬和批评"><span class="nav-text">3 赞扬和批评</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-赞扬"><span class="nav-text">3.1 赞扬</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-批评"><span class="nav-text">3.2 批评</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-评价"><span class="nav-text">3.3 评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-其他类似工具"><span class="nav-text">4 其他类似工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Berkeley-Make-工具"><span class="nav-text">4.1 Berkeley Make 工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用法"><span class="nav-text">用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-NMake"><span class="nav-text">4.2  NMake</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-ElectricAccelerator-和-Spark-Build"><span class="nav-text">4.3 ElectricAccelerator 和 Spark Build</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ElectricAccelerator"><span class="nav-text">ElectricAccelerator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spark-Build"><span class="nav-text">Spark Build</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
