<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/9/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/9/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/18 声明/" itemprop="url">
                  18 声明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T20:29:30+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/18 声明/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/18 声明/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>通过声明变量和函数，可以再检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。</p>
</blockquote>
<h2 id="18-1-声明的语法"><a href="#18-1-声明的语法" class="headerlink" title="18.1    声明的语法"></a>18.1    声明的语法</h2><blockquote>
<p><strong>语法：</strong><code>声明说明符 声明符;</code></p>
</blockquote>
<h3 id="18-1-1-声明说明符"><a href="#18-1-1-声明说明符" class="headerlink" title="18.1.1    声明说明符"></a>18.1.1    声明说明符</h3><blockquote>
<p><strong>分类：</strong>分3类（可组合）</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>包括</th>
<th>位置</th>
<th>可多个</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>auto static extern register</td>
<td>声明中的首要位置</td>
<td>否</td>
</tr>
<tr>
<td>类型限定符</td>
<td>const volatile</td>
<td>存储类型的后边</td>
<td>是</td>
</tr>
<tr>
<td>类型说明符</td>
<td>void char short int long float double signed unsigned 结构 联合 枚举 typedef创建的类型名</td>
<td>存储类型的后边</td>
<td>是，出现顺序无限制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>类型限定符和类型说明符的顺序没有限制，习惯上前者在前。</p>
</blockquote>
<h3 id="18-1-2-声明符"><a href="#18-1-2-声明符" class="headerlink" title="18.1.2    声明符"></a>18.1.2    声明符</h3><blockquote>
<p><strong>说明：</strong>一次可以声明多个声明符，彼此用<code>,</code>隔开。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>是否可跟初始化式</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单变量名</td>
<td>标识符</td>
<td>是</td>
</tr>
<tr>
<td>数组名</td>
<td>后边跟随[]的标识符</td>
<td>是</td>
</tr>
<tr>
<td>指针名</td>
<td>前放置*的标识符</td>
<td>是</td>
</tr>
<tr>
<td>函数名</td>
<td>后边跟随()的标识符</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="18-1-3-举例"><a href="#18-1-3-举例" class="headerlink" title="18.1.3    举例"></a>18.1.3    举例</h3><p><em>同时声明多个声明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.19.png" alt="Alt text"></p>
<p><em>带有初始化式</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.31.png" alt="Alt text"></p>
<p><em>同时使用多种类型说明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.57.png" alt="Alt text"></p>
<p><em>函数声明</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.09.05.png" alt="Alt text"></p>
<h2 id="18-2-存储类型"><a href="#18-2-存储类型" class="headerlink" title="18.2    存储类型"></a>18.2    存储类型</h2><blockquote>
<p><strong>说明：</strong>可以用于变量、较小范围的函数和形式参数的说明。根据声明位置的不同，在不用存储类型修饰的情况下，变量具有默认的存储类型，当默认的性质无法满足要求时，可以通过指定明确的存储类型来改变变量的性质。<br><strong>关键字：</strong><code>auto</code> <code>static</code> <code>extern</code> <code>register</code><br><strong>块（block）：</strong>表示函数体（大括号闭合的部分）或块语句（包含生命的复合语句）。</p>
</blockquote>
<h3 id="18-2-1-变量的特性"><a href="#18-2-1-变量的特性" class="headerlink" title="18.2.1    变量的特性"></a>18.2.1    变量的特性</h3><blockquote>
<p><strong>说明：</strong>变量的3个性质</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
<th>说明</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储期限</td>
<td>为变量预留和释放内存的时间</td>
<td>自动存储期限、静态存储期限</td>
</tr>
<tr>
<td>作用域</td>
<td>指引用变量的那部分程序文件</td>
<td>块作用域、文件作用域</td>
</tr>
<tr>
<td>链接</td>
<td>程序的不同部分可以共享此变量的范围</td>
<td>外部链接、内部链接、无链接</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>声明位置决定的存储特性：</strong>对许多变量而言，默认的存储期限、作用域和链接是可以符合要求的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>声明位置</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>块内部</td>
<td>自动存储期限、块作用域、无链接</td>
</tr>
<tr>
<td>程序的最外层</td>
<td>静态存储期限、文件作用域、外部链接</td>
</tr>
</tbody>
</table>
<h4 id="1-存储期限"><a href="#1-存储期限" class="headerlink" title="1. 存储期限"></a>1. 存储期限</h4><table>
<thead>
<tr>
<th>存储期限</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
<td>在所属块被执行时获得内存单元，并在块终止时释放内存单元（变量失去值）</td>
<td></td>
</tr>
<tr>
<td>静态存储期限</td>
<td>在程序运行期间占有同样的存储单元</td>
<td>可以允许变量无限期地保留它的值</td>
</tr>
</tbody>
</table>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>块作用域</td>
<td>变量从声明的地方一直到闭合块的末尾都是可见的</td>
<td></td>
</tr>
<tr>
<td>文件作用域</td>
<td>从声明的地方一直到闭合文件的末尾都时可见的</td>
</tr>
</tbody>
</table>
<h4 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h4><table>
<thead>
<tr>
<th>链接</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部链接</td>
<td>可以被程序中的几个（或者全部）文件共享</td>
<td></td>
</tr>
<tr>
<td>内部链接</td>
<td>只能属于单独一个文件</td>
<td></td>
</tr>
<tr>
<td>无链接</td>
<td>属于单独一个函数，而且根本不能被共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 静态存储期限</span><br><span class="line">* 文件作用域</span><br><span class="line">* 外部链接</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	* 自动存储期限</span><br><span class="line">	* 块作用域</span><br><span class="line">	* 无链接</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-2-auto存储类型"><a href="#18-2-2-auto存储类型" class="headerlink" title="18.2.2    auto存储类型"></a>18.2.2    auto存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>auto</code><br>注意：auto存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h3 id="18-2-3-static存储类型"><a href="#18-2-3-static存储类型" class="headerlink" title="18.2.3    static存储类型"></a>18.2.3    static存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>static</code><br><strong>可以修饰：</strong>全部变量<br><strong>特性：</strong>修饰快外部声明的变量和块内部声明的变量会有不同的效果</p>
<ul>
<li><strong>块外部</strong>：static使变量由外部链接变为内部链接（即<code>信息隐藏</code>，因为本质上隐藏了它所在声明文件内的变量，只有出现在同一文件中的函数可以看到此变量）</li>
<li><strong>块内部</strong>：static使变量的存储期限从自动变成静态的(无限期保留值)</li>
</ul>
<ol>
<li>块内的<code>static</code> 型变量只在程序执行前进行一次初始化，而<code>auto</code>型变量则会在每次变成有效时进行初始化</li>
<li>每次函数进行递归调用时，它都会获得一组新的<code>auto</code>型变量的集合。<code>static</code>修饰的变量则会被共用</li>
<li>函数不能返回<code>auto</code>型变量的指针，但可以返回指向<code>static</code>型变量的指针</li>
</ol>
<p><strong>用途：</strong></p>
<ol>
<li><strong>提升性能：</strong>修饰块内部变量，避免函数每次调用都对变量进行初始化</li>
<li><strong>信息隐藏：</strong>修饰块外部变量，用于在“隐藏”区域内的调用之间保留信息</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 内部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 无链接</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 将10进制的数字转换为16进制的</span><br><span class="line">* param &#123;int&#125; digit 10进制数字（16以内）</span><br><span class="line">* return &#123;char&#125; 表示响应16进制数字的字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">digit_to_hex_char</span> <span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 无论函数呗调用多少次，只会初始化一次</span></span><br><span class="line">	<span class="keyword">const</span> chat hex_chars[<span class="number">16</span>] = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">	return hex_chars[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-4-extern存储类型"><a href="#18-2-4-extern存储类型" class="headerlink" title="18.2.4    extern存储类型"></a>18.2.4    extern存储类型</h3><blockquote>
<p><strong>说明：</strong>只声明变量（不初始化）<br><strong>关键字：</strong><code>extern</code><br><strong>用途：</strong>多文件共享同一个变量<br><strong>性质：</strong></p>
<ul>
<li><strong>存储期限：</strong>使变量具有<code>静态存储期限</code>（即使在块中声明的变量）</li>
<li><strong>作用域：</strong><code>extern</code>不影响变量作用域（块内声明为块作用域，否则是文件作用域）</li>
<li><strong>链接：</strong>通常情况为<code>外部链接</code>；当同时被<code>static</code>修饰且声明位置为任何函数外部时为<code>内部链接</code></li>
</ul>
<p><strong>注意：</strong>用<code>extern</code>修饰的变量仍然可以同时初始化（但就没有了用<code>extern</code>的意义）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//等价于int i = 0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 链接？</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 链接？</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-5-register存储类型"><a href="#18-2-5-register存储类型" class="headerlink" title="18.2.5    register存储类型"></a>18.2.5    register存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>register</code><br><strong>用途：</strong>使变量存储在寄存器而不是内存中，提高访问和更新速度。<br><strong>寄存器：</strong>使驻留在计算机CPU中的存储单元。在传统计算机架构中，存储在寄存器中的数据会比存储在普通内存中的数据访问和更新速度更快。<br><strong>特点：</strong></p>
<ul>
<li>具有和<code>auto</code>型变量一样的俄存储期限、作用域和链接</li>
<li>对<code>register</code>型变量使用取地址运动符<code>&amp;</code>使非法的（因为寄存器没有地址）</li>
</ul>
<p><strong>注意：</strong>随着编译器变得更加复杂和高效，一些编译器可以自动决定变量保存在寄存器中还是内存中来达到最优性能。因此<code>register</code>的使用不再流行了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for语句的循环控制变量应用`register`是一个很好的选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-6-函数的存储类型"><a href="#18-2-6-函数的存储类型" class="headerlink" title="18.2.6    函数的存储类型"></a>18.2.6    函数的存储类型</h3><blockquote>
<p><strong>说明：</strong>函数只能用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<table>
<thead>
<tr>
<th>不修饰或<code>extern</code></th>
<th><code>static</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>静态存储期限</td>
</tr>
<tr>
<td>文件作用域</td>
<td>文件作用域</td>
</tr>
<tr>
<td><code>外部链接</code></td>
<td><code>内部链接</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong> 当声明不打算被其他文件调用的任意函数时，建议使用<code>static</code>修饰</p>
<ol>
<li><strong>更容易维护：</strong>稍后修改文件的人可以知道对被<code>static</code>修饰的函数的修改一般不会影响其他文件中的函数（即便该函数所在文件中其它函数将指向该函数的指针传递了出去，也可以在当前文件发现）</li>
<li><strong>减少“命名空间污染”：</strong>可以在其它文件中使用相同的名字命名函数而不会发生冲突<br><strong>注意：</strong>使用<code>extern</code>画蛇添足，不必使用但也无害。</li>
</ol>
<p><strong>扩展：</strong>函数行参的存储类型（只能用<code>register</code>修饰）</p>
</blockquote>
<table>
<thead>
<tr>
<th>默认（等同于块中的<code>auto</code>型变量）</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h2 id="18-3-类型限定符"><a href="#18-3-类型限定符" class="headerlink" title="18.3    类型限定符"></a>18.3    类型限定符</h2><table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const</code></td>
<td>声明只读类型（也称为常量）</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td><a href="">20.3节</a></td>
</tr>
</tbody>
</table>
<h3 id="const介绍"><a href="#const介绍" class="headerlink" title="const介绍"></a><code>const</code>介绍</h3><p><strong>用途：</strong>定义常量</p>
<blockquote>
<ol>
<li>提示阅读程序的人，对象的值不能改变</li>
<li>让编译器检查防止程序改变对象的值</li>
<li>可能的话（特别是嵌入式系统），编译器可以用让<code>const</code>修饰的变量存储到<code>ROM</code>(只读内存)中</li>
</ol>
</blockquote>
<p><code>只读（const）</code>和<code>宏（#define）</code>：如何恰当使用两者？</p>
<blockquote>
<p><strong>技巧：</strong>建议对表示数字（比如数组维数）或字符的常量使用<code>#define</code>;<code>const</code>常用于保护存储在数组中的常量数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>只读（const）</th>
<th>宏(#define)</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>数字常量、字符常量、字符串常量</td>
<td>任何类型（包括常量数组、常量指针、常量结构、常量联合）</td>
</tr>
<tr>
<td>作用域</td>
<td>遵守作用域规则</td>
<td>不遵守，不能产生具有块作用域的常量</td>
</tr>
<tr>
<td>能否在调试器观察</td>
<td>能</td>
<td>不能</td>
</tr>
<tr>
<td>能否用于常量表达式</td>
<td>不能，比如数组大小（常量表达式）不能用<code>const</code>定义的常量</td>
<td>能</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">// 使用错误，只读类型不能用于常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="18-4-声明符"><a href="#18-4-声明符" class="headerlink" title="18.4    声明符"></a>18.4    声明符</h2><h3 id="声明符组成"><a href="#声明符组成" class="headerlink" title="声明符组成"></a>声明符组成</h3><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>标识符</code></td>
<td>声明的变量或函数的名字</td>
<td>是</td>
</tr>
<tr>
<td><code>*</code></td>
<td>声明指针或对指针进行索引</td>
<td>否</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>声明数组</td>
<td>否</td>
</tr>
<tr>
<td><code>()</code></td>
<td>声明函数或提高优先级</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="简单的声明规则"><a href="#简单的声明规则" class="headerlink" title="简单的声明规则"></a>简单的声明规则</h3><table>
<thead>
<tr>
<th>符号(用于声明)</th>
<th>简单规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>用*开头的声明符表示指针</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>用[]结尾的声明符表示数组</td>
</tr>
<tr>
<td><code>()</code></td>
<td>用()结尾的声明符表示函数</td>
</tr>
</tbody>
</table>
<h3 id="不合法的声明符"><a href="#不合法的声明符" class="headerlink" title="不合法的声明符"></a>不合法的声明符</h3><blockquote>
<ol>
<li>函数不能返回数组</li>
<li>函数不能返回函数</li>
<li>数组不能是函数型的</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的情况：标识符就是声明符</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; <span class="comment">//extern int a[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">()</span></span>; <span class="comment">// 空括号形式使得编译器不检查函数调用的参数情况，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 明确告诉编译器没有参数，编译器会检查参数情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>; <span class="comment">// 允许在函数声明中忽略形式参数的名字</span></span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-解释复杂声明"><a href="#18-4-1-解释复杂声明" class="headerlink" title="18.4.1    解释复杂声明"></a>18.4.1    解释复杂声明</h3><blockquote>
<p><strong>规则：</strong>无论多么复杂的声明都可以被下面的两条规则解释</p>
<ol>
<li>从标识符开始，由内往外解读</li>
<li>当符号位于同一层级(一左一右)时，确定声明的是什么东西的优先级是：<code>[] &gt; () &gt; *</code>(数组 &gt; 函数 &gt; 指针)</li>
</ol>
<p><strong>技巧：</strong>作为上面规则的补充，符号<code>()</code>和<code>*</code>有存在歧义的时候，下面是甄别的依据</p>
<ol>
<li><code>()</code>：当位于声明符最右端时代表“函数”；否则是用来进行指针索引的，像这样：<code>(*其它部分)</code></li>
<li><code>*</code>：<code>(*其它部分)</code>代表指针索引，否则是定义函数的返回值类型为指针（如果是函数）或者是指针类型的定义。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则2，ap是数组（元素是int *型的指针）</span></span><br><span class="line"><span class="keyword">int</span> *ap[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，fp是函数（返回值类型为float *）</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> *<span class="title">fp</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过技巧1，(*pf)是函数，所以pf是指向函数的指针（函数的返回值为void）</span></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，(*x[10])是函数（返回值为int *, 参数为void），则x[10]为函数指针，所以x是存储函数指针的数组。</span></span><br><span class="line"><span class="keyword">int</span> *(*x[<span class="number">10</span>])(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-使用类型定义来简化声明"><a href="#18-4-2-使用类型定义来简化声明" class="headerlink" title="18.4.2    使用类型定义来简化声明"></a>18.4.2    使用类型定义来简化声明</h3><blockquote>
<p><strong>说明：</strong>利用一组类型定义拆分复杂的声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价：int *(*x[10])(void);</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">Fcn</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> Fcn *Fcn_ptr;</span><br><span class="line"><span class="keyword">typedef</span> Fcn_ptr Fcn_ptr_array[<span class="number">10</span>];</span><br><span class="line">Fcn_ptr_array x;</span><br></pre></td></tr></table></figure>
<h2 id="18-5-初始化式"><a href="#18-5-初始化式" class="headerlink" title="18.5    初始化式"></a>18.5    初始化式</h2><blockquote>
<p><strong>说明：</strong>可以在声明符的后边书写=, 后边再跟上初始化式（不同于赋值，赋值只要是合法的右值即可，而初始化式存在诸多限制）。<br><strong>变量的默认值（声明时不给初始化式）：</strong>变量的初始化值依赖于变量的存储期限</p>
<ul>
<li><em>自动存储期限</em>：没有默认的初始值，不能预测初始值</li>
<li><em>静态存储期限</em>：基于类型初始化为“零”（整型初始化为0，浮点数初始化为0.0，指针初始化为空指针）</li>
</ul>
<p><strong>技巧：</strong>推荐为静态类型的变量提供初始化式，便于阅读者确定变量的值，也便于查看初始化赋值的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单变量的初始化：一个变量，与变量类型一样的表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型不匹配，采用和赋值运算相同的规则进行自动类型转换（7.5节）</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量的初始化：必须是具有和变量相同类型或void *类型的指针表达式</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组、结构或联合的初始化式通常是遗传封闭在大括号内的值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="额外规则"><a href="#额外规则" class="headerlink" title="额外规则"></a>额外规则</h3><ul>
<li>具有静态存储期限的变量：初始化式必须是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 100</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = LAST - FIRST + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>具有自动存储期限的变量：初始化式不必要是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用大括号闭合的数组、结构或联合的初始化式必须只能包含常量表达式，不允许有变量或函数调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="keyword">int</span> powers[<span class="number">3</span>] = &#123;<span class="number">1</span>, N, N*N, N*N*N&#125;; <span class="comment">// N是常量，所以合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自动类型的结构或联合：初始化式可以是另外一个结构或联合</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">struct</span> <span class="keyword">complex</span> c1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">complex</span> c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/17 指针的高级应用/" itemprop="url">
                  17 指针的高级应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T19:38:12+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/17 指针的高级应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/17 指针的高级应用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-动态存储分配"><a href="#17-1-动态存储分配" class="headerlink" title="17.1    动态存储分配"></a>17.1    动态存储分配</h2><blockquote>
<p><strong>背景：</strong>c语言的数据结构通常是固定大小的，为了扩大数据结构的容量，必须修改程序并且再次编译。<br><strong>说明（行为）：</strong>在程序执行期间分配内存单元<br><strong>用途：</strong>可以根据需要设计可以扩大（和缩小）的数据结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>适用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>数组</td>
<td></td>
</tr>
<tr>
<td>结构</td>
<td>可以链接成表、树和其它数据结构</td>
</tr>
</tbody>
</table>
<h3 id="17-1-1-内存分配函数"><a href="#17-1-1-内存分配函数" class="headerlink" title="17.1.1    内存分配函数"></a>17.1.1    内存分配函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>库</th>
<th>备注</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>malloc</code></td>
<td>分配内存快，但是不对内存块进行初始化</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>最常用，不需要对分配的内存块进行清除，所以它比<code>calloc</code>更高效</td>
<td><code>void *</code>(通用指针，本质上只是内存地址)</td>
</tr>
<tr>
<td><code>calloc</code></td>
<td>分配内存块，并且对内存块进行清除</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
<td></td>
</tr>
<tr>
<td><code>realloc</code></td>
<td>调整先前分配的内存块</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
</tr>
</tbody>
</table>
<h3 id="17-1-2-空指针"><a href="#17-1-2-空指针" class="headerlink" title="17.1.2    空指针"></a>17.1.2    空指针</h3><p><strong>说明：</strong>“指向为空的指针”，这是一个区别于所有有效指针的特殊值。<code>Q&amp;A</code>用<code>NULL</code>（宏）来表示空指针。<br><strong>相关场景：</strong>当调用内存分配函数时，如果无法定位满足我们需要的足够大的内存块，函数会返回空指针（<code>null pointer</code>）。</p>
<p><strong>定义了<code>NULL</code>的库文件：</strong></p>
<ol>
<li><locale.h></locale.h></li>
<li><stddef.h></stddef.h></li>
<li><stdio.h></stdio.h></li>
<li><stdlib.h></stdlib.h></li>
<li><string.h></string.h></li>
<li><time.h></time.h></li>
</ol>
<blockquote>
<p><strong>真假：</strong>所有非空指针都为真，而只有空指针为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) ... </span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (!p) ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != NULL) ...</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (p) ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>更酷的方式</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = malloc(<span class="number">10000</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-2-动态分配字符串"><a href="#17-2-动态分配字符串" class="headerlink" title="17.2    动态分配字符串"></a>17.2    动态分配字符串</h2><h3 id="17-2-1-使用malloc函数为字符串分配内存"><a href="#17-2-1-使用malloc函数为字符串分配内存" class="headerlink" title="17.2.1    使用malloc函数为字符串分配内存"></a>17.2.1    使用malloc函数为字符串分配内存</h3><blockquote>
<p><strong>注意：</strong>为字符串分配内存空间时不要忘记包含空字符串的空间。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">char</span> *p = (char *) <span class="built_in">malloc</span>(n + <span class="number">1</span>);<span class="comment">// malloc返回的通用指针会自动转化为char*型变量，因此强制类型转换的部分可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="17-2-2-在字符串函数中使用动态存储分配"><a href="#17-2-2-在字符串函数中使用动态存储分配" class="headerlink" title="17.2.2    在字符串函数中使用动态存储分配"></a>17.2.2    在字符串函数中使用动态存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 拼接两个字符串并返回一个“新字符串”（不改变原有的两个字符串）</span><br><span class="line"> * @param  s1 要拼接的字符串的第一部分</span><br><span class="line"> * @param  s2 要拼接的字符串的第二部分</span><br><span class="line"> * @return    新字符串地址</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, concat(<span class="string">"abc"</span>, <span class="string">"def"</span>)); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义指向新字符串的临时指针变量</span></span><br><span class="line">	<span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新字符串分配空间</span></span><br><span class="line">	result = <span class="built_in">malloc</span>(strlen(s1) + strlen(s2) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存失败</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in concat \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一部分复制到新字符串的空间中（会有剩余）</span></span><br><span class="line">	<span class="built_in">strcpy</span>(result, s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二部分拼接到后面</span></span><br><span class="line">	<span class="built_in">strcat</span>(result, s2);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-3-动态分配字符串的数组"><a href="#17-2-3-动态分配字符串的数组" class="headerlink" title="17.2.3    动态分配字符串的数组"></a>17.2.3    动态分配字符串的数组</h3><blockquote>
<p><strong>说明：</strong>在数组中存储字符串有两种方式。二维字符数组或者字符串字面量指针数组，相比之下，前者可能会浪费空间。</p>
</blockquote>
<h3 id="17-2-4-程序：显示一个月的提示列表（改进版）"><a href="#17-2-4-程序：显示一个月的提示列表（改进版）" class="headerlink" title="17.2.4    程序：显示一个月的提示列表（改进版）"></a>17.2.4    程序：显示一个月的提示列表（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> *reminders[MAX_REMIND];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			reminders[j], reminders[j<span class="number">-1</span>];</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line">		reminders[i] = <span class="built_in">malloc</span>(<span class="number">2</span> + strlen(msg_str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (reminders[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-动态分配数组"><a href="#17-3-动态分配数组" class="headerlink" title="17.3    动态分配数组"></a>17.3    动态分配数组</h2><blockquote>
<p><strong>原理：</strong>在程序执行期间为数组分配空间，然后通过指向数组第一个元素的指针访问数组。由于c语言中数组和指针的紧密关系，指向动态分配的内存块的指针可以当作数组的名字使用。<br><strong>注意：</strong>计算数组所需的空间要使用sizeof运算符，如果分配空间不足，稍后网数组中存储时程序会出现异常。</p>
</blockquote>
<h3 id="17-3-1-使用malloc函数为数组分配存储空间"><a href="#17-3-1-使用malloc函数为数组分配存储空间" class="headerlink" title="17.3.1    使用malloc函数为数组分配存储空间"></a>17.3.1    使用malloc函数为数组分配存储空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个含n个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">a = <span class="built_in">malloc</span>(n * sizeof(int)); <span class="comment">// 计算数组所需的空间要使用sizeof运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作数组使用</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-3-2-calloc函数"><a href="#17-3-2-calloc函数" class="headerlink" title="17.3.2    calloc函数"></a>17.3.2    calloc函数</h3><blockquote>
<p><strong>函数原型（<code>stdlib.h</code>）：</strong>如果要求的空间无效，那么此函数返回空指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 分配内存空间并初始化</span><br><span class="line">* @param &#123;size_t&#125; numeb 数组的长度</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 数组第一个元素的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmeb, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当第一个参数为1时，可以为任何类型的数据项（不仅仅是数组）分配空间</li>
<li>calloc函数会清除分配的空间中的数据</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为n的int型数组，并将所有项初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(n, sizeof(int));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向结构体的指针</span></span><br><span class="line"><span class="keyword">struct</span> point &#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125; *p;</span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1</span>, sizeof(struct point)); <span class="comment">//p将指向新创建的结构体，且结构体的成员x、y都为0</span></span><br></pre></td></tr></table></figure>
<h3 id="17-3-3-realloc函数"><a href="#17-3-3-realloc函数" class="headerlink" title="17.3.3    realloc函数"></a>17.3.3    realloc函数</h3><blockquote>
<p><strong>原型(<code>stdlib.h</code>)：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 调整分配的内存的大小</span><br><span class="line">* @param &#123;void *&#125; ptr 指向内存块（通常是数组）的指针</span><br><span class="line">* @param &#123;size_t&#125; size 内存块的新尺寸</span><br><span class="line">* @return &#123;void *&#125; 新的内存块的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用途：</strong>一旦为数组分配完内存，稍后可能会返现数组过大或过小。relloc函数可以调整数组的大小以使它更适合需要。<br><strong>局限：</strong>要确定传递给<code>realloc函数</code>的指针来自于先前<code>malloc函数</code>、<code>calloc函数</code>或<code>realloc函数</code>的调用获得的。否则程序会出现异常。<br><strong>规则：</strong></p>
<ul>
<li>如果无法扩大内存（后边内存被占用），会在别处分配新的内存，然后把旧块中的内容复制过去</li>
<li>当扩展内存块时，    <code>realloc函数</code>不会对添加进内存块的字节进行初始化</li>
<li>如果<code>realloc函数</code>不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。</li>
<li>如果<code>realloc函数</code>调用时以空指针作为第一个实际参数，那么它的行为就将像<code>malloc函数</code>一样</li>
<li>如果<code>realloc函数</code>调用时以0作为第二个实际参数，那么它会释放掉内存块    </li>
</ul>
<p><strong>注意：</strong>一旦<code>realloc函数</code>返回，一定要对指向内存块的所有指针进行更新（将新的地址赋值给指针），因为可能realloc函数移动到了其地方的内存块。</p>
</blockquote>
<h2 id="17-4-释放存储"><a href="#17-4-释放存储" class="headerlink" title="17.4    释放存储"></a>17.4    释放存储</h2><blockquote>
<p><strong>堆（heap）：</strong><code>malloc函数</code>和其他内存分配函数所获得的内存块都来自一个称为堆的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也会耗尽堆，这会导致函数返回空指针。<br><strong>垃圾（garbage）：</strong>对程序而言不再访问到的内存块被称为垃圾。<br><strong>内存泄漏（memroy leak）：</strong>运行中留有垃圾被称为内存泄漏。<br><strong>垃圾收集器（garbage collector）：</strong>用于垃圾的自动定位和回收，但c语言不提供。相反，每个c程序负责回收各自的垃圾（调用<code>free函数</code>）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟内存泄漏*/</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...)</span><br><span class="line">q = <span class="built_in">malloc</span>(...)</span><br><span class="line">p = q; <span class="comment">// p原本指向的内存块变成垃圾</span></span><br></pre></td></tr></table></figure>
<h3 id="17-4-1-free函数"><a href="#17-4-1-free函数" class="headerlink" title="17.4.1    free函数"></a>17.4.1    free函数</h3><blockquote>
<p><strong>用途：</strong>调用<code>free函数</code>将内存块释放返回堆。<br><strong>原型：</strong><code>stdlib.h</code><br><strong>限制：</strong><code>free函数</code>的世纪参数必须是指针，而且一定是先前<code>内存分配函数</code>返回的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 释放内存</span><br><span class="line">* @param &#123;void *&#125; ptr 指向需要释放的内存块的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-4-2-“悬空指针”问题"><a href="#17-4-2-“悬空指针”问题" class="headerlink" title="17.4.2    “悬空指针”问题"></a>17.4.2    “悬空指针”问题</h3><blockquote>
<p><strong>悬空指针（dangling pointer）：</strong>指向被<code>free</code>掉的内存块的指针。<br><strong>注意：</strong>悬空指针很难被发现，而且试图通过“悬空指针”修改被释放掉的内存块会导致程序异常。</p>
</blockquote>
<h2 id="17-5-链表"><a href="#17-5-链表" class="headerlink" title="17.5    链表"></a>17.5    链表</h2><blockquote>
<p><strong>链表（linked list）：</strong>时由一连串的结构（节点）组成的，其中每个节点都包含指向下一个链中节点的指针。<br><strong>优点：</strong>更灵活，方便扩大和缩小（插入和删除）。<br><strong>缺点：</strong>没有“随机访问”的能力</p>
</blockquote>
<h3 id="17-5-1-声明节点类型"><a href="#17-5-1-声明节点类型" class="headerlink" title="17.5.1    声明节点类型"></a>17.5.1    声明节点类型</h3><blockquote>
<p><strong>注意：</strong>结点类型只能使用标记而不能使用<code>typedef</code>定义结构，因为后者无法在节点内声明指向另一个结点的成员。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的单个节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node *first = <span class="literal">NULL</span>; <span class="comment">//链表初始为空</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-2-创建节点"><a href="#17-5-2-创建节点" class="headerlink" title="17.5.2    创建节点"></a>17.5.2    创建节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点分配内存</span></span><br><span class="line">new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点初始化值</span></span><br><span class="line">(*new_node).value = <span class="number">0</span>; <span class="comment">// .的优先级高于间接寻址运算符*，所以使用()提升后者优先级</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-3-gt-运算符"><a href="#17-5-3-gt-运算符" class="headerlink" title="17.5.3    -&gt;运算符"></a>17.5.3    -&gt;运算符</h3><blockquote>
<p><strong>右箭头选择（right arrow selection）：</strong>通过指针访问结构中的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;value); <span class="comment">//scanf("%d", &amp;(*new_node).value)</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-4-在链表的开始处插入节点"><a href="#17-5-4-在链表的开始处插入节点" class="headerlink" title="17.5.4    在链表的开始处插入节点"></a>17.5.4    在链表的开始处插入节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>为节点分配内存单元</li>
<li>把数据存储在节点中</li>
<li>把节点插入到链表中</li>
</ol>
<p><strong>伏笔：</strong>在17.6节中对<code>add_to_list</code>有进一步优化。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FALURE 0</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 节点</span><br><span class="line"> * @struct</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加节点到链表头部</span><br><span class="line"> * 需要注意的是，该函数执行后还需要将头部指向该函数返回的新的节点才能完成插入到链表头部的工作</span><br><span class="line"> * @param  list 要插入的链表（指向头部节点的指针）</span><br><span class="line"> * @param  n    要插入的节点存储的值</span><br><span class="line"> * @return      新的链表（指向新的头节点的指针）</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明新节点</span></span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配内存</span></span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_ro list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FALURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	new_node-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	return new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行完成链表的创建</span><br><span class="line"> * @return  链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">read_numbers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *first = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a series of intergers (0 to terminate):\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			return first;</span><br><span class="line">		&#125;</span><br><span class="line">		first = add_to_list(first, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个含有用户录入的数字的链表</span></span><br><span class="line">	<span class="keyword">struct</span> node *num_list;</span><br><span class="line">	num_list = read_numbers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-5-搜索链表"><a href="#17-5-5-搜索链表" class="headerlink" title="17.5.5    搜索链表"></a>17.5.5    搜索链表</h3><blockquote>
<p><strong>惯用法：</strong><code>for (p = first; p != NULL; p = p-&gt;next)</code><br><em>形式一：惯用法</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;value == n) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式二：省略中间变量</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span>; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;value == n) &#123;</span><br><span class="line">			return <span class="built_in">list</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式三：链表到末尾和找到目标判定合并</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式四：使用while</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	wile (<span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-6-从链表中删除节点"><a href="#17-5-6-从链表中删除节点" class="headerlink" title="17.5.6    从链表中删除节点"></a>17.5.6    从链表中删除节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定位要删除的节点</li>
<li>改变前一个节点，从而使它“绕过”删除节点</li>
<li>调用<code>free函数</code>从而收回删除节点占用的内存空间</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据节点的值找到节点并删除之</span><br><span class="line">* @param &#123;struct node*&#125; list 所在的链表</span><br><span class="line">* @param &#123;int&#125; n 要删除的节点存储的值</span><br><span class="line">* @return &#123;struct node*&#125; 链表的头节点</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">delete_from_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *cur, *prev;</span><br><span class="line">	<span class="comment">// 定位要删除的节点</span></span><br><span class="line">	<span class="keyword">for</span> (cur = <span class="built_in">list</span>, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;value != n; prev = cur, cur = cur-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	<span class="comment">// 没有找到要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了，要删除的节点是第一个节点</span></span><br><span class="line">	<span class="keyword">if</span> (prev == NUL) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了， 要删除的节点不是第一个几点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		prev-&gt;next = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cur);</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-8-程序：维护零件数据库（改进版）"><a href="#17-5-8-程序：维护零件数据库（改进版）" class="headerlink" title="17.5.8    程序：维护零件数据库（改进版）"></a>17.5.8    程序：维护零件数据库（改进版）</h3><blockquote>
<p><strong>说明：</strong>使用链表代替数组有两个主要的好处</p>
<ol>
<li>不需要事先限制数据库的大小，数据库可以扩大到没有更多内存空间存储零件为止</li>
<li>可以很容易保持用零件编号排序的数据库，当往数据库中添加新零件时，只是简单把它插入链表中的适当位置就可以了</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ tree -L 2</span><br><span class="line"> .</span><br><span class="line"> ├── invent2</span><br><span class="line"> ├── invent2.c</span><br><span class="line"> ├── invent2.o</span><br><span class="line"> ├── makefile</span><br><span class="line"> ├── readline.c</span><br><span class="line"> ├── readline.h</span><br><span class="line"> └── readline.o   └── readline.o</span><br></pre></td></tr></table></figure>
<h4 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invent2-c"><a href="#invent2-c" class="headerlink" title="invent2.c"></a>invent2.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (linked list version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * 定义零件</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number; <span class="comment">// 编号</span></span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>]; <span class="comment">// 名字长度</span></span><br><span class="line"> 	<span class="keyword">int</span> on_hand; <span class="comment">// 当前库存</span></span><br><span class="line"> 	<span class="keyword">struct</span> part *next; <span class="comment">// 指向下一个零件</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表（头节点）</span></span><br><span class="line"> <span class="keyword">struct</span> part *inventory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"> 		<span class="comment">// 跳过换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>: insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>: search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>: update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>: print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>: return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索零件</span><br><span class="line"> * @param  number 零件包含的值</span><br><span class="line"> * @return        对应零件节点的地址（没找到返回NULL）</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span> &amp;&amp; number &gt; p-&gt;number; p = p -&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; number == p-&gt;number) &#123;</span><br><span class="line"> 		return p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入一种零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *cur, *prev, *new_node;</span><br><span class="line"> 	<span class="comment">// 为新节点分配空间</span></span><br><span class="line"> 	new_node = <span class="built_in">malloc</span>(sizeof(struct part));</span><br><span class="line"> 	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Database is full; can't add more parts.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 零件编号</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;number);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 根据编号寻找插入位置(按从小到大的顺序排列)</span></span><br><span class="line"> 	<span class="keyword">for</span> (cur = inventory, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number &gt; cur-&gt;number; prev = cur, cur = cur-&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 发现编号相同的节点</span></span><br><span class="line"> 	<span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number == cur-&gt;number) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exits.\n"</span>);</span><br><span class="line"> 		<span class="built_in">free</span>(new_node);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name:"</span>);</span><br><span class="line"> 	read_line(new_node-&gt;name, NAME_LEN);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件数量</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;on_hand);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 插入进去</span></span><br><span class="line"> 	new_node-&gt;next = cur;</span><br><span class="line"> 	<span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		inventory = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		prev-&gt;next = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 以交互的方式根据编号搜索并显示目标零件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">struct</span> part *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">	p = find_part(number);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p-&gt;name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, p-&gt;on_hand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 修改零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> number, change;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	p = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		p-&gt;on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印所有零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part number    Part Name   Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d      %-25s%11d\n"</span>, p-&gt;number, p-&gt;name, p-&gt;on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-6-指向指针的指针"><a href="#17-6-指向指针的指针" class="headerlink" title="17.6    指向指针的指针"></a>17.6    指向指针的指针</h2><blockquote>
<p><strong>说明：</strong>对17.5.4中的<code>add_to_list</code>进行优化，优化后插入链表的功能将完全由该函数提供。<br><strong>原理：</strong>通过指针的指针的副本，达到修改指针指向的目的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 向链表中插入节点</span><br><span class="line">* @param &#123;struct node **&#125; node 指向链表的头节点的指针的指针</span><br><span class="line">* @param &#123;int&#125; n 节点存储的值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node **<span class="built_in">list</span>,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_to_list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURES);</span><br><span class="line">	&#125;</span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	<span class="comment">// 新节点的下一个节点指向链表头节点</span></span><br><span class="line">	new_node-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原本指向头节点的指针指向新节点</span></span><br><span class="line">	<span class="comment">// 详解：list的值是first这个指针本身的地址，通过*list便可以访问到first这个指针</span></span><br><span class="line">	*<span class="built_in">list</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">add_to_list(&amp;first, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="17-7-指向函数的指针"><a href="#17-7-指向函数的指针" class="headerlink" title="17.7    指向函数的指针"></a>17.7    指向函数的指针</h2><blockquote>
<p><strong>说明：</strong>毕竟函数占用内存单元，所以每个函数都有地址，就像每个变量都有地址一样。</p>
</blockquote>
<h3 id="17-7-1-函数指针作为实际参数"><a href="#17-7-1-函数指针作为实际参数" class="headerlink" title="17.7.1    函数指针作为实际参数"></a>17.7.1    函数指针作为实际参数</h3><blockquote>
<p><strong>声明：</strong>声明为指向函数的指针有两种方式，从编译器的角度看是完全一样的。</p>
<blockquote>
<p>方式一：<strong>返回值 函数名(<code>返回值 (*函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double (*f)(double), double a, double b)  &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x); // 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式二：<strong>返回值 函数名(<code>返回值 (函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double f(double), double a, double b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x);// 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-7-2-qsort函数"><a href="#17-7-2-qsort函数" class="headerlink" title="17.7.2    qsort函数"></a>17.7.2    qsort函数</h3><blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 为数组排序</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;int (*)&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size,  int (*compar) (const void *, const void *));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较函数（提供给qsort函数排序规则）</span><br><span class="line"> * @param &#123;void *&#125; p 第一个零件</span><br><span class="line"> * @param &#123;void *&#125; q 第二个零件</span><br><span class="line"> * @return   正数（1）：*p &gt; *q;负数（-1）：*p &lt; *q;零（0）：*p = *q</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_parts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">const</span> <span class="keyword">void</span> *q)</span> </span>&#123;</span><br><span class="line">	return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比较函数进行排序</span></span><br><span class="line">qsort(inventory, num_parts, <span class="keyword">sizeof</span>(struct part), compare_parts);</span><br></pre></td></tr></table></figure>
<h3 id="17-7-3-函数指针的其他用途"><a href="#17-7-3-函数指针的其他用途" class="headerlink" title="17.7.3    函数指针的其他用途"></a>17.7.3    函数指针的其他用途</h3><blockquote>
<p><strong>说明：</strong>c语言对待指向函数的指针就像对待指向数据的指针一样。我们可以把函数存储在变量中，或者用做数组的元素，再或者用做结构或联合的成员，甚至可以编写返回函数指针的函数，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*存储函数的变量*/</span></span><br><span class="line"><span class="keyword">void</span> (*pf) (<span class="keyword">int</span>); <span class="comment">//声明一个可以存储指向函数的指针的变量（pf可以指向任何带有int型实际参数，且返回值为void的函数）</span></span><br><span class="line"></span><br><span class="line">pf = f; <span class="comment">// 指向函数f</span></span><br><span class="line"></span><br><span class="line">(*pf)(i); <span class="comment">// pf(i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储函数的数组*/</span></span><br><span class="line"><span class="keyword">void</span> (*file_cmd[])(<span class="keyword">void</span>) = &#123;</span><br><span class="line">	new_cmd,</span><br><span class="line">	open_cmd,</span><br><span class="line">	close_cmd,</span><br><span class="line">	close_all_cmd,</span><br><span class="line">	save_cmd,</span><br><span class="line">	ext_cmd</span><br><span class="line">&#125;;</span><br><span class="line">(*file_cmd[n])(); <span class="comment">// 或者file_cmd[n]();</span></span><br></pre></td></tr></table></figure>
<h3 id="17-7-4-程序：列三角函数表"><a href="#17-7-4-程序：列三角函数表" class="headerlink" title="17.7.4    程序：列三角函数表"></a>17.7.4    程序：列三角函数表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tabulates values of trigonometric functions</span><br><span class="line"> */</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)double, double first, double last, double incr);</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">	double final, increament, initial;</span><br><span class="line">	printf("Enter initial value: ");</span><br><span class="line">	scanf("%lf", &amp;initial);</span><br><span class="line"></span><br><span class="line">	printf("Enter final value:");</span><br><span class="line">	scanf("%lf", &amp;final);</span><br><span class="line"></span><br><span class="line">	printf("Enter increament:");</span><br><span class="line">	scanf("%lf", &amp;increament);</span><br><span class="line"></span><br><span class="line">	printf("\n     x     cos(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(cos, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     sin(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(sin, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     tan(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(tan, initial, final, increament);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)(double), double first, double last, double incr) &#123;</span><br><span class="line">	double x;</span><br><span class="line">	int i, num_intervals;</span><br><span class="line">	num_intervals = cell((last - first) / incr);</span><br><span class="line">	for (i = 0; i &lt;= num_intervals; i++) &#123;</span><br><span class="line">		x = first + i * incr;</span><br><span class="line">		printf("%10.5f %10.5f\n", x, (*f)[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/16 结构、联合和枚举/" itemprop="url">
                  16 结构、联合和枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:49:46+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/16 结构、联合和枚举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/16 结构、联合和枚举/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="16-1-结构变量"><a href="#16-1-结构变量" class="headerlink" title="16.1    结构变量"></a>16.1    结构变量</h2><blockquote>
<p><strong>结构：</strong>结构的特性与数组很不相同。</p>
<ul>
<li>结构的元素（成员）可能具有不同的类型</li>
<li>每个结构成员都有名字</li>
<li>为了选择特殊的结构成员需要知名结构成员的名字而不是它的位置</li>
</ul>
<p><strong>扩展：</strong>大多数语言都提供类似的特性，所以结构可能听起来很舒需。再其它语言中，经常把结构称为纪录（record），把结构的成员称为字段（field）。</p>
</blockquote>
<h3 id="16-1-1-结构变量的声明"><a href="#16-1-1-结构变量的声明" class="headerlink" title="16.1.1    结构变量的声明"></a>16.1.1    结构变量的声明</h3><p><strong>语法：</strong>只声明不初始化（会非配内存但成员不会初始化）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span>, 实例变量<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong>结构实例化的变量具备以下特点</p>
<ul>
<li>成员在内存中是按照顺序存储的</li>
<li>内部成员拥有单独的名字空间（name space）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//零件</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//零件编号</span></span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//零件名称</span></span><br><span class="line">	<span class="keyword">int</span> on_hand;<span class="comment">//零件现有数量</span></span><br><span class="line">&#125;part1, part2;<span class="comment">//同时用这种结构实例化了两个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//工号</span></span><br><span class="line">	<span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line">&#125;employee1, employee2;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-2-结构变量的初始化"><a href="#16-1-2-结构变量的初始化" class="headerlink" title="16.1.2    结构变量的初始化"></a>16.1.2    结构变量的初始化</h3><blockquote>
<p><strong>语法：</strong>声明的同时初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">    成员<span class="number">2</span>类型 成员<span class="number">2</span>名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;,   </span><br><span class="line">  实例变量<span class="number">2</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;, </span><br><span class="line">  ...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则：</strong>类似数组</p>
<ol>
<li>用于结构初始化式的表达式必须是常量</li>
<li>初始化式可以短于它所初始化的结构，任何剩余的成员都用0作为它的初始值</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> on, hand;</span><br><span class="line">&#125;part1 = &#123;<span class="number">528</span>, <span class="string">"Disk drive"</span>, <span class="number">10</span>&#125;,</span><br><span class="line"> part2 = &#123;<span class="number">914</span>, <span class="string">"Printer cable"</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-3-对结构的操作"><a href="#16-1-3-对结构的操作" class="headerlink" title="16.1.3    对结构的操作"></a>16.1.3    对结构的操作</h3><blockquote>
<p><strong>限制：</strong>不能用<code>==</code>或<code>!=</code>判定两个结构是否相等或不等。</p>
</blockquote>
<h4 id="16-1-3-1-访问成员"><a href="#16-1-3-1-访问成员" class="headerlink" title="16.1.3.1    访问成员"></a>16.1.3.1    访问成员</h4><blockquote>
<p><strong>左值：</strong>结构成员的值是左值</p>
<ul>
<li>可以出现在赋值运算的左侧</li>
<li>作为自增或自减表达式的操作数</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Part number %d:"</span>, part1.number);</span><br><span class="line">part1.number = <span class="number">228</span>;<span class="comment">//可以出现在赋值运算的左侧</span></span><br><span class="line">part1.on_hand++;<span class="comment">//作为自增或自减表达式的操作数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>逗号运算符：</strong><code>结构变量.成员名</code></p>
<ul>
<li>优先级和后缀++和后缀–相同（几乎高于所有其他运算符）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part1.on_hand);<span class="comment">//.运算符优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-2-赋值运算"><a href="#16-1-3-2-赋值运算" class="headerlink" title="16.1.3.2    赋值运算"></a>16.1.3.2    赋值运算</h4><blockquote>
<p><strong>说明：</strong>数组不能用=运算符实现变量间数组内容的复制，但结构变量可以。<br><strong>注意：</strong>只能用于同一个结构类型声明的的变量之间。<br><strong>技巧：</strong>把需要复制的数组嵌在结构体内（作为成员）进行复制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;a1, a2;</span><br><span class="line"></span><br><span class="line">a1 = a2;<span class="comment">//a1的存储空间中数据和a2相同，实现了复制</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-结构类型"><a href="#16-2-结构类型" class="headerlink" title="16.2    结构类型"></a>16.2    结构类型</h2><blockquote>
<p><strong>说明：</strong>上一小结重点放在结构变量而不是结构类型本身上，这一节将重点观察结构类型。<br><strong>命名结构类型：</strong>如果需要在程序的不同位置声明结构变量，上一节的“匿名结构”就行不通了。c语言提供了两种命名结构的方法</p>
<ol>
<li>声明“结构标记”(结构用语链表时，只能声明“结构标记”)</li>
<li>使用<code>typedef</code>定义类型名</li>
</ol>
</blockquote>
<h3 id="16-2-1-结构标记的声明"><a href="#16-2-1-结构标记的声明" class="headerlink" title="16.2.1    结构标记的声明"></a>16.2.1    结构标记的声明</h3><blockquote>
<p><strong>结构标记(structure tag)：</strong>结构标记用于标记某种特定结构类型的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  结构类型名&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125;[结构变量<span class="number">1</span>, ...];<span class="comment">//分号表示声明的结束，不能省略</span></span><br><span class="line"><span class="keyword">struct</span> 结构类型名 结构变量<span class="number">2</span>, ...;<span class="comment">//struct关键字不能省略，因为结构类型名不是有效的c语言类型名(原生的和typedef定义的才是)。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不仅声明了标记part，而且声明了变量</span></span><br><span class="line"><span class="keyword">struct</span> part&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> part  part1 = &#123;<span class="number">528</span>, <span class="string">"disk drive"</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> part part2;</span><br><span class="line">part2 = part1;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-2-结构类型的定义"><a href="#16-2-2-结构类型的定义" class="headerlink" title="16.2.2    结构类型的定义"></a>16.2.2    结构类型的定义</h3><blockquote>
<p><strong>说明：</strong>用typedef来定义真正的类型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125; 结构类型名;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; Part;<span class="comment">//类型名的名字必须出现在定义的末尾，而不是在单词struct的后边</span></span><br><span class="line">Part part1, part2;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-3-结构类型的实际参数和返回值"><a href="#16-2-3-结构类型的实际参数和返回值" class="headerlink" title="16.2.3    结构类型的实际参数和返回值"></a>16.2.3    结构类型的实际参数和返回值</h3><blockquote>
<p><strong>缺点：</strong>带来一定系统开销，尤其是结构题很大的时候</p>
<blockquote>
<p>给函数传递结构和从函数返回结构都要求使用结构中所有成员的副本。</p>
</blockquote>
<p><strong>技巧：</strong>有时用指向结构的指针来代替传递给函数（或函数返回）的结构本身是很明智的做法。</p>
</blockquote>
<h4 id="16-2-3-1-用作参数"><a href="#16-2-3-1-用作参数" class="headerlink" title="16.2.3.1    用作参数"></a>16.2.3.1    用作参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_part</span> <span class="params">(<span class="keyword">struct</span> part p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"part number: %d\n"</span>, p.number);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Quality on hand: %d \n"</span>, p.on_hand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line">print_part(part1);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-2-用作返回值"><a href="#16-2-3-2-用作返回值" class="headerlink" title="16.2.3.2    用作返回值"></a>16.2.3.2    用作返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> part <span class="title">build_part</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> on_hand)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> part p;</span><br><span class="line">	p.number = number;</span><br><span class="line">	<span class="built_in">strcpy</span>(p.name, name);</span><br><span class="line">	p.on_hand = on_hand;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-3-数组和结构的嵌套"><a href="#16-3-数组和结构的嵌套" class="headerlink" title="16.3    数组和结构的嵌套"></a>16.3    数组和结构的嵌套</h2><h3 id="16-3-1-嵌套的结构"><a href="#16-3-1-嵌套的结构" class="headerlink" title="16.3.1    嵌套的结构"></a>16.3.1    嵌套的结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义姓名</span></span><br><span class="line"><span class="keyword">struct</span> person_name &#123;</span><br><span class="line">	<span class="keyword">char</span> first[FIRST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> middle_initial;</span><br><span class="line">	<span class="keyword">char</span> last[LAST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">struct</span> student &#123;</span><br><span class="line">	<span class="keyword">struct</span> person_name name; <span class="comment">// 结构的成员可以是另一种结构体</span></span><br><span class="line">	int_id, age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; student1, student2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">"Fred"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-结构数组"><a href="#16-3-2-结构数组" class="headerlink" title="16.3.2    结构数组"></a>16.3.2    结构数组</h3><blockquote>
<p><strong>说明：</strong>结构可以作为数组的元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="comment">// 声明结构数组</span></span><br><span class="line"><span class="keyword">struct</span> part inventory[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问*/</span></span><br><span class="line"><span class="comment">// 访问结构数组中的结构</span></span><br><span class="line">print_part(inventory[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*操作*/</span></span><br><span class="line"><span class="comment">// 为数组中的结构的成员赋值</span></span><br><span class="line">inventory[i].number = <span class="number">883</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组中的结构的成员（字符串）置空</span></span><br><span class="line"> inventory[i].name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-3-结构数组的初始化"><a href="#16-3-3-结构数组的初始化" class="headerlink" title="16.3.3    结构数组的初始化"></a>16.3.3    结构数组的初始化</h3><blockquote>
<p><strong>语法：</strong>类似二维数组的初始化，每个结构都拥有自己的大括号。<br><strong>注意：</strong>每个结构值的内层大括号是可选项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构：国家代码</span></span><br><span class="line"><span class="keyword">struct</span> dialog_code &#123;</span><br><span class="line">	<span class="keyword">char</span> *country;</span><br><span class="line">	<span class="keyword">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> dialog_code country_codes[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Argentina"</span>, <span class="number">54</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Bangladesh"</span>, <span class="number">66</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-4-程序：维护零件数据库"><a href="#16-3-4-程序：维护零件数据库" class="headerlink" title="16.3.4    程序：维护零件数据库"></a>16.3.4    程序：维护零件数据库</h3><h4 id="16-3-4-1-编写"><a href="#16-3-4-1-编写" class="headerlink" title="16.3.4.1    编写"></a>16.3.4.1    编写</h4><h5 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invent-c"><a href="#invent-c" class="headerlink" title="invent.c"></a>invent.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (array version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line"> 	<span class="keyword">int</span> on_hand;</span><br><span class="line"> &#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> num_parts = <span class="number">0</span>; <span class="comment">// 当前零件的数量</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待用户操作</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 跳过所有的换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line"> 				insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line"> 				search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line"> 				update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line"> 				print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line"> 				return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 				<span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 按照零件的编号查找零件在清单数组中的下标</span><br><span class="line"> * @param  number 零件的编号</span><br><span class="line"> * @return        零件在清单中的下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (inventory[i].number == number) &#123;</span><br><span class="line"> 			return i;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行插入零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 输入零件号</span></span><br><span class="line"> 	<span class="keyword">int</span> part_number;</span><br><span class="line"> 	<span class="keyword">if</span> (num_parts == MAX_PARTS) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Datebase is full, can't add more parts .\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter partnumber: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part_number);</span><br><span class="line"> 	<span class="keyword">if</span> (find_part(part_number) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exists.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	inventory[num_parts].number = part_number;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 输入零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name: "</span>);</span><br><span class="line"> 	read_line(inventory[num_parts].name, NAME_LEN);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inventory[num_parts].on_hand);</span><br><span class="line"> 	num_parts++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 在命令行根据零件编号搜索零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, inventory[i].name);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新清单中某种零件的数量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number, change;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number : "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand: "</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		inventory[i].on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印当前零件清单中所有种类零件的信息</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part Number   Part Name             "</span></span><br><span class="line"> 		   <span class="string">"Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d     %-25s%11d\n"</span>, inventory[i].number, inventory[i].name, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-3-4-2-编译"><a href="#16-3-4-2-编译" class="headerlink" title="16.3.4.2    编译"></a>16.3.4.2    编译</h4><p>$ vim makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invent:invent.o readline.o</span><br><span class="line">	gcc -o invent invent.o readline.o</span><br><span class="line">invent.o:invent.c readline.h</span><br><span class="line">	gcc -c invent.c</span><br><span class="line">readline.o:readline.c readline.h</span><br><span class="line">	gcc -c readline.c</span><br></pre></td></tr></table></figure>
<p>$ make</p>
<h4 id="16-3-4-3-运行"><a href="#16-3-4-3-运行" class="headerlink" title="16.3.4.3    运行"></a>16.3.4.3    运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./invent </span><br><span class="line"> Enter operation code:i</span><br><span class="line"> Enter partnumber: 01</span><br><span class="line"> Enter part name: screen</span><br><span class="line"> Enter quantity on hand: 1 </span><br><span class="line"></span><br><span class="line"> Enter operation code:p</span><br><span class="line"> Part Number   Part Name             Quantity on hand</span><br><span class="line">       1     screen</span><br></pre></td></tr></table></figure>
<h2 id="16-4-联合"><a href="#16-4-联合" class="headerlink" title="16.4    联合"></a>16.4    联合</h2><h3 id="特点（和结构相比）"><a href="#特点（和结构相比）" class="headerlink" title="特点（和结构相比）"></a>特点（和结构相比）</h3><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>包含一个或多个成员</li>
<li>成员可以是不同的类型</li>
<li>声明标记和类型的方式</li>
<li>访问成员的方式</li>
<li>可以使用<code>=</code>进行复制操作</li>
<li>可以在函数间传递或作为函数的返回值</li>
<li>初始化方式</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>联合的实例所有成员共享相同的存储空间</li>
<li>联合的实例大小由最大的成员的类型决定</li>
<li>联合初始化实例时初始化的是按照第一个成员的类型来初始化值的</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; u = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0会按照i的类型初始化存储空间</span></span><br><span class="line"></span><br><span class="line">u.f = <span class="number">78.4</span>; <span class="comment">// 为联合赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="16-4-1-使用联合来节省空间"><a href="#16-4-1-使用联合来节省空间" class="headerlink" title="16.4.1    使用联合来节省空间"></a>16.4.1    使用联合来节省空间</h3><blockquote>
<p><strong>原理：</strong>在<code>struct</code>中使用<code>union</code>作为成员，后者使用<code>struct</code>作为成员。这种混合的结构可以实现一种数据结构应用于多种情境的效果。<br><strong>扩展：</strong>在<code>c++</code>中，<code>struct</code>中的<code>union</code>可以匿名，在<code>c</code>中则不得不指定<code>union</code>的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_LEN 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTHOR_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESIGN_LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 礼品册上的商品</span><br><span class="line"> * 可以存储3种类型的商品：书籍、杯子、衬衫</span><br><span class="line"> *</span><br><span class="line"> * @type &#123;struct&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> catalog_item &#123;</span><br><span class="line">	<span class="keyword">int</span> stock_number; <span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">int</span> item_type; <span class="comment">// 分类</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 可能是书</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> title[TITLE_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">char</span> author[AUTHOR_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> num_pages;</span><br><span class="line">		&#125; book;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是杯子</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">		&#125; mug;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是衬衫</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> colors;</span><br><span class="line">			<span class="keyword">int</span> sizes;</span><br><span class="line">	 	&#125; shirt;</span><br><span class="line">	&#125; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构体实例</span></span><br><span class="line">	<span class="keyword">struct</span> catalog_item bookItem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为结构体中的联合的成员赋值</span></span><br><span class="line">	<span class="built_in">strcpy</span>(bookItem.item.book.title, <span class="string">"three body"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问结构题中的联合的成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, bookItem.item.book.title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-2-使用联合来构造混合的数据结构"><a href="#16-4-2-使用联合来构造混合的数据结构" class="headerlink" title="16.4.2    使用联合来构造混合的数据结构"></a>16.4.2    使用联合来构造混合的数据结构</h3><blockquote>
<p><strong>说明：</strong>创建含有不同数据类型的混合数据结构（比如数组）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 混合数据类型，包含整型和浮点型</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;union&#125; Number</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明混合型数组</span></span><br><span class="line">	Number number_array[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	number_array[<span class="number">0</span>].i = <span class="number">5</span>; <span class="comment">// 第一个值为整型</span></span><br><span class="line">	number_array[<span class="number">1</span>].f = <span class="number">3.14</span>; <span class="comment">// 第二个值为浮点型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number_array[<span class="number">0</span>].i); <span class="comment">// 5</span></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-3-为联合添加“标记字段”"><a href="#16-4-3-为联合添加“标记字段”" class="headerlink" title="16.4.3    为联合添加“标记字段”"></a>16.4.3    为联合添加“标记字段”</h3><blockquote>
<p><strong>用途：</strong>为联合提供额外的当前类型信息，防止获取到无意义的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_KIND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_KIND 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;struct&#125; </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> kind; <span class="comment">// 标记字段</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据数据结构的类型以不同的方式打印值</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;struct&#125; n 要打印的数据结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构实例</span></span><br><span class="line">	Number n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记字段</span></span><br><span class="line">	n.kind = INT_KIND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	n.u.i = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印出来</span></span><br><span class="line">	print_number(n); <span class="comment">// 82</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n.u.i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%g\n"</span>, n.u.f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-5-枚举"><a href="#16-5-枚举" class="headerlink" title="16.5    枚举"></a>16.5    枚举</h2><blockquote>
<p><strong>说明：</strong><code>enum</code>是一种由程序员列出值的类型，而且程序员必须为每种值（枚举常量）命名。<br><strong>特点：</strong></p>
<ul>
<li>遵循到c语言的作用域规则（如果枚举声明在函数体内，那么它的常量对外部函数是不可见的）</li>
<li>声明的方式类似结构和联合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的声明方式：定义枚举类型的同时声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-1-枚举标记和枚举类型"><a href="#16-5-1-枚举标记和枚举类型" class="headerlink" title="16.5.1    枚举标记和枚举类型"></a>16.5.1    枚举标记和枚举类型</h3><blockquote>
<p><strong>说明：</strong>类似结构和联合的标记，有两种方式。</p>
</blockquote>
<h5 id="方式1：enum-标记名-可能值"><a href="#方式1：enum-标记名-可能值" class="headerlink" title="方式1：enum 标记名 {可能值}"></a>方式1：<code>enum 标记名 {可能值}</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> suit s1, s2;</span><br></pre></td></tr></table></figure>
<h5 id="方式2：typedef-enum-可能值-类型名"><a href="#方式2：typedef-enum-可能值-类型名" class="headerlink" title="方式2：typedef enum {可能值} 类型名"></a>方式2：<code>typedef enum {可能值} 类型名</code></h5><blockquote>
<p><strong>技巧：</strong>利用<code>typedef</code>来创建布尔类型是非常好的一种方法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; Suit;</span><br><span class="line">Suit s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-2-枚举作为整数"><a href="#16-5-2-枚举作为整数" class="headerlink" title="16.5.2    枚举作为整数"></a>16.5.2    枚举作为整数</h3><blockquote>
<p><strong>说明：</strong>在系统内部，c语言会把枚举变量和常量作为整数处理。</p>
<ul>
<li>当没有为枚举常量指定值时，它的值时一个大于前一个常量的值（默认第一个枚举常量的值为0）</li>
<li>可以为枚举常量自由选择不同的值</li>
<li>当为枚举常量指定值时，对大小顺序没有要求</li>
<li>两个或多个枚举常量具有相同的值也是合法的</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS = <span class="number">20</span>, DIAMONDS = <span class="number">10</span>, HEARTS, SPADES&#125;; <span class="comment">// 20, 10, 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>把整数用作枚举的值是非常危险的，<code>c++</code>不允许整数用作枚举的值来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s;</span><br><span class="line">i = DIAMONDS;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">s++;</span><br><span class="line">i = s + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-3-用枚举声明“标记字段”"><a href="#16-5-3-用枚举声明“标记字段”" class="headerlink" title="16.5.3    用枚举声明“标记字段”"></a>16.5.3    用枚举声明“标记字段”</h3><blockquote>
<p><strong>说明：</strong><code>enum</code>和<code>union</code>配合实现<code>union</code>的“标记字段”。<br><strong>优点：</strong></p>
<ul>
<li>不需要额外定义宏</li>
<li>明确类型的可能值范围</li>
<li>含义更明确</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedeg <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">enum</span> &#123;INT_KIND, FLOAT_KIND&#125; kind;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/15 编写大规模程序/" itemprop="url">
                  15 编写大规模程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:39:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/15 编写大规模程序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/15 编写大规模程序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="15-1-源文件"><a href="#15-1-源文件" class="headerlink" title="15.1    源文件"></a>15.1    源文件</h2><blockquote>
<p><strong>说明：</strong>可以把程序分割成一定数量的源文件(.c文件和.h文件)。</p>
<ul>
<li>原文件的扩展名为.c，每个原文件包含程序的部分内容，主要是函数的定义和变量</li>
<li>一个原文件必须包含名为main的函数，次函数作为程序的起始点</li>
</ul>
<p><strong>优点：</strong>把程序分裂成多个源文件有许多显著的优点。</p>
<ul>
<li>（易读）把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构</li>
<li>（易维护）可以单独对每一个文件进行编译。</li>
<li>（易复用）当把函数集合在单独的源文件中时，会更容易在其他程序中重新使用这些函数。</li>
</ul>
</blockquote>
<h3 id="案例－计算器："><a href="#案例－计算器：" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h3><blockquote>
<p><strong>逆波兰符号（Reverse Polish Notation, RPN）：</strong>指运算符都跟在操作数的后边。例如：<code>30 5 - 7 *</code>。<br><strong>思路：</strong>程序逐个读入操作数和运算符，那么利用栈跟踪中间结果这样的方式计算逆波兰表达式是很容易的。</p>
<ol>
<li>读取“记号”（数或运算符）</li>
<li>如果程序读取数，就将此数压入栈</li>
<li>如果程序读取运算符，那么将从栈顶弹出两个数进行相应的计算。</li>
</ol>
</blockquote>
<h2 id="15-2-头文件"><a href="#15-2-头文件" class="headerlink" title="15.2    头文件"></a>15.2    头文件</h2><blockquote>
<p><strong>说明：</strong>如果打算几个源文件可以访问相同的信息，那么将把此信息放在文件中，扩展名为<code>.h</code>，然后利用<code>#include</code>指令把文件的内容带进每个源文件中。这样的<code>.h</code>文件就是头文件（或包含文件）。</p>
</blockquote>
<h3 id="15-2-1-include指令"><a href="#15-2-1-include指令" class="headerlink" title="15.2.1    #include指令"></a>15.2.1    #include指令</h3><p><strong>语法：</strong>有两种格式，其中的<code>文件名</code>可以包含路径或驱动器号。而且预处理器不会讲<code>&quot;文件名&quot;</code>当作字符串处理了，不然DOS路径中的某些字符有可能被当作转义字符。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>搜索目标</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>#include &lt;文件名&gt;</td>
<td>系统头文件所在的目录</td>
<td>有可能是多个，通常是/usr/include</td>
</tr>
<tr>
<td>#include “文件名”</td>
<td>搜索当前目录，然后搜索系统头文件所在的目录</td>
<td>可以通过诸如-I选项修改搜索目录</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"c:\cprogs\utils.h"</span>/*DOS path*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"/cprogs/utils.h"</span>/*UNIX path*/</span></span><br></pre></td></tr></table></figure>
<p><strong>可移植性技巧：</strong>不要在<code>#include</code>指令中包含路径或驱动器信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys\stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;..\include\utils.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-共享宏定义和类型定义"><a href="#15-2-2-共享宏定义和类型定义" class="headerlink" title="15.2.2    共享宏定义和类型定义"></a>15.2.2    共享宏定义和类型定义</h3><blockquote>
<p><strong>说明：</strong>将通用的宏定义和类型定义放在头文件中有许多明显的好处。</p>
<ul>
<li>不用频繁复制代码</li>
<li>易于修改和维护</li>
<li>避免犹豫原文件包含相同宏或类型的不同定义而导致的矛盾</li>
</ul>
</blockquote>
<p><em>boolean.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-共享函数原型"><a href="#15-2-3-共享函数原型" class="headerlink" title="15.2.3    共享函数原型"></a>15.2.3    共享函数原型</h3><blockquote>
<p><strong>说明：</strong>为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。<br><strong>技巧：</strong>为了保证函数原型声明一致，声明部分单独放在一个头文件中。然后在定义和调用的源文件中都引入该头文件。<br><strong>注意：</strong>在调用在其他文件中的函数时，要始终确保编译器在调用之前看到函数的原型。</p>
</blockquote>
<h4 id="案例－计算器：-1"><a href="#案例－计算器：-1" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h4><p><em>1. 头文件：<code>stack.h</code></em></p>
<blockquote>
<p><strong>说明：</strong>包含共享的函数的原型声明。<br><strong>注意：</strong>只在<code>calc.c</code>中使用的的函数不应该定义在该头文件中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>2. 函数定义：<code>stack.c</code></em></p>
<blockquote>
<p><strong>说明：</strong>实现stack.c中声明的所有函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>3. 入口文件：<code>calc.c</code></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//编译器会通过stack.h中make_empty的原型找到对应的定义，从而正确调用</span></span><br><span class="line">	make_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>编译运行</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o calc calc.c stack.c</span><br><span class="line">$ ./calc </span><br><span class="line"> what</span><br></pre></td></tr></table></figure>
<h3 id="15-2-4-共享变量声明"><a href="#15-2-4-共享变量声明" class="headerlink" title="15.2.4    共享变量声明"></a>15.2.4    共享变量声明</h3><blockquote>
<p><strong>说明：</strong>为了共享变量<code>i</code>，首先把变量i的定义（和初始化）放置在一个文件中，而在其他文件中包含变量<code>i</code>的声明（使用关键字<code>extern</code>）。<br><strong>变量声明：</strong><code>extern</code></p>
<ul>
<li>类似函数的声明，仅声明变量名和类型（内存不会为其分配空间）</li>
<li>通常情况下我们不使用<code>extern</code>，这种情况下变量声明和定义同时完成</li>
<li>可以用于所有类型的变量</li>
<li>在数组的声明中使用<code>extern</code>时可以忽略数组的长度<code>extern int a[];</code></li>
<li>编译器无法检查<code>变量声明</code>是否和<code>变量定义</code>严格匹配，因此有可能出现和声明类型不一致的定义，这会导致程序的异常行为</li>
</ul>
<p><strong>技巧：</strong>通常把共享的变量的声明放置在头文件中，需要访问该共享变量的源文件中引入该头文件。同时如果变量的定义在其它源文件（而不是入口文件中），则也需要引入该头文件。<br><strong>扩展：</strong>虽然在文件中共享变量是<code>c</code>语言界的长期惯例，但是它有重大缺陷。<code>19.2</code>节有如何设计不需要共享变量的程序的知识。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern提示编译器变量i是在程序的其它位置定义的（同一文件或不同文件）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-5-嵌套包含"><a href="#15-2-5-嵌套包含" class="headerlink" title="15.2.5    嵌套包含"></a>15.2.5    嵌套包含</h3><blockquote>
<p><strong>说明：</strong>头文件自身可以包含<code>#include</code>指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"boolean.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-6-保护头文件"><a href="#15-2-6-保护头文件" class="headerlink" title="15.2.6    保护头文件"></a>15.2.6    保护头文件</h3><blockquote>
<p><strong>为什么保护：</strong>如果源文件包含同一个文件两次（直接或间接），那么可能（如果包含类型定义）会产生编译错误。</p>
<ul>
<li>避免由重复的类型定义导致的编译错误</li>
<li>节约编译时间</li>
</ul>
<p><strong>如何保护：</strong>为了防止头文件多次包含导致的多次编译，将用<code>#ifndef</code>和<code>#endif</code>两个指令把文件闭合起来。在预编译阶段去重复掉引入的头文件的代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BOOLEAN_H是按照所在头文件名(BOOLEAN.h)进行命名的，目的是避免和其它头文件中的宏冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-7-头文件中的-error指令"><a href="#15-2-7-头文件中的-error指令" class="headerlink" title="15.2.7    头文件中的#error指令"></a>15.2.7    头文件中的#error指令</h3><blockquote>
<p><strong>用途：</strong>放在头文件中用来检查不应该包含头文件的条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在DOS程序中才能正常使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOS</span></span><br><span class="line">	<span class="comment">//如果非DOS程序试图包含此头文件，那么编译将在#error指令处停止</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">error</span> Grapphics supported only under DOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="15-3-把程序划分成多个文件（程序：文本格式化）"><a href="#15-3-把程序划分成多个文件（程序：文本格式化）" class="headerlink" title="15.3    把程序划分成多个文件（程序：文本格式化）"></a>15.3    把程序划分成多个文件（程序：文本格式化）</h2><blockquote>
<p><strong>功能分析：</strong>能够将输入的文本格式化的命令行工具。</p>
<ul>
<li>“删除空行、制表符”</li>
<li>“填充”：添加单词直到再多一个单词就会导致溢出时才停止</li>
<li>“调整”：除最后一行外，在单词间添加额外的空格以便每行有精确的相同长度（60个字符）</li>
</ul>
</blockquote>
<h2 id="15-4-构建多文件程序"><a href="#15-4-构建多文件程序" class="headerlink" title="15.4    构建多文件程序"></a>15.4    构建多文件程序</h2><blockquote>
<p><strong>原理：</strong>大多数编译器允许一步完成编译和链接的过程。</p>
<ol>
<li><strong>编译：</strong>对每个源文件（不包括头文件）分别进行编译</li>
<li><strong>链接：</strong>把上一步产生的目标文件和库函数的代码结合在一起生成可执行的程序。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-o告诉编译器最终的可执行文件的名字</span></span><br><span class="line">$ gcc -o fmt fmt.c line.c word.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-1-makefile"><a href="#15-4-1-makefile" class="headerlink" title="15.4.1    makefile"></a>15.4.1    makefile</h3><p><strong>命令行编译的缺点：</strong></p>
<ul>
<li>枯燥乏味（敲没有营养的编译命令）</li>
<li>浪费时间，所有源文件每次都会被重新编译</li>
<li>构建大规模程序费时费力易出错</li>
</ul>
<p><strong>说明：</strong>Unix系统发明了makefile的概念，这个文件包含构建程序的必要信息。</p>
<ol>
<li>列出了作为程序部分的文件</li>
<li>描述了文件之间的依赖性</li>
</ol>
<p><strong>基本语法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件名:依赖的文件</span><br><span class="line">[tab]命令</span><br></pre></td></tr></table></figure>
<p><strong>扩展：</strong>不是每个人都使用makefile，其它程序维护工具正变得流行，包括一些集成开发环境支持的“工程文件”。</p>
<h4 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt:fmt.o word.o line.o</span><br><span class="line">	gcc -o fmt fmt.o word.o line.o</span><br><span class="line">fmt.o:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.o:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.o:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h4 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.exe:fmt.obj word.obj line.obj</span><br><span class="line">	gcc -o fmt fmt.obj word.obj line.obj</span><br><span class="line">fmt.obj:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.obj:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.obj:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-2-链接期间的错误"><a href="#15-4-2-链接期间的错误" class="headerlink" title="15.4.2    链接期间的错误"></a>15.4.2    链接期间的错误</h3><blockquote>
<p><strong>常见错误：</strong></p>
<ol>
<li>Undefined symbol</li>
<li>Unresollved external reference</li>
</ol>
<p><strong>起因：</strong>程序中丢失了函数定义或变量定义，那么链接器将无法解决外部引用。</p>
<ol>
<li>拼写错误</li>
<li>丢失文件</li>
<li>丢失库</li>
</ol>
</blockquote>
<h3 id="15-4-3-重新构建程序"><a href="#15-4-3-重新构建程序" class="headerlink" title="15.4.3    重新构建程序"></a>15.4.3    重新构建程序</h3><blockquote>
<p><strong>两种情况：</strong>无论哪个文件发生变化，重新编译后都需要重新链接整个程序。</p>
<ol>
<li>变化影响单独一个源文件：只对此文件进行重新编译</li>
<li>变化影响头文件：重新编译所有包含此头文件的源文件</li>
</ol>
<p><strong>使用makefile重新构建：</strong>通过检查每个文件的日期，makex可以确定从程序最后一次构建后哪些文件发生了变化。然后根据依赖关系判断如何重新编译。</p>
</blockquote>
<h3 id="15-4-4-在程序外定义宏"><a href="#15-4-4-在程序外定义宏" class="headerlink" title="15.4.4    在程序外定义宏"></a>15.4.4    在程序外定义宏</h3><blockquote>
<p><strong>意义：</strong>不需要编辑任何程序文件就对宏的值进行改变。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D</td>
<td>在命令行指定宏的值</td>
<td>大多数UNIX编译器和某些非UNIX编译器</td>
</tr>
<tr>
<td>-U</td>
<td>取消指定宏的定义</td>
<td>一些编译器</td>
</tr>
</tbody>
</table>
<p><em>foo.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br></pre></td></tr></table></figure>
<p><em>命令行</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DDEBUG=1 foo.c</span><br><span class="line"># gcc -UDEBUG foo.c</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/14 预处理器/" itemprop="url">
                  14 预处理器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:28:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/14 预处理器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/14 预处理器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>预处理器是一个小软件，它可以在编译前编辑c程序<br><strong>弊端：</strong></p>
<ul>
<li>造成那一发现的错误的根源</li>
<li>经常被错误地用来编写一些几乎不可能读懂的程序</li>
</ul>
<p><strong>技巧：</strong>适度使用预处理功能，减少对于处理器的依赖。<br><strong>扩展：</strong>c++中可以进一步限制预处理器的使用。</p>
</blockquote>
<h2 id="14-1-预处理器的工作方式"><a href="#14-1-预处理器的工作方式" class="headerlink" title="14.1    预处理器的工作方式"></a>14.1    预处理器的工作方式</h2><blockquote>
<p><strong>说明：</strong>预处理器的输入是一个c语言程序，程序中可能会包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8B%E5%8D%884.28.36.png" alt="Alt text"></p>
<blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>不检查错误</li>
<li>不删除包含指令的行，而是简单地将它们替换为空</li>
<li>将每一处注视替换为空格字符（有些与编译器会进一步删除不必要的空白字符，并在每一行开始使用缩进的空格符和制表符）</li>
</ul>
<p><strong>注意：</strong>预处理器仅知道少量的c语言规则，因此，它在执行指令时非常有可能产生非法的程序。</p>
</blockquote>
<h2 id="14-2-预处理指令"><a href="#14-2-预处理指令" class="headerlink" title="14.2    预处理指令"></a>14.2    预处理指令</h2><p><strong>分类：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>包括</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义</td>
<td><code>#define</code> <code>#undef</code></td>
</tr>
<tr>
<td>文件包含</td>
<td><code>#include</code></td>
</tr>
<tr>
<td>条件编译</td>
<td><code>#if</code> <code>ifdef</code> <code>ifindef</code> <code>elif</code> <code>#else</code> <code>#endif</code></td>
</tr>
<tr>
<td>其他</td>
<td><code>#error</code> <code>#line</code> <code>#pragma</code></td>
</tr>
</tbody>
</table>
<p><strong>语法：</strong></p>
<ul>
<li>指令都以<code>#</code>开始：<code>空白符 #指令名 指令所需要的其他信息</code></li>
<li>在指令的符号之间可以插入任意树龄的空格或横向制表符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#		<span class="meta-keyword">define</span>		N 		100<span class="comment">// 这样写也是合法的</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>指令总是在第一个换行符处结束，除非明确地指明要继续（通过在行末尾使用<code>\</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISK_CAPACITY (SIDES *  \</span><br><span class="line">                        TRACK_PER_SIDE * \)</span></span><br><span class="line">				    	  SECTORS_PER_TRACK * \</span><br><span class="line">						  BYTES_PER_SECTOR)</span><br></pre></td></tr></table></figure>
<ul>
<li>指令可以出现在程序种任何地方（<code>#define</code>和<code>#include</code>通常放在文件开始）</li>
<li>注释可以和指令放在同一行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREEZING_PT 32.0	<span class="comment">/* Freezing point of water */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-3-宏定义"><a href="#14-3-宏定义" class="headerlink" title="14.3    宏定义"></a>14.3    宏定义</h2><blockquote>
<p><strong>说明：</strong>除了简单的宏，与编译器也支持带参数的宏。</p>
</blockquote>
<h3 id="14-3-1-简单的宏"><a href="#14-3-1-简单的宏" class="headerlink" title="14.3.1    简单的宏"></a>14.3.1    简单的宏</h3><p><strong>语法：</strong><code>#define 表示符 替换列表</code><br><strong>替换列表：</strong>一系列c语言记号，包括表示符、关键字、数、字符常量、字符串字面量、运算符和标点符号。<br><strong>原理：</strong>当预处理器遇到一个宏定义时，会做一个<code>标识符</code>代表<code>替换列表</code>的记录。再文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。<br><strong>注意（常见错误）：</strong></p>
<ol>
<li>不要在宏定义中放置任何额外的符号</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N = 1000<span class="comment">//不能使用=</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会成为int a[= 100]，导致错误</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不能在宏定义的末尾添加分号</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;<span class="comment">//这里添加的分号会被作为替换列表的一部分</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会变成int a[100;]</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>简单的宏主要用来定义那些被<code>Kernighan</code>和<code>Ritchie</code>称为明示常量（<code>manifest constant</code>）的东西。优点如下</p>
<ol>
<li>程序更易读</li>
<li>易于修改</li>
<li>帮助避免前后不一致或键盘输入错误</li>
<li>可以对c语法做小的修改</li>
<li>对类型重命名</li>
<li>控制条件编译</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE_LEN 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR <span class="string">'R'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOS <span class="string">'\0'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-带参数的宏"><a href="#14-3-2-带参数的宏" class="headerlink" title="14.3.2    带参数的宏"></a>14.3.2    带参数的宏</h3><blockquote>
<p><strong>语法：</strong><code>#define 标识符(x1, x2, ..., xn) 替换列表</code></p>
<ul>
<li>宏的<code>(</code>和<code>标识符</code>之间必须没有空格（否则会被当作简单宏处理）</li>
</ul>
<p><strong>原理：</strong>当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，宏调用<code>标识符(y1,y2,...,yn)</code>会被<code>替换列表</code>替换，且参数也会依据<code>宏定义</code>对应到替换列表中。<br><strong>用途：</strong></p>
<ul>
<li>经常被用来作为一些简单的函数使用（模拟函数调用）</li>
<li>经常被作为模版，替换经常重复书写的代码段（替换语句）<br><strong>优点：</strong>相比实际的函数</li>
<li>程序可能会稍快些（没有存储上下文、复制参数等的开销）</li>
<li>宏会更“通用”（没有对参数类型的限制）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>编译后的代码通常会变大</li>
<li>宏参数没有类型检查</li>
<li>无法用一个指针指向一个宏</li>
<li>宏可能会不止一次地计算它的参数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果宏使用带有副作用的参数，多次进行宏调用带来的副作用可能导致不易察觉的错误。</li>
</ul>
<p><strong>技巧：</strong>避免使用带有副作用的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y)	((x) &gt; (y) ? (x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EVEN(n) ((n)%2 == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTINT_INT(x) printf(<span class="string">"%d\n"</span>, x)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">i = MAX(j+k, m-n);<span class="comment">//会被修改为i = ((j+k) &gt; (m-n) ? (j+k):(m-n));</span></span><br><span class="line"><span class="keyword">if</span>(IS_EVEN(i)) i++;<span class="comment">//if(((i)%2 == 0)) i++;</span></span><br><span class="line"></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("%d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-运算符"><a href="#14-3-3-运算符" class="headerlink" title="14.3.3    #运算符"></a>14.3.3    <code>#</code>运算符</h3><blockquote>
<p><strong>说明：</strong>将带参数的宏的参数转换为字符串字面量<br><strong>语法：</strong><code>#define 标识符(x1...) 替换列表</code></p>
<ul>
<li><code>#参数</code>仅允许出现在带参数的宏的替换列表中</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(x) printf(#x <span class="string">" = %%d"</span>, x)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//c语言中相邻的字符串字面量会被合并</span></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("i/j = %d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-4-运算符"><a href="#14-3-4-运算符" class="headerlink" title="14.3.4    ##运算符"></a>14.3.4    <code>##</code>运算符</h3><blockquote>
<p><strong>说明：</strong>可以将两个记号（例如标识符）“粘”在一起，成为一个记号。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define MK_ID(n) i##n</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">//int i1, i2, i3;</span><br><span class="line">int MK_ID(1), MK_ID(2), MK_ID(3);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>求最大值的函数模版（针对不同类型）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERIC_MAX(type)		\</span><br><span class="line">type type##_max(type x, type y)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return x &gt; y ? x : y;		\</span><br><span class="line">&#125;	</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* float float_max(float x, float y)&#123;</span><br><span class="line">*	return x &gt; y ? x : y;</span><br><span class="line">* &#125;</span><br><span class="line">*/</span></span><br><span class="line">GENERIC_MAX(<span class="keyword">float</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-5-宏的通用属性"><a href="#14-3-5-宏的通用属性" class="headerlink" title="14.3.5    宏的通用属性"></a>14.3.5    宏的通用属性</h3><ul>
<li>宏的替换列表可以包含对另一个宏的调用</li>
<li>预处理器智慧替换完整的记号，而不会替换记号的片段</li>
<li>一个宏定义的作用范围通常到出现这个宏的文件末尾</li>
<li>宏不可以被定义两遍，除非新的定义和旧的定义是一样的</li>
<li>宏可以使用<code>#undef</code>指令取消定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N<span class="comment">//取消对N的定义以便给出新的定义</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-6-宏定义中的圆括号"><a href="#14-3-6-宏定义中的圆括号" class="headerlink" title="14.3.6    宏定义中的圆括号"></a>14.3.6    宏定义中的圆括号</h3><blockquote>
<p><strong>说明：</strong>在宏定义中缺少圆括号会导致c语言最让人讨厌的错误（比如优先级问题）。<br><strong>哪里要添加圆括号：</strong></p>
<ol>
<li>如果宏的替换列表中又运算符，那么始终要讲替换列表放在括号中</li>
<li>当宏有参数时，仅给替换列表添加圆括号是不够的，参数的每一次出现都要添加圆括号</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE(x) (x*10)<span class="comment">//需要给x添加括号</span></span></span><br><span class="line">...</span><br><span class="line">j = SCALE(i+<span class="number">1</span>);<span class="comment">//j = ((i+1)*10);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-7-创建较长的宏"><a href="#14-3-7-创建较长的宏" class="headerlink" title="14.3.7    创建较长的宏"></a>14.3.7    创建较长的宏</h3><h4 id="14-3-7-1-逗号运算符"><a href="#14-3-7-1-逗号运算符" class="headerlink" title="14.3.7.1    逗号运算符"></a>14.3.7.1    逗号运算符</h4><blockquote>
<p><strong>说明：</strong>创建较长的宏的一个办法是使用<code>逗号运算符</code>，特别是可以使用逗号运算符来使替换列表包含一系列表达式。<br><strong>限制：</strong><code>逗号运算符</code>只能连接<code>表达式</code>，不能连接<code>语句</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-2-复合语句"><a href="#14-4-7-2-复合语句" class="headerlink" title="14.4.7.2        复合语句"></a>14.4.7.2        复合语句</h4><blockquote>
<p><strong>说明：</strong>除了使用逗号表达式，还可以将<code>语句</code>或<code>表达式</code>放在<code>{}</code>内形成复合语句。<br><strong>缺点：</strong>不能在<code>替换列表</code>为复合语句的宏调用的末尾使用分号结尾，因为在<code>if</code>语句中会调用会导致错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-3-在只循环一次的do-while中包含语句和表达式"><a href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式" class="headerlink" title="14.4.7.3    在只循环一次的do-while中包含语句和表达式"></a>14.4.7.3    在只循环一次的do-while中包含语句和表达式</h4><blockquote>
<p><strong>说明：</strong>加入一个宏需要包含一系列的语句，而不仅仅是一些列的表达式，可以将语句放在<code>do</code>循环中，并将条件设置为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s)		\</span><br><span class="line">	do&#123;				\</span><br><span class="line">		gets(s); 	\</span><br><span class="line">		puts(s);	\</span><br><span class="line">	&#125;while(0)		</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//do&#123;gets(s); puts(s);&#125;while(0)</span></span><br><span class="line">ECHO(str);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-8-预定义宏"><a href="#14-3-8-预定义宏" class="headerlink" title="14.3.8    预定义宏"></a>14.3.8    预定义宏</h3><blockquote>
<p><strong>说明：</strong>在c语言中预定义了一些有用的宏，这些宏主要是提供当前编译的信息。<br><strong>扩展：</strong>c语言提供了一个通用的、用于错误检测的宏—assert宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>LINE</em></td>
<td>被编译的文件的行数</td>
</tr>
<tr>
<td><em>FILE</em></td>
<td>被编译的文件的名字</td>
</tr>
<tr>
<td><em>DATE</em></td>
<td>编译的日期（格式”Mmm dd yyyy”）</td>
</tr>
<tr>
<td><em>TIME</em></td>
<td>编译的时间（格式”hh:mm:ss”）</td>
</tr>
<tr>
<td><em>STDC</em></td>
<td>如果编译器接受标准c，那么值为1</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测被零除的错误</span></span><br><span class="line"><span class="comment">//该宏应该在除法之前被调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ZERO(divisor)	\</span><br><span class="line">	<span class="meta-keyword">if</span>(divisor == 0)&#123;		\</span><br><span class="line">		printf(<span class="string">"**** Attempt to divide by zero on line %d "</span> \</span><br><span class="line">				<span class="string">"of file $s ***\n"</span>, _LINE_, _FILE_);		\\</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">CHECK_ZERO(j);</span><br><span class="line">k = i / j;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="14-4-条件编译"><a href="#14-4-条件编译" class="headerlink" title="14.4    条件编译"></a>14.4    条件编译</h2><blockquote>
<p><strong>说明：</strong>条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段。</p>
</blockquote>
<h3 id="14-4-1-if指令和-endif指令"><a href="#14-4-1-if指令和-endif指令" class="headerlink" title="14.4.1    #if指令和#endif指令"></a>14.4.1    #if指令和#endif指令</h3><blockquote>
<p><strong>语法：</strong>当预处理器遇到<code>if</code>指令时，会计算常量表达式。如果表达式的值为0，那么<code>#if</code>与<code>#endif</code>之间的行将在预处理过程中删除。<br><strong>注意：</strong>对于没有定义过的标识符，<code>#if</code>指令会把它当作是值为0的宏对待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">&gt;	语句</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of i: %d\n"</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of j: %d\n"</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-defined运算符"><a href="#14-4-2-defined运算符" class="headerlink" title="14.4.2    defined运算符"></a>14.4.2    defined运算符</h3><blockquote>
<p><strong>说明：</strong>如果标识符是一个定义过的宏返回1，否则返回0。<br><strong>用途：</strong>判断宏某个标识符是否被定义的宏，通常和<code>#if</code>指令结合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-3-ifdef指令和-ifndef指令"><a href="#14-4-3-ifdef指令和-ifndef指令" class="headerlink" title="14.4.3    #ifdef指令和#ifndef指令"></a>14.4.3    #ifdef指令和#ifndef指令</h3><blockquote>
<p><strong>说明：</strong>严格说来，这里要介绍的两种指令都不是必须的，因为都可以用其他指令模拟。</p>
</blockquote>
<h4 id="14-4-3-1-ifdef指令"><a href="#14-4-3-1-ifdef指令" class="headerlink" title="14.4.3.1    #ifdef指令"></a>14.4.3.1    #ifdef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>if defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="14-4-3-2-ifndef指令"><a href="#14-4-3-2-ifndef指令" class="headerlink" title="14.4.3.2    #ifndef指令"></a>14.4.3.2    #ifndef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>#if !defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="14-4-4-elif指令和-else指令"><a href="#14-4-4-elif指令和-else指令" class="headerlink" title="14.4.4    #elif指令和#else指令"></a>14.4.4    #elif指令和#else指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 表达式1</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 表达式2</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<h3 id="14-4-5-使用条件编译"><a href="#14-4-5-使用条件编译" class="headerlink" title="14.4.5    使用条件编译"></a>14.4.5    使用条件编译</h3><p><strong>常见应用：</strong></p>
<ul>
<li>编写在多台机器或多种操作系统之间可移植的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WINDOWS)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(DOS)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS2)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写可以使用不同的编译器进行编译的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC__</span></span><br><span class="line">标准c函数原型</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">经典c函数声明</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>为宏提供默认定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUFFER_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时屏蔽包含注释的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">包含注释的代码行</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-5-其他指令"><a href="#14-5-其他指令" class="headerlink" title="14.5    其他指令"></a>14.5    其他指令</h2><h3 id="14-5-1-error指令"><a href="#14-5-1-error指令" class="headerlink" title="14.5.1    #error指令"></a>14.5.1    #error指令</h3><blockquote>
<p><strong>语法：</strong><code>#error 消息</code><br><strong>说明：</strong>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，这个消息一定会包含<code>消息</code>，然后大多数编译器会立即终止编译而不去找出其他错误。<br><strong>用途：</strong>通常与条件编译指令一起用于检测正常编译过程中不应出现的情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if INT_MAX &lt; 1000000</span><br><span class="line">#error int type is too small//Error directive:int type is too small</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="14-5-2-line指令"><a href="#14-5-2-line指令" class="headerlink" title="14.5.2    #line指令"></a>14.5.2    #line指令</h3><blockquote>
<p><strong>说明：</strong>用来改变程序行编号的方式以及使编译器认为所在文件是另一个文件。<br><strong>语法：</strong><code>#line 行号 [文件名]</code></p>
<ul>
<li><code>行号</code>是大小介于1-32767之间的整数</li>
<li><code>行号</code>会影响<code>__LINE__</code>宏的值，<code>文件名</code>影响<code>__FILE__</code>的值</li>
</ul>
<p><strong>用途：</strong>主要用于那些产生c代码作为输入的程序，因为出错信息都指向程序员编写的文件，而不是（更复杂）由一些工具生成的文件。</p>
</blockquote>
<h3 id="14-5-3-pragma指令"><a href="#14-5-3-pragma指令" class="headerlink" title="14.5.3    #pragma指令"></a>14.5.3    #pragma指令</h3><blockquote>
<p><strong>语法：</strong><code>#pragma 记号</code></p>
<ul>
<li>＃pragma指令通常只跟着一个记号，这个记号表示了一条编译器需要服从的命令</li>
<li>一些编译器允许#pragma指令所包含的不仅是简单的命令（特别是有些编译器允许#pragma指令带参数）</li>
<li>如果#pragma指令包含了无法识别的命令，编译器必须忽略这些#pragma指令，不允许产生出错信息</li>
</ul>
<p><strong>注意：</strong>#pragma指令中出现的命令集在不同的编译器上是不一样的，需要查阅相关编译器的文档。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/13 字符串/" itemprop="url">
                  13 字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:11:36+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/13 字符串/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/13 字符串/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="13-1-字符串字面量"><a href="#13-1-字符串字面量" class="headerlink" title="13.1    字符串字面量"></a>13.1    字符串字面量</h2><blockquote>
<p><strong>说明：</strong>用一对双括号括起来的字符序列。</p>
<h3 id="13-1-1-字符串字面量中的转义序列"><a href="#13-1-1-字符串字面量中的转义序列" class="headerlink" title="13.1.1    字符串字面量中的转义序列"></a>13.1.1    字符串字面量中的转义序列</h3><p><strong>说明：</strong><code>char</code>型字面量中能够使用的转义字符字符串字面量中都可以使用。<br><strong>注意：</strong>数字转义字符并不常用，但使用时会需要注意一些<code>char</code>中不会遇到的问题</p>
</blockquote>
<table>
<thead>
<tr>
<th>数字转义字符</th>
<th>格式</th>
<th>字符串字面量额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制转义字符</td>
<td><code>\最多含有3位数字的八进制数字</code></td>
<td>在3个数字之后结束，或者在第一个非八进制数字符处结束。</td>
</tr>
<tr>
<td>十六进制转义字符</td>
<td><code>\x十六进制数</code></td>
<td>没有字数限制，直到第一个非十六机制数字符截止（通常还限制十六进制数大小为<code>\x0~\x7f</code>或<code>\x0~\xff</code>）</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串字面量中使用8进制转义字符</span></span><br><span class="line"><span class="string">"\1234"</span><span class="comment">//2个字符（\123和4）</span></span><br><span class="line"><span class="string">"\189"</span><span class="comment">//3个字符（\1，8，9）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字面量中使用16进制转义字符</span></span><br><span class="line"><span class="string">"Z\x81rich"</span><span class="comment">//6个字符（Z, \81, r, i, c, h）</span></span><br><span class="line"><span class="string">"\x81ber"</span><span class="comment">//2个字符（\x81be和r）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-延续字符串字面量"><a href="#13-1-2-延续字符串字面量" class="headerlink" title="13.1.2    延续字符串字面量"></a>13.1.2    延续字符串字面量</h3><h4 id="方式一：用字符-结尾"><a href="#方式一：用字符-结尾" class="headerlink" title="方式一：用字符\结尾"></a>方式一：用字符<code>\</code>结尾</h4><blockquote>
<p><strong>说明：</strong>只要在一行用字符<code>\</code>结尾，那么c语言就允许在下一行延续字符串字面量。<br><strong>注意：</strong>除了（看不见）的末尾的换行符，在同一行不可以有其他字符跟在<code>\</code>后面。<br><strong>扩展：</strong>不只字符串，字符<code>\</code>还可以用来分隔任何长的符号。<br><strong>缺点：</strong>字符字面量必须从下一行的起始位置继续，破坏了程序的缩紧结构。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A,then \</span><br><span class="line">press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="方式二：字面量自动合并（c标准）"><a href="#方式二：字面量自动合并（c标准）" class="headerlink" title="方式二：字面量自动合并（c标准）"></a>方式二：字面量自动合并（c标准）</h4><blockquote>
<p><strong>说明：</strong>当两条或更多条字符串字面量相连时（仅用空白字符分割），编译器必须把他们合并成单独一条字符串。<br><strong>优点：</strong>不必破坏缩紧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A, then"</span></span><br><span class="line">	   <span class="string">"press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-如何存储字符串字面量"><a href="#13-1-3-如何存储字符串字面量" class="headerlink" title="13.1.3    如何存储字符串字面量"></a>13.1.3    如何存储字符串字面量</h3><blockquote>
<p><strong>存储形式：</strong>c语言把字符串字面量作为字符数组来处理，相当于<code>char *</code>。<br><strong>空字符（<code>\0</code>）：</strong><code>ASCII</code>字符集中的第一个字符。<br><strong>内存分配：</strong>当c语言编译器在程序中遇到长度为<code>n</code>的字符串字面量时，它会为字符串字面量分配长度为<code>n+1</code>的内存空间，用来存储字符串子民啊量中的字符，以及额外的一个字符——<code>空字符</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc"</span>);<span class="comment">//当调用printf时，会传递"abc"的地址（即指向字母`a`存储单元的指针）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-4-字符串字面量的操作"><a href="#13-1-4-字符串字面量的操作" class="headerlink" title="13.1.4    字符串字面量的操作"></a>13.1.4    字符串字面量的操作</h3><blockquote>
<p><strong>说明：</strong>可以将字符串字面量赋值给<code>char *</code>指针。<br><strong>特点：</strong></p>
<ul>
<li><p>c语言允许指针添加下标，因此可以给字符串字面量添加下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = <span class="string">"abc"</span>[<span class="number">1</span>];<span class="comment">//b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>允许改变字符串字面量的字符（不推荐）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//一些编译器可能会出现异常</span></span><br><span class="line">&gt;<span class="keyword">char</span> *p = <span class="string">"abc"</span>;</span><br><span class="line">&gt;*p = <span class="string">'b'</span>;<span class="comment">//字符串字面量被修改为"bbc"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = <span class="string">"abc"</span>;<span class="comment">//这个赋值操作不是复制"abc"中的字符，而仅仅是使用p指向字符串的第一个字符。</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-5-字符串字面量与字符常量"><a href="#13-1-5-字符串字面量与字符常量" class="headerlink" title="13.1.5    字符串字面量与字符常量"></a>13.1.5    字符串字面量与字符常量</h3><blockquote>
<p><strong>说明：</strong>只包含一个字符的字符串字面量不同于字符常量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>例子</th>
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;a&quot;</code></td>
<td>字符串字面量</td>
<td>用指针来表示</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>字符常量</td>
<td>用整数（字符的ASCII码）来表示</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//合法，相当于传递`char *`指针作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">'\n'</span>);<span class="comment">//会报错，传递的不是指针而是整数</span></span><br></pre></td></tr></table></figure>
<h2 id="13-2-字符串变量"><a href="#13-2-字符串变量" class="headerlink" title="13.2    字符串变量"></a>13.2    字符串变量</h2><blockquote>
<p><strong>存储方式：</strong><code>char str[STR_LEN+1]</code></p>
<ul>
<li>载体为一维的字符数组</li>
<li>以空字符串结尾（数组的长度比字符串的长度多一个字符）</li>
</ul>
<p><strong>注意：</strong>如果没有给空字符预留位置，可能导致程序运行时出现不可预知的结果，因为c函数库中的函数假设字符串都以空字符串结束。<br><strong>技巧：</strong>字符串的长度取决于空字符的位置，而不是取决于存放字符串的字符数组的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="keyword">char</span> str[STR_LEN+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="13-2-1-初始化字符串变量"><a href="#13-2-1-初始化字符串变量" class="headerlink" title="13.2.1    初始化字符串变量"></a>13.2.1    初始化字符串变量</h3><blockquote>
<p><strong>两种字面量：</strong><code>字符串字面量</code>和<code>数组字初始化式</code></p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p><strong>底层：</strong>c编译器会把它看成是数组初始化式的缩写形式。<br><strong>规则：</strong></p>
<ul>
<li>如果初始化式太短以至于不能填满字符串变量时，c编译器会讲多出的部分都赋值为<code>\0</code></li>
<li>如果没有空间给空字符串，将使数组无法作为字符串使用</li>
</ul>
<p><strong>注意：</strong>一定要确保数组的长度要长于初始化式的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器将把字符床"June 14"中的字符复制到数组date1中，然后追加一个空字符串从而使date1可以作为字符串使用</span></span><br><span class="line"><span class="keyword">char</span> date[<span class="number">8</span>] = <span class="string">"June 14"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>J</th>
<th>u</th>
<th>n</th>
<th>e</th>
<th></th>
<th>1</th>
<th>4</th>
<th>\0</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p><strong>规则：</strong>如果初始化式比本身短，会把余下的字符数组元素初始化为<code>\0</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组长度可以省略由编译器自己计算，手工计算很容易出错</span></span><br><span class="line"><span class="keyword">char</span> date1[<span class="number">8</span>] = &#123;<span class="string">'J'</span>, <span class="string">'u'</span>, <span class="string">'n'</span>, <span class="string">'e'</span>, <span class="string">' '</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-2-字符数组和字符指针"><a href="#13-2-2-字符数组和字符指针" class="headerlink" title="13.2.2    字符数组和字符指针"></a>13.2.2    字符数组和字符指针</h3><blockquote>
<p><strong>说明：</strong>数组变量有两种</p>
</blockquote>
<table>
<thead>
<tr>
<th>＊</th>
<th>字符数组</th>
<th>字符指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>声明</strong></td>
<td><code>char varStr[]</code></td>
<td><code>char *varStr</code></td>
</tr>
<tr>
<td><strong>元素是否可修改</strong></td>
<td>是</td>
<td>否（因为指针指向的是不可修改的字符串）</td>
</tr>
<tr>
<td><strong>变量本身是否可改变指向</strong></td>
<td>否（数组名和数组绑定在一起且无法改变指向）</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>声明字符指针必需指向字符数组后才能使用，无论是字面量（两种形式的字面量）还是已经声明好的字符数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[STR_LEN+<span class="number">1</span>];</span><br><span class="line">p = srt;<span class="comment">//p指向了str的第一个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="13-3-字符串的读／写"><a href="#13-3-字符串的读／写" class="headerlink" title="13.3    字符串的读／写"></a>13.3    字符串的读／写</h2><h3 id="13-3-1-用printf函数和puts函数写字符串"><a href="#13-3-1-用printf函数和puts函数写字符串" class="headerlink" title="13.3.1    用printf函数和puts函数写字符串"></a>13.3.1    用printf函数和puts函数写字符串</h3><h4 id="13-3-1-1-printf函数"><a href="#13-3-1-1-printf函数" class="headerlink" title="13.3.1.1    printf函数"></a>13.3.1.1    <code>printf</code>函数</h4><blockquote>
<p><strong>说明：</strong>转换说明为<code>%[m][.p]s</code>，下面分3中情景讨论。</p>
</blockquote>
<hr>
<p><em>情景1:<code>%s</code>（不限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>情景</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>末尾提供了<code>空字符</code></td>
<td>逐个写字符<code>直到遇到空字符</code></td>
</tr>
<tr>
<td>末尾没有<code>空字符</code></td>
<td>会越过字符串的末尾继续写，直到最终在<code>内存的某个地方找到空字符</code>为止</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景2:<code>%ms</code>（限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>m大小</th>
<th>表现</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>>字符串长度</td>
<td>多出部分显示空格，字符串右对齐</td>
<td>在<code>m</code>前使用<code>-</code>强制左对齐</td>
</tr>
<tr>
<td>&lt;字符串长度</td>
<td>忽略设置的m，显示整个字符串</td>
<td>不会截断</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景3:<code>%m.ps</code>（限制宽度，截断）</em><br>会使字符串的前p个字符在大小为m的区域内显示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Are we having fun yet?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value of str:%s\n"</span>, str);<span class="comment">//Are we having fun yet?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(str);<span class="comment">////Are we having fun yet?(\n)</span></span><br></pre></td></tr></table></figure>
<h4 id="13-3-1-2-put函数"><a href="#13-3-1-2-put函数" class="headerlink" title="13.3.1.2    put函数"></a>13.3.1.2    put函数</h4><blockquote>
<p><strong>参数：</strong>需要显示的字符串<br><strong>说明：</strong></p>
<ul>
<li>不使用转换说明和格式串</li>
<li>在写完字符串后，puts函数总会添加一个额外的换行符</li>
</ul>
</blockquote>
<h3 id="13-3-2-用scanf函数和gets函数读字符串"><a href="#13-3-2-用scanf函数和gets函数读字符串" class="headerlink" title="13.3.2    用scanf函数和gets函数读字符串"></a>13.3.2    用scanf函数和gets函数读字符串</h3><h4 id="13-3-2-1-scanf函数"><a href="#13-3-2-1-scanf函数" class="headerlink" title="13.3.2.1    scanf函数"></a>13.3.2.1    scanf函数</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>不需要在str前添加运算符<code>&amp;</code>，因为str是数组名，编译器会自动把它当作指针来处理</li>
<li>空白符（换行符、空格符、制表符）会使scanf函数停止读入，因此用scanf输入的字符串永远不会包含空白符</li>
<li>scanf函数始终会在字符串末尾存储一个<code>空字符</code>（否则无法当作正常字符串使用）</li>
</ul>
<p><strong>注意：</strong>scanf不会检测何时填满数组，可能会越过数组边界，导致异常。<br><strong>技巧：</strong>使用<code>%ns</code>代替<code>%s</code>可以使scanf函数更安全（<code>n</code> 指可以存储的最大字符的数量）</p>
<p><strong>限制：</strong>通常不用于读入一整行输入。</p>
</blockquote>
<h4 id="13-3-2-2-gets函数"><a href="#13-3-2-2-gets函数" class="headerlink" title="13.3.2.2    gets函数"></a>13.3.2.2    gets函数</h4><blockquote>
<p><strong>说明：</strong>类似scanf函数，把读入的字符放在数组中，然后存储一个<code>空字符</code>。</p>
<ul>
<li>不会在开始读字符串之前跳过空白字符（scanf函数会跳过）</li>
<li>会持续读入直到找到换行符（不是任意空白符）</li>
</ul>
<p><strong>扩展：</strong>gets函数天生就是不安全的，fgets函数是更加安全的选择。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sentence[STR_LEN+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a sentence:\n"</span>);<span class="comment">//To , or not to c</span></span><br><span class="line">gets(sentence);<span class="comment">//sentence的值为"To , or not to c"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-3-3-逐个字符读字符串"><a href="#13-3-3-逐个字符读字符串" class="headerlink" title="13.3.3    逐个字符读字符串"></a>13.3.3    逐个字符读字符串</h3><p><strong>说明：</strong>利用<code>getchar</code>自定义更加灵活的输入函数<br><strong>编程思路：</strong></p>
<ol>
<li>在开始存储字符串之前，函数应该跳过空白字符吗？</li>
<li>什么字符会导致函数停止读取：换行符、任意空白字符、还是其他一些字符？需要存储这类字符还是忽略掉？</li>
<li>如果输入的字符串太长以致无法存储，那么程序应该做些什么：胡咧额外的字符，还是把它们留给下一次的操作输入？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 不会跳过空白符，在第一个换行符处（不把换行符存储到字符串中）停止读取，</span><br><span class="line">* 并且忽略额外的字符。</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-访问字符串中的字符"><a href="#13-4-访问字符串中的字符" class="headerlink" title="13.4    访问字符串中的字符"></a>13.4    访问字符串中的字符</h2><p><strong>说明：</strong>访问字符串中的字符存在两种方式</p>
<ol>
<li>数组下标</li>
<li>指针</li>
</ol>
<h3 id="13-4-1-用数组下标"><a href="#13-4-1-用数组下标" class="headerlink" title="13.4.1    用数组下标"></a>13.4.1    用数组下标</h3><p><strong>说明：</strong>既然字符串是以数组的方式存储的，那么可以使用下标来访问字符串中的字符。<br><strong><code>const</code>：</strong>形式参数使用<code>const</code>修饰可以防止数组被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用数组下标遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-2-用指针"><a href="#13-4-2-用指针" class="headerlink" title="13.4.2    用指针"></a>13.4.2    用指针</h3><blockquote>
<p><strong>说明：</strong>使用指针代替数组下标访问字符串中的字符会更加便捷。<br><code>const</code>：用<code>const</code>修饰字符串指针可以避免传进来的实参的指向被改变，即便如此，因为传进来的指针的副本，所以可以可以自增。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用指针遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; s != <span class="string">'\0'</span>; s++)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-使用c语言的字符串库"><a href="#13-5-使用c语言的字符串库" class="headerlink" title="13.5    使用c语言的字符串库"></a>13.5    使用c语言的字符串库</h2><blockquote>
<p><strong>说明：</strong>c语言的函数库为字符串的操作提供了丰富的函数集，包含在<code>string.h</code>中。<br><strong>参数：</strong></p>
<ul>
<li>每个函数至少需要一个字符串作为实际参数</li>
<li>字符串形式参数类型可以是<code>char *</code></li>
<li>合法的实际参数类型：字符数组、<code>char *</code>类型变量、字符串字面量</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>形式参数没有声明为const的函数会在调用函数时修改形式参数，因此对应的实际参数不能为字符串字面量（字符串字面量的特点在于不可修改）。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-1-strcpy函数"><a href="#13-5-1-strcpy函数" class="headerlink" title="13.5.1    strcpy函数"></a>13.5.1    strcpy函数</h3><p><strong>背景：</strong>不能使用赋值运算符将字符串字面量赋值给字符数组（但字符串指针可以）。因为数组名在c语言中是不能作为左值使用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<p><strong>原型：</strong><code>char *strcpy(char *s1, const char *s2)</code><br><strong>用途：</strong>将<code>s2</code>指向的字符串复制到<code>s1</code>指向的数组中。<br><strong>返回值：</strong>被赋值的字符串的首地址，可以被用来实现多重赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcpy</span>(s2, <span class="string">"abc"</span>));<span class="comment">//将abc复制给s1和s2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>函数会将<code>s2</code>指向的字符串逐个复制过去直到遇到一个空字符为止，因此假设<code>s2</code>长度为<code>n</code>，如果<code>s1</code>长度小于<code>n</code>包含（<code>\0</code>），<code>s1</code>后面的内存也会被覆盖</li>
<li>因为不会修改<code>s2</code>指向的字符串，因此s2被声明为<code>const</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<h3 id="13-5-2-strcat函数"><a href="#13-5-2-strcat函数" class="headerlink" title="13.5.2    strcat函数"></a>13.5.2    strcat函数</h3><p><strong>原型：</strong><code>char *strcats(char *s1, const char *s2)</code><br><strong>说明：</strong>将<code>s2</code>指向的字符串追加到<code>s1</code>指向的字符串的后面<br><strong>返回值：</strong><code>s1</code>指向的字符串（指针）<br><strong>注意：</strong>如果<code>s1</code>指向的数组的大小不足以容纳所有的字符，将会多余的字符复制到数组后面的内存，到处错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2, <span class="string">"def"</span>);<span class="comment">//"abcdefhgi"</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcat</span>(s2, <span class="string">"ghi"</span>));<span class="comment">//"defhgi"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-3-strcmp函数"><a href="#13-5-3-strcmp函数" class="headerlink" title="13.5.3    strcmp函数"></a>13.5.3    strcmp函数</h3><p><strong>原型：</strong><code>int strcmp(const char *s1, const chat *s2)</code><br><strong>说明：</strong>比较两个字符串的大小</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于0</td>
<td>s1 &lt; s2</td>
</tr>
<tr>
<td>0</td>
<td>s1 == s2</td>
</tr>
<tr>
<td>大于0</td>
<td>s1 &gt; s2</td>
</tr>
</tbody>
</table>
<p><strong>底层：</strong>依据对应ASCII字符集的大小</p>
<ul>
<li>字典顺序</li>
<li>前<code>i</code>个字符相同，第<code>i+1</code>个字符大的大（若其中一个没有第<code>i+1</code>个字符，则字符数多的大）</li>
<li>所有大写字母（65～90）都小于所有小写字符（97～122 ）</li>
<li>数字（48～57）小于字母</li>
<li>空格符（32）小于所有打印字符</li>
</ul>
<h3 id="13-5-4-strlen函数"><a href="#13-5-4-strlen函数" class="headerlink" title="13.5.4    strlen函数"></a>13.5.4    strlen函数</h3><p><strong>原型：</strong><code>size_t strlen(const char *s)</code><br><strong>说明：</strong>求字符串的长度，即字符串中第一个空字符串前的字符的个数（不包括空字符）。</p>
<blockquote>
<p><strong>size_ t</strong>：无符号整数类型（unsigned int 或 unsigned long int ），在c函数库定义的。</p>
</blockquote>
<p><strong>注意：</strong>当用数组作为函数的实际参数时，strlen函数不会测量数组本身的长度，而是返回存储在数组中的字符串的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">fen = <span class="built_in">strlen</span>(<span class="string">"abc"</span>);<span class="comment">//3</span></span><br><span class="line">len = <span class="built_in">strlen</span>(<span class="string">" "</span>);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, <span class="string">"abc"</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(str1);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-5-程序：显示一个月的提示列表"><a href="#13-5-5-程序：显示一个月的提示列表" class="headerlink" title="13.5.5    程序：显示一个月的提示列表"></a>13.5.5    程序：显示一个月的提示列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$./remind</span><br><span class="line"> Enter day and reminder:1 dd</span><br><span class="line"> Enter day and reminder:2 ff</span><br><span class="line"> Enter day and reminder:3 ff</span><br><span class="line"> Enter day and reminder:0</span><br><span class="line"></span><br><span class="line"> Day Reminder</span><br><span class="line">  1 dd</span><br><span class="line">  2 ff</span><br><span class="line">  3 ff</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合(记录备忘列表)，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> reminders[MAX_REMIND][MSG_LEN + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(reminders[j], reminders[j<span class="number">-1</span>]);</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-6-字符串惯用法"><a href="#13-6-字符串惯用法" class="headerlink" title="13.6    字符串惯用法"></a>13.6    字符串惯用法</h2><h3 id="13-6-1-搜索字符串的结尾"><a href="#13-6-1-搜索字符串的结尾" class="headerlink" title="13.6.1    搜索字符串的结尾"></a>13.6.1    搜索字符串的结尾</h3><p><strong>相关惯用法：</strong></p>
<ol>
<li><code>while(*s){s++;}</code></li>
<li><code>while(*s++){...}
 ;</code></li>
</ol>
<h4 id="13-6-1-1-原始版本"><a href="#13-6-1-1-原始版本" class="headerlink" title="13.6.1.1    原始版本"></a>13.6.1.1    原始版本</h4><blockquote>
<p><strong>思路：</strong>从左到右扫描字符串，n自增。当s最终指向一个空字符串时，n的长度就是字符串的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">for</span>(n = <span class="number">0</span>; *s != <span class="string">'\0'</span>; s++)&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-1-2-优化版本"><a href="#13-6-1-2-优化版本" class="headerlink" title="13.6.1.2    优化版本"></a>13.6.1.2    优化版本</h4><blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>空字符的ASCII码值为0，而0在c语言中可以代表“假”</li>
<li>字符串是被当作字符数组来处理的，而数组不同元素的存储地址之差和下标之差相同，因此可以通过地址之差计算数组长度，避免了频繁的自增操作，从而提高速度</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> chat *s)&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">	<span class="keyword">while</span>(*s)&#123;</span><br><span class="line">		*s++;</span><br><span class="line">	&#125;</span><br><span class="line">	return s - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-6-2-复制字符串"><a href="#13-6-2-复制字符串" class="headerlink" title="13.6.2    复制字符串"></a>13.6.2    复制字符串</h3><blockquote>
<p><strong>惯用法：</strong>字符串复制惯用法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span>(*p++ = *s2++)</span><br><span class="line">&gt; ;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="13-6-2-1-原版"><a href="#13-6-2-1-原版" class="headerlink" title="13.6.2.1    原版"></a>13.6.2.1    原版</h4><blockquote>
<p><strong>说明：</strong>自定义实现<code>strcat</code>函数<br><strong>思路：</strong></p>
<ol>
<li>查找字符串s1末尾空字符串的位置，并使指针p指向它</li>
<li>把字符串s2中的字符逐个复制到p所指向的位置</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> chat *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*s2 != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		*p = *s2;</span><br><span class="line">		p++;</span><br><span class="line">		s2++;</span><br><span class="line">	&#125;</span><br><span class="line">	*p = <span class="string">'\0'</span>;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-2-2-优化版"><a href="#13-6-2-2-优化版" class="headerlink" title="13.6.2.2    优化版"></a>13.6.2.2    优化版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*p++ = s2++)</span><br><span class="line">		;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-7-字符串数组"><a href="#13-7-字符串数组" class="headerlink" title="13.7    字符串数组"></a>13.7    字符串数组</h2><blockquote>
<p><strong>两种方式：</strong><code>二维字符数组</code>和<code>一维指针数组</code><br><strong>技巧：</strong>得益于指针和数组之间的紧密联系，访问一维指针数组中的元素的方式和访问而为字符数组中元素的方式相同。</p>
</blockquote>
<h4 id="二维字符数组"><a href="#二维字符数组" class="headerlink" title="二维字符数组"></a>二维字符数组</h4><blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>需要知道所有字符串的长度，以最长的字符串的长度来确定二位数组每一行的长度。</li>
<li>不能填满数组的一整行的字符会用空字符填补，浪费空间。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> planets[][<span class="number">8</span>] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Earth"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>, <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Neptune"</span>, <span class="string">"Pluto"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.16.44.png" alt="Alt text"></p>
<h4 id="一维字符指针数组"><a href="#一维字符指针数组" class="headerlink" title="一维字符指针数组"></a>一维字符指针数组</h4><blockquote>
<p><strong>说明：</strong>大部分字符串集都是长短字符串的混合，c语言本身不提供“参次不齐的数组”，但可以通过字符数组指针的数组模拟。<br><strong>参次不齐的数组(ragged array)：</strong>数组的每一行有不同的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">m</span><br><span class="line"></span><br><span class="line"><span class="title">for</span><span class="params">(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(planets[i][<span class="number">0</span>] == <span class="string">'M'</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s begins with M\n"</span>, planets[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.23.02.png" alt="Alt text"></p>
<h3 id="13-7-1-命令行参数"><a href="#13-7-1-命令行参数" class="headerlink" title="13.7.1    命令行参数"></a>13.7.1    命令行参数</h3><p><strong>程序参数（command-line atgument）：</strong>不仅是操作系统命令，所有程序都有命令行信息。<code>Q&amp;A</code>为了能够访问这些命令行参数，必须为<code>main</code>函数定义为含有两个参数的函数，这两个参数通常命名为<code>argc</code>和<code>argv</code>。<br><strong>空指针：</strong>是一种不指向任何内容的特殊指针。宏<code>NULL</code>代表空指针。<br><strong>参数向量（argv）和参数计数（argc）：</strong></p>
<ul>
<li>argv[0]：指向程序名的字符串</li>
<li>argv[1]~argv[argc-1]：余下的命令行参数</li>
<li>argv[argc]：指向空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*argc：参数计数，命令行参数的数量（包括程序名本身）</span><br><span class="line">*argv: 参数向量，指向命令行参数的指针数组（以字符串的行书存储）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.56.34.png" alt="Alt text"></p>
<p><em>命令行输入参数案例</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l remind.c</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用数组）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;argc; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用指针）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **p;<span class="comment">//p用来指向argv中的字符串，因为argv本身作为数组就是指针，而其中的字符串（字符数组）也是指针，所以声明p为指针的指针</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;argv[<span class="number">1</span>]; *p != <span class="literal">NULL</span>; p++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-7-2-程序：核对行星的名字"><a href="#13-7-2-程序：核对行星的名字" class="headerlink" title="13.7.2    程序：核对行星的名字"></a>13.7.2    程序：核对行星的名字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_PLANETS 9<span class="comment">//行星的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//9大行星</span></span><br><span class="line">	<span class="keyword">char</span> *planets[] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Eath"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>,  <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Nepture"</span>, <span class="string">"Pluto"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以此访问每个参数，并遍历9大行星寻找匹配的目标</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NUM_PLANETS; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[i], planets[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is planets %d\n"</span>, argv[i], j+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j == NUM_PLANETS)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is not a planet\n"</span>, argv[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./planet Pluto  </span><br><span class="line"> Pluto is planets 9</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/12 指针和数组/" itemprop="url">
                  12 指针和数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:24:07+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/12 指针和数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/12 指针和数组/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="12-1-指针的算术运算"><a href="#12-1-指针的算术运算" class="headerlink" title="12.1    指针的算术运算"></a>12.1    指针的算术运算</h2><blockquote>
<p><strong>说明：</strong>指针不仅可以指向普通变量，还可以指向数组元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">//a[0]值变为5</span></span><br></pre></td></tr></table></figure>
<p><strong>3种格式：</strong></p>
<ol>
<li>指针加上整数</li>
<li>指针减去整数</li>
<li>两个指针相减</li>
</ol>
<h3 id="12-1-1-指针加上整数"><a href="#12-1-1-指针加上整数" class="headerlink" title="12.1.1    指针加上整数"></a>12.1.1    指针加上整数</h3><blockquote>
<p><strong>说明：</strong>指针<code>p</code>加上整数<code>j</code>产生指向<code>p</code>元素后<code>j</code>个位置的指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line">q = p + <span class="number">3</span>;<span class="comment">//p指向了数组下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-2-指针减去整数"><a href="#12-1-2-指针减去整数" class="headerlink" title="12.1.2    指针减去整数"></a>12.1.2    指针减去整数</h3><blockquote>
<p><strong>说明：</strong>如果<code>p</code>指向数组元素<code>a[i]</code>，那么<code>p-j</code>指向<code>a[i-j]</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">8</span>];</span><br><span class="line">q = p<span class="number">-3</span>;<span class="comment">//指向数组a下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-指针相减"><a href="#12-1-3-指针相减" class="headerlink" title="12.1.3    指针相减"></a>12.1.3    指针相减</h3><blockquote>
<p><strong>说明：</strong>当两个指针相减时，结果为指针之间的距离。<br><strong>用途：</strong>用来计算数组种元素的个数。如果<code>p</code>指向<code>a[i]</code>且<code>q</code>指向<code>a[j]</code>，那么<code>p-q</code>就等于<code>i-j</code>。<br><strong>限制：</strong></p>
<ul>
<li>只有在<code>p</code>指向数组元素时，指针<code>p</code>上的算数运算才会获得意义的结果</li>
<li>只有在两个指针指向同一个数组时，指针相减才有意义</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">i = p - q;<span class="comment">//4</span></span><br><span class="line">i = q - p;<span class="comment">//-4</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-指针比较"><a href="#12-1-4-指针比较" class="headerlink" title="12.1.4    指针比较"></a>12.1.4    指针比较</h3><blockquote>
<p><strong>说明：</strong>可以用关系运算符（<code>&lt;</code> <code>&lt;=</code>  <code>&lt;</code>  <code>&gt;=</code>）和判等运算符（<code>==</code>和<code>!=</code>）。<br><strong>限制：</strong>只有在两个指针指向同一个数组时，用关系运算符进行的指针比较才有意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p &lt;= q;<span class="comment">//0</span></span><br><span class="line">q &gt; p;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h2 id="12-2-指针用于数组处理"><a href="#12-2-指针用于数组处理" class="headerlink" title="12.2    指针用于数组处理"></a>12.2    指针用于数组处理</h2><blockquote>
<p><strong>说明：</strong>指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。<br><strong>注意：</strong>数组<code>a</code>的下标是<code>0到N-1</code>,但<code>&amp;a[N]</code>是合法的，只要不尝试对该地址存储空间进行读取活写入，就是安全的。<br><strong>性能：</strong>一些编译器依赖下标而不是指针产生的循环代码性会更好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N], sum, *p;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符和-运算符的组合"><a href="#运算符和-运算符的组合" class="headerlink" title="*运算符和++运算符的组合"></a><code>*</code>运算符和<code>++</code>运算符的组合</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*p++</code>或<code>*(p++)</code></td>
<td>表达式的值是<code>*p</code>，然后<code>p</code>自增1</td>
</tr>
<tr>
<td><code>(*p)++</code></td>
<td>表达式的值为<code>*p</code>，然后<code>*p</code>自增1</td>
</tr>
<tr>
<td><code>*++p</code></td>
<td>先自增<code>p</code>，在自增后的指针对应的值</td>
</tr>
<tr>
<td><code>++*p</code>或<code>++(*p)</code></td>
<td>表达式的值是<code>*p</code>自增后的值</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(p &lt; &amp;a[N])&#123;</span><br><span class="line">	sum += *p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程序-栈"><a href="#程序-栈" class="headerlink" title="程序:栈"></a>程序:栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> *top = contents[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = &amp;contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[STACK_SIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		*top++ = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return *--top;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-用数组名作为指针"><a href="#12-3-用数组名作为指针" class="headerlink" title="12.3    用数组名作为指针"></a>12.3    用数组名作为指针</h2><blockquote>
<p><strong>说明：</strong>可以用数组的名字作为指向数组第一个元素的指针。<br><strong>意义：</strong>简化了指针的算术运算，而且使得数组和指针都更加通用。<br><strong>局限：</strong>虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其它地方是错误的。所以当需要的时候，可以先将数组指针复制给其它变量，然后改变该指针变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">*a = <span class="number">7</span>;<span class="comment">//a[0]=7</span></span><br><span class="line">*(a+<span class="number">1</span>); = <span class="number">12</span>;<span class="comment">//a[1]=12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-1-程序：数列反向（改进版）"><a href="#12-3-1-程序：数列反向（改进版）" class="headerlink" title="12.3.1    程序：数列反向（改进版）"></a>12.3.1    程序：数列反向（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reverses a series of numbers (pointer version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//输入N个数组存储到数组中</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers\n"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//逆向打印所有数组元素</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In reverse order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a + N <span class="number">-1</span>; p &gt;= a; p--)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">" %d"</span>, *p);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./reverse2                             </span><br><span class="line"> Enter 10 numbers</span><br><span class="line"> 1 2 3 4 5 6 7 8 9 0</span><br><span class="line"> In reverse order: 0 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<h3 id="12-3-2-数组型实际参数（改进版）"><a href="#12-3-2-数组型实际参数（改进版）" class="headerlink" title="12.3.2    数组型实际参数（改进版）"></a>12.3.2    数组型实际参数（改进版）</h3><blockquote>
<p><strong>说明：</strong>数组作为实参传递给函数是是作为指针传递的（传引用），而不会复制数组。</p>
</blockquote>
<ul>
<li><p>因为没有对数组进行复制，所以数组作为实际参数不会防止原数组被修改<br><strong>防改变：</strong>为了指明数组形式参数不会改变，可以在它的声明中包含单词<code>const</code></p>
</li>
<li><p>给函数传递数组所需的时间不依赖于数组的大小</p>
</li>
<li>声明形参时，数组型式和指针形式等价，编译器处理这两类声明就好像它们是完全一样的<br><strong>局限：</strong>不适用于普通变量的声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];<span class="comment">//会导致编译器为10个证书预留空间</span></span><br><span class="line"><span class="keyword">int</span> *a;<span class="comment">//会导致编译器为指针变量分配空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以给形式参数为数组的函数传递数组的“片段”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, max;</span><br><span class="line">	max = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; max)&#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">4</span>, b = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> larget = find_largest(b, N);<span class="comment">//会把数组b的第一个元素的地址赋给a，数组本身并没有复制</span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-3-用指针作为数组名"><a href="#12-3-3-用指针作为数组名" class="headerlink" title="12.3.3    用指针作为数组名"></a>12.3.3    用指针作为数组名</h3><blockquote>
<p><strong>说明：</strong>指向数组的指针除了可以通过指针的方式操作数组外，还可以将该指针当作数组来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> a[N], i, sum = <span class="number">0</span>, *p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	sum += p[i];<span class="comment">//*(p+i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-4-指针和多维数组"><a href="#12-4-指针和多维数组" class="headerlink" title="12.4    指针和多维数组"></a>12.4    指针和多维数组</h2><h3 id="12-4-1-处理多维数组的元素"><a href="#12-4-1-处理多维数组的元素" class="headerlink" title="12.4.1    处理多维数组的元素"></a>12.4.1    处理多维数组的元素</h3><blockquote>
<p><strong>说明：</strong>可以通过指针递增的方式访问到多维数组的每一个元素，因为c语言始终按照顺序存储多维数组的元素。</p>
</blockquote>
<p><em>数组遍历（数组下标的方式）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="comment">//将数组元素初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">0</span>; row &lt; NUM_ROWS; row++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(col = <span class="number">0</span>; col &lt; NUM_COLS; col++)&#123;</span><br><span class="line">		a[row][col] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>数组遍历（指针的方式）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>][<span class="number">0</span>]; p &lt;= &amp;a[NUMROWS<span class="number">-1</span>][NUM_COLS<span class="number">-1</span>]; P++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-2-处理多维数组的行"><a href="#12-4-2-处理多维数组的行" class="headerlink" title="12.4.2    处理多维数组的行"></a>12.4.2    处理多维数组的行</h3><blockquote>
<p><strong>说明：</strong>二维数组第<code>i</code>(从0开始)行第一个元素的地址<br><code>a[i]</code> == <code>*(a + i)</code> ==<code>&amp;a[i][0]</code> == <code>&amp;(*(a[i] + 0))</code> == <code>&amp;*a[i]</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[NUM_ROWS][NUM_COLS], *p, i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//初始化a的第i行元素为0</span></span><br><span class="line"><span class="keyword">for</span>(p = a[i]; p &lt; a[i] + NUM_COLS; p++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-3-用多维数组名作为指针"><a href="#12-4-3-用多维数组名作为指针" class="headerlink" title="12.4.3    用多维数组名作为指针"></a>12.4.3    用多维数组名作为指针</h3><p><strong>指针的指针：</strong><code>int a[10], b[10][10];</code></p>
<blockquote>
<p><code>a</code>可以看作是<code>int *</code>型的指针，而<code>b</code>用作指针时则是<code>int **</code>型的（指针某个整数的指针的指针）。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/11 指针/" itemprop="url">
                  11 指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:05:35+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/11 指针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/11 指针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>字节(byte)：</strong>大多数现代计算机用字节来分割内存，每个字节可以存储8位信息。每个字节都有唯一的地址，用来和内存中的其他字节进行区别。<br><strong>变量在内存中的地址：</strong>程序中的每个变量占有一个或多个内存字节，把第一个字节的地址称为变量的地址。<br><strong>指针变量：（pointer variable）</strong>虽然可以用整数表示地址，但是其取值单位可能不同于整数的范围，所以一定不能用普通整型变量存储地址。但是，可以用热熟的指针变量存储地址。<br><strong>指针：</strong>在用指针变量p存储变量i的地址时，我们说成是p“指向”i。换句话说，指针就是地址，而且指针变量是只存储地址的变量。</p>
<h2 id="11-1声明指针变量"><a href="#11-1声明指针变量" class="headerlink" title="11.1声明指针变量"></a>11.1声明指针变量</h2><p><strong>语法：</strong><code>int *p</code></p>
<ul>
<li>必须在指针变量名字前放置<code>*</code></li>
<li>可以和其他变量一起出现在声明中</li>
<li>每个指针变量唯一指向特定类型（引用类型）的对象</li>
<li>对指针可以指向的引用类型没有限制，甚至可以指向另一个指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, i, a[<span class="number">10</span>], *p;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-取地址运算符和间接寻址运算符"><a href="#11-2-取地址运算符和间接寻址运算符" class="headerlink" title="11.2    取地址运算符和间接寻址运算符"></a>11.2    取地址运算符和间接寻址运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;变量</code></td>
<td>取地址运算符</td>
<td>找到变量的地址</td>
</tr>
<tr>
<td><code>*指针变量</code></td>
<td>间接寻址运算符</td>
<td>找到指针指向的对象</td>
</tr>
</tbody>
</table>
<h3 id="11-2-1-取地址运算符"><a href="#11-2-1-取地址运算符" class="headerlink" title="11.2.1    取地址运算符"></a>11.2.1    取地址运算符</h3><p><strong>先声明后赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p;</span><br><span class="line">p = &amp;i;</span><br></pre></td></tr></table></figure>
<p><strong>声明的同时赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-间接寻址运算符"><a href="#11-2-2-间接寻址运算符" class="headerlink" title="11.2.2    间接寻址运算符"></a>11.2.2    间接寻址运算符</h3><blockquote>
<p><strong>说明：</strong>一旦指针变量指向指向了对象，就可以使用<code>*</code>运算符访问存储在对象中的内容。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);<span class="comment">//*p等价于i</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>不要把间接寻址运算符用于未初始化的指针变量。否则一旦改变未知的内存单元可能会导致不规律的行为或操作系统的崩溃。</p>
<h2 id="11-3-指针赋值"><a href="#11-3-指针赋值" class="headerlink" title="11.3    指针赋值"></a>11.3    指针赋值</h2><blockquote>
<p><strong>前提：</strong>两个指针具有相同的类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, *p, *q;</span><br><span class="line">p = &amp;i;</span><br><span class="line">q = p;<span class="comment">//把i的地址右赋值给了p，此时右两个指针同时指向i</span></span><br></pre></td></tr></table></figure>
<h2 id="11-4-指针作为实际参数"><a href="#11-4-指针作为实际参数" class="headerlink" title="11.4    指针作为实际参数"></a>11.4    指针作为实际参数</h2><blockquote>
<p><strong>背景：</strong>c语言的参数传递机制为“值传递”，参数传递进来的是变量的副本。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_part;</span><br><span class="line"><span class="keyword">float</span> frace_part;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *frac_part)</span></span>;</span><br><span class="line"><span class="comment">//或void decompose(float x, int *, float *);</span></span><br><span class="line">decompose(<span class="number">3.1415926</span>, &amp;i, &amp;f);</span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义*/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 取出一个浮点数的整数部分和小数部并分别赋值给两个外部变量</span><br><span class="line">* @param x 目标浮点数</span><br><span class="line">* @param *int_part 存储整数部分的地址</span><br><span class="line">* @param *fract_part 存储小数部分的变量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *fract_part)</span></span>&#123;</span><br><span class="line">	*int_part = (int) x;</span><br><span class="line">	*fract_part = x - *int_part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-1-程序：找出数组中的最大元素和最小元素"><a href="#11-4-1-程序：找出数组中的最大元素和最小元素" class="headerlink" title="11.4.1    程序：找出数组中的最大元素和最小元素"></a>11.4.1    程序：找出数组中的最大元素和最小元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Finds the largest and smallest elements in an array</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> b[N], i, big, small;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers:"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	max_min(b, N, &amp;big, &amp;small);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Largest: %d\n"</span>, big);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"smallest: %d\n"</span>, small);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 找出最大值和最小值并将结果赋给响应指针对应的变量</span><br><span class="line"> * @param a   数组</span><br><span class="line"> * @param n   数组大小</span><br><span class="line"> * @param max 存储最大值的变量</span><br><span class="line"> * @param min 存储最小值的变量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	*max = *min = a[<span class="number">0</span>];</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line"> 			*max = a[i];</span><br><span class="line"> 		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line"> 			*min = a[i];</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./maxmin </span><br><span class="line"> Enter 10 numbers:1 2 3 4 5 6 7 8 9 10</span><br><span class="line"> Largest: 10</span><br><span class="line"> smallest: 1</span><br></pre></td></tr></table></figure>
<h3 id="11-4-2-用const保护实际参数"><a href="#11-4-2-用const保护实际参数" class="headerlink" title="11.4.2    用const保护实际参数"></a>11.4.2    用const保护实际参数</h3><p><strong>使用指针替代变量副本：</strong>如果需要大量的存储空间，那么传递变量的值可能浪费时间和空间。<br><strong>const：</strong>放在形式参数的类型说明之前，证明函数不会改变传递给函数的指针所指向的对象。试图改变用<code>const</code>修饰的形参对应的实参会引发编译器发出特定消息。</p>
<h2 id="11-5-指针作为返回值"><a href="#11-5-指针作为返回值" class="headerlink" title="11.5    指针作为返回值"></a>11.5    指针作为返回值</h2><p><strong>用途：</strong>函数返回结果的内存位置而不是返回值。<br><strong>场景：</strong></p>
<ol>
<li>返回指向外部变量的指针</li>
<li>返回声明为<code>static</code>的局部变量的指针</li>
<li><strong>限制：</strong>永远不会返回指向自动局部变量的指针，因为函数返回后局部变量的存储空间就不存在了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">max</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*a &gt; *b)&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p, x, y;</span><br><span class="line">p = max(*x, &amp;y);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/10 程序结构/" itemprop="url">
                  10 程序结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T22:53:52+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/10 程序结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/10 程序结构/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="10-1-局部变量"><a href="#10-1-局部变量" class="headerlink" title="10.1    局部变量"></a>10.1    局部变量</h2><p><strong>局部：</strong>在函数体内声明的变量称为相对于函数的局部。<br><strong>存储期限（storage duration）：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。<br><strong>特点：</strong></p>
<ul>
<li><strong>自动存储期限：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。在闭合函数返回时收回分配。</li>
<li><strong>程序快作用域：</strong>变量的作用域是可以参考变量的程序文本的部分。从变量声明的点开始一直到闭合函数的末尾。局部变量拥有程序块作用域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">log</span> = <span class="number">0</span>;<span class="comment">/*局部变量*/</span></span><br><span class="line">   <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">     n /= <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">log</span>++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-1-静态存储期限：static"><a href="#10-1-1-静态存储期限：static" class="headerlink" title="10.1.1 静态存储期限：static"></a>10.1.1 静态存储期限：<code>static</code></h3><p><strong>特点：</strong>具有静态存储期限的变量拥有永久的存储单元，所以会在整个程序执行期间会保留变量的值。</p>
<ol>
<li>静态局部变量始终有程序块作用域，它对其他函数而言是不可见的</li>
<li>静态变量是隐藏来自其他函数的数据的地方，但是它会为将来同一个函数的调用保留这些数据。</li>
</ol>
<p><strong>声明方式：</strong>在局部变量声明中放置单词<code>static</code>可以使用变量从自动存储期限变为静态存储期限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*因为局部变量i已经声明为static，所以在程序执行期间它占有同样的存储单元。在f返回时，变量i不会丢失自身的值。*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-形式参数"><a href="#10-1-2-形式参数" class="headerlink" title="10.1.2 形式参数"></a>10.1.2 形式参数</h3><p><strong>和局部变量比较</strong></p>
<ul>
<li><strong>相同点：</strong>自动存储期限、块级作用域</li>
<li><strong>不同点：</strong>在每次函数调用时对形式参数自动进行初始化（调用中通过赋值获得实际参数的值）</li>
</ul>
<h2 id="10-2-外部变量"><a href="#10-2-外部变量" class="headerlink" title="10.2    外部变量"></a>10.2    外部变量</h2><blockquote>
<p><strong>又名：</strong>全局变量<br><strong>声明位置：</strong>外部变量是声明在任何函数体外的。<br><strong>性质：</strong></p>
<ul>
<li>静态存储期限：同声明的static的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。</li>
<li>文件作用域：从变量声明的点开始一直到闭合文件的末尾。跟随在外部变量声明后的所有函数都可以访问它。</li>
</ul>
</blockquote>
<h3 id="10-2-1-程序：用外部变量实现栈"><a href="#10-2-1-程序：用外部变量实现栈" class="headerlink" title="10.2.1    程序：用外部变量实现栈"></a>10.2.1    程序：用外部变量实现栈</h3><blockquote>
<p><strong>栈（stack）：</strong>像数组一样，栈可以存储具有相同数据类型的多个数据项。<br><strong>操作方式：</strong>LIFO(后进先出)，占中数据项的操作是十分受限制的，可以忘栈中压入数据，或者从栈中弹出数据项。禁止测试或修改不在栈顶的数据项。<br><strong>c语言实现：</strong>把元素存储在数组中，称为<code>constents</code>,命名为top的一个整型变量用来标记栈栈顶的位置。栈为空时，top值为0。为了往栈中压入数据项，可以把数据项简单存储在contents中标记为top的位置上，然后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>中标记为top的位置上，谈后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>的索引取回弹出的数据项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		contents[top++] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return contents[--top];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-外部变量的利与弊"><a href="#10-2-2-外部变量的利与弊" class="headerlink" title="10.2.2 外部变量的利与弊"></a>10.2.2 外部变量的利与弊</h3><blockquote>
<p><strong>利：</strong>有利于多个函数必须共享一个变量或者上述几个函数共享大量变量。<br><strong>蔽：</strong></p>
<ol>
<li>可维护性差：如果改变外部变量，那么需要检查同一个文件中的每个函数，确认该改变对函数的影响。</li>
<li>可读性差：如果外部变量出现问题，难以确定导致这个值发生错误的函数。</li>
<li>可复用性差：很难再其他城程序中复用依赖于外部变量的函数。因为以来外部变量的函数不是“独立的”。</li>
</ol>
<p><strong>技巧：</strong>为了提高可阅读性和可能的错误，使用外部变量时，确保它们都拥有有意义的名字。</p>
</blockquote>
<h3 id="10-2-3-程序：猜数（略）"><a href="#10-2-3-程序：猜数（略）" class="headerlink" title="10.2.3 程序：猜数（略）"></a>10.2.3 程序：猜数（略）</h3><h2 id="10-3-程序块"><a href="#10-3-程序块" class="headerlink" title="10.3    程序块"></a>10.3    程序块</h2><blockquote>
<p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    多条声明</span><br><span class="line">    多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>作用域：</strong>程序块中的变量具有进入程序块时为存储变量分配单元，而在退出程序块时解除分配。<br><strong>函数体（也是程序块）放置临时变量的优点：</strong></p>
<ol>
<li>避免函数体起始位置的声明与只是临时使用的变量相混淆</li>
<li>减少了名字冲突</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = i;</span><br><span class="line">	i = j;</span><br><span class="line">	j = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-作用域"><a href="#10-4-作用域" class="headerlink" title="10.4    作用域"></a>10.4    作用域</h2><blockquote>
<p><strong>规则：</strong></p>
<ol>
<li>标识符拥有文件作用域，即在所声明的闭合程序块内有效</li>
<li>新的声明临时会“隐藏”旧的声明</li>
<li>在程序块结束后后面，被“隐藏”的标识符重新获得旧的含义</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第1个*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第2个*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*第3个*/</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/*第4个*/</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		i = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-5-构建c-程序"><a href="#10-5-构建c-程序" class="headerlink" title="10.5    构建c 程序"></a>10.5    构建c 程序</h2><p><strong>程序构成要素：</strong></p>
<ul>
<li>预处理指令：诸如<code>#include</code>和<code>#define</code></li>
<li>类型定义</li>
<li>函数声明和外部变量声明</li>
<li>函数定义</li>
</ul>
<p><strong>建议编排顺序：</strong></p>
<ol>
<li>#include指令</li>
<li>define指令</li>
<li>类型定义（typedef）</li>
<li>外部变量声明</li>
<li>除main函数之外的函数原型</li>
<li>main函数的定义</li>
<li>其他函数的定义</li>
</ol>
<p><strong>建议函数注释：</strong>盒形注释</p>
<ul>
<li>函数名</li>
<li>描述函数的目的</li>
<li>讨论每个参数的含义</li>
<li>描述返回值</li>
<li>罗列任何的副作用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/9 函数/" itemprop="url">
                  9 函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T19:06:38+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/9 函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/9 函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="9-1-函数的定义和调用"><a href="#9-1-函数的定义和调用" class="headerlink" title="9.1    函数的定义和调用"></a>9.1    函数的定义和调用</h2><blockquote>
<p><strong>语法</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>简析</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回类型（return type）</td>
<td>每次调用函数返回数据的类型，当不需要返回值时使用<code>void</code></td>
</tr>
<tr>
<td>形式参数（parameter）</td>
<td>每一个参数都必须有类型，没有行参使用<code>void</code></td>
</tr>
<tr>
<td>函数体（body）</td>
<td>用<code>{}</code>括起来的执行部分</td>
</tr>
<tr>
<td>实际参数（argument）</td>
<td>为了激活（即调用（call））函数，需要写出函数名及跟随其后的实际参数列表</td>
</tr>
</tbody>
</table>
<h3 id="9-1-1-程序：计算平均值"><a href="#9-1-1-程序：计算平均值" class="headerlink" title="9.1.1    程序：计算平均值"></a>9.1.1    程序：计算平均值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes pairwise averages of three numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>&#123;</span><br><span class="line"> 	return (a+b) / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter three numbers:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f%f%f"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, y, average(x,y));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, y, z, average(y,z));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, z, average(x,z));</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./average</span><br><span class="line"> Enter three numbers:1 2 3</span><br><span class="line"> Average of 1 and 2: 1.5</span><br><span class="line"> Average of 2 and 3: 2.5</span><br><span class="line"> Average of 1 and 3: 2</span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-程序：显示倒数计时"><a href="#9-1-2-程序：显示倒数计时" class="headerlink" title="9.1.2    程序：显示倒数计时"></a>9.1.2    程序：显示倒数计时</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a countdown</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, n);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">10</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line"> 		print_count(i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./countdwn </span><br><span class="line">T minus 10 and counting</span><br><span class="line">T minus 9 and counting</span><br><span class="line">T minus 8 and counting</span><br><span class="line">T minus 7 and counting</span><br><span class="line">T minus 6 and counting</span><br><span class="line">T minus 5 and counting</span><br><span class="line">T minus 4 and counting</span><br><span class="line">T minus 3 and counting</span><br><span class="line">T minus 2 and counting</span><br><span class="line">T minus 1 and counting</span><br></pre></td></tr></table></figure>
<h3 id="9-1-3-程序：显示双关语"><a href="#9-1-3-程序：显示双关语" class="headerlink" title="9.1.3    程序：显示双关语"></a>9.1.3    程序：显示双关语</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a bad pun</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	print_pun();</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./pun2</span><br><span class="line"> To c, or not to c:that is the question.</span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-函数定义"><a href="#9-1-4-函数定义" class="headerlink" title="9.1.4    函数定义"></a>9.1.4    函数定义</h3><blockquote>
<p><strong>函数定义：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  声明</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数无法返回数组，但是没有其它关于返回类型的限制</li>
<li>如果忽略返回类型，那么会假定函数返回值的类型时<code>int</code>型</li>
<li>制定返回类型是<code>void</code>型说明函数没有返回值</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>为每个函数指定一个明显的返回类型是一个很好的方法（<code>void</code>也可以省略，毕竟经典c没有<code>void</code>概念，但不推荐这样）</li>
<li>如果返回值很冗长，比如<code>unsigned long int</code>，那么把返回类型单独放一行是非常有用的</li>
</ul>
</blockquote>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>需要在每个形式参数的前面说明其类型</li>
<li>形式参数间用逗号进行分隔</li>
<li>如果函数没有形式参数，那么在圆口哈没应该出现<code>void</code></li>
<li>即使有些行参具有相同数据类型，也必须对每个形式参数分别进行类型说明</li>
</ul>
</blockquote>
<h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数体内声明的变量专属于此函数，其它函数不能对这些变量进行检查或修改</li>
<li>函数体可以为空，以后可以回来编写它的函数体</li>
</ul>
</blockquote>
<h3 id="9-1-5-函数调用"><a href="#9-1-5-函数调用" class="headerlink" title="9.1.5    函数调用"></a>9.1.5    函数调用</h3><blockquote>
<p><strong>语法：</strong><code>[强制转换返回类型] 函数名(实参1, 实参2 ...);</code><br><strong>有无返回值的函数调用的区别：</strong>void型的函数调用是语句，所以调用后边始终跟着分号；非void型的函数调用是表达式。<br><strong>注意：</strong>丢掉圆括号仍然是合法的表达式，但不起任何作用，有些编译器会给出警告。</p>
</blockquote>
<h4 id="强制转换返回类型"><a href="#强制转换返回类型" class="headerlink" title="[强制转换返回类型]"></a>[强制转换返回类型]</h4><blockquote>
<p><strong>说明：</strong>很少用到，可以省略<br><strong>技巧：</strong>可以将返回值强制类型转换成<code>void</code>，使别人清楚编写者使故意扔掉返回值的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"Hi, Mom!\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-程序：判定素数"><a href="#9-1-6-程序：判定素数" class="headerlink" title="9.1.6    程序：判定素数"></a>9.1.6    程序：判定素数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests whether a number is prime</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"> <span class="function">Bool <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> divisor;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"> 		return FALSE;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">for</span>(divisor = <span class="number">2</span>; divisor * divisor &lt;= n; divisor++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(n % divisor == <span class="number">0</span>)&#123;</span><br><span class="line"> 			return FALSE;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return TRUE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> 	<span class="keyword">if</span>(is_prime(n))&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"'Prime'\n"</span>);</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Not prime\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./prime </span><br><span class="line"> Enter a number:34</span><br><span class="line"> Not prime</span><br></pre></td></tr></table></figure>
<h2 id="9-2-函数声明"><a href="#9-2-函数声明" class="headerlink" title="9.2    函数声明"></a>9.2    函数声明</h2><blockquote>
<p><strong>背景：</strong>c语言没有要求函数的定义必须放置在<code>main</code>函数的定义之后。如果函数的定义在调用之后，那么编译器会为被调用的函数的函数做一些假设。如果假设错误，则程序无法正常工作。<br><strong>说明：</strong>在调用前声明（declare）每个函数，函数声明是的编译器对函数进行概要浏览，而函数的完整定义稍后再出现。</p>
<blockquote>
<p><strong>函数原型（function prototype）：</strong><code>Q&amp;A</code>中将这种函数声明称为函数原型。原型为如何调用函数提供了一个完整的描述：提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型。<br><strong>行参规则：</strong>可以不写形式参数的名字，只要显示类型就可以，<code>float average(float float)</code>，但不建议，为了代码的可阅读性和可维护性。</p>
</blockquote>
<p><strong>语法：</strong><code>返回类型 函数名（形式参数）;</code><br><strong>注意：</strong>函数的声明必须和函数的定义一致。</p>
</blockquote>
<h2 id="9-3-实际参数"><a href="#9-3-实际参数" class="headerlink" title="9.3    实际参数"></a>9.3    实际参数</h2><blockquote>
<p><strong>实参和形参：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式参数(parameter)</td>
<td>出现在函数定义中，它们以假名字来表示函数调用时提供的值</td>
</tr>
<tr>
<td>实际参数(argument)</td>
<td>出现在函数调用中的表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>通过值传递：</strong>调用函数时，计算出每个实际参数的值并且把它赋值给相应的形式参数。</p>
<blockquote>
<p><strong>特点：</strong>在函数的执行过程中，对形式参数的改变不会影响实际参数的值。</p>
</blockquote>
</blockquote>
<h3 id="9-3-1-实际参数的转换"><a href="#9-3-1-实际参数的转换" class="headerlink" title="9.3.1    实际参数的转换"></a>9.3.1    实际参数的转换</h3><blockquote>
<p><strong>说明：</strong>c语言允许在实际参数的类型和形式参数的类型不匹配的情况下进行函数调用。<br><strong>实参转换规则：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>编译器在调用前是否遇到原型</th>
<th>转换方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>实参的值被隐式转换成相应形式参数的类型。</td>
</tr>
<tr>
<td>否</td>
<td>编译器执行默认的实际参数提升</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>默认的实际参数提升</strong></p>
<ol>
<li>把<code>float</code>型的实际参数转换成<code>double</code>类型</li>
<li>执行整数的提升（即把<code>char</code>型和<code>short</code>型的实际参数转换成<code>int</code>型）<br><strong>注意：</strong>默认的实际参数提升不总会获得期望的效果<br><strong>技巧：</strong>始终在调用函数前声明函数非常必要。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter number to be squard:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">	<span class="comment">//把变量i强制转换为正确的类型的方法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The answer if %g\n"</span>, square((double)i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-数组型实际参数"><a href="#9-3-2-数组型实际参数" class="headerlink" title="9.3.2    数组型实际参数"></a>9.3.2    数组型实际参数</h3><p><strong>语法：</strong><code>数组类型 数组实参名[数组长度]</code><br><strong>特点：</strong></p>
<ul>
<li>其中<code>数组长度</code>通常省略不写。即便写了在函数中仍然无法判断数组的长度。</li>
<li>多维数组形式参数只能忽略第一位的长度</li>
</ul>
<p><strong>获取实参数组长度：</strong>c语言没有提供任何简便的方法来确定传递给它的数组的长度。但是如果函数需要，必须把长度作为额外的实际参数提供给函数。<br><strong>注意：</strong>在函数内部通过<code>sizeof(a) / sizeof(a[0])</code>的方式并不能正确计算出传递进来的数组的长度。<br><strong>技巧：</strong>通过传递比数组实际长度小的整数参数，来部分操作数组。<br><strong>延伸：</strong>不能传递令人困扰的具有任意列数的多维数组。幸运的是，我们经常可以通过使用指针数组的方式处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数原型*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//如果愿意可以省略形式参数的名字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b[LEN], total;</span><br><span class="line">	total = sun_array(b, LEN);<span class="comment">//在数组名传递给函数时，不要在数组名的后边放置方括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* params&#123;int Array&#125; a 数组</span><br><span class="line">* params&#123;int&#125; n 数组长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, sun = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		sun += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-return语句"><a href="#9-4-return语句" class="headerlink" title="9.4    return语句"></a>9.4    return语句</h2><blockquote>
<p><strong>return语句：</strong><code>return 表达式;</code><br><strong>隐式转换：</strong>如果<code>return</code>语句中表达式的类型和函数的返回类型不匹配，那么系统将会把表达式的类型隐式转换为返回类型<br><strong>立即返回：</strong>在返回类型为<code>void</code>的函数中可以使用<code>return;</code>，会导致函数立即返回，后面不能包含表达式</p>
</blockquote>
<p><strong><code>void</code>和非<code>void</code></strong></p>
<table>
<thead>
<tr>
<th>返回值类型是否为<code>void</code></th>
<th>是否必须<code>return</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td>是</td>
<td>必须使用<code>return 表达式</code>返回值，否则某些编译器会报错</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td><code>return</code>并不是必须的，因为在执行最后一条语句后函数将会自动跳转。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to C :that is the qyestion.\n"</span>)</span><br><span class="line">	return;<span class="comment">/*可以省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-5-程序终止"><a href="#9-5-程序终止" class="headerlink" title="9.5    程序终止"></a>9.5    程序终止</h2><blockquote>
<p><strong>状态码：</strong>即<code>main</code>函数的返回值，默认为<code>int</code>类型；或者<code>exit</code>函数的实参。</p>
<blockquote>
<p><strong>用途：</strong>在某些操作系统中程序终止时可以检测到状态码。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常终止</td>
<td>0</td>
</tr>
<tr>
<td>异常终止</td>
<td>非0</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>即使不打算用状态码，确信每个c程序都返回状态码也是一个很好的实践，因为某些运行程序的人可能稍后再决定测试状态码。</p>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><p><strong>功能：</strong>终止程序，相当于在<code>main</code>函数中使用<code>return</code>。<br><strong>实参：</strong>传递给<code>exit</code>函数的实际参数和<code>main</code>函数的返回值具有相同的含义，两者都说明程序终止时的状态。<br><strong>所在库：</strong><code>&lt;stdlib.h&gt;</code><br><strong>相关宏定义：</strong><code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>,值由实现定义，典型的值是0和1<br><strong>区别于<code>return</code>：</strong><code>return</code>和<code>exit</code>都可以在任何函数中调用，但<code>return</code>只有在<code>main</code>函数中调用才会终止程序；<code>exit</code>在任何函数中调用都会终止程序。<br><strong>技巧：</strong>一些程序员专门使用<code>exit</code>函数以便于模式匹配程序可以很容易地定位程序中全部的退出点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<h2 id="9-6-递归函数"><a href="#9-6-递归函数" class="headerlink" title="9.6    递归函数"></a>9.6    递归函数</h2><blockquote>
<p><strong>说明：</strong>如果函数调用它本身，那么此函数就是递归的（recursice）。<br><strong>技巧：</strong>为了防止无限递归，所有递归函数都需要某些类型的终止条件。<br><strong>注意：</strong>c语言允许递归，但大多数c程序员并不经常使用递归。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 计算n的阶乘</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">face</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return n * fact(n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 计算x^n</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	return n == <span class="number">0</span> ? <span class="number">1</span> : x * power(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-1-快速排序算法"><a href="#9-6-1-快速排序算法" class="headerlink" title="9.6.1    快速排序算法"></a>9.6.1    快速排序算法</h3><blockquote>
<p><strong>分治法(divide-and-conquer)：</strong>把一个大问题划分成多个较小的问题，然后采用相同的算法分别解决这些小问题。比如排序算法。<br><strong>算法操作：</strong></p>
<ol>
<li>选择数组元素e（作为“分割元素”），然后重新排列数组使得元素从1一直到i-1都是小雨或等于元素e的，元素i包含e，而元素从i-1一直到n都是大于或等于e的。</li>
<li>通过递归地采用快速排序算法，对从1到i-1的元素进行排序。</li>
<li>通过递归地采用快速排序方法，对从i+1到n的元素进行排序。</li>
</ol>
</blockquote>
<h4 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of integers using Quicksort algorthm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 12</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>&#125;;</span><br><span class="line"> 			  </span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line"> 	printArr(a, <span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印数组</span><br><span class="line"> * @param &#123;int&#125; a 需要打印的数组</span><br><span class="line"> * @param &#123;int&#125; flag 表示打印时排序处在的状态</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 自己实现的快排程序：快速排序</span><br><span class="line"> * @param &#123;int&#125; a[] 被排序的数组</span><br><span class="line"> * @param &#123;int&#125; low 起点</span><br><span class="line"> * @param &#123;int&#125; high 终点</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">myquicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"%d****%d\n"</span>, low, high);</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return ;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> middleValue = a[low];</span><br><span class="line"> 		<span class="keyword">int</span> emptyPoint = low;</span><br><span class="line"> 		<span class="keyword">int</span> newLow = low, </span><br><span class="line"> 			newHigh = high;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">/**</span><br><span class="line"> 		 * 只要low指针和high指针没有最后相遇，就交替往中间靠拢。并在在这个过程中完成位置的交换。</span><br><span class="line"> 		 * 原理是：有点像拆东墙补西墙，把中间数字两边的数字看作东墙和西墙的话，</span><br><span class="line"> 		 * 其实就是在东墙上找西墙上的砖补到西墙上，东墙被拿走砖的位置且只能是这个位置需要西墙去补。一来二去就完成了砖的交换过程。</span><br><span class="line"> 		 */</span></span><br><span class="line"> 		<span class="keyword">while</span>(newLow &lt; newHigh)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(newLow == emptyPoint)&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为低位：高位指针向左移动寻找比中间值小的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newHigh] &gt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newHigh--;	</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newHigh];</span><br><span class="line"> 				emptyPoint = newHigh;</span><br><span class="line"> 			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为高位：低位指针向右移动寻找比中间值大的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newLow] &lt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newLow++;</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newLow];</span><br><span class="line"> 				emptyPoint = newLow;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			printArr(a, <span class="number">1</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//标记</span></span><br><span class="line"> 		done:</span><br><span class="line"> 		a[emptyPoint] = middleValue;</span><br><span class="line"> 		printArr(a, <span class="number">0</span>);</span><br><span class="line"> 		<span class="keyword">if</span>(newLow &gt; low)&#123;</span><br><span class="line"> 			quicksort(a, low, newLow - <span class="number">1</span>);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span>(newHigh &lt; high)&#123;</span><br><span class="line"> 			quicksort(a, newHigh + <span class="number">1</span>, high);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-2-程序：快速排序"><a href="#9-6-2-程序：快速排序" class="headerlink" title="9.6.2 程序：快速排序"></a>9.6.2 程序：快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of intergers using Quicksort algorithm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="comment">/*声明函数*/</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], i;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*输入需要排队的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers to be sorted :"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*调用排序函数进行排序*/</span></span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*打印排序好的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In sorted order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 快排程序</span><br><span class="line"> * @param &#123;Array&#125; a 数组</span><br><span class="line"> * @param &#123;int&#125; low 开始下标 </span><br><span class="line"> * @param &#123;int&#125; high 结束下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> middle;</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//获得分段的中间位置</span></span><br><span class="line"> 	middle = split(a, low, high);</span><br><span class="line"> 	quicksort(a, low, middle <span class="number">-1</span>);</span><br><span class="line"> 	quicksort(a, middle + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> part_element = a[low];</span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">/*high指针向左移动寻找比part_element小的数，直到找到或low和high指针重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; part_element &lt;= a[high])&#123;</span><br><span class="line"> 			high--;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果重合了，说明没有找到</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果找到了，将找到的比中间值小的数放到当前low指针指向的位置，并将指针向右移动</span></span><br><span class="line"> 		a[low++] = a[high];</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">/*low指针向右移动，寻找比part_element大的数，直到找到一个或low和high重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= part_element)&#123;</span><br><span class="line"> 			low++;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//重合了就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果没重合，就讲找到的数移动到high指针指向的位置，并将high的指针向左移动一下</span></span><br><span class="line"> 		a[high--] = a[low];</span><br><span class="line"> 		return high;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-3-改进"><a href="#9-6-3-改进" class="headerlink" title="9.6.3    改进"></a>9.6.3    改进</h3><ol>
<li><p>改进分割算法</p>
<blockquote>
<p>上面介绍的方法不是最有效的。我们不再选择数组中的第一个元素作为分割元素，较好的方法是取第一个元素、中间元素和最后一个元素的中间值。分个过程本身也可以加速。特别是，在两个while循环中避免测试low&lt;high是可能的。</p>
</blockquote>
</li>
<li><p>采用不同的方法进行小数组排序</p>
</li>
<li><p>使得快速排序非递归</p>
<blockquote>
<p>虽然快速排序本质上是使用递归算法，并且递归格式的快速排序是最容易理解的，但是实际上若去掉递归会更有效率。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">98</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
