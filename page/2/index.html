<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/2/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/2/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_03  字符串和字符/" itemprop="url">
                  3 字符串和字符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:32:42+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_03  字符串和字符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_03  字符串和字符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>有序的<code>Character</code>类型的值的集合，通过<code>String类</code>来表示。</p>
<ul>
<li>每一个字符串都是由编码无关的<code>Unicide</code>字符组成</li>
<li>可以通过內插的方式将字符串插入到常量、变量、字面量表达式中</li>
</ul>
<p><strong>扩展：</strong>和Cocoa中的Foundation框架中的<code>NSString类</code>进行了无缝对接</p>
<ul>
<li>可以将创建的任何字符串的值转换成<code>NSString</code></li>
<li>可以调用任意的<code>NSString</code>API</li>
<li>可以在任意要求传入<code>NSString</code>实例作为参数的API中用<code>String类</code>的值代替</li>
</ul>
</blockquote>
<p>##3.1    字符串字面量</p>
<blockquote>
<p><strong>格式：</strong><code>&quot;固定顺序的文本字符集&quot;</code><br><strong>应用：</strong>为常量或变量提供初始值</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span></span><br></pre></td></tr></table></figure>
<p>##3.2    初始化空字符串</p>
<blockquote>
<p><strong>说明：</strong>2种形式</p>
<ol>
<li>将空的字符串字面量赋值给变量</li>
<li>初始化一个新的<code>String</code>实例</li>
</ol>
<p><strong>判空：</strong>可以通过字符串实例的<code>isEmpty</code>属性(Boolean)来判断字符串是否为空。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3.3    字符串可变性</p>
<blockquote>
<p><strong>说明：</strong>和Swift中其它值类型一样，可变性取决于定义为常量还是变量</p>
<ul>
<li>常量：不可改变</li>
<li>变量：可以改变</li>
</ul>
<p><strong>扩展：</strong>在O-C和Cocoa中，字符串的可变性取决于使用<code>NSString类</code>还是<code>NSMutableString类</code>。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义为变量</span></span><br><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Hourse"</span></span><br><span class="line"><span class="comment">// 所以可以修改</span></span><br><span class="line">variableString += <span class="string">" add carriage"</span></span><br></pre></td></tr></table></figure>
<p>##3.4    字符串是值类型</p>
<blockquote>
<p><strong>说明：</strong>意味着在以下操作中通过拷贝来传递值</p>
<ul>
<li>常量、变量赋值操作</li>
<li>在函数、方法中传参</li>
</ul>
<p><strong>意义：</strong>确保传递的字符串不会被意外修改。<br><strong>扩展：</strong>为了保证性能，Swift编译器只会在绝对必要的情况下才进行复制。</p>
<p>##3.5    使用字符<br><strong>说明：</strong><code>Character</code></p>
<ul>
<li>字符类型的常量和字符串相似，不同点在于自能包含一个字符。</li>
<li>用字符常量初始化字符类型必须指定常量或变量为<code>Character</code>，否则默认为字符串类型。</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamatuinMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<p>###3.5.1    字符串的Chracters属性</p>
<blockquote>
<p><strong>说明：</strong>可以通过该属性遍历字符串对应的字符数组。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串中的字符</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog"</span>.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###3.5.2    字符数组转换为字符串</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明字符数组</span></span><br><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>]</span><br><span class="line"><span class="comment">// 将字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)<span class="comment">// "Cat"</span></span><br></pre></td></tr></table></figure>
<p>##3.6    连接字符串和字符</p>
<blockquote>
<p><strong>说明：</strong>两种方式</p>
<ul>
<li><code>+</code>、<code>+=</code>：字符串拼接</li>
<li><code>append方法</code><br>###append方法<br><strong>说明：</strong>将一个字符附加到字符串变量的尾部<br><strong>原型：</strong><code>String类实例方法</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Character&#125; c 字符</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;void append(<span class="built_in">c</span>: <span class="type">Character</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>参数只能是<code>Character</code>常量或变量，不能是字面量(因为存在歧义)</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">" there"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+</span></span><br><span class="line"><span class="keyword">var</span> welcome = str1 + str2<span class="comment">// hello there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+=</span></span><br><span class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></span><br><span class="line">instruction += str2<span class="comment">// look over there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//append</span></span><br><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br><span class="line">instruction.append(exclamationMark)</span><br></pre></td></tr></table></figure>
<p>##3.7    字符串插值</p>
<blockquote>
<p><strong>用途：</strong>构建新的字符串。<br><strong>语法：</strong><code>\(表达式)</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="comment">// 通过插值构建新的字符串</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"</span></span><br></pre></td></tr></table></figure>
<p>##3.8    Unicode</p>
<p>###3.8.1    Unicode标量</p>
<blockquote>
<p><strong>Unicode码位：</strong>格式为<code>U+[1到8位16进制数字]</code></p>
<ul>
<li><strong>Unicode标量码位：</strong>是对应字符或者修饰符的唯一的21位数字，每个<code>Unicode标量</code>都对应着一个<code>Unicode码位</code>，但反过来不成立。</li>
<li><strong>Unicode代理项码位：</strong>Unicode码位中不属于Unicode标量的部分。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>U+0000~U+D7FF</th>
<th>U+D800~U+DFFF</th>
<th>U+E000~U+10FFF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unicode标量</td>
<td>unicode代理项</td>
<td>Unicode标量</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>应用：</strong>Swift的<code>String</code>类型是基于Unicode标量建立的。</p>
</blockquote>
<p>###3.8.2    字符串字面量的特殊字符</p>
<blockquote>
<p><strong>说明：</strong>分两类</p>
<ul>
<li>转义字符</li>
<li>Unicode标量</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\0</code></td>
<td>空字符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\u{1到8位16进制数}</code></td>
<td>Unicode标量</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \"</span></span><br><span class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more importent than knowledge\" - Einstein"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unocode标量</span></span><br><span class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span></span><br></pre></td></tr></table></figure>
<p>###3.8.3    可扩展的字形群集</p>
<blockquote>
<p><strong>说明：</strong>有些字符由多个部分组成，每个部分都可以用一个Unicode标量表示。组合起来就形成了一个新字符。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span><span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span><span class="comment">// é</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;D55C&#125;"</span><span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;"</span><span class="comment">// 한</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// é⃝</span></span><br><span class="line"><span class="keyword">let</span> encosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span><span class="comment">// é⃝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 🇺🇸</span></span><br><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;"</span><span class="comment">// 🇺🇸</span></span><br></pre></td></tr></table></figure>
<p>##3.9    计算字符数量</p>
<p>###characters.count属性</p>
<blockquote>
<p><strong>说明：</strong><code>String</code>类实例成员<code>characters</code>提供的记录字符总数的属性。<br><strong>性能问题：</strong>字符串中可能包含可扩展字符群，只有遍历<code>Unicode</code>标量确定字符群表示的字符后才能确定字符串的长度<br><strong>扩展：</strong><code>NSString</code>的<code>length</code>属性不同于swift的<code>String</code>的<code>count</code>属性。前者利用<code>UTF-16</code>表示的16位代码单元数字。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala, Snail, Penguin, Dromedary"</span></span><br><span class="line"><span class="comment">// 获得字符串中字符的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has \(unusualMenagerie.characters.count)"</span>)<span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可扩展的群组作为Character拼接到字符串时，字符串的字符数量并不一定会改变</span></span><br><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in \(word) is \(word.characters.count)"</span>)<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span><span class="comment">// café</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in \(word) is \(word.characters.count)"</span>)<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>##3.10    访问和修改字符串</p>
<blockquote>
<p><strong>说明：</strong>两种方式</p>
<ul>
<li>字符串的属性和方法</li>
<li>下标语法<br>###3.10.1    字符串索引<br>####相关属性(2个)</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>字符串实例属性</th>
<th>说明</th>
<th>空字符串相应属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td>startIndex</td>
<td>第一个<code>Character</code>的下标</td>
<td>0</td>
</tr>
<tr>
<td>endIndex</td>
<td>最后一个<code>Character</code>的下标 + 1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>####predecessor方法</p>
<blockquote>
<p><strong>说明：</strong>通过当前下标获得前一个下标<br><strong>原型：</strong><code>Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return  &#123;String.CharacterView.Index&#125; 下标索引</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">predecessor</span> -&gt; <span class="title">String</span>.<span class="title">CharacterView</span>.<span class="title">Index</span></span></span><br></pre></td></tr></table></figure>
<p>####successor方法</p>
<blockquote>
<p><strong>说明：</strong>通过当前索引获得后面一个索引。<br><strong>原型：</strong><code>Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return  &#123;String.CharacterView.Index&#125; 下标索引</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">successor</span> -&gt; <span class="title">String</span>.<span class="title">CharacterView</span>.<span class="title">Index</span></span></span><br></pre></td></tr></table></figure>
<p>####indices属性</p>
<blockquote>
<p><strong>说明：</strong>包含全部索引的<code>Range</code><br><strong>类型：</strong><code>Range &lt;Index&gt;</code><br><strong>原型：</strong><code>String&gt;characters的成员属性</code></p>
</blockquote>
<p>####advancedBy方法</p>
<blockquote>
<p><strong>说明：</strong>以当前位置为参照，获得相隔指定数量个下标的位置处的下标。<br><strong>原型：</strong><code>String.CharacterView.Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Int&#125; n 距离（正数代表向右移动，负数代表向左移动）</span><br><span class="line">&gt;* @return &#123;Index&#125; 下标</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">advancedBy</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Gunten Tag!"</span></span><br><span class="line"><span class="comment">// 访问第一个字符</span></span><br><span class="line">greeting[greeting.startIndex]<span class="comment">// G</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问最后一个字符</span></span><br><span class="line">greeting[greeting.endIndex.predecessor()]<span class="comment">// !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第二个字符</span></span><br><span class="line">greeting[greeting.startIndex.successor()]<span class="comment">// u</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问最后一个字符</span></span><br><span class="line">greeting[greeting.endIndex.advancedBy(-<span class="number">1</span>)] <span class="comment">// !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indices属性</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(greeting[index])"</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###3.10.2    插入和删除</p>
<p>####insert函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引插入一个字符串。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Character&#125; newElement 要插入的字符</span><br><span class="line">&gt;* @param &#123;Index&#125; atIndex 插入的位置</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(newElement: Character, atIndex: Index)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<p>####insertContentsOf函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引插入一个字符串。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;CollectionType&#125; newElements 插入的集合</span><br><span class="line">&gt;* @param &#123;Index&#125; at 插入位置</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insertContentsOf</span><span class="params">(newElements: CollectionType, at: Index)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<p>####removeAtIndex函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串中的指定索引删除一个字符<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param  &#123;Index&#125; i 要删除的字符对应的索引</span><br><span class="line">&gt;* @return &#123;Character&#125; 删除的字符</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(i: Index)</span></span> -&gt; <span class="type">Character</span></span><br></pre></td></tr></table></figure>
<p>####removeRange函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引删除一个字串<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeRange</span><span class="params">(subRange: Range&lt;Index&gt;)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串尾部插入一个字符</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, atIndex: welcome.endIndex)<span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串倒数第二个位置插入另一个字符串</span></span><br><span class="line">welcome.insertContentsOf(<span class="string">" there"</span>.characters, at: welcome.endIndex.predecessor())<span class="comment">// hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定索引处的字符</span></span><br><span class="line">welcome.removeAtIndex(welcome.endIndex.predecessor())<span class="comment">// hello there!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除子串</span></span><br><span class="line"><span class="keyword">let</span> range = welcome.endIndex.advancedBy(-<span class="number">6</span>)..&lt;welcome.endIndex<span class="comment">// 5..&lt;11</span></span><br><span class="line">welcome.removeRange(range)<span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>##3.11    比较字符串</p>
<p>###3.11.1    字符串/字符相等</p>
<blockquote>
<p><strong>说明：</strong>使用<code>!=</code>和<code>==</code></p>
<ul>
<li>如果两个字符串（或字符）的可扩展字形群集是标准相等（Unicode标量不同，语言外观相同）的，那就认为它们是相等的</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较普通两个字符串</span></span><br><span class="line"><span class="keyword">let</span> quotation = <span class="string">"we're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"we're a lot alike, you and I."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个Unicode标量不同但外观相同的字符串</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;E9&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion = <span class="string">"Voulez-vous uncaf\u&#123;65&#125;\u&#123;301&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These twostrings are considered equal"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###33.11.2        前缀/后缀相等</p>
<p>####hasPrefix函数</p>
<blockquote>
<p><strong>说明：</strong>判断字符串是否包含某种前缀。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;String&#125; prefix 前缀</span><br><span class="line">&gt;* @return &#123;Boolean&#125; true : 包含前缀；false : 不包含前缀</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">hasPrefix</span><span class="params">(<span class="keyword">prefix</span>: String)</span></span> -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<p>####hasSuffix函数</p>
<blockquote>
<p><strong>说明：</strong>判断字符串是否包含某种后缀。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;String&#125; suffix 前缀</span><br><span class="line">&gt;* @return &#123;Boolean&#125; true : 包含后缀；false : 不包含后缀</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">hasSuffix</span><span class="params">(<span class="keyword">prefix</span>: String)</span></span> -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景位置</span></span><br><span class="line"><span class="keyword">let</span> romeoAndJuliet = [</span><br><span class="line">    <span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 3: A room in Capulet's room"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 3: Ouside Friar Lawrence's cell"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span><span class="comment">// 场景一数量</span></span><br><span class="line"><span class="comment">// 根据前缀删选数据项</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1 "</span>) &#123;</span><br><span class="line">        ++act1SceneCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are \(act1SceneCount) scenes in Act 1"</span>)</span><br></pre></td></tr></table></figure>
<p>##3.12    字符串的Unicode表示形式</p>
<blockquote>
<p><strong>编码方式和字符集：</strong>事实上，计算机存储任何数据（包括文本文件）都是以<code>二进制方式</code>存储的，但字符如何对应到二进制数据，或者说二进制数据如何解读成字符是由<code>编码方式</code>和<code>字符集</code>决定的。每种<code>字符集</code>都对应一种或多种<code>编码方式</code>。<br><strong>说明：</strong>当字符串被保存到文本文件时，会按照某种编码方式存储。而Unicode标量对应的编码方式包括以下三种。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Unicode字符集对应的编码方式</th>
<th>代码单元大小（bit）</th>
<th>对应的String的成员属性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UTF-8</strong></td>
<td>8</td>
<td>utf8</td>
</tr>
<tr>
<td><strong>UTF-16</strong></td>
<td>16</td>
<td>utf16</td>
</tr>
<tr>
<td><strong>UTF-32(Unicode标量集合)</strong></td>
<td>32</td>
<td>unicodeScalars</td>
</tr>
</tbody>
</table>
<p>###举个例子：<code>Dog‼🐶</code></p>
<table>
<thead>
<tr>
<th>code unit(十进制)</th>
<th>D</th>
<th>o</th>
<th>g</th>
<th>!!</th>
<th>🐶</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UTF-8编码</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>226 128 188</td>
<td>240 159 144 182</td>
</tr>
<tr>
<td><strong>UTF-16编码</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>8252</td>
<td>55357 56374</td>
</tr>
<tr>
<td><strong>UTF-32(Unicode标量)</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>8252</td>
<td>128054</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_02  基本运算符/" itemprop="url">
                  2 基本运算符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:32:24+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_02  基本运算符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_02  基本运算符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>基本运算</th>
<th>正负</th>
<th>自加/减</th>
<th>自返运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>a+b</td>
<td>+a</td>
<td>a++/++a</td>
<td>a+=b</td>
</tr>
<tr>
<td>a-b</td>
<td>-b</td>
<td><code>b--/--b</code></td>
<td>a-=b</td>
</tr>
<tr>
<td>a*b</td>
<td></td>
<td></td>
<td>a*=b</td>
</tr>
<tr>
<td>a/b</td>
<td></td>
<td></td>
<td>a/=b</td>
</tr>
<tr>
<td>a%b</td>
<td></td>
<td></td>
<td>a%=b</td>
</tr>
</tbody>
</table>
<p>[toc]</p>
<h2 id="2-1-术语"><a href="#2-1-术语" class="headerlink" title="2.1    术语"></a>2.1    术语</h2><ul>
<li>运算符</li>
</ul>
<table>
<thead>
<tr>
<th>按照操作数数量分类</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一元运算符</td>
<td>分为前值运算符和后值运算符</td>
<td><code>!</code>、<code>++</code>、<code>--</code>等</td>
</tr>
<tr>
<td>二元运算符</td>
<td>在两个操作数之间</td>
<td>大部分运算符都属于二元运算符</td>
</tr>
<tr>
<td>三元运算符</td>
<td>和C语言一样只有一个三目运算符</td>
<td><code>a ? b : c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>操作数：受运算影响的值叫做操作数</li>
</ul>
<h2 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2    赋值运算符"></a>2.2    赋值运算符</h2><blockquote>
<p><strong>说明：</strong>用来跟新或初始化变量或常量。</p>
<ul>
<li>右边如果是元组，会被分解成多个常量或变量</li>
<li>不返回值（不同于c和o-c）</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-3-算术运算符"><a href="#2-3-算术运算符" class="headerlink" title="2.3    算术运算符"></a>2.3    算术运算符</h2><h3 id="2-3-1-四则运算"><a href="#2-3-1-四则运算" class="headerlink" title="2.3.1    四则运算"></a>2.3.1    四则运算</h3><blockquote>
<p><strong>说明：</strong>其中<code>+</code>允许操作数为字符串，此时不再是四则运算中的加法运算，而是用来拼接字符串。</p>
</blockquote>
<table>
<thead>
<tr>
<th>四则运算符</th>
<th>说明</th>
<th>操作数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法或连接符</td>
<td>数值类型或字符串</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>数值类型</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>数值类型</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>数值类型（两个操作数都是整数则结果取整(<code>Int</code>)，否则为<code>Double</code>）</td>
</tr>
</tbody>
</table>
<h3 id="2-3-2-求余运算符"><a href="#2-3-2-求余运算符" class="headerlink" title="2.3.2    求余运算符"></a>2.3.2    求余运算符</h3><blockquote>
<p><strong>说明：</strong>在其它语言中也叫做取膜运算。<br><strong>规则：</strong><code>余数 = a % b</code>，其中<code>a = (|b| x 倍数) + 余数</code></p>
<ul>
<li><code>b</code>的符号将会被忽略，也就是说 <code>a % b</code>和<code>a % -b</code>相同</li>
</ul>
</blockquote>
<h3 id="2-3-3-浮点数求余运算"><a href="#2-3-3-浮点数求余运算" class="headerlink" title="2.3.3    浮点数求余运算"></a>2.3.3    浮点数求余运算</h3><blockquote>
<p><strong>说明：</strong>不同于<code>c</code>和<code>o-c</code>，<code>Swift</code>中可以对浮点数进行求余。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> % <span class="number">2.5</span><span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-自增和自减运算"><a href="#2-3-4-自增和自减运算" class="headerlink" title="2.3.4    自增和自减运算"></a>2.3.4    自增和自减运算</h3><blockquote>
<p><strong>操作对象：</strong>整型和浮点型<br><strong>技巧：</strong>先修改后返回更符合我们的逻辑，因此除非需要<code>i++（i--）</code>的特性，否则推荐使用<code>++i(--i)</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>相对操作数的位置</th>
<th>自增</th>
<th>自减</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置</td>
<td><code>++i</code></td>
<td><code>--i</code></td>
<td>先自增，后返回</td>
</tr>
<tr>
<td>后置</td>
<td><code>i++</code></td>
<td><code>i++</code></td>
<td>先返回，后自增</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = ++a<span class="comment">// a 1, b 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a++<span class="comment">// a 2, c 1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-一元负号运算符"><a href="#2-3-5-一元负号运算符" class="headerlink" title="2.3.5    一元负号运算符"></a>2.3.5    一元负号运算符</h3><blockquote>
<p><strong>符号：</strong><code>-</code><br><strong>说明：</strong>写在操作数之前，中间没有空格</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three</span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-一元正号运算符"><a href="#2-3-6-一元正号运算符" class="headerlink" title="2.3.6    一元正号运算符"></a>2.3.6    一元正号运算符</h3><blockquote>
<p><strong>说明：</strong>不做任何改变地返回操作数的值<br><strong>用途：</strong>和负数一起使用时为整数添加<code>+</code>符号使代码看起来更加对称。</p>
</blockquote>
<h2 id="2-4-复合赋值"><a href="#2-4-复合赋值" class="headerlink" title="2.4    复合赋值"></a>2.4    复合赋值</h2><table>
<thead>
<tr>
<th>自返运算(复合赋值)</th>
</tr>
</thead>
<tbody>
<tr>
<td>a+=2</td>
</tr>
<tr>
<td>a-=2</td>
</tr>
<tr>
<td>a*=2</td>
</tr>
<tr>
<td>a/=2</td>
</tr>
<tr>
<td>a%=2</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span><span class="comment">// a 3</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-比较运算符"><a href="#2-5-比较运算符" class="headerlink" title="2.5    比较运算符"></a>2.5    比较运算符</h2><blockquote>
<p><strong>应用：</strong>多用于<code>if</code>语句</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a == b</td>
<td>等于</td>
</tr>
<tr>
<td>a != b</td>
<td>不等于</td>
</tr>
<tr>
<td>a &gt; b</td>
<td>大于</td>
</tr>
<tr>
<td>a &lt; b</td>
<td>小于</td>
</tr>
<tr>
<td>a === b</td>
<td>两个引用指向同一个对象实例</td>
</tr>
<tr>
<td>a !== b</td>
<td>两个引用不指向同一个对象实例</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"word"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"wword"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm sorry \(name), but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-三目运算符"><a href="#2-6-三目运算符" class="headerlink" title="2.6    三目运算符"></a>2.6    三目运算符</h2><blockquote>
<p><strong>语法：</strong><code>问题 ? 答案1 : 答案2</code><br><strong>技巧：</strong>过度使用三目运算符会使简洁的代码变得难懂。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-7-空合运算符"><a href="#2-7-空合运算符" class="headerlink" title="2.7    空合运算符"></a>2.7    空合运算符</h2><blockquote>
<p><strong>语法：</strong><code>a ?? b</code><br><strong>说明：</strong>对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>。</p>
<ul>
<li><code>a ?? b</code>等价于<code>a != nil ? a! : b</code></li>
<li>表达式<code>a</code>必须是<code>Optional</code>类型</li>
<li>默认值<code>b</code>的类型必须要和<code>a</code>存储的类型保持一致</li>
<li>短路求值：如果<code>a</code>不是<code>nil</code>，则<code>b</code>不会被估值</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?<span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName<span class="comment">// red</span></span><br></pre></td></tr></table></figure>
<h2 id="2-8-区间运算符"><a href="#2-8-区间运算符" class="headerlink" title="2.8    区间运算符"></a>2.8    区间运算符</h2><blockquote>
<p><strong>说明：</strong>分两种</p>
<ul>
<li>闭区间运算符（<code>a...b</code>）：包含a和b</li>
<li>半开区间运算符（<code>a..&lt;b</code>）：包含a不包含b</li>
</ul>
<p><strong>应用：</strong>在迭代一个区间的所有值时非常有用，比如在<code>for-in</code>循环中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brain"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第 \(i + 1) 个人叫 \(names[i])"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-9-逻辑运算符"><a href="#2-9-逻辑运算符" class="headerlink" title="2.9    逻辑运算符"></a>2.9    逻辑运算符</h2><blockquote>
<p><strong>说明：</strong>一共3个</p>
</blockquote>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>是否短路</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!a</code></td>
<td>逻辑非</td>
<td></td>
</tr>
<tr>
<td><code>a &amp;&amp; b</code></td>
<td>逻辑与</td>
<td>是</td>
<td>左结合</td>
</tr>
<tr>
<td><code>a｜｜b</code></td>
<td>逻辑或</td>
<td>是</td>
<td>左结合</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>提高可读性：</strong></p>
<ul>
<li>多个逻辑运算符组合运算时使用括号来明确优先级</li>
<li>小心地选择布尔常量或变量</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_01  基础部分/" itemprop="url">
                  1 基础部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:31:53+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_01  基础部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_01  基础部分/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-常量和变量"><a href="#1-1-常量和变量" class="headerlink" title="1.1    常量和变量"></a>1.1    常量和变量</h2><blockquote>
<p><strong>描述：</strong>常量和变量把一个名字和一个指定类型的值关良起来。<br><strong>说明：</strong>两者的区别在于设定后是否还能修改</p>
<ul>
<li>常量：设定后不可能修改</li>
<li>变量：可以随意更改</li>
</ul>
</blockquote>
<h3 id="1-1-1-声明常量和变量"><a href="#1-1-1-声明常量和变量" class="headerlink" title="1.1.1    声明常量和变量"></a>1.1.1    声明常量和变量</h3><blockquote>
<p><strong>共同规则：</strong></p>
<ul>
<li>可以在一行中声明多个，用<code>,</code>分隔</li>
</ul>
<p><strong>关键字：</strong></p>
<ul>
<li><code>let</code>：常量</li>
<li><code>var</code>：变量</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量声明</span></span><br><span class="line"><span class="keyword">let</span> maximunNumberOfLoginAttemts = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempts = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-类型标注"><a href="#1-1-2-类型标注" class="headerlink" title="1.1.2    类型标注"></a>1.1.2    类型标注</h3><blockquote>
<p><strong>用途：</strong>说明常量或者变量中要存储的值的类型<br><strong>注意：</strong></p>
<ul>
<li>如果没有类型标注，声明时都必须设置一个值作为初始值，否则报错</li>
<li>类型标注可以省略，此时Swift可以通过赋的初始值推断其类型</li>
</ul>
<p><strong>语法：</strong><code>var welcomeMessage: String</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>var</th>
<th>welcomeMessage:</th>
<th></th>
<th>String</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let(var)</code></td>
<td>常量(变量)名</td>
<td><code>:</code></td>
<td><code>空格</code></td>
<td>类型名称</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明：</strong>可以在一行中定义多个同样类型的变量，<code>,</code>分隔，并在最后一个比变量名之后添加<code>类型标注</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">welcomeMessage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明多个具有相同类型标注的变量的略写方式</span></span><br><span class="line"><span class="keyword">var</span> red, green, blue:<span class="type">Double</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-常量和变量的命名"><a href="#1-1-3-常量和变量的命名" class="headerlink" title="1.1.3    常量和变量的命名"></a>1.1.3    常量和变量的命名</h3><blockquote>
<p><strong>说明：</strong>声明完成后，一些特性将不能再次修改</p>
<ul>
<li>已经声明的名字不能再次用来声明</li>
<li>声明时确定的类型不能更改</li>
<li>常量与变量不能相互转换</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>不允许的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学符号</td>
</tr>
<tr>
<td>箭头</td>
</tr>
<tr>
<td>保留的（非法的）<code>Univode</code>码位</td>
</tr>
<tr>
<td>连线</td>
</tr>
<tr>
<td>制表符</td>
</tr>
<tr>
<td>数字（仅开头不能使用）</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量和变量的命名</span></span><br><span class="line"><span class="keyword">let</span> π = <span class="number">3.141592654</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">let</span> ？？ = <span class="string">"dog"</span><span class="comment">// 中文全角的</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-4-输出常量和变量"><a href="#1-1-4-输出常量和变量" class="headerlink" title="1.1.4    输出常量和变量"></a>1.1.4    输出常量和变量</h3><h4 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h4><blockquote>
<p><strong>描述：</strong>一个用来输出一个或多个值到适当输出区的全局函数。<br><strong>说明：</strong>可以直接通过<code>\(表达式)</code>的方式在字符串中插值（<code>String interprolation</code>）<br><strong>原型：</strong><code>全局函数</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Any...&#125; items 可变个任意类型的参数</span><br><span class="line">&gt;* @param &#123;String=&#125; separator 连接符（默认为空格，可省略）</span><br><span class="line">&gt;* @param &#123;String=&#125; terminator 自动追加再末尾的字串（默认为换行符，可省略）</span><br><span class="line">&gt;* @param &#123;&amp;Target=&#125; toStream 输出流（默认为标准输出流，可省略）</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;void <span class="built_in">print</span>(items: <span class="type">Any</span>..., separator: <span class="type">String</span>, terminator: <span class="type">String</span>, toStream: &amp;<span class="type">Target</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"world"</span></span><br><span class="line"><span class="comment">// hello,world!</span></span><br><span class="line"><span class="built_in">print</span>(str1, str2, separator:<span class="string">","</span>, terminator:<span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world\n</span></span><br><span class="line"><span class="built_in">print</span>(str1, str2)</span><br></pre></td></tr></table></figure>
<h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2    注释"></a>1.2    注释</h2><blockquote>
<p><strong>说明：</strong>和C语言的注释非常相似</p>
<ul>
<li>单行注释：<code>// 这是一个注释</code></li>
<li>多行注释：<code>/* 多行注释 */</code></li>
</ul>
<p><strong>注意：</strong>和C语言不同的是，swift支持前套的多行注释。便于在原先多行注释的基础上扩大注释范围。</p>
</blockquote>
<h2 id="1-3-分号"><a href="#1-3-分号" class="headerlink" title="1.3    分号"></a>1.3    分号</h2><blockquote>
<p><strong>说明：</strong>和大部分语句有所不同</p>
<ul>
<li>单独占一行的语句的结尾处的分号可以省略</li>
<li>一行代码存在多个语句，则语句之间的<code>;</code>不能省略</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"?"</span>; <span class="built_in">print</span>(cat)</span><br></pre></td></tr></table></figure>
<h2 id="1-3-整数"><a href="#1-3-整数" class="headerlink" title="1.3    整数"></a>1.3    整数</h2><blockquote>
<p><strong>说明：</strong>一共有<code>10</code>种整数类型（<code>(U)Int(4种宽度)</code>）<br><strong>注意：</strong>其中8种类型是指定的宽度的，<code>Int</code>和<code>UInt</code>类型比较特殊，其宽度依赖于处理器架构。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度(bit)</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>Int8</td>
<td>UInt8</td>
</tr>
<tr>
<td>16</td>
<td>Int16</td>
<td>UInt16</td>
</tr>
<tr>
<td>32</td>
<td>Int32</td>
<td>UInt32</td>
</tr>
<tr>
<td>64</td>
<td>Int64</td>
<td>UInt64</td>
</tr>
<tr>
<td>依赖平台</td>
<td>Int</td>
<td>UInt</td>
</tr>
</tbody>
</table>
<h3 id="1-3-1-整数范围"><a href="#1-3-1-整数范围" class="headerlink" title="1.3.1    整数范围"></a>1.3.1    整数范围</h3><blockquote>
<p><strong>说明：</strong>可以通过<code>mix</code>和<code>max</code>属性获得相应类型的最大值和最小值。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-Int"><a href="#1-3-2-Int" class="headerlink" title="1.3.2    Int"></a>1.3.2    Int</h3><blockquote>
<p><strong>技巧：</strong>大多数时候使用<code>Int</code>类型</p>
<ul>
<li>可以提高代码的一致性和可复用性</li>
<li>即使在32位机器上，也足够大了（<code>-2,147,483,648~2,147,483,647</code>）</li>
</ul>
</blockquote>
<h3 id="1-3-3-UInt"><a href="#1-3-3-UInt" class="headerlink" title="1.3.3    UInt"></a>1.3.3    UInt</h3><blockquote>
<p><strong>技巧：</strong>尽可能使用<code>Int</code>而不是<code>UInt</code>，即使已知值是非负的</p>
<ul>
<li>一致型和可复用性</li>
<li>避免不同类型数字之间的转换(默认的对整数类型的表达式的推断类型为<code>Int</code>)</li>
</ul>
</blockquote>
<h2 id="1-4-浮点数"><a href="#1-4-浮点数" class="headerlink" title="1.4    浮点数"></a>1.4    浮点数</h2><blockquote>
<p><strong>定义：</strong>有小数部分的数字<br><strong>说明：</strong>有两种有符号浮点数类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>浮点类型</th>
<th>解释</th>
<th>最大精度（整数部分和小数部分数字位数之和）</th>
<th>适用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64位浮点数</td>
<td>7</td>
<td>需要存储很大或很高精度的浮点数时</td>
</tr>
<tr>
<td>Float</td>
<td>32位浮点数</td>
<td>16</td>
<td>精度要求不高时</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f:<span class="type">Float</span> = <span class="number">0.123456789</span><span class="comment">// 0.1234568</span></span><br><span class="line"><span class="keyword">var</span> d:<span class="type">Double</span> = <span class="number">0.12345678901234567</span><span class="comment">// 0.1234567890123457</span></span><br></pre></td></tr></table></figure>
<h2 id="1-5-类型安全和类型推断"><a href="#1-5-类型安全和类型推断" class="headerlink" title="1.5    类型安全和类型推断"></a>1.5    类型安全和类型推断</h2><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><strong>类型安全：</strong>编译器会在编译阶段进行类型检查，并把不匹配的类型标记为错误</li>
<li><strong>类型推断：</strong>如果在声明阶段没有显示指定类型，编译器回通过赋的值自动推断出表达式的类型</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>当推断浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code></li>
<li>如果表达式中同时出现整数和浮点数，则计算结果被推断为<code>Double</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式种出现了一个浮点字面量，所以表达式被推断为 Double 类型</span></span><br><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br></pre></td></tr></table></figure>
<h2 id="1-6-数值型字面量"><a href="#1-6-数值型字面量" class="headerlink" title="1.6    数值型字面量"></a>1.6    数值型字面量</h2><h3 id="整数字面量"><a href="#整数字面量" class="headerlink" title="整数字面量"></a>整数字面量</h3><blockquote>
<p><strong>说明：</strong>根据进制划分有<code>4</code>种</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>无</td>
</tr>
<tr>
<td>二进制</td>
<td><code>0b</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0x</code></td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> binaryInter = <span class="number">0b10001</span><span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span><span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span><span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点数字面量"><a href="#浮点数字面量" class="headerlink" title="浮点数字面量"></a>浮点数字面量</h3><blockquote>
<p><strong>说明：</strong>根据进制划分有<code>2</code>种</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>前缀</th>
<th>小数点两边</th>
<th>可选的指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>无</td>
<td>至少有一个十进制数</td>
<td><code>(E)e</code>， 基数为10</td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0x</code></td>
<td>至少有一个十六进制数</td>
<td><code>(P)p</code></td>
<td>基数为2</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10进制</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1.25e2</span><span class="comment">// 1.25 x 10^2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制</span></span><br><span class="line"><span class="keyword">let</span> b = 0xFp-<span class="number">2</span><span class="comment">// 15 x 2^-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.1875</span></span><br><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21876e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<h3 id="增强可读性"><a href="#增强可读性" class="headerlink" title="增强可读性"></a>增强可读性</h3><blockquote>
<p><strong>说明：</strong>整数和浮点数都可以添加额外的零并且包含下划线来增强可读性</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外的零</span></span><br><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="comment">// 额外的下划线</span></span><br><span class="line"><span class="keyword">let</span> oneMillon = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-数值型类型转换"><a href="#1-7-数值型类型转换" class="headerlink" title="1.7    数值型类型转换"></a>1.7    数值型类型转换</h2><blockquote>
<p><strong>使用<code>Int</code>：</strong>即使代码中的整数常量或变量已知非负，也尽量使用<code>Int</code></p>
<ul>
<li>保证整数变量或常量可以直接被复用</li>
<li>可以匹配整数类字面量的类型推断（整数字面量只会被推断为<code>Int</code>，赋值给其它类型的整数需要类型转换）</li>
</ul>
<p><strong>使用其它整数类型：</strong></p>
<ul>
<li>处理外部的长度明确的数据时，为了优化性能、内存占用等</li>
<li>可以及时发现溢出</li>
<li>可以暗示正在处理特殊数据</li>
</ul>
</blockquote>
<h3 id="1-7-1-整数转换"><a href="#1-7-1-整数转换" class="headerlink" title="1.7.1    整数转换"></a>1.7.1    整数转换</h3><h4 id="1-7-1-1-必要性"><a href="#1-7-1-1-必要性" class="headerlink" title="1.7.1.1    必要性"></a>1.7.1.1    必要性</h4><blockquote>
<ul>
<li>如果数字超过了常量或变量可存储的范围，编译的时候会报错</li>
<li>两种类型（<code>Int</code>除外）的整数不能直接相加</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会报错，因为 UInt8 不能存储负数</span></span><br><span class="line"><span class="keyword">let</span> cannotBeNegative:<span class="type">UInt8</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，因为超过了最大值</span></span><br><span class="line"><span class="keyword">let</span> tooBig:<span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-1-2-使用类型对应的构造器进行转换"><a href="#1-7-1-2-使用类型对应的构造器进行转换" class="headerlink" title="1.7.1.2    使用类型对应的构造器进行转换"></a>1.7.1.2    使用类型对应的构造器进行转换</h4><blockquote>
<p><strong>注意：</strong>不能传入任意类型的值给构造器，只能是有对应构造器的值<br><strong>扩展：</strong>可以通过扩展现有的类型让它可以接受其它类型的值</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 one 由 UInt8 转换为 UInt16，最终 twoThousandAndOne 被推断为 UInt16</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<h3 id="1-7-2-整数和浮点数转换"><a href="#1-7-2-整数和浮点数转换" class="headerlink" title="1.7.2    整数和浮点数转换"></a>1.7.2    整数和浮点数转换</h3><h4 id="1-7-2-1-整数-gt-浮点数"><a href="#1-7-2-1-整数-gt-浮点数" class="headerlink" title="1.7.2.1    整数-&gt;浮点数"></a>1.7.2.1    整数-&gt;浮点数</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><strong>强制转换：</strong>对与所有类型的整数常量或变量，可以强制转换为<code>Double</code>或<code>Float</code></li>
<li><strong>隐式转换：</strong>声明时指定<code>Double</code>或<code>Float</code>，则用来初始化的整数字面量会被自动转换</li>
</ul>
<p><strong>注意：</strong>数值类常量或变量不同于数值类字面量，后者可以不同类型可以一起运算，因为字面量本身没有明确的类型</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">let</span> d:<span class="type">Double</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFineNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFineNine</span><br></pre></td></tr></table></figure>
<h4 id="1-7-2-2-浮点数-gt-整数"><a href="#1-7-2-2-浮点数-gt-整数" class="headerlink" title="1.7.2.2    浮点数-&gt;整数"></a>1.7.2.2    浮点数-&gt;整数</h4><blockquote>
<p><strong>说明：</strong>声明变量或常量时指定任何一种整数类型，则用来初始化字面量只能是整数。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br></pre></td></tr></table></figure>
<h2 id="1-8-类型别名"><a href="#1-8-类型别名" class="headerlink" title="1.8    类型别名"></a>1.8    类型别名</h2><blockquote>
<p><strong>语法：</strong><code>typealias 别名 = 原始类型名</code><br><strong>用途：</strong>给现有类型起一个更有意义的名字。<br><strong>说明：</strong>定义了类型别名之后，可以在任何使用原始类型名的地方使用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br><span class="line"><span class="comment">// 调用类型别名</span></span><br><span class="line"><span class="keyword">var</span> maxAmolitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br></pre></td></tr></table></figure>
<h2 id="1-9-布尔值"><a href="#1-9-布尔值" class="headerlink" title="1.9    布尔值"></a>1.9    布尔值</h2><blockquote>
<p><strong>类型：</strong><code>Bool</code><br><strong>字面量：</strong></p>
<ul>
<li>true</li>
<li>false</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 橙子是橙子，true</span></span><br><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 萝卜很好吃，false</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-10-元组"><a href="#1-10-元组" class="headerlink" title="1.10    元组"></a>1.10    元组</h2><blockquote>
<p><strong>用途：</strong>元组把多个值组合成一个复合值<br><strong>说明：</strong></p>
<ul>
<li>元组内的值可以是任意类型，并不要求是相同类型。</li>
<li>可以作为函数的返回值</li>
<li>可以为元组中的每个元素命名</li>
<li>可以通过下标访问元组中的每个元素</li>
</ul>
<p><strong>语法：</strong><code>(字面量1, 字面量2, ...)</code></p>
<p><strong>限制：</strong>元组在临时组织值的时候很有用，但不适合创建复杂的数据结构。<br><strong>扩展：</strong>如果数据结构不是临时使用，请使用类或者结构体而不是元组。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明：一个类型为 (Int, String) 的元组</span></span><br><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not found"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(statusCode)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is \(statusMessage)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解时用_忽略</span></span><br><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标访问元组中的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(http404Error.1))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元组时为单个元素命名</span></span><br><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(http200Status.statusCode)"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="1-11-可选类型"><a href="#1-11-可选类型" class="headerlink" title="1.11    可选类型"></a>1.11    可选类型</h2><blockquote>
<p><strong>用途：</strong>值可能缺失的情况<br><strong>应用：</strong>任何类型</p>
</blockquote>
<h3 id="1-11-1-nil"><a href="#1-11-1-nil" class="headerlink" title="1.11.1    nil"></a>1.11.1    nil</h3><blockquote>
<p><strong>语法：</strong><code>var(let) 标识符: 类型? = 表达式</code><br><strong>相关字面量：</strong><code>nil</code></p>
<ul>
<li><code>nil</code>不能用于非可选的常量或变量</li>
<li>如果声明一个可选常量或者变量但是没有赋值，他们会自动被设置为<code>nil</code></li>
<li>任何类型的可选状态都可以被设置为<code>nil</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nil是一类可选类型字面量，表示没有值</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h3 id="1-11-2-if语句以及强制解析"><a href="#1-11-2-if语句以及强制解析" class="headerlink" title="1.11.2        if语句以及强制解析"></a>1.11.2        if语句以及强制解析</h3><blockquote>
<ol>
<li>通过判断可选型是否<code>!= nil</code>,判断可选型是否存在值</li>
<li>如果存在(否则会报错)通过<code>可选型变量或常量!</code>强制解析</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="comment">// 强制类型转换返回的是一个可选型</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 !强制解析</span></span><br><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of \(convertedNumber!)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-3-可选绑定"><a href="#1-11-3-可选绑定" class="headerlink" title="1.11.3    可选绑定"></a>1.11.3    可选绑定</h3><blockquote>
<p><strong>用途：</strong>更加便捷地解包可选型值。<br><strong>限制：</strong>只能结合<code>if</code>或<code>while</code>使用<br><strong>说明：</strong>如果包含值就把值赋给一个临时<code>常量</code>或者<code>变量</code>。</p>
</blockquote>
<h4 id="绑定一个"><a href="#绑定一个" class="headerlink" title="绑定一个"></a>绑定一个</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> possibleNumber = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="comment">// 如果确实包含一个值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' has an integer value of \(actualNumber)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 可选值为nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' could not be converted to an integer"</span>)<span class="comment">// 'abc' could not be converted to an intege</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="批量绑定"><a href="#批量绑定" class="headerlink" title="批量绑定"></a>批量绑定</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) <span class="keyword">where</span> firstNumber &lt; secondNumber &#123;</span><br><span class="line">    <span class="comment">// 4 &lt; 42</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(firstNumber) &lt; \(secondNumber)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-4-隐式解析可选类型"><a href="#1-11-4-隐式解析可选类型" class="headerlink" title="1.11.4    隐式解析可选类型"></a>1.11.4    隐式解析可选类型</h3><blockquote>
<p><strong>说明：</strong>相当于声明可选型(<code>类型?</code>)和强制解包(<code>可选型!</code>)两个过程的结合。</p>
<ul>
<li>被赋值后，值要么是解包后的值，要么是<code>nil</code></li>
<li>在可选绑定中仍然可以作为普通可选类型使用</li>
</ul>
<p><strong>限制：</strong>右边表达式的返回值必须是可选型，否则将报错。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可选型并强制解析</span></span><br><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式解析(一步到位)</span></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在可选绑定中使用隐式解析可选类型</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-12-错误处理"><a href="#1-12-错误处理" class="headerlink" title="1.12    错误处理"></a>1.12    错误处理</h2><blockquote>
<p><strong>说明：</strong>分位两步</p>
<ol>
<li>定义函数时，使用<code>throws</code>标记可能抛出错误的函数</li>
<li>用<code>do-try-catch</code>包含函数的调用过程和错误处理方式</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 可能报错的函数的调用前必须加关键字 try</span></span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    <span class="comment">// 如果没有报错则执行</span></span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</span><br><span class="line">    <span class="comment">// 捕获错误类型1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    <span class="comment">// 捕获错误类型2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-13-断言"><a href="#1-13-断言" class="headerlink" title="1.13    断言"></a>1.13    断言</h2><blockquote>
<p><strong>用途：</strong>当满足一定条件时结束代码运行通过调试来找到值缺失的原因。<br><strong>适用场景：</strong></p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>的值</li>
</ul>
</blockquote>
<h3 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h3><blockquote>
<p><strong>说明：</strong>在运行时判断一个逻辑条件是否为<code>true</code></p>
<ul>
<li>如果为<code>true</code>，代码继续运行</li>
<li>如果为<code>false</code>，代码执行结束</li>
<li>可以附加一条调试信息</li>
</ul>
<p><strong>注意：</strong>在Xcode 中使用<code>target Release</code>配置为<code>build</code>时，断言会被禁用。<br><strong>原型：</strong><code>全局</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Bool&#125; condition 结果为true或false的表达式</span><br><span class="line">&gt;* @param &#123;String=&#125; message 调试信息</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="type">Void</span> <span class="built_in">assert</span>(condition: <span class="type">Bool</span>,  message: <span class="type">String</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"Aperson's age cannot be less than zero"</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_0 简介/" itemprop="url">
                  简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:31:15+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_0 简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_0 简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-1-关于Swift-About-Swift"><a href="#0-1-关于Swift-About-Swift" class="headerlink" title="0.1    关于Swift(About Swift)"></a>0.1    关于Swift(About Swift)</h2><blockquote>
<p><strong>用途：</strong>编写<code>IOS</code>、<code>OS X</code>、<code>watchOS</code>应用程序<br><strong>特点归纳：</strong></p>
<ul>
<li>基于<code>Cocoa</code>和<code>Cocoa Touch</code>框架</li>
<li>自动垃圾回收（自动引用计数）</li>
<li>采用了<code>Object-C</code>的命名参数和动态对象模型，兼容<code>Object-C</code>，可以无缝对接到现有的<code>Cocoa</code>框架</li>
<li>支持<code>过程式编程</code>和<code>面向对象编程</code></li>
<li>支持代码预览（像脚本语言一样，可以实时查看结果）</li>
</ul>
</blockquote>
<h2 id="0-2-Swift初见（A-Swift-Tour）"><a href="#0-2-Swift初见（A-Swift-Tour）" class="headerlink" title="0.2    Swift初见（A Swift Tour）"></a>0.2    Swift初见（A Swift Tour）</h2><h3 id="0-2-1-简单值（Simple-Values）"><a href="#0-2-1-简单值（Simple-Values）" class="headerlink" title="0.2.1    简单值（Simple Values）"></a>0.2.1    简单值（Simple Values）</h3><h4 id="0-2-1-1-自动推断类型"><a href="#0-2-1-1-自动推断类型" class="headerlink" title="0.2.1.1    自动推断类型"></a>0.2.1.1    自动推断类型</h4><blockquote>
<p><strong>说明：</strong>声明的同时赋值的话，如果不指定类型，编译器会自动推断其类型。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动推断类型为integer</span></span><br><span class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></span><br><span class="line"><span class="comment">// 自动推断类型为double</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-2-指定类型"><a href="#0-2-1-2-指定类型" class="headerlink" title="0.2.1.2    指定类型"></a>0.2.1.2    指定类型</h4><blockquote>
<p><strong>说明：</strong>指定类型会导致强制类型转换</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型为double</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble:<span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-3-显示转换（在表达式中）"><a href="#0-2-1-3-显示转换（在表达式中）" class="headerlink" title="0.2.1.3    显示转换（在表达式中）"></a>0.2.1.3    显示转换（在表达式中）</h4><blockquote>
<p><strong>说明：</strong>表达式中的值任何时候都不会发生隐式转化。需要转换为其它类型必须进行显示转换。<br><strong>特别：</strong><code>\(变量或表达式)</code>（转换成字符串类型）</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> label = <span class="string">"The width is"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer显示转换为string</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure>
<p><em><code>\(变量或表达式)</code></em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have \(apples) apples."</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have \(apples + oranges) pices of fruit."</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-4-数组和字典"><a href="#0-2-1-4-数组和字典" class="headerlink" title="0.2.1.4    数组和字典"></a>0.2.1.4    数组和字典</h4><p><em>声明并初始化（自动推断类型）</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>, <span class="string">"blue paint"</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">    <span class="string">"Malcolm"</span>: <span class="string">"Caption"</span>,</span><br><span class="line">    <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span></span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空（类型信息可以被推断出来）</span></span><br><span class="line">shoppingList = []</span><br><span class="line">occuations = [:]</span><br></pre></td></tr></table></figure>
<p><em>空数组和空字典</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空数组(指定每个元素的类型)</span></span><br><span class="line"><span class="keyword">let</span> emptyArry = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字典（指定键的类型和值的类型）</span></span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>:<span class="type">Float</span>]()</span><br></pre></td></tr></table></figure>
<h3 id="0-2-2-控制流（Control-Flow）"><a href="#0-2-2-控制流（Control-Flow）" class="headerlink" title="0.2.2    控制流（Control Flow）"></a>0.2.2    控制流（Control Flow）</h3><h4 id="0-2-2-1-条件判断"><a href="#0-2-2-1-条件判断" class="headerlink" title="0.2.2.1    条件判断"></a>0.2.2.1    条件判断</h4><blockquote>
<p><strong>说明：</strong>有两类</p>
<ul>
<li>if</li>
<li>switch</li>
</ul>
<p><strong>if语法：</strong></p>
<ul>
<li>包裹条件的<code>()</code>可以省略</li>
<li>语句的<code>{}</code>不可以省略</li>
<li><code>条件</code>必须是一个<code>布尔表达式</code>（其它数据类型会报错，因为不会隐式转换）</li>
</ul>
<p><strong>switch语法：</strong></p>
<ul>
<li>支持任意类型（不仅仅是整数）</li>
<li>支持各种比较操作（不仅仅是测试想等）</li>
<li><code>case</code>后可以有多个数据</li>
<li><code>case</code>后可以使用<code>where</code>字句</li>
<li>匹配字句后程序会退出<code>switch</code>，不需要在每个字句结尾写break</li>
<li>…<br><strong>技巧：</strong><code>if</code>和<code>let</code>组合起来使用可以来为可选值解包</li>
</ul>
</blockquote>
<p><em>if(配合let解包可选值)</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString:<span class="type">String</span>? = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(optionalString == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName:<span class="type">String</span>? = <span class="string">"Join Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello"</span></span><br><span class="line"><span class="comment">// 将可选值optionalName解包后的值给name</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">"Hello, \(name)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    greeting = <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>switch</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Is it a spicy \(x)?"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Everything tasts good in soup."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-2-2-2-循环"><a href="#0-2-2-2-循环" class="headerlink" title="0.2.2.2    循环"></a>0.2.2.2    循环</h4><blockquote>
<p><strong>说明：</strong>有4类</p>
<ul>
<li>for-in</li>
<li>for</li>
<li>while</li>
<li>repeat-while</li>
</ul>
</blockquote>
<p><em>for-in</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找字典中的所有数组中的最大值</span></span><br><span class="line">let interestingNumbers = [</span><br><span class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">]</span><br><span class="line">var largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) in interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number in numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(largest)<span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p><em>repeat-while</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m = m * <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<p><em>for</em></p>
<blockquote>
<p><strong>区间：</strong></p>
<ul>
<li>包含边界：<code>...</code></li>
<li>不包含上边界：<code>..&lt;</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间的方式</span></span><br><span class="line"><span class="keyword">var</span> firstForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    firstForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(firstForLoop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统的方式</span></span><br><span class="line"><span class="keyword">var</span> secondForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i &#123;</span><br><span class="line">    secondForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(secondForLoop)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-3-函数和闭包（Functions-and-Closures）"><a href="#0-2-3-函数和闭包（Functions-and-Closures）" class="headerlink" title="0.2.3    函数和闭包（Functions and Closures）"></a>0.2.3    函数和闭包（Functions and Closures）</h3><h4 id="0-2-3-1-简单函数"><a href="#0-2-3-1-简单函数" class="headerlink" title="0.2.3.1    简单函数"></a>0.2.3.1    简单函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello \(name), today is \(day)."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"Bob"</span>, day: <span class="string">"Tuesday"</span>)<span class="comment">// 第一个参数不用说明label</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-2-返回元组"><a href="#0-2-3-2-返回元组" class="headerlink" title="0.2.3.2    返回元组"></a>0.2.3.2    返回元组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到元组的最大值、最小值和总和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum += score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> statistics = calculateStatistics([<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-3-可变参数"><a href="#0-2-3-3-可变参数" class="headerlink" title="0.2.3.3    可变参数"></a>0.2.3.3    可变参数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变参数函数</span></span><br><span class="line"><span class="comment">// 计算总和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf()</span><br><span class="line">sumOf(<span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-4-函数嵌套"><a href="#0-2-3-4-函数嵌套" class="headerlink" title="0.2.3.4    函数嵌套"></a>0.2.3.4    函数嵌套</h4><blockquote>
<p><strong>说明：</strong>如果嵌套的函数被返回，调用返回的函数就会出现闭包的效果。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 函数内部的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数内部的函数</span></span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-5-返回函数"><a href="#0-2-3-5-返回函数" class="headerlink" title="0.2.3.5    返回函数"></a>0.2.3.5    返回函数</h4><blockquote>
<p><strong>说明：</strong>返回的函数是闭包的一种</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-6-函数作为参数"><a href="#0-2-3-6-函数作为参数" class="headerlink" title="0.2.3.6    函数作为参数"></a>0.2.3.6    函数作为参数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: Int -&gt; Bool)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被作为参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanThen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(numbers, condition: lessThanThen)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-7-匿名函数（匿名闭包）"><a href="#0-2-3-7-匿名函数（匿名闭包）" class="headerlink" title="0.2.3.7    匿名函数（匿名闭包）"></a>0.2.3.7    匿名函数（匿名闭包）</h4><blockquote>
<p><strong>说明：</strong>匿名函数写法非常自由</p>
<ul>
<li>如果一个闭包的类型已知，比如作为一个回调函数，可以忽略参数的类型和返回值</li>
<li>单个语句闭包会把它语句的值当作结果返回</li>
<li>可以通过参数位置而不是参数名引用参数</li>
<li>当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面</li>
<li>当一个闭包是传给函数的唯一参数，可以完全忽略<code>()</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名闭包1（包含参数类型和返回值类型）</span></span><br><span class="line">numbers.<span class="built_in">map</span>(&#123;</span><br><span class="line">    (number:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 匿名闭包2（可以推导出闭包的参数类型和返回值类型的话，两者都可以省略）</span></span><br><span class="line"><span class="keyword">let</span> mappedNumbers = numbers.<span class="built_in">map</span>(&#123;number <span class="keyword">in</span> <span class="number">3</span> * number&#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名闭包3（函数体中通过参数位置而不是参数名访问参数）</span></span><br><span class="line"><span class="keyword">let</span> sortedNumbers = numbers.<span class="built_in">sort</span> &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-4-对象和类（Object-and-Classes）"><a href="#0-2-4-对象和类（Object-and-Classes）" class="headerlink" title="0.2.4    对象和类（Object and Classes）"></a>0.2.4    对象和类（Object and Classes）</h3><blockquote>
<p><strong>语法：</strong></p>
<ul>
<li><code>class 类型名 {...}</code></li>
<li>使用<code>.</code>访问实例的属性和方法</li>
<li>在成员方法中使用<code>self</code>引用当前实例对象</li>
<li>使用构造函数<code>init</code>初始化类实例</li>
<li>使用析构函数<code>deinit</code>在删除对象之前做一些清理工作</li>
<li>没有标准的根类（不同于<code>java</code>）</li>
<li>子类的定义：<code>class 子类名:父类名</code></li>
<li>重写父类的方法许必须用<code>override</code>标记</li>
</ul>
</blockquote>
<p><em>简单类</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形状</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作实例的成员</span></span><br><span class="line">shape.numberOfSides = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure>
<p><em>构造函数和子类</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带名字的形状（基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt;  <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length \(sideLength)."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-1-计算属性"><a href="#0-2-4-1-计算属性" class="headerlink" title="0.2.4.1    计算属性"></a>0.2.4.1    计算属性</h4><blockquote>
<p><strong>说明：</strong>计算属性有getter和setter</p>
<ul>
<li>get：读取属性时返回计算出的属性值</li>
<li>set：写入值时被调用，其中内置变量<code>newValue</code>存储新值</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等腰三角形（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算属性：提供get和set</span></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength = newValue / <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"An equilateral triagle with sides of length \(sideLength)."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle = <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">"a triangle"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问计算属性（get被调用）</span></span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line"><span class="comment">// 设置计算属性（set计算属性）</span></span><br><span class="line">triangle.perimeter = <span class="number">9.9</span></span><br><span class="line"><span class="comment">// 访问存储属性</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-2-属性监控"><a href="#0-2-4-2-属性监控" class="headerlink" title="0.2.4.2    属性监控"></a>0.2.4.2    属性监控</h4><blockquote>
<p><strong>说明：</strong>不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码。可以使用<code>willset</code>和<code>didSet</code>。</p>
<ul>
<li>willset：在设置之前调用</li>
<li>didSet：在设置后后调用</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含一个三角形实例和一个正方形实例作为成员，并确保边长相等</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="comment">// 设置新值前调用</span></span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="comment">// 设置新值之前调用</span></span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span> (size: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle = <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"another test shape"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置前</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置其中一个成员（会触发willset）</span></span><br><span class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">"larger square"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置之后</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-3-实例是可选值"><a href="#0-2-4-3-实例是可选值" class="headerlink" title="0.2.4.3    实例是可选值"></a>0.2.4.3    实例是可选值</h4><blockquote>
<p><strong>说明：</strong>当实例是nil是，需要避免访问实例的成员导致报错。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可选型</span></span><br><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? = <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">"optional square"</span>)</span><br><span class="line"><span class="comment">// 在操作（方法调用／属性访问／子脚本访问）前加?</span></span><br><span class="line"><span class="keyword">let</span> sideLength = optionalSquare?.sideLength</span><br></pre></td></tr></table></figure>
<h3 id="0-2-5-枚举和结构体（Enumerations-and-Structures）"><a href="#0-2-5-枚举和结构体（Enumerations-and-Structures）" class="headerlink" title="0.2.5    枚举和结构体（Enumerations and Structures）"></a>0.2.5    枚举和结构体（Enumerations and Structures）</h3><h4 id="0-2-5-1-枚举"><a href="#0-2-5-1-枚举" class="headerlink" title="0.2.5.1    枚举"></a>0.2.5.1    枚举</h4><blockquote>
<p><strong>关键字：</strong><code>enum</code><br><strong>说明：</strong>swift中的所有命名类型都可以包含方法（包括枚举）。</p>
<ul>
<li>可以不设置枚举值的原始值类型</li>
<li>同一枚举类型的实例的成员（枚举值）的原始值（可以在创建实例的时候传入值）可以不同</li>
<li>如果原始值类型为<code>Int</code>，可以只设置第一个原始值，剩下的原始值会按照顺序自动完成赋值</li>
<li>也可以使用字符串或者浮点数作为枚举的原始值</li>
<li>使用<code>rawValue</code>属性来访问一个枚举成员的原始值</li>
<li>存在一个默认的初始化构造器<code>init?(rawValue:)</code>，这意味着可以通过原始值创建可选型美剧值（使用前需要解包）</li>
<li>声明枚举类型常量或在<code>switch</code>中时，当指定了枚举类型时，可以使用<code>.枚举值</code>的方式</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扑克牌级别</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Ace</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Two</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span></span><br><span class="line">    <span class="comment">// 枚举类型可以声明方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Queen</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"king"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类型变量</span></span><br><span class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.<span class="type">Ace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用枚举类型值的方法</span></span><br><span class="line">ace.simpleDescription()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型变量的原始值</span></span><br><span class="line"><span class="keyword">let</span> aceRawValue = ace.rawValue<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包通过init?(rawValue:)初始化构造器创建的枚举类型值</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank = <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> threeDescription = convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>不设置原始值类型</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扑克牌花色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Spades</span>, <span class="type">Hearts</span>, <span class="type">Diamonds</span>, <span class="type">Clubs</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Spades</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Hearts</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Diamonds</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Clubs</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举值</span></span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.<span class="type">Hearts</span></span><br><span class="line"><span class="comment">// 调用枚举值的方法查看枚举值对应的说明</span></span><br><span class="line"><span class="keyword">let</span> heartsDescription = hearts.simpleDescription()</span><br></pre></td></tr></table></figure>
<p><em>枚举的每个case还可以包含一些值</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器响应</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确响应</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Result</span>(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为实例传值</span></span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.<span class="type">Result</span>(<span class="string">"6:00 am"</span>, <span class="string">"8:09 pm"</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.<span class="type">Error</span>(<span class="string">"Out of cheese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Result</span>(sunrise, sunset):</span><br><span class="line">    <span class="comment">// 获取枚举实例的值</span></span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"sunset is at \(sunrise) and sunset is at \(sunset)."</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Error</span>(error):</span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"Failure... \(error)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-2-5-2-结构体"><a href="#0-2-5-2-结构体" class="headerlink" title="0.2.5.2    结构体"></a>0.2.5.2    结构体</h4><blockquote>
<p><strong>说明：</strong>结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的区别就是结构体是传值，类是传引用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扑克牌</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 级别</span></span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="comment">// 花色</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The \(rank.simpleDescription()) of \(suit.simpleDescription())"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 黑桃3</span></span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .<span class="type">Three</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="keyword">let</span> threeOfSpandesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure>
<h3 id="0-2-6-协议和扩展（Protocols-and-Extensions）"><a href="#0-2-6-协议和扩展（Protocols-and-Extensions）" class="headerlink" title="0.2.6    协议和扩展（Protocols and Extensions）"></a>0.2.6    协议和扩展（Protocols and Extensions）</h3><h4 id="0-2-6-1-协议"><a href="#0-2-6-1-协议" class="headerlink" title="0.2.6.1    协议"></a>0.2.6.1    协议</h4><blockquote>
<p><strong>关键字：</strong><code>protocol</code><br><strong>说明：</strong>类似于接句，类、枚举、结构体都可以实现协议。<br><strong>注意：</strong></p>
<ul>
<li>使用结构体实现协议时，如果实现的方法会修改结构体，需要用<code>mutating</code>标记。</li>
<li>可以直接使用协议声明变量或常量，但无法调用运行时类型实现的协议值完的方法或属性</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类实现这个协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A very simple class."</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">" Now 100% adjust."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"><span class="comment">// 像使用其他命名类型一样使用协议名，用其声明一个变量，并将实现了该协议的类的实例赋值给它</span></span><br><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</span><br><span class="line"><span class="comment">// 使用协议本身声明的变量或常量不能访问协议外定义成员</span></span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过结构体实现这个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A simple structure"</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"(adjusted)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="type">SimpleStructure</span>()</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDesctiption = b.simpleDescription</span><br></pre></td></tr></table></figure>
<h4 id="0-2-6-2-扩展"><a href="#0-2-6-2-扩展" class="headerlink" title="0.2.6.2    扩展"></a>0.2.6.2    扩展</h4><blockquote>
<p><strong>关键字：</strong><code>extension</code><br><strong>描述：</strong>为现有的类型添加功能，比如新的方法和计算属性。<br><strong>说明：</strong>你可以使用扩展在别处修改定义，甚至是从外部库活着框架引入的一个类型，使得这个类型遵循某个协议。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The number \(self)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-7-范型（Generics）"><a href="#0-2-7-范型（Generics）" class="headerlink" title="0.2.7    范型（Generics）"></a>0.2.7    范型（Generics）</h3><blockquote>
<p><strong>描述：</strong>在<code>&lt;&gt;</code>中写一个名字来创建一个范型函数或者类型。<br><strong>说明：</strong>可以应用于</p>
<ul>
<li>函数</li>
<li>方法</li>
<li>类</li>
<li>枚举</li>
<li>结构体</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>可以使用<code>where</code>来指定对类型的要求</li>
<li><code>&lt;T: Equatable&gt;</code>和<code>&lt;T where T: Equatable&gt;</code>等价</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span> &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; <span class="params">(lhs: T, <span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h2 id="0-3-Swift版本历史记录"><a href="#0-3-Swift版本历史记录" class="headerlink" title="0.3    Swift版本历史记录"></a>0.3    Swift版本历史记录</h2><h2 id="0-4-The-Swift-Programing-language中文版"><a href="#0-4-The-Swift-Programing-language中文版" class="headerlink" title="0.4    The Swift Programing language中文版"></a>0.4    The Swift Programing language中文版</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_20 NSPredicate/" itemprop="url">
                  20 NSpredicate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:43:10+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_20 NSPredicate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_20 NSPredicate/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Cocoa</code>提供了一个名为<code>NSPredicate</code>的类，用于指定过滤器的条件。<br><strong>原理：</strong>可以创建<code>NSPredicate</code>对象，通过它准确描述所需的条件，通过<code>谓词</code>(计算真值和假值的函数)筛选每个对象，判断它们是否与条件相匹配。</p>
</blockquote>
<h2 id="20-1-创建谓词"><a href="#20-1-创建谓词" class="headerlink" title="20.1    创建谓词"></a>20.1    创建谓词</h2><blockquote>
<p><strong>说明：</strong>使用<code>谓词</code>有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建许多<code>NSPredicate</code>对象，组合使用</td>
<td>构建通用用户界面来指定查询的场景</td>
</tr>
<tr>
<td>谓词字符串</td>
<td>适用于初学者使用，比较简单</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>通常将以使用<code>面向字符串</code>的<code>API</code>，尤其是在缺少编译器的错误检查和奇怪的运行时错误的时候。</p>
</blockquote>
<h3 id="predicateWithFormat工厂方法"><a href="#predicateWithFormat工厂方法" class="headerlink" title="predicateWithFormat工厂方法"></a>predicateWithFormat工厂方法</h3><blockquote>
<p><strong>说明：</strong>基于<code>谓词字符串</code>在后台构建<code>对象数</code>，创建<code>谓词</code>。<br><strong>谓词字符串：</strong>用途类似<code>sql</code>，语法类似标准c语言表达式<br><strong>原型：</strong><code>NSPredicate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; predicateFormat 谓词字符串（地位类似格式串）</span><br><span class="line">* @param &#123;...&#125; 对应为此字符串中的占位符</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSPredicate</span> *)predicateWithFormat:(<span class="built_in">NSString</span> *)predicateFormat, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存入汽车实例</span></span><br><span class="line">Car *car;</span><br><span class="line">car = makeCar(<span class="string">@"Herbie"</span>, <span class="string">@"Honda"</span>, <span class="string">@"CRX"</span>, <span class="number">1984</span>, <span class="number">2</span>, <span class="number">34000</span>, <span class="number">58</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建谓词：过滤 name 属性值为 Herbie 的车</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate;</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == 'Herbie'"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="20-2-计算谓词"><a href="#20-2-计算谓词" class="headerlink" title="20.2    计算谓词"></a>20.2    计算谓词</h2><h3 id="evaluateWithObject实例方法"><a href="#evaluateWithObject实例方法" class="headerlink" title="evaluateWithObject实例方法"></a>evaluateWithObject实例方法</h3><blockquote>
<p><strong>说明：</strong>通知接收对象（即<code>谓词</code>）根据<code>指定的对象</code>计算自身的值。<br><strong>用途：</strong>计算<code>某个对象</code>是否符合某个<code>谓词</code>中的判断逻辑。<br><strong>原型：</strong>``</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; object 谓词的主语</span><br><span class="line">* @return &#123;BOOL&#125; YES 判断为真， NO 判断为假</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateWithObject:(nullable <span class="keyword">id</span>)object;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 谓词1：过滤 name 属性值为 Herbie 的车</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate;</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == 'Herbie'"</span>];</span><br><span class="line"><span class="comment">// 搭配主语进行判断</span></span><br><span class="line"><span class="built_in">BOOL</span> match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词2：引擎马力大于150</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; 150"</span>];</span><br><span class="line">match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词3：和谓词1等价</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == %@"</span>, <span class="string">@"Herbie"</span>];</span><br><span class="line">match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="20-3-数组过滤器"><a href="#20-3-数组过滤器" class="headerlink" title="20.3    数组过滤器"></a>20.3    数组过滤器</h2><blockquote>
<p><strong>说明：</strong>某些<code>类别</code>将<code>谓词过滤方法</code>添加到了<code>Cocoa</code>集合类（比如<code>NSArray</code>）中。</p>
</blockquote>
<h3 id="filteredArrayUsingPredicate实例方法"><a href="#filteredArrayUsingPredicate实例方法" class="headerlink" title="filteredArrayUsingPredicate实例方法"></a>filteredArrayUsingPredicate实例方法</h3><blockquote>
<p><strong>说明：</strong>循环过滤数组内容，根据<code>谓词</code>计算每个对象的值，并将值为<code>YES</code>的对象累计到将被放回的新数组中。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组过滤 */</span></span><br><span class="line"><span class="comment">// 创建汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"><span class="comment">// 添加汽车实例</span></span><br><span class="line">car = makeCar (<span class="string">@"Badger"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Integra"</span>, <span class="number">1987</span>, <span class="number">5</span>, <span class="number">217036.7</span>, <span class="number">130</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Elvis"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Legend"</span>, <span class="number">1989</span>, <span class="number">4</span>, <span class="number">28123.4</span>, <span class="number">151</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Phoenix"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Firebird"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">85128.3</span>, <span class="number">345</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Streaker"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Silver Streak"</span>, <span class="number">1950</span>, <span class="number">2</span>, <span class="number">39100.0</span>, <span class="number">36</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Judge"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"GTO"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">45132.2</span>, <span class="number">370</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Paper Car"</span>, <span class="string">@"Plymouth"</span>, <span class="string">@"Valiant"</span>, <span class="number">1965</span>, <span class="number">2</span>, <span class="number">76800</span>, <span class="number">105</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"><span class="comment">// 创建谓词</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; 150"</span>];</span><br><span class="line"><span class="comment">// 获取汽车实例组成的数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *cars = [garage cars];</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (Car *car <span class="keyword">in</span> cars) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([predicate evaluateWithObject:car]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, car.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建谓词</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; %d"</span>, <span class="number">50</span>];</span><br><span class="line"><span class="comment">// 过滤数组：引擎马力大于50的</span></span><br><span class="line"><span class="built_in">NSArray</span> *results = [cars filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h3 id="filterUsingPredicate实例方法"><a href="#filterUsingPredicate实例方法" class="headerlink" title="filterUsingPredicate实例方法"></a>filterUsingPredicate实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>谓词</code>剔除可变数组中计算结果不为真的对象。<br><strong>原型：</strong><code>NSMutableArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSPredicate *&#125; predicate 谓词</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)filterUsingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------可变数组过滤</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *carsCopy = [cars mutableCopy];</span><br><span class="line"><span class="comment">// 过滤（有副作用的过滤）</span></span><br><span class="line">[carsCopy filterUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-4-格式说明符"><a href="#20-4-格式说明符" class="headerlink" title="20.4    格式说明符"></a>20.4    格式说明符</h2><blockquote>
<p><strong>说明：</strong>硬编码并非好事，可以通过两种方式将不同的内同放入<code>谓词格式字符串</code>中</p>
<ul>
<li>格式说明符：<code>%格式说明符</code></li>
<li>变量名：<code>$变量名</code></li>
</ul>
</blockquote>
<h3 id="20-4-1-格式说明符"><a href="#20-4-1-格式说明符" class="headerlink" title="20.4.1    格式说明符"></a>20.4.1    格式说明符</h3><blockquote>
<p><strong>说明：</strong>分3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>printf说明符</td>
<td><code>c</code>语言使用的格式说明符</td>
<td><code>%d</code>、<code>%f</code>等</td>
</tr>
<tr>
<td><code>%@</code></td>
<td>插入<code>O-C</code>字符串值</td>
<td></td>
</tr>
<tr>
<td><code>%K</code></td>
<td>插入键路径</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用printf式格式字符串</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; %d"</span>, <span class="number">50</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="comment">// 使用%@插入字符串值</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == %@"</span>, <span class="string">@"Herbie"</span>];</span><br><span class="line"><span class="comment">// 使用%K指定键路径</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"%K == %@"</span>, <span class="string">@"name"</span>, <span class="string">@"Herbie"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="20-4-2-插入变量名"><a href="#20-4-2-插入变量名" class="headerlink" title="20.4.2    插入变量名"></a>20.4.2    插入变量名</h3><blockquote>
<p><strong>说明：</strong>需要配合<code>字典</code>和<code>predicateWithSubstitutionVariables</code>实例方法一起使用。</p>
</blockquote>
<h4 id="predicateWithSubstitutionVariables"><a href="#predicateWithSubstitutionVariables" class="headerlink" title="predicateWithSubstitutionVariables"></a>predicateWithSubstitutionVariables</h4><blockquote>
<p><strong>说明：</strong>通过已有的<code>谓词</code>（<code>谓词字符串</code>中包含插入的变量名）创建更加具体的<code>专用谓词</code>。<br><strong>原型：</strong><code>NSPredicate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSDictionary&lt;NSString *, id&gt; *&#125; variables 用于具体化谓词的字典</span><br><span class="line">* @return &#123;NSPredicate&#125; 专用谓词</span><br><span class="line">*/</span></span><br><span class="line">- (instancetype)predicateWithSubstitutionVariables:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)variables;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字典的键名插入到谓词字符串中</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == $NAME"</span>];<span class="comment">// 创建谓词模版</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *varDict;</span><br><span class="line"><span class="comment">// 变量名为NSString类型</span></span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"Heribie"</span>, <span class="string">@"NAME"</span>, <span class="literal">nil</span>];<span class="comment">// 用来为上述谓词模版的$NAME赋值的字典</span></span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];<span class="comment">// 通过谓词模版创建谓词</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"SNORGLE：%@"</span>, predicate);</span><br><span class="line">match = [predicate evaluateWithObject:car];<span class="comment">// 主语结合谓词进行计算</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; $POWER"</span>];</span><br><span class="line"><span class="comment">// 变量名为NSNumber类型</span></span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>], <span class="string">@"POWER"</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"OOP %@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-5-运算符"><a href="#20-5-运算符" class="headerlink" title="20.5    运算符"></a>20.5    运算符</h2><blockquote>
<p><strong>说明：</strong><code>NSPredicate</code>的格式串中包含大量不同的运算符。<br><strong>注意：</strong>本章将介绍大多数运算符，其余的可以通过苹果公司的<code>在线文档</code>进行查询。</p>
</blockquote>
<h3 id="20-5-1-比较和逻辑运算符"><a href="#20-5-1-比较和逻辑运算符" class="headerlink" title="20.5.1    比较和逻辑运算符"></a>20.5.1    比较和逻辑运算符</h3><blockquote>
<p><strong>说明：</strong><code>谓词字符串</code>语法支持<code>C</code>语言中一些常用的运算符</p>
<ul>
<li>等号运算符：<code>==</code></li>
<li>不等号运算符：<code>&gt;</code>、<code>&lt;=</code>、<code>!=</code>等</li>
<li>赋值运算符：<code>=</code></li>
<li>逻辑运算符：<code>AND(&amp;&amp;)</code>、<code>OR(||)</code>、<code>NOT(!)</code></li>
</ul>
</blockquote>
<h4 id="20-5-1-1-比较运算符"><a href="#20-5-1-1-比较运算符" class="headerlink" title="20.5.1.1    比较运算符"></a>20.5.1.1    比较运算符</h4><blockquote>
<p><strong>说明：</strong>包括<code>等号运算符</code>和<code>不等号运算符</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code>(<code>&lt;&gt;</code>)</td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;=</code>(<code>=&lt;</code>)</td>
<td>小于或等于</td>
</tr>
<tr>
<td><code>&gt;=</code>(<code>=&gt;</code>)</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较运算符：过滤出数组中name属性小于"Newton"的对象组成的新数组</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name &lt; 'Newton'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [results valueForKey:<span class="string">@"name"</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="20-5-1-2-逻辑运算符"><a href="#20-5-1-2-逻辑运算符" class="headerlink" title="20.5.1.2    逻辑运算符"></a>20.5.1.2    逻辑运算符</h4><blockquote>
<p><strong>说明：</strong>共3个</p>
</blockquote>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th><code>O-C</code>形式</th>
<th>c语言形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>与</td>
<td><code>AND</code></td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>或</td>
<td><code>OR</code></td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td>非</td>
<td><code>NOT</code></td>
<td><code>!</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>谓词字符串</code>中的运算符不区分大小写</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"(engine.horsepower &gt; 50) AND (engine.horsepower &lt; 200)"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oop %@"</span>, results);</span><br></pre></td></tr></table></figure>
<h3 id="20-5-2-数组运算符"><a href="#20-5-2-数组运算符" class="headerlink" title="20.5.2    数组运算符"></a>20.5.2    数组运算符</h3><blockquote>
<p><strong>说明：</strong>有2个</p>
</blockquote>
<p>|数组运算符|说明|<br>|<code>BETWEEN</code>|判断是否介于两个值之间|<br>|<code>IN</code>|判断数组中是否包含某个值|</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组字面量</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:</span><br><span class="line">             <span class="string">@"engine.horsepower BETWEEN &#123; 50, 200 &#125;"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组变量</span></span><br><span class="line"><span class="built_in">NSArray</span> *betweens = [<span class="built_in">NSArray</span> arrayWithObjects:</span><br><span class="line">                     [<span class="built_in">NSNumber</span> numberWithInt: <span class="number">50</span>], [<span class="built_in">NSNumber</span> numberWithInt: <span class="number">200</span>], <span class="literal">nil</span>];</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"engine.horsepower BETWEEN %@"</span>, betweens];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组变量＋谓词模版</span></span><br><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"engine.horsepower BETWEEN $POWERS"</span>];</span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: betweens, <span class="string">@"POWERS"</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables: varDict];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组运算符 IN：使用数组字面量</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name IN &#123; 'Herbie', 'Snugs', 'Badger', 'Flap' &#125;"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, [results valueForKey: <span class="string">@"name"</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="20-6-有-SELF-就足够了"><a href="#20-6-有-SELF-就足够了" class="headerlink" title="20.6    有 SELF 就足够了"></a>20.6    有 SELF 就足够了</h2><blockquote>
<p><strong>说明：</strong>在谓词字符串的<code>键路径</code>部分，除了可以使用对象的属性名外，还可以通过<code>SELF</code>引用自身。<br><strong>用途：</strong><code>SELF</code>表示的是响应谓词计算的对象本身，适用于将谓词应用于简单的值（例如纯文本字符串），而非哪些可以通过键路径进行操作的复杂对象。<br><strong>技巧：</strong>可以使用<code>谓词</code>计算两个数组的交集，其中一个数组作为<code>主语</code>，另一个在<code>谓词</code>中，使用<code>IN</code>运算符。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------ SELF ：应用于复杂对象</span></span><br><span class="line"><span class="comment">// 判断 name 属性是不是在指定 字符串数组中</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF.name IN &#123;'Herbie', 'Snugs', 'Badger', 'Flap'&#125;"</span>];</span><br><span class="line"><span class="comment">// 使用谓词过滤汽车数组，获取子数组</span></span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------ SELF：应用于简单对象</span></span><br><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line">names = [cars valueForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// 判断字符串自身是不是在指定 字符串数组中</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF IN &#123;'Herbie', 'Snugs', 'Bager', 'Flap'&#125;"</span>];</span><br><span class="line"><span class="comment">// 主语＋谓词</span></span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- 使用 IN 运算符计算两个数组的交集</span></span><br><span class="line"><span class="built_in">NSArray</span> *names1 = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Herbie"</span>, <span class="string">@"Badger"</span>, <span class="string">@"Judge"</span>, <span class="string">@"Elvis"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *names2 = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Judge"</span>, <span class="string">@"Paper Car"</span>, <span class="string">@"Badger"</span>, <span class="string">@"Phoenix"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"SELF IN %@"</span>, names1];</span><br><span class="line">results = [names2 filteredArrayUsingPredicate: predicate];</span><br></pre></td></tr></table></figure>
<h2 id="20-7-字符串运算符"><a href="#20-7-字符串运算符" class="headerlink" title="20.7    字符串运算符"></a>20.7    字符串运算符</h2><blockquote>
<p><strong>说明：</strong>3个专门针对字符串的运算符</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BEGINSWITH</code></td>
<td>前缀是否是某一个字符串</td>
</tr>
<tr>
<td><code>ENDSWITH</code></td>
<td>后缀是某一个字符串</td>
</tr>
<tr>
<td><code>CONTAINS</code></td>
<td>是否包含某一个子串</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>运算符修饰符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c</code></td>
<td>不区分大小写</td>
</tr>
<tr>
<td><code>d</code></td>
<td>不区分发音符号</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>不区分大小写和发音符号</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>处分是需要区分大小写或重音符号的特殊原因，否则请尽力使用<code>cd</code>修饰符。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------- 字符串运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH 'Bad'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH 'HERB'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH[cd] 'HERB'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-8-LIKE-运算符"><a href="#20-8-LIKE-运算符" class="headerlink" title="20.8    LIKE 运算符"></a>20.8    LIKE 运算符</h2><blockquote>
<p><strong>说明：</strong><code>LIKE</code>运算符包含2个通配符</p>
</blockquote>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>与任意个任意字符匹配</td>
</tr>
<tr>
<td><code>?</code></td>
<td>与一个任意字符匹配</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>如果热衷于正则表达式，可以使用<code>MATCHES</code>运算符。<br><strong>技巧：</strong>由于正则表达式计算开销比较大，因此可以在使用<code>MATCH</code>之前先使用其它运算符做初步过滤，从而提高运算速度。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- like 运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name LIKE[cd] '*er*'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name LIKE[cd] '???er*'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-9-结语"><a href="#20-9-结语" class="headerlink" title="20.9    结语"></a>20.9    结语</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_19 使用静态分析器/" itemprop="url">
                  19 使用静态分析器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:52+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_19 使用静态分析器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_19 使用静态分析器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>从<code>Xcode 3.2</code>开始加入的新功能，不需要运行程序就可以从逻辑上检测代码的工具，它可以寻找会演变成bug的错误。</p>
</blockquote>
<h2 id="19-1-静态工作"><a href="#19-1-静态工作" class="headerlink" title="19.1    静态工作"></a>19.1    静态工作</h2><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>可以识别以下几种错误</p>
<ul>
<li><strong>安全问题：</strong>比如内存泄漏和缓冲区溢出</li>
<li><strong>并发性问题：</strong>比如静态条件（也就是依赖时间的两个或多个任务失效）</li>
<li><strong>逻辑问题：</strong>包括废代码和不好的编码习惯</li>
</ul>
<p><strong>注意：</strong><code>静态分析器</code>存在以下不足</p>
<ul>
<li>拖慢构建程序的过程：因为需要消耗时间来进行分析</li>
<li>有时会误报错误</li>
<li>需要适应：因为改变了熟悉的工作流程</li>
</ul>
</blockquote>
<h3 id="19-1-1-开始分析"><a href="#19-1-1-开始分析" class="headerlink" title="19.1.1    开始分析"></a>19.1.1    开始分析</h3><blockquote>
<p><strong>运行静态分析器：</strong><code>Product(菜单) -&gt; Analyze</code>，分解决过在导航栏<code>issue</code>中可以看到<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%885.26.58.png" alt="Alt text"></p>
</blockquote>
<h4 id="19-1-1-1-废代码"><a href="#19-1-1-1-废代码" class="headerlink" title="19.1.1.1    废代码"></a>19.1.1.1    废代码</h4><blockquote>
<p><strong>废代码：</strong>创建了一个对象<code>pool</code>，但从没有在代码中直接访问过，没有向它发送消息也没有更改过它。<br><strong>优化手段：</strong>移除<code>废代码</code><br><strong>优化意义：</strong>废代码并不一定会给程序带来功能上的问题，但终归会浪费性能，移除废代码可以使应用程序更加高效。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.42.15.png" alt="Alt text"></p>
<h4 id="19-1-1-2-内存泄漏：对象被释放之前程序return"><a href="#19-1-1-2-内存泄漏：对象被释放之前程序return" class="headerlink" title="19.1.1.2    内存泄漏：对象被释放之前程序return"></a>19.1.1.2    内存泄漏：对象被释放之前程序return</h4><blockquote>
<p><strong>说明：</strong>通常还没有释放掉分配的内存的对象，就过早返回时便会出现这种情况。<br><strong>扩展：</strong>可以通过点击带有<code>分析器图标</code>的代码来观察代码从开始到当前行的运行流程</p>
<ol>
<li>触发“运行流程”<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.50.10.png" alt="Alt text"></li>
<li>完毕<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.55.01.png" alt="Alt text"></li>
</ol>
</blockquote>
<h4 id="19-1-1-3-内存泄漏：副本没有释放"><a href="#19-1-1-3-内存泄漏：副本没有释放" class="headerlink" title="19.1.1.3    内存泄漏：副本没有释放"></a>19.1.1.3    内存泄漏：副本没有释放</h4><blockquote>
<p><strong>说明：</strong>创建一个对象的副本，要在适当的时候对其进行释放，否则引发内存泄漏。<br><strong>优化手段：</strong>在<code>main</code>函数结尾处释放<code>carCopy</code>。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%887.02.18.png" alt="Alt text"></p>
</blockquote>
<h4 id="19-1-1-4-内存泄漏：description方法中的desc在返回前没有释放"><a href="#19-1-1-4-内存泄漏：description方法中的desc在返回前没有释放" class="headerlink" title="19.1.1.4    内存泄漏：description方法中的desc在返回前没有释放"></a>19.1.1.4    内存泄漏：description方法中的desc在返回前没有释放</h4><blockquote>
<p><strong>说明：</strong><code>AllWeatherRadial类</code>中的<code>description</code>方法中分配了一个字符串<code>desc</code>，但没有在返回函数之前释放它。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:</span><br><span class="line">                   <span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>,</span><br><span class="line">               [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth],</span><br><span class="line">               [<span class="keyword">self</span> rainHandling], </span><br><span class="line">               [<span class="keyword">self</span> snowHandling]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [desc autorelease];</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// description</span></span><br></pre></td></tr></table></figure>
<h3 id="19-1-2-协助分析器"><a href="#19-1-2-协助分析器" class="headerlink" title="19.1.2    协助分析器"></a>19.1.2    协助分析器</h3><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>分析出的“问题”如果是我们有意的，可以通过在声明方法时使用一些<code>关键字</code>避免误报；或者有些情况下，想要使通常没问题的方式发出警报。比如</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用途</th>
<th>对应的惯例</th>
<th>返回对象为<code>Core Foundation</code>对象时</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NS_RETURNS_RETAINTED</code></td>
<td>标记方法，以返回一个保留计数器的值不是零的对象</td>
<td>分配内存的地方也要负责清理内存</td>
<td><code>CF_RETURNS_RETAINTED</code></td>
</tr>
<tr>
<td><code>NS_RETURNS_NOT_RETAINED</code></td>
<td>使<code>静态分析器</code>在方法试图返回一个保留对象时发出<code>issue</code></td>
<td>返回保留对象通常不需要做额外内存管理</td>
<td><code>NS_RETURNS_NOT_RETAINED</code></td>
</tr>
<tr>
<td><code>CLANG_ANALYZER_NORETURN</code></td>
<td>如果方法有值返回，就在<code>静态分析</code>是发出警报</td>
<td>方法返回值不会发生<code>issue</code></td>
<td>无意义</td>
</tr>
</tbody>
</table>
<h4 id="NS-RETURNS-RETAINTED：返回一个保留的对象"><a href="#NS-RETURNS-RETAINTED：返回一个保留的对象" class="headerlink" title="NS_RETURNS_RETAINTED：返回一个保留的对象"></a>NS_RETURNS_RETAINTED：返回一个保留的对象</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator <span class="built_in">NS_RETURNS_RETAINED</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *myArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 没将 myArray 释放就返回了</span></span><br><span class="line">	<span class="keyword">return</span> myArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NS-RETURNS-NOT-RETAINED：返回一个未保留的对象"><a href="#NS-RETURNS-NOT-RETAINED：返回一个未保留的对象" class="headerlink" title="NS_RETURNS_NOT_RETAINED：返回一个未保留的对象"></a>NS_RETURNS_NOT_RETAINED：返回一个未保留的对象</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析器会在该方法视图返回一个保留对象时提出issue</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator <span class="built_in">NS_RETURNS_NOT_RETAINED</span>;</span><br></pre></td></tr></table></figure>
<h3 id="19-1-3-了解更多"><a href="#19-1-3-了解更多" class="headerlink" title="19.1.3    了解更多"></a>19.1.3    了解更多</h3><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>能够找到的其它问题</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>issue</code></th>
<th>说明</th>
<th>解决<code>issue</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>等号错误</td>
<td><code>if (myValue = expression)</code>存在歧义</td>
<td>赋值后判空：<code>if ((myValue = expression))</code>；判等：<code>if (nil != (myValue = expression))</code></td>
</tr>
<tr>
<td>内存泄漏</td>
<td>方法中的运行时错误使方法提前return，导致release代码没有执行而发生内存泄漏</td>
<td>无论什么时候退出了方法，都需要确认有没有分配了单海没有释放的对象</td>
</tr>
<tr>
<td>过度释放</td>
<td>重复<code>autorelease</code></td>
<td>移除多余的<code>autorelease</code></td>
</tr>
<tr>
<td><code>@synchronized语句中的空值</code></td>
<td><code>@synchronized(object)</code>中的<code>object</code>如果为<code>nil</code>就发出<code>issue</code></td>
<td>确保<code>object</code>不为<code>nil</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>把<code>静态分析器</code>作为一个善意但烦人的朋友，因为它所说的通常都是对的。<br><strong>注意：</strong>不要太依赖<code>静态分析器</code>来查找每一个内存泄漏和废代码，自己要对自己的代码负责。</p>
</blockquote>
<h2 id="19-2-小结"><a href="#19-2-小结" class="headerlink" title="19.2    小结"></a>19.2    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_18 键／值编码/" itemprop="url">
                  18 键/值编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:32+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_18 键／值编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_18 键／值编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="18-1-入门项目"><a href="#18-1-入门项目" class="headerlink" title="18.1    入门项目"></a>18.1    入门项目</h2><blockquote>
<p><strong>说明：</strong></p>
</blockquote>
<h2 id="18-2-KVC简介"><a href="#18-2-KVC简介" class="headerlink" title="18.2    KVC简介"></a>18.2    KVC简介</h2><blockquote>
<p><strong>说明：</strong>通过<code>键／值编码（KVC）</code>，没有相应<code>getter</code>方法也能获取属性值，没有相应<code>setter</code>方法也能设置属性值。<br><strong>自动开箱和装箱：</strong>仅<code>KVC</code>具有这种功能，常规方法调用和属性语法不具备该功能。</p>
</blockquote>
<h3 id="valueForKey实例方法"><a href="#valueForKey实例方法" class="headerlink" title="valueForKey实例方法"></a>valueForKey实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>获取属性的<code>值</code>。<br><strong>原理：</strong>在<code>Objective-C</code>的运行中使用元数据打开对象并进入其中查找需要的信息，查找顺序为</p>
<ol>
<li>以参数命名(<code>key</code>或<code>isKey</code>)的<code>getter</code></li>
<li>名称为<code>_key</code>或<code>key</code>的实例变量</li>
</ol>
<p><strong>自动装箱：</strong>通过该方法获取属性值时，如果属性为<code>标量(int、float、struct)</code>，该方法会根据需要将属性放入<code>NSNumber</code>或<code>NSValue</code>中。<br><strong>兼容性：</strong>在<code>C</code>或<code>C++</code>中不能执行这种操作。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; key 属性名</span><br><span class="line">* @return &#123;id&#125; 属性值（标量会被自动装箱）</span><br><span class="line">*/</span></span><br><span class="line">- (nullable <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<h3 id="setValue-forkey实例方法"><a href="#setValue-forkey实例方法" class="headerlink" title="setValue:forkey实例方法"></a>setValue:forkey实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>设置属性的<code>值</code>。<br><strong>自动开箱：</strong>使用该方法设置属性时，如果属性是<code>标量（int、float、struct）</code>，则会从新值（<code>id</code>）中提取出和属性类型相符的<code>标量</code>。<br><strong>技巧：</strong>如果想设置一个<code>标量</code>值，在调用<code>setValue</code>方法之前需要将它们包装掐来（封装到对象中）。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; value 要设置的值（需要的话会被开箱）</span><br><span class="line">* @param &#123;NSString *&#125; key 属性名</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(nullable <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建 Car 对象</span></span><br><span class="line">Car *car = [[Car alloc] init];</span><br><span class="line">car.name = <span class="string">@"Herbie"</span>;</span><br><span class="line">car.make = <span class="string">@"Honda"</span>;</span><br><span class="line">car.model = <span class="string">@"CRX"</span>;</span><br><span class="line">car.modelYear = <span class="number">1984</span>;</span><br><span class="line">car.numberOfDoors = <span class="number">2</span>;</span><br><span class="line">car.mileage = <span class="number">110000</span>;</span><br><span class="line"><span class="comment">// 初始化轮胎</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AllWeatherRadial *tire;</span><br><span class="line">    tire = [[AllWeatherRadial alloc] init];</span><br><span class="line">    [car setTire: tire atIndex:i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化引擎</span></span><br><span class="line">Slant6 *engine = [[Slant6 alloc] init];</span><br><span class="line">car.engine = engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 访问车的引擎的马力</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [engine valueForKey:<span class="string">@"horsepower"</span>]);</span><br><span class="line"><span class="comment">// 通过 KVC 重新设置车的引擎的马力</span></span><br><span class="line">[engine setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>] forKey:<span class="string">@"horsepower"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [engine valueForKey:<span class="string">@"horsepower"</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Car is %@"</span>, car);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 访问车的名字</span></span><br><span class="line"><span class="built_in">NSString</span> *name = [car valueForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, name);</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的制造商</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"make is %@"</span>, [car valueForKey:<span class="string">@"make"</span>]);</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的车型出厂日期</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"model year is %@"</span>, [car valueForKey:<span class="string">@"modelYear"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 设置车名</span></span><br><span class="line">[car setValue:<span class="string">@"Harold"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"new car name is %@"</span>, [car name]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 设置里程数</span></span><br><span class="line">[car setValue:[<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">25062.4</span>] forKey:<span class="string">@"mileage"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"new mileage is %.1f"</span>, [car mileage]);</span><br></pre></td></tr></table></figure>
<h2 id="18-3-键路径"><a href="#18-3-键路径" class="headerlink" title="18.3    键路径"></a>18.3    键路径</h2><blockquote>
<p><strong>说明：</strong>进行<code>get</code>和<code>set</code>操作，除了通过<code>键</code>，还可以通过<code>键路径</code>。<code>键路径</code>可以根据<code>对象图</code>访问到任意深度的对象，比使用一系列嵌套方法调用更容易访问到对象。</p>
</blockquote>
<h3 id="valueForKeyPath实例方法"><a href="#valueForKeyPath实例方法" class="headerlink" title="valueForKeyPath实例方法"></a>valueForKeyPath实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>获取属性的<code>值</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; keyPath 键路径</span><br><span class="line">* @return &#123;id&#125; 属性值（标量会被自动装箱）</span><br><span class="line">*/</span></span><br><span class="line">- (nullable <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<h3 id="setValue-forKeyPath实例方法"><a href="#setValue-forKeyPath实例方法" class="headerlink" title="setValue:forKeyPath实例方法"></a>setValue:forKeyPath实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>设置属性的<code>值</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; value 要设置的值（需要的话会被开箱）</span><br><span class="line">* @param &#123;NSString *&#125; keyPath 键路径</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(nullable <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 KVC 设置车的引擎的马力</span></span><br><span class="line">[car setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">155</span>] forKeyPath:<span class="string">@"engine.horsepower"</span>];</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的引擎的马力</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [car valueForKeyPath:<span class="string">@"engine.horsepower"</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="18-4-整体操作"><a href="#18-4-整体操作" class="headerlink" title="18.4    整体操作"></a>18.4    整体操作</h2><blockquote>
<p><strong>说明：</strong>如果使用<code>键值</code>或<code>键路径</code>访问位于对象中的数组类型的<code>实例属性</code>的元素，实际上会对数组中所有元素进行操作。如果是查询操作，则还会将查询结果打包到另一个数组中并返回。<br><strong>注意：</strong>这种<code>整体操作</code>意味着无法在<code>键路径</code>中单独索引数组类型的属性的其中一个元素。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 KVC 访问车的轮胎的胎压，会便利tires的每个属性，并将所有tires的属性的pressure变量封装到 NSNumber 对象中并返回</span></span><br><span class="line"><span class="built_in">NSArray</span> *pressures = [car valueForKeyPath:<span class="string">@"tires.pressure"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"pressures %@"</span>, pressures);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-休息一下"><a href="#18-4-1-休息一下" class="headerlink" title="18.4.1    休息一下"></a>18.4.1    休息一下</h3><blockquote>
<p><strong>说明：</strong>创建一个新的类用于后面的学习使用。</p>
</blockquote>
<p><em>Garage.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Car</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Garage</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *cars;</span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *stuff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) addCar: (Car *) car;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Garage</span></span><br></pre></td></tr></table></figure>
<p><em>Garage.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Garage.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Garage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) addCar: (Car *) car &#123;</span><br><span class="line">	<span class="keyword">if</span> (cars == <span class="literal">nil</span>) &#123;</span><br><span class="line">		cars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">	[cars addObject: car];</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// addCar</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	[name release];</span><br><span class="line">	[cars release];</span><br><span class="line">	[stuff release];</span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print &#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@:"</span>, name);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Car *car <span class="keyword">in</span> cars) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"    %@"</span>, car);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setValue: (<span class="keyword">id</span>) value  forUndefinedKey: (<span class="built_in">NSString</span> *) key &#123;</span><br><span class="line">	<span class="keyword">if</span> (stuff == <span class="literal">nil</span>) &#123;</span><br><span class="line">		stuff = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">	[stuff setValue: value forKey: key];</span><br><span class="line">&#125; <span class="comment">// setValueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">	<span class="keyword">id</span> value = [stuff valueForKey: key];</span><br><span class="line">	<span class="keyword">return</span> (value);</span><br><span class="line">&#125; <span class="comment">// valueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span>  <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"><span class="comment">// 创建一些汽车实例</span></span><br><span class="line">Car *car;</span><br><span class="line">car = makeCar(<span class="string">@"Herbie"</span>, <span class="string">@"Honda"</span>, <span class="string">@"CRX"</span>, <span class="number">1984</span>, <span class="number">2</span>, <span class="number">110000</span>, <span class="number">58</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Badger"</span>, <span class="string">@"Acura"</span>, <span class="string">@"integra"</span>, <span class="number">1987</span>, <span class="number">5</span>, <span class="number">217036</span>, <span class="number">130</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Elvis"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Legend"</span>, <span class="number">1989</span>, <span class="number">4</span>, <span class="number">28123.4</span>, <span class="number">151</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Phoenix"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Firebird"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">85128.3</span>, <span class="number">345</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察汽车集合</span></span><br><span class="line">[garage print];</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-快速运算"><a href="#18-4-2-快速运算" class="headerlink" title="18.4.2    快速运算"></a>18.4.2    快速运算</h3><blockquote>
<p><strong>说明：</strong><code>键路径</code>中可以使用进行引用一些运算符进行一些运算，比如</p>
<ul>
<li><strong>prevProperty.<code>@count</code>：</strong>计算 <strong>prevProperty</strong> 包含的对象的总数</li>
<li><strong>prevProperty.<code>@sum</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的总和</li>
<li><strong>prevProperty.<code>@avg</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的平均值</li>
<li><strong>prevProperty.<code>@max</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的最大值</li>
<li><strong>prevProperty.<code>@min</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的最小值</li>
<li><strong>prevProperty.<code>@distinctUnionOfObjects</code>.nextProperty：</strong>获得从<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性构成的集合去重后的集合</li>
</ul>
<p><strong>注意：</strong>不要滥用<code>KVC</code>通过<code>键路径</code>提供的处理集合类的<code>快速运算</code>特性，因为</p>
<ul>
<li>速度比较慢</li>
<li>编译器无法对它进行错误检查（出现运行时错误时才能发觉）</li>
</ul>
<p><strong>限制：</strong>无法添加自定义的运算符</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// @count</span></span><br><span class="line"><span class="built_in">NSNumber</span> *count = [garage valueForKeyPath:<span class="string">@"cars.@count"</span>];</span><br><span class="line"><span class="comment">// @sum</span></span><br><span class="line"><span class="built_in">NSNumber</span> *sum = [garage valueForKeyPath:<span class="string">@"cars.@sum.mileage"</span>];</span><br><span class="line"><span class="comment">// @avg</span></span><br><span class="line"><span class="built_in">NSNumber</span> *avgMileage = [garage valueForKeyPath:<span class="string">@"cars.@avg.mileage"</span>];</span><br><span class="line"><span class="comment">// @max、 @min</span></span><br><span class="line"><span class="built_in">NSNumber</span> *min, *max;</span><br><span class="line">max = [garage valueForKeyPath:<span class="string">@"cars.@max.mileage"</span>];</span><br><span class="line">min = [garage valueForKeyPath:<span class="string">@"cars.@max.mileage"</span>];</span><br><span class="line"><span class="comment">// @distinctUnionOfObjects</span></span><br><span class="line"><span class="built_in">NSArray</span> *manufacture = [garage valueForKeyPath:<span class="string">@"cars.@distinctUnionOfObjects.make"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="18-5-批处理"><a href="#18-5-批处理" class="headerlink" title="18.5    批处理"></a>18.5    批处理</h2><blockquote>
<p><strong>说明：</strong><code>KVC</code>提供了对对象进行批量操作的方式。</p>
</blockquote>
<h3 id="setValuesForKeysWithDictionary实例方法"><a href="#setValuesForKeysWithDictionary实例方法" class="headerlink" title="setValuesForKeysWithDictionary实例方法"></a>setValuesForKeysWithDictionary实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>字典</code>对对象进行批量<code>set</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSDictionary&lt;NSString *, id&gt; *&#125; keyedValues 包含一系列属性名和值的字典</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>
<h3 id="dictionaryWithValuesForKeys实例方法"><a href="#dictionaryWithValuesForKeys实例方法" class="headerlink" title="dictionaryWithValuesForKeys实例方法"></a>dictionaryWithValuesForKeys实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>数组</code>对对象进行批量<code>set</code><br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSArray&lt;NSString *&gt; *&#125; keys 包含要获取的属性的属性名</span><br><span class="line">* @return &#123;NSDictionary&lt;NSString *, id&gt; *&#125; 包含要获取的属性名/属性值对的字典</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取汽车集合中的最后一个汽车实例</span></span><br><span class="line">car = [[garage valueForKeyPath:<span class="string">@"cars"</span>] lastObject];</span><br><span class="line"><span class="comment">// 创建一个数组：包含创建字典需要的键集合</span></span><br><span class="line"><span class="built_in">NSArray</span> *keys = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"make"</span>, <span class="string">@"model"</span>, <span class="string">@"modelYear"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 批量get：利用上一步创建的包含一系列键的数组</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *carValues = [car dictionaryWithValuesForKeys:keys];</span><br><span class="line"><span class="comment">// 创建字典：用于初始化汽车实例的属性</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *newValues = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                           <span class="string">@"Chevy"</span>, <span class="string">@"make"</span>,</span><br><span class="line">                           <span class="string">@"Nova"</span>,<span class="string">@"model"</span>,</span><br><span class="line">                           [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1964</span>], <span class="string">@"modelYear"</span>,</span><br><span class="line">                           [<span class="built_in">NSNull</span> null], <span class="string">@"mileage"</span>,</span><br><span class="line">                           <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 批量set汽车</span></span><br><span class="line">[car setValuesForKeysWithDictionary:newValues];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"car with new values is %@"</span>, car);</span><br></pre></td></tr></table></figure>
<h2 id="18-6-nil-仍然可用"><a href="#18-6-nil-仍然可用" class="headerlink" title="18.6    nil 仍然可用"></a>18.6    nil 仍然可用</h2><blockquote>
<p><strong>背景：</strong>默认情况下，应用<code>KVC</code>调用<code>setValue:forKey</code>设置某个属性的值为<code>nil</code>时，编译器会给出警告。<br><strong>解决：</strong>可以通过重写<code>setNilValueForKey</code>方法给出有意义个返回值而避免警告。<br><strong>扩展：</strong>这里的 <code>nil</code>是标量<code>nil</code>，不要和<code>[NSNull null]</code>相混淆</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setNilValueForKey: (<span class="built_in">NSString</span> *) key &#123;</span><br><span class="line">	<span class="keyword">if</span> ([key isEqualToString: <span class="string">@"mileage"</span>]) &#123;</span><br><span class="line">		mileage = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		[<span class="keyword">super</span> setNilValueForKey: key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">// setNilValueForKey</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会将 mileage 设置为 0</span></span><br><span class="line">[car setValue: <span class="literal">nil</span> forKey: <span class="string">@"mileage"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="18-7-处理未定义键"><a href="#18-7-处理未定义键" class="headerlink" title="18.7    处理未定义键"></a>18.7    处理未定义键</h2><blockquote>
<p><strong>背景：</strong>如果<code>KVC</code>机制无法找到处理方法，会退回并询问该如何处理。默认的实现会取消操作。<br><strong>解决：</strong>通过重写<code>setValue:forUndefinedKey</code>和<code>valueForUndefinedKey</code>更改默认行为，使对象可以设置和获取任何键。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  @override</span><br><span class="line"> *  处理通过 KVC 设置不存在的属性的值</span><br><span class="line"> *</span><br><span class="line"> *  @param value 要设置的值</span><br><span class="line"> *  @param key   要设置的属性名</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setValue:(<span class="keyword">id</span>)value forUndefinedKey: (<span class="built_in">NSString</span> *) key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 惰性初始化</span></span><br><span class="line">    <span class="keyword">if</span> (stuff == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stuff = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    [stuff setValue:value forKey:key];</span><br><span class="line">&#125;<span class="comment">// setValueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @override</span><br><span class="line"> *  处理通过 KVC 方式获取不存在的属性的值</span><br><span class="line"> *</span><br><span class="line"> *  @param key 属性名</span><br><span class="line"> *</span><br><span class="line"> *  @return 试图获取不存在的属性的值时的返回值</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) valueForUndefinedKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> value = [stuff valueForKey:key];</span><br><span class="line">    <span class="keyword">return</span> (value);</span><br><span class="line">&#125;<span class="comment">// valueForUnderfinedKey</span></span><br></pre></td></tr></table></figure>
<h2 id="18-8-小结"><a href="#18-8-小结" class="headerlink" title="18.8    小结"></a>18.8    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_17 文件的加载于保存/" itemprop="url">
                  17 文件的加载与保存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:12+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_17 文件的加载于保存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_17 文件的加载于保存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-属性列表"><a href="#17-1-属性列表" class="headerlink" title="17.1    属性列表"></a>17.1    属性列表</h2><h3 id="17-1-1-NSDate"><a href="#17-1-1-NSDate" class="headerlink" title="17.1.1    NSDate"></a>17.1.1    NSDate</h3><h4 id="date类方法"><a href="#date类方法" class="headerlink" title="date类方法"></a>date类方法</h4><blockquote>
<p><strong>说明：</strong>获取当前日期和时间。<br><strong>原型：</strong><code>NSDate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;instancetype&#125; NSDate类实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)date;</span><br></pre></td></tr></table></figure>
<h4 id="dateWithTimeIntervalSinceNow类方法"><a href="#dateWithTimeIntervalSinceNow类方法" class="headerlink" title="dateWithTimeIntervalSinceNow类方法"></a>dateWithTimeIntervalSinceNow类方法</h4><blockquote>
<p><strong>说明：</strong>获取与当前时间相隔一定时差的日期<br><strong>原型：</strong><code>NSDate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@return &#123;instancetype&#125; NSDate实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)dateWithTimeIntervalSinceNow:(<span class="built_in">NSTimeInterval</span>)secs;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的日期和时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"today is %@"</span>, date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取24小时之前的时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *yesterday = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-(<span class="number">24</span>* <span class="number">60</span> *<span class="number">60</span>)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"yesterday is %@"</span>, yesterday);</span><br></pre></td></tr></table></figure>
<h3 id="17-1-2-NSData"><a href="#17-1-2-NSData" class="headerlink" title="17.1.2    NSData"></a>17.1.2    NSData</h3><blockquote>
<p><strong>说明：</strong>该类可以包含大量的字节，可以获得数据的长度和指向字节启示位置的指针<br><strong>用途：</strong>如果想将数据块传递给一个函数或方法，可以通过传递一个<code>NSData</code>来实现。<br>注意：<code>NSData</code>是一个对象，支持<code>自动释放</code>的，常规的内存管理对它是有效的，因而无需担心内存清理的问题。</p>
</blockquote>
<h4 id="dataWithBytes类方法"><a href="#dataWithBytes类方法" class="headerlink" title="dataWithBytes类方法"></a>dataWithBytes类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个保存一个普通C字符串（一个字节序列）的<code>NSData</code>对象。<br><strong>原型：</strong><code>NSData</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;nullable const void *&#125; bytes 字符串</span><br><span class="line">* @param &#123;NSUInteger&#125; length 字符串的长度（包括尾部的`\0`）</span><br><span class="line">* @return &#123;instancetype&#125; NSData实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)dataWithBytes:(nullable <span class="keyword">const</span> <span class="keyword">void</span> *)bytes length:(<span class="built_in">NSUInteger</span>)length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong><code>NSData</code>是不可变的，创建后不能改变其中的内容来；<code>NSMutableData</code>是可变的，可以在数据中添加和删除字节。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 语言字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="string">"hi there, this is a C string!"</span>;</span><br><span class="line"><span class="comment">// 创建 NSData 对象</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:string length:strlen(string) + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 操作 NSData 对象</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"data is %@"</span>, data);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld byte string is '%s'"</span>, [data length], [data bytes]);</span><br></pre></td></tr></table></figure>
<h3 id="17-1-3-写入和读取属性列表"><a href="#17-1-3-写入和读取属性列表" class="headerlink" title="17.1.3    写入和读取属性列表"></a>17.1.3    写入和读取属性列表</h3><blockquote>
<p><strong>说明：</strong>属性列表类可以存储到文件中，也可以从文件中读取出来。此外，<code>Xcode</code>包含一个属性列表编辑器，可以用来方便地查看<code>plist</code>文件。<br><strong>注意：</strong>如果出现问题，下面介绍的函数都不会返回具体的错误的原因。</p>
</blockquote>
<h4 id="writeToFile实例方法"><a href="#writeToFile实例方法" class="headerlink" title="writeToFile实例方法"></a>writeToFile实例方法</h4><blockquote>
<p><strong>说明：</strong>将属性列表的内容写入到文件。<br><strong>技巧：</strong>应尽量使用<code>atomically</code>的方式保存文件，除非保存的文件容量非常大，会占用用户大量的磁盘空间。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; 文件路径</span><br><span class="line">* @param &#123;BOOL&#125;useAuxiliaryFile 是否首先将文件内容保存到临时文件中（防止极端情况下原始文件被破坏）</span><br><span class="line">*/</span></span><br><span class="line">(<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path atomically:(<span class="built_in">BOOL</span>)useAuxiliaryFile;</span><br></pre></td></tr></table></figure>
<h4 id="arrayWithContentsOfFile类方法"><a href="#arrayWithContentsOfFile类方法" class="headerlink" title="arrayWithContentsOfFile类方法"></a>arrayWithContentsOfFile类方法</h4><blockquote>
<p><strong>说明：</strong>读取文件中的数组信息并据此创建数组。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; path 文件路径</span><br><span class="line">* @return &#123;NSArray&#125; 数组实例</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="built_in">NSArray</span>&lt;ObjectType&gt; *)arrayWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 NSArray 实例</span></span><br><span class="line"><span class="built_in">NSArray</span> *phrase;</span><br><span class="line">phrase = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"I"</span>, <span class="string">@"seem"</span>, <span class="string">@"to"</span>, <span class="string">@"be"</span>, <span class="string">@"a"</span>, <span class="string">@"verb"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 将 NSArray 对象写入文件</span></span><br><span class="line">[phrase writeToFile:<span class="string">@"/tmp/verbiage.txt"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 通过文件创建 NSArray 实例</span></span><br><span class="line"><span class="built_in">NSArray</span> *phrase2 = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:<span class="string">@"/tmp/veribage.txt"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, phrase2);</span><br></pre></td></tr></table></figure>
<p><em>/tmp/verbiage.txt</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>I<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>seem<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>to<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>be<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>a<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>verb<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="17-1-4-修改对象类型"><a href="#17-1-4-修改对象类型" class="headerlink" title="17.1.4    修改对象类型"></a>17.1.4    修改对象类型</h3><blockquote>
<p><strong>说明：</strong>存储或加载属性列表时可以使用<code>NSPropertyListSerialization</code>添加一些设定项。</p>
</blockquote>
<h4 id="dataFromPropertyList类方法"><a href="#dataFromPropertyList类方法" class="headerlink" title="dataFromPropertyList类方法"></a>dataFromPropertyList类方法</h4><blockquote>
<p><strong>说明：</strong>存储到文件时指定设定项。已过时。<br><strong>原型：</strong><code>NSPropertyListSerialization</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; plist 属性列表类型对象</span><br><span class="line">* @param &#123;NSPropertyListFormat&#125; format 存储属性列表的方式</span><br><span class="line">* @param &#123;NSString *&#125; errorDescription 错误信息</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="built_in">NSData</span> *)dataFromPropertyList:(<span class="keyword">id</span>)plist format:(<span class="built_in">NSPropertyListFormat</span>)format errorDescription:(<span class="keyword">out</span> __<span class="keyword">strong</span> <span class="built_in">NSString</span> * __nullable * __nullable)errorString <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_0, <span class="number">10</span>_10, <span class="number">2</span>_0, <span class="number">8</span>_0, <span class="string">"Use dataWithPropertyList:format:options:error: instead."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变数组(首都集合)</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *capitols = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 第一个国家</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *capitol = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="string">@"Canada"</span> forKey:<span class="string">@"country"</span>];</span><br><span class="line">[capitol setObject:<span class="string">@"Ottawa"</span> forKey:<span class="string">@"capitol"</span>];</span><br><span class="line">[capitols addObject:capitol];</span><br><span class="line"><span class="comment">// 第二个国家</span></span><br><span class="line">capitol = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="string">@"Norway"</span> forKey:<span class="string">@"country"</span>];</span><br><span class="line">[capitol setObject:<span class="string">@"Oslo"</span> forKey:<span class="string">@"capitol"</span>];</span><br><span class="line">[capitols addObject:capitol];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 将 plist 数据内容以二进制形式写入文件</span></span><br><span class="line"><span class="built_in">NSData</span> *encodeArray = [<span class="built_in">NSPropertyListSerialization</span> dataFromPropertyList:capitols format:<span class="built_in">NSPropertyListXMLFormat_v1_0</span> errorDescription:&amp;error];</span><br><span class="line">[encodeArray writeToFile:<span class="string">@"/tmp/capitols.txt"</span> atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<h4 id="propertyListFromData实例方法"><a href="#propertyListFromData实例方法" class="headerlink" title="propertyListFromData实例方法"></a>propertyListFromData实例方法</h4><blockquote>
<p><strong>说明：</strong>以指定形式将文件读取到内存。<br><strong>原型：</strong><code>NSPropertyListSerialization</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSData *&#125; data 从文件读取原始数据</span><br><span class="line">* @param &#123;NSPropertyListMutabilityOptions&#125; opt format 读取形式</span><br><span class="line">* @param &#123;NSString *&#125; errorString 可能的错误信息</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="keyword">id</span>)propertyListFromData:(<span class="built_in">NSData</span> *)data mutabilityOption:(<span class="built_in">NSPropertyListMutabilityOptions</span>)opt format:(nullable <span class="built_in">NSPropertyListFormat</span> *)format errorDescription:(<span class="keyword">out</span> __<span class="keyword">strong</span> <span class="built_in">NSString</span> * __nullable * __nullable)errorString <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_0, <span class="number">10</span>_10, <span class="number">2</span>_0, <span class="number">8</span>_0, <span class="string">"Use propertyListWithData:options:format:error: instead."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件中读取属性列表数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/tmp/capitols.txt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定的格式将文件中的内容读取到内存</span></span><br><span class="line"><span class="built_in">NSPropertyListFormat</span> properyListFormat = <span class="built_in">NSPropertyListXMLFormat_v1_0</span>;</span><br><span class="line"><span class="built_in">NSString</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *capitols = [<span class="built_in">NSPropertyListSerialization</span> propertyListFromData:data mutabilityOption:<span class="built_in">NSPropertyListMutableContainersAndLeaves</span> format:&amp;properyListFormat errorDescription:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"capitols %@"</span>, capitols);</span><br></pre></td></tr></table></figure>
<h2 id="17-2-编码对象"><a href="#17-2-编码对象" class="headerlink" title="17.2    编码对象"></a>17.2    编码对象</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>具备一种将任意对象转换成某种格式并保存到磁盘中的机制。</p>
<ul>
<li><strong>序列化（编码）：</strong>将对象的实例变量和其他数据编码为数据块，然后保存到磁盘</li>
<li><strong>反序列化（解码）：</strong>将数据块读回内存，并基于保存的数据创建新对象</li>
</ul>
</blockquote>
<h3 id="NSCoding协议"><a href="#NSCoding协议" class="headerlink" title="NSCoding协议"></a>NSCoding协议</h3><blockquote>
<p><strong>说明：</strong>通过采纳该协议，可以使对象具备<code>序列化和反序列化</code>的能力。<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCoding</span></span></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) encoder;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder;</span><br><span class="line">&gt;<span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="archiveDataWithRootObject类方法"><a href="#archiveDataWithRootObject类方法" class="headerlink" title="archiveDataWithRootObject类方法"></a>archiveDataWithRootObject类方法</h3><blockquote>
<p><strong>说明：</strong>对对象进行编码。</p>
<ol>
<li>创建了一个<code>KSKeyedArchier</code>实例</li>
<li>将上一步创建的实例传递给参数指定的对象的<code>encodeWithCoder</code>方法</li>
<li>递归编码自身使用到的其它对象，比如字符串、数组及放入数组中的任何对象</li>
<li>所有对象完成键值编码后，被放入一个<code>NSData</code>对象并返回</li>
</ol>
<p><strong>原型：</strong><code>KSKeyedArchiver</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; rootObject 要被序列化的对象</span><br><span class="line">* @return &#123;NSData *&#125; 序列化为 NSData 型数据</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)archivedDataWithRootObject:(<span class="keyword">id</span>)rootObject;</span><br></pre></td></tr></table></figure>
<p><em>Thingie.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Thingie</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    <span class="keyword">int</span> magicNumber;</span><br><span class="line">    <span class="keyword">float</span> shoeSize;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *subThingies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> magicNumber;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> shoeSize;</span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSMutableArray</span> *subThingies;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithName: (<span class="built_in">NSString</span> *) n</span><br><span class="line">        magicNumber: (<span class="keyword">int</span>) mn</span><br><span class="line">           shoeSize: (<span class="keyword">float</span>) ss;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Thingie.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Thingie.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Thingie</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"><span class="keyword">@synthesize</span> magicNumber;</span><br><span class="line"><span class="keyword">@synthesize</span> shoeSize;</span><br><span class="line"><span class="keyword">@synthesize</span> subThingies;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 便利构造函数：通过用户名</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithName:(<span class="built_in">NSString</span> *)</span><br><span class="line">        magicNumber:(<span class="keyword">int</span>)mn</span><br><span class="line">        shoeSize:(<span class="keyword">float</span>)ss</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = n;</span><br><span class="line">        <span class="keyword">self</span>.magicNumber = mn;</span><br><span class="line">        <span class="keyword">self</span>.showSize = ss;</span><br><span class="line">        <span class="keyword">self</span>.subThingies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采纳协议:反序列化</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [decoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">        <span class="keyword">self</span>.magicNumber = [decoder decodeIntForKey:<span class="string">@"magicNumber"</span>];</span><br><span class="line">        <span class="keyword">self</span>.shoeSize = [decoder decodeIntForKey:<span class="string">@"shoeSize"</span>];</span><br><span class="line">        <span class="keyword">self</span>.subThingies = [decoder decodeObjectForKey:<span class="string">@"subThingies"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采纳协议：序列化</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) coder</span><br><span class="line">&#123;</span><br><span class="line">    [coder encodeObject:name</span><br><span class="line">                 forKey:<span class="string">@"name"</span>];</span><br><span class="line">    [coder encodeInt:magicNumber</span><br><span class="line">              forKey:<span class="string">@"magicNumber"</span>];</span><br><span class="line">    [coder encodeFloat:shoeSize</span><br><span class="line">                forKey:<span class="string">@"shoeSize"</span>];</span><br><span class="line">    [coder encodeObject:subThingies</span><br><span class="line">                 forKey:<span class="string">@"subThingies"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@: %d/%.1f %@"</span>, name, magicNumber, shoeSize, subThingies];</span><br><span class="line">    <span class="keyword">return</span> (description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [name release];</span><br><span class="line">    [subThingies release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Thingie.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">/** 简单情形 **/</span></span><br><span class="line">        <span class="comment">// 创建可序列化的对象</span></span><br><span class="line">        Thingie *thing1;</span><br><span class="line">        thing1 = [[Thingie alloc]</span><br><span class="line">                  initWithName:<span class="string">@"thing1"</span></span><br><span class="line">                  magicNumber:<span class="number">42</span></span><br><span class="line">                  shoeSize:<span class="number">10.5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"some thing: @"</span>, thing1);</span><br><span class="line">        <span class="comment">// 序列化为 NSData 对象</span></span><br><span class="line">        <span class="built_in">NSData</span> *freezeDried;</span><br><span class="line">        freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        [thing1 release];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued thing: %@"</span>, thing1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 复杂情形：递归序列化 */</span></span><br><span class="line">        <span class="comment">// 初始化thing1.subThingies（数组）</span></span><br><span class="line">        Thingie *anotherThing;</span><br><span class="line">        anotherThing = [[[Thingle alloc]</span><br><span class="line">                         initWithName:<span class="string">@"thing2"</span></span><br><span class="line">                         magicNumber:<span class="number">23</span> shoeSize:<span class="number">13.0</span>]];</span><br><span class="line">        [thing1.subThingies addObject:anotherThing];</span><br><span class="line">        anotherThing = [[[Thingle alloc]</span><br><span class="line">                         initWithName:<span class="string">@"thing3"</span></span><br><span class="line">                         magicNumber:<span class="number">17</span> shoeSize:<span class="number">9.0</span>]];</span><br><span class="line">        [thing1.subThingies addObject:anotherThing];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued muthing: %@"</span>, thing1);</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        [freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued multiting: %@"</span>, thing1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 复杂情形：设置一处引用自己的数据，序列化和反序列化仍能正常工作 */</span></span><br><span class="line">        [thing1.subThingies addObject:thing1];</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-小结"><a href="#17-3-小结" class="headerlink" title="17.3    小结"></a>17.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_16 UIKit简介/" itemprop="url">
                  16 UIKit简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:48+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_16 UIKit简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_16 UIKit简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Mac</code>应用程序使用的是<code>AppKit</code>框架，而<code>iOS</code>应用程序使用的是<code>UIKit</code>框架，它包含了所有的<code>UI</code>组件和构成<code>iOS</code>应用程序的资源。<br><strong>注意：</strong><code>iOS</code>和<code>OS X</code>存在以下区别</p>
<ul>
<li>没有<code>shell</code>和控制台</li>
<li>应用程序在<code>Mac</code>电脑的模拟器中运行</li>
<li>无法支持一些无<code>UI</code>界面的<code>API</code></li>
<li>大部分程序员都认为开发<code>iOS</code>应用更加轻松</li>
</ul>
<p><strong>项目创建：</strong>步骤如下</p>
<ol>
<li><code>File-&gt;New-&gt;New Project</code>(command + shift + n)</li>
<li>选择应用程序模版：左边列表选择<code>iOS</code>下的<code>Application</code>，然后右边选择<code>Single View Application</code></li>
</ol>
<ul>
<li><code>Master-Detail</code>：用一个导航控制器和一个表视图来显示项目列表遗迹项目的详细信息</li>
<li><code>OpenGL Game</code>：游戏</li>
<li><code>Page-Based</code>：创建电子书式的应用，拥有翻页动画效果（该效果支持ipad）</li>
<li><code>Tabbed</code>：多视图应用程序，底部又一个标签栏并且每个标签都有一个视图香关联的那种应用程序</li>
<li><code>Utility</code>：和<code>Single View Application</code>相似，但还多处一个翻转视图</li>
<li><code>Empty</code>：是一个高级选项，如果没有合适的模版，或是你非常了解如何构建你的应用程序，那么刻意选择使用这个模版</li>
</ul>
<ol>
<li>点击<code>Next</code>按钮，弹出询问程序名等信息的对话框</li>
</ol>
<ul>
<li>复选框：不选择<code>Use Storyboard</code>和<code>Include Unit Tests</code>，选中<code>Use Automatic Reference Counting</code></li>
<li><code>Device Family</code>：选择<code>Universal</code>（意味着可以同时运行在<code>iPhone</code>、<code>iPod</code>、<code>iPad</code>上）</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%8811.15.54.png" alt="Alt text"></p>
<p><em>AppDelegate.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">ViewController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"><span class="comment">// 视图控制器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ViewController *viewController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>AppDelegate.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> window = _window;</span><br><span class="line"><span class="keyword">@synthesize</span> viewController = _viewController;</span><br><span class="line"><span class="comment">// 窗口被创建时回被调用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">/* 初始化窗口对象 */</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始视图控制器 */</span></span><br><span class="line">    <span class="comment">// iPhone</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice] userInterfaceIdiom] == <span class="built_in">UIUserInterfaceIdiomPhone</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController_iPhone"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// iPad</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController_iPad"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将视图控制器的视图添加到应用程序层级</span></span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.viewController;</span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span></span><br><span class="line">    <span class="comment">// Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span></span><br><span class="line">    <span class="comment">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="16-1-视图控制器"><a href="#16-1-视图控制器" class="headerlink" title="16.1    视图控制器"></a>16.1    视图控制器</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>主要使用的是<code>MVC</code>模式</p>
<ul>
<li><strong>视图：</strong>从<code>nib</code>文件中获取视图</li>
<li><strong>模型：</strong>一组数据</li>
<li><strong>控制器：</strong><code>UIViewController</code>的子类</li>
</ul>
</blockquote>
<h3 id="16-1-1-在Nib文件中添加控件"><a href="#16-1-1-在Nib文件中添加控件" class="headerlink" title="16.1.1    在Nib文件中添加控件"></a>16.1.1    在Nib文件中添加控件</h3><blockquote>
<p><strong>说明：</strong>完成视图的部分</p>
<ul>
<li>拖进一个<code>TextField</code>对象</li>
<li>拖进一个<code>Label</code></li>
<li>拖进两个<code>Button</code></li>
</ul>
</blockquote>
<p><img src="./屏幕快照 2016-01-26 下午10.07.01.png" alt="Alt text"></p>
<h3 id="16-1-2-视图（Nib文件）和控制器建立连接"><a href="#16-1-2-视图（Nib文件）和控制器建立连接" class="headerlink" title="16.1.2    视图（Nib文件）和控制器建立连接"></a>16.1.2    视图（Nib文件）和控制器建立连接</h3><blockquote>
<p><strong>说明：</strong>打开辅助窗口，通过拖拽完成<code>视图</code>(<code>Nib</code>文件)和<code>控制器</code>(<code>ViewController.h</code>)之间的连接。</p>
<ol>
<li>代开辅助窗口：<code>Command+Option+Return</code>或<code>Editor</code>组中间的按钮</li>
<li>为<code>Text Field</code>和<code>Label</code>创建输出口（<code>outlet</code>）：按住<code>control</code>键，将鼠标从视图中的图像元素一直拖到<code>ViewController.h</code>相应位置<br><img src="./屏幕快照 2016-01-26 下午10.01.24 2.png" alt="Alt text"><br><img src="./屏幕快照 2016-01-26 下午10.01.30 2.png" alt="Alt text"></li>
<li>为两个按钮创建<code>操作</code>(Action)</li>
</ol>
<ul>
<li>Name：操作的名称</li>
<li>Type：操作方法参数的类型（默认为<code>id</code>）</li>
<li>Event：事件类型</li>
<li>Arguments：<code>None</code>、<code>Sender</code>和<code>Event</code>（包含一个<code>UIEvent</code>类型的参数）<br><img src="./屏幕快照 2016-01-26 下午10.23.36.png" alt="Alt text"></li>
</ul>
</blockquote>
<h3 id="16-1-3-完成代码的手动编写部分"><a href="#16-1-3-完成代码的手动编写部分" class="headerlink" title="16.1.3    完成代码的手动编写部分"></a>16.1.3    完成代码的手动编写部分</h3><blockquote>
<p><strong>说明：</strong>包括程序核心功能的实现以及一些事件的回调。</p>
</blockquote>
<p><em>ViewController.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *textField;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase;</span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ViewController.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> textField;</span><br><span class="line"><span class="keyword">@synthesize</span> resultsField;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  重写父类的便利构造器：完成视图和控制器的绑定</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"init: text %@ / result %@"</span>, textField, resultsField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  系统在nib文件加载和对象初始化完成后调用：从ios 5 不会再调用该方法了</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"awake: text %@ / result %@"</span>, textField, resultsField);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  系统在nib文件加载和对象初始化完成后调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewDidLoad: text %@ / results %@"</span>, textField, resultsField);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置输入框的placeholder(占位符)</span></span><br><span class="line">    [textField setPlaceholder:<span class="string">@"Enter text here"</span>];</span><br><span class="line">    <span class="comment">// 设置Label的默认值</span></span><br><span class="line">    resultsField.text = <span class="string">@"Result"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  视图从视图层级中移除后会调用这个方法，可以在这里做一些内存清理的事情</span><br><span class="line"> *  该方法已过时</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidUnload &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTextField:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> setResultsField:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">super</span> viewDidUnload];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图出现前调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图出现后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图消失前调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图消失后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *original = textField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *uppercase = [original uppercaseString];</span><br><span class="line">    resultsField.text = uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *original = textField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *lowercase = [original lowercaseString];</span><br><span class="line">    resultsField.text = lowercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-小结"><a href="#16-2-小结" class="headerlink" title="16.2    小结"></a>16.2    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_15 AppKit简介/" itemprop="url">
                  15 AppKit简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:28+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_15 AppKit简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_15 AppKit简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Application Kit</code>中包含<code>Cocoa</code>中关于用户界面的大量资源。<br><strong>注意：</strong>学习这一章节时，<code>Xcode</code>的最新版本是<code>7.2</code>，部分知识已经过时。比如目前<code>storyboard</code>已经基本取代了<code>xib</code>。</p>
</blockquote>
<h2 id="15-1-构建项目"><a href="#15-1-构建项目" class="headerlink" title="15.1    构建项目"></a>15.1    构建项目</h2><blockquote>
<p><strong>说明：</strong>下面是通过<code>Xcode</code>构建<code>Cocoa</code>应用程序项目的步骤。</p>
<ol>
<li>File-&gt;New-&gt;New Project（Create a New Xcode Project）</li>
<li>左边列表<code>Mac OS X</code>下的<code>Application</code>选项-&gt;<code>Cocoa Application</code>-&gt;Next</li>
<li>项目信息</li>
</ol>
<ul>
<li><code>Product Name</code>：应用名称</li>
<li><code>Company Identifier</code>：企业标识符，用来区分应用程序</li>
<li><code>Class Prefix</code>：伪命名空间，避免文件名冲突</li>
</ul>
<ol>
<li>复选框</li>
</ol>
<ul>
<li><code>Create Document-Based Application</code></li>
<li><code>Use Core Data</code></li>
<li><code>Include Unit Test</code></li>
<li><code>Use Automatic Reference Counting</code></li>
</ul>
</blockquote>
<h2 id="15-2-创建委托文件-interface部分"><a href="#15-2-创建委托文件-interface部分" class="headerlink" title="15.2    创建委托文件@interface部分"></a>15.2    创建委托文件<code>@interface</code>部分</h2><blockquote>
<p><strong><code>Interface Builder</code>：</strong>简称<code>IB</code>，用可视化的方式为<code>OS X</code>和<code>iOS</code>布局窗口内容，构建用户界面。<br><strong><code>IBOutlet</code>和<code>IBAction</code>：</strong>这两个关键字会经常出现在代码中，用于</p>
<ul>
<li>为<code>Interface Builder</code>提供标记</li>
<li>帮助阅读代码</li>
</ul>
</blockquote>
<h2 id="15-3-Interface-Builder"><a href="#15-3-Interface-Builder" class="headerlink" title="15.3    Interface Builder"></a>15.3    Interface Builder</h2><blockquote>
<p><strong>说明：</strong>通过<code>.xib</code>文件就可以打开<code>IB</code>的可视化编辑器。</p>
<ul>
<li><strong>nib文件：</strong>编译时，<code>.xib</code>(<code>XML</code>格式)文件会被编译为<code>nib(NeXT Interface Builder)</code>文件，它是包含了压缩对象的二进制文件，</li>
<li><strong>对象库：</strong>包含了大量可以拖入窗口的不同类型的对象。</li>
</ul>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-25%20%E4%B8%8B%E5%8D%8810.17.36.png" alt="Alt text"></p>
</blockquote>
<h2 id="15-4-设计用户界面"><a href="#15-4-设计用户界面" class="headerlink" title="15.4    设计用户界面"></a>15.4    设计用户界面</h2><blockquote>
<p><strong>说明：</strong>对用户界面进行布局</p>
<ol>
<li>拖入一个<code>Text Filed</code></li>
<li>拖入一个<code>Label</code></li>
<li>拖入一个<code>push button</code></li>
</ol>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-25%20%E4%B8%8B%E5%8D%8810.42.36.png" alt="Alt text"></p>
<h2 id="15-5-创建连接"><a href="#15-5-创建连接" class="headerlink" title="15.5    创建连接"></a>15.5    创建连接</h2><blockquote>
<p><strong>说明：</strong>将<code>代码</code>与刚创建的<code>用户界面元素</code>相连接。</p>
</blockquote>
<h3 id="15-5-1-连接输出口（IBOutlet）"><a href="#15-5-1-连接输出口（IBOutlet）" class="headerlink" title="15.5.1    连接输出口（IBOutlet）"></a>15.5.1    连接输出口（IBOutlet）</h3><blockquote>
<p><strong>说明：</strong>通过拖动自动生成界面元素对应的代码。以其中的<code>Text Field</code>为例子</p>
<ol>
<li>打开辅助编辑器</li>
<li>按住<code>Control</code>键将光标从<code>文本框</code>拖动到<code>头文件</code>中<code>@property</code>那一行的下面</li>
<li>出现<code>Insert Outlet orAction</code>提示消息时松开鼠标</li>
<li>在弹出的对话框中输入<code>textField</code>，点击<code>Connect</code></li>
</ol>
</blockquote>
<h3 id="15-5-2-连接操作（IBAction）"><a href="#15-5-2-连接操作（IBAction）" class="headerlink" title="15.5.2    连接操作（IBAction）"></a>15.5.2    连接操作（IBAction）</h3><blockquote>
<p><strong>说明：</strong>将按钮连接到操作，这样按下按钮就会触发代码。以<code>UpperCae</code>按钮为例</p>
<ol>
<li>按住<code>Control</code>键和<code>UpperCase</code>按钮</li>
<li>拖动一条直线到<code>头文件</code>的最后一行<code>@property</code>语句下</li>
<li>弹出连接对话框，选择<code>Action</code>类型</li>
<li>在Name文本框中输入<code>uppercase</code>，并点击<code>Connect</code>(自动在头文件中创建方法的声明，并在实现文件中创建方法的实现)</li>
</ol>
</blockquote>
<h2 id="15-6-应用程序委托的实现"><a href="#15-6-应用程序委托的实现" class="headerlink" title="15.6    应用程序委托的实现"></a>15.6    应用程序委托的实现</h2><blockquote>
<p><strong>说明：</strong><code>IBOutlet</code>的工作方式</p>
<ol>
<li>应用程序启动时，<code>MainMenu.nib</code>被自动加载，界面对象被创建</li>
<li>分配并初始化<code>MSCApplelegate</code>实例（<code>IBOutlet</code>的实例变量）</li>
<li>建立连接：将<code>NSTextField</code>等对象的地址添加到<code>MSCAppDelegate</code>实例变量中，然后像每个每个<code>界面对象</code>发送<code>awakeFromNib</code>消息。</li>
</ol>
</blockquote>
<p><em>MSCAppDelegate.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MSCAppDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSWindow</span> *window;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *textField;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase:(<span class="keyword">id</span>)sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase:(<span class="keyword">id</span>)sender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>MSCAppDelegate.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MSCAppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MSCAppDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> window = _window;</span><br><span class="line"><span class="keyword">@synthesize</span> textField = _textField;</span><br><span class="line"><span class="keyword">@synthesize</span> resultsField = _resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="comment">// 此时还没和界面对象建立连接，因此都是 nil</span></span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"init: text %@ / results %@"</span>, _textField, _resultsField);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 对界面对象进行一些初始化工作</span><br><span class="line"> * 连接建立后会被调用</span><br><span class="line"> *  @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"awake: text %@ / results %@"</span>, _textField, _resultsField);</span><br><span class="line">	</span><br><span class="line">	[_textField setStringValue:<span class="string">@"Enter text here"</span>];</span><br><span class="line">	[_resultsField setStringValue:<span class="string">@"Results"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">NSNotification</span> *)aNotification &#123;</span><br><span class="line">    <span class="comment">// Insert code here to initialize your application</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *original = [_textField stringValue];</span><br><span class="line">	<span class="built_in">NSString</span> *uppercase = [original uppercaseString];</span><br><span class="line">	[_resultsField setStringValue:uppercase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *original = [_textField stringValue];</span><br><span class="line">	<span class="built_in">NSString</span> *lowercase = [original lowercaseString];</span><br><span class="line">	[_resultsField setStringValue:lowercase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="15-7-小结"><a href="#15-7-小结" class="headerlink" title="15.7    小结"></a>15.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_14 代码块和并发性/" itemprop="url">
                  14 代码块和并发行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:10+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_14 代码块和并发性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_14 代码块和并发性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="14-1-代码块"><a href="#14-1-代码块" class="headerlink" title="14.1    代码块"></a>14.1    代码块</h2><blockquote>
<p><strong>说明：</strong><code>代码块</code>是由C语言实现的，是对C语言中函数的扩展。<br><strong>支持的语言：</strong><code>Objective-C</code>、<code>C</code> 、<code>C++</code>、<code>Objective-C++</code><br><strong>用途：</strong><code>替代函数</code>或实现<code>闭包</code><br><strong>现状：</strong><code>代码块</code>在<code>Xcode</code>的<code>GCC</code>和<code>CLang</code>工具中是有效的，但它不属于<code>ANSI</code>的<code>C</code>语言标准。关于代码块的提议已经提交给C语言标准团体。</p>
</blockquote>
<h3 id="14-1-1-代码块和函数指针"><a href="#14-1-1-代码块和函数指针" class="headerlink" title="14.1.1    代码块和函数指针"></a>14.1.1    代码块和函数指针</h3><blockquote>
<p><strong>说明：</strong><code>代码块</code>的语法借鉴了<code>函数指针</code></p>
<ul>
<li><strong>返回类型</strong>可以手动声明也可以由编译器通过代码块推导</li>
<li>具有指定类型的<strong>参数</strong>列表</li>
<li>拥有<strong>名称</strong></li>
<li>代码放在<code>{}</code>中</li>
</ul>
<p><strong>语法：</strong><code>&lt;returntype&gt; (^blockname)(list of arguments) = ^(arguments){body;}</code><br><em>实现部分推导出返回值类型</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现部分省略了返回值类型，没有参数列表</span></span><br><span class="line"><span class="keyword">void</span> (^theBlock)() = ^&#123;</span><br><span class="line">	printf(<span class="string">"Hello Blocks!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定义并实现代码块 square_block</span><br><span class="line">* 计算乘方</span><br><span class="line">* @param &#123;int&#125; number 数值</span><br><span class="line">* @return &#123;int&#125; number 乘方结果</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> (^square_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="keyword">return</span> (number * number);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="keyword">int</span> result = square_block(<span class="number">5</span>);</span><br><span class="line">printf(<span class="string">"Result = %d\n"</span>, result);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-1-通过代码块名调用代码块"><a href="#14-1-1-1-通过代码块名调用代码块" class="headerlink" title="14.1.1.1    通过代码块名调用代码块"></a>14.1.1.1    通过代码块名调用代码块</h4><blockquote>
<p><strong>说明：</strong>可以像调用<code>函数</code>一样调用<code>代码块</code>。<br><strong>比函数强大：</strong>代码块可以访问与它相同的有效范围内声明的变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化变量：声明时的作用域和代码块相同</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">int</span> (^multiply_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="comment">// 访问外部同作用域声明的变量</span></span><br><span class="line">	<span class="keyword">return</span> (value * number);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-2-直接调用代码块（匿名）"><a href="#14-1-1-2-直接调用代码块（匿名）" class="headerlink" title="14.1.1.2    直接调用代码块（匿名）"></a>14.1.1.2    直接调用代码块（匿名）</h4><blockquote>
<p><strong>说明：</strong>使用代码块时通常不需要创建一个代码块变量，而是在代码中内联代码块的内容。<br><strong>使用场景：</strong>作为参数传递给方法或函数</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Amir"</span>, <span class="string">@"Mishal"</span>, <span class="string">@"Irrum"</span>, <span class="string">@"Adam"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Unsorted Array %@"</span>, array);</span><br><span class="line"><span class="comment">// 传递匿名代码块</span></span><br><span class="line"><span class="built_in">NSArray</span> *soredArray = [array sortedArrayUsingComparator: ^(<span class="built_in">NSString</span> *object1, <span class="built_in">NSString</span> *object2)] &#123;</span><br><span class="line">	<span class="keyword">return</span> [object1 compare: object2];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Sorted Array %@"</span>, sortedArray);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-3-使用typedef关键字"><a href="#14-1-1-3-使用typedef关键字" class="headerlink" title="14.1.1.3    使用typedef关键字"></a>14.1.1.3    使用<code>typedef</code>关键字</h4><blockquote>
<p><strong>说明：</strong>将<code>代码块</code>声明定义为一种类型，更易于代码的编写。<br><strong>语法：</strong><code>typedef 代码块定义;</code><br><strong>注意：</strong><code>typedef</code>后面的<code>代码块</code>定义中的代码块名不再具备<code>代码块名</code>的功能，而是一种类型名。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将代码块定义为一种类型： MKSampleMultiply2BlockRef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 使用新类型创建代码块</span></span><br><span class="line"><span class="built_in">MKSampleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line">printf(<span class="string">"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-4-代码块和变量"><a href="#14-1-1-4-代码块和变量" class="headerlink" title="14.1.1.4    代码块和变量"></a>14.1.1.4    代码块和变量</h4><blockquote>
<p><strong>说明：</strong>代码块被声明后会捕捉到创建时的上下文中的变量或函数。</p>
<ul>
<li>全局变量（包括在封闭范围内声明的本地静态变量）</li>
<li>全局函数</li>
<li>封闭范围内的参数</li>
<li><code>Objective-C</code>的实例变量</li>
<li>代码块内部的本地变量</li>
</ul>
</blockquote>
<h5 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h5><blockquote>
<p><strong>说明：</strong>与代码块在同一范围内声明的变量。<br><strong>捕获情况：</strong>代码块会在定义时把本地变量当作<code>常量</code>复制并保存它们的状态。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiplyBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 本地变量</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 声明并实现代码块，复制并保存状态</span></span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	reutrn a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改本地变量</span></span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">b = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote>
<p><strong>说明：</strong>可以根据需要将变量标记为<code>静态的（全局的）</code>。<br><strong>捕获情况：</strong>同本地变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">MKSimpleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h5><blockquote>
<p><strong>说明：</strong>代码块中的参数变量与函数中的参数变量具有相同的作用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 声明并实现代码块</span></span><br><span class="line"><span class="built_in">MKSimpleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h5 id="block变量"><a href="#block变量" class="headerlink" title="_block变量"></a>_block变量</h5><blockquote>
<p><strong>关键字：</strong><code>_block</code><br><strong>说明：</strong><code>本地变量</code>会被<code>代码块</code>当作<code>常量</code>获取到，如果想要修改它们的值，必须通过<code>_black</code>将它们声明为<code>可修改</code>的。<br><strong>限制：</strong>由两种情况不能使用<code>_block</code>修饰</p>
<ul>
<li>长度可变数组</li>
<li>包含长度可变数组的结构体</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用_block 修饰，使变量 c 在代码块中的副本可修改</span></span><br><span class="line">_block <span class="keyword">double</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">	c = a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="代码块内部的本地变量"><a href="#代码块内部的本地变量" class="headerlink" title="代码块内部的本地变量"></a>代码块内部的本地变量</h5><blockquote>
<p><strong>说明：</strong>对<code>代码块来说</code>，和<code>本地变量</code>一样使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">void</span> (^<span class="built_in">MKSampleBlockRef</span>)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, a * c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">MKSimpleBlockRef</span>();</span><br></pre></td></tr></table></figure>
<h3 id="14-1-2-Objective-C代码块内存管理"><a href="#14-1-2-Objective-C代码块内存管理" class="headerlink" title="14.1.2    Objective-C代码块内存管理"></a>14.1.2    Objective-C代码块内存管理</h3><blockquote>
<p><strong>说明：</strong>代码块是对象，所以可以向它发送任何与内存管理由关的信息。</p>
<ul>
<li>如果引用了一个<code>Objective-C</code>对象，必须要<code>保留</code>它</li>
<li>如果类的方法中的<code>代码块</code>通过引用访问了一个实例变量，要<code>保留</code>一次<code>self</code>（执行所在方法的对象）</li>
<li>如果通过数值访问了一个实例变量，变量需要<code>保留</code></li>
</ul>
</blockquote>
<p><em>ProcessString.h：方法中包含代码块的类</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProcessStrings</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ProcessString.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProcessStrings</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> theString = _theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 代码块1</span></span><br><span class="line">    <span class="built_in">NSString</span> *string1 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则2：直接通过引用（实例变量名）访问了实例变量，若没有ARC则应该保留self</span></span><br><span class="line">        <span class="keyword">return</span> [_theString stringByAppendingString:_theString];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *localObject = _theString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块2</span></span><br><span class="line">    <span class="built_in">NSString</span> *string2 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则3: 通过中间变量间接访问了实例变量，如果没有ARC则要保留localObject</span></span><br><span class="line">        <span class="keyword">return</span> [localObject stringByAppendingString:localObject];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessStrings *myStringProcessor = [[ProcessStrings alloc] init];</span><br><span class="line">        myStringProcessor.theString = <span class="string">@"Hello Objective Blocks!"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用对象中包含代码块的方法</span></span><br><span class="line">        [myStringProcessor testMyString];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>在C语言中，必须使用<code>Block_copy()</code>和<code>Block_release()</code>函数来适当地管理内存。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^<span class="built_in">MKSampleVoidBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block1 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block1"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block1();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block2 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block2"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block2();</span><br><span class="line">        Block_release(block2);</span><br><span class="line">        </span><br><span class="line">        block2 = Block_copy(block1);</span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-2-并发性"><a href="#14-2-并发性" class="headerlink" title="14.2    并发性"></a>14.2    并发性</h2><blockquote>
<p><strong>说明：</strong>能够在同一时间执行多个任务的程序称为<code>并发的(concurrent)</code>程序。苹果公司提供了多种可以利用多核特性的<code>API</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关技术选择</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSIX线程</td>
<td>利用并发行最基础的方法是使用<code>POSIX</code>线程来处理程序的不同部分使其能够独立运行。<code>POSIX线程</code>拥有支持<code>C</code>和<code>Objective-C</code>的API。</td>
<td>因为线程是级别较低的API，必须手动管理，挑战很大</td>
</tr>
<tr>
<td>GDC(Grand Central Dipatch)</td>
<td>运行在系统级别，减少了不少线程管理的麻烦</td>
<td>可以平衡应用程序所有内同的家在，从而提高计算机或设备的运行效率</td>
</tr>
</tbody>
</table>
<h3 id="14-2-1-同步"><a href="#14-2-1-同步" class="headerlink" title="14.2.1    同步"></a>14.2.1    同步</h3><blockquote>
<p><strong>关键字：</strong><code>@synchronized</code><br><strong>说明：</strong>用来设置<code>临界区</code>，确保多个线程不会在同一时间进入<code>临界区</code>。<br><strong>相关：</strong><code>@property</code>指令的<code>atomic</code>特性会让编译器通过插入<code>@synchronize(mutex, atomic)</code>生成强制彼此互斥的<code>getter</code>和<code>setter</code>方法（降低了代码性能），而<code>nonatomic</code>特性（默认）则不会。</p>
</blockquote>
<h4 id="14-2-1-1-选择性能"><a href="#14-2-1-1-选择性能" class="headerlink" title="14.2.1.1    选择性能"></a>14.2.1.1    选择性能</h4><blockquote>
<p><strong>说明：</strong><code>NSObject</code>提供了一些可以使代码在后台以较低性能运行的方法（方法名带有<code>performSelector</code>前缀）</p>
</blockquote>
<h5 id="performSelectorInBackground实例方法"><a href="#performSelectorInBackground实例方法" class="headerlink" title="performSelectorInBackground实例方法"></a>performSelectorInBackground实例方法</h5><blockquote>
<p><strong>说明：</strong>通过创建一个线程，在后端运行一个指定的方法。<br><strong>限制：</strong>指定运行的方法（第一个参数）要遵从以下限制</p>
<ul>
<li>方法中需要<code>@autoreleasepool</code></li>
<li>方法不能有返回值，参数最多一个且必须为<code>id</code>类型</li>
</ul>
<ol>
<li><code>- (void) myMethod;</code></li>
<li><code>- (void) myMethod:(id)myObject;</code></li>
</ol>
<p><strong>原型：</strong><code>NSObject</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;SEL&#125; 希望在后台运行的方法</span><br><span class="line">* @param &#123;id&#125; object 可以传递一个对象</span><br><span class="line">*/</span></span><br><span class="line">(<span class="keyword">void</span>) performSelectorInBackground:(nonnull SEL) withObject:(nullable <span class="keyword">id</span>)&gt;</span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SelectorTester</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SelectorTester.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SelectorTester</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  封装对性能选择器的调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors &#123;</span><br><span class="line">    <span class="comment">// 在后端运行不带参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod1) withObject:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 在后端运行带一个参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod2:) withObject:<span class="string">@"Hello Selector"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Done performing selectors"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：不带参数</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod1 &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：只有一个参数</span><br><span class="line"> *  @param &#123;id&#125; object 一个对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod2: (<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod2 %@"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="14-2-1-2-调度队列"><a href="#14-2-1-2-调度队列" class="headerlink" title="14.2.1.2    调度队列"></a>14.2.1.2    调度队列</h4><blockquote>
<p><strong>说明：</strong><code>GDC</code>可以使用<code>调度队列（dispatch queue）</code>，共有3种。</p>
</blockquote>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>说明</th>
<th>并行／串行</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>连续队列</td>
<td>根据指派的顺序执行任务</td>
<td>串行，先入先出（FIFO，栈）</td>
<td>可以创建多个<code>连续</code>队列，彼此并行</td>
</tr>
<tr>
<td>并发队列</td>
<td>并发执行一个或多个任务</td>
<td>并行，根据指派到队列的顺序开始执行</td>
<td>无法创建，只能从系统提供的并发队列中选择（一共3个）</td>
</tr>
<tr>
<td>主队列</td>
<td>应用程序的有效的主队列</td>
<td>主线程只有一个，无所谓串/并行</td>
<td>执行的应用程序的主线程任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>调度队列数据类型：</strong><code>dispatch_queue_t</code></p>
</blockquote>
<h5 id="连续队列"><a href="#连续队列" class="headerlink" title="连续队列"></a>连续队列</h5><blockquote>
<p><strong>说明：</strong>只要任务是异步提交的，队列会确保任务根据预定顺序执行，不会发生死锁。<br><strong>适用：</strong>一连串的任务需要按照一定的顺序执行的场景</p>
</blockquote>
<h6 id="dispatch-queue-create全局方法"><a href="#dispatch-queue-create全局方法" class="headerlink" title="dispatch_queue_create全局方法"></a>dispatch_queue_create全局方法</h6><blockquote>
<p><strong>说明：</strong>创建连续队列<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;const char *&#125; label 队列的名称</span><br><span class="line">* @param &#123;dispatch_queue_attr_t&#125; attr 队列的特性（可以为NULL）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明连续队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_serial_queue;</span><br><span class="line"><span class="comment">// 创建连续队列</span></span><br><span class="line">my_serial_queue = dispatch_queue_create(<span class="string">"com.apress.MySerialQueue1"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h5 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h5><blockquote>
<p><strong>说明：</strong>并发调度队列适用于那些可以并行运行的任务</p>
<ul>
<li>开始执行时间遵从FIFO</li>
<li>任务可以在前一个任务结束前就开始执行</li>
<li>一次所运行的任务数量是无法预测的（根据其它运行的任务的状况）</li>
</ul>
<p><strong>技巧：</strong>如果需要确保每次运行的任务的数量都是一样的，可以通过线程<code>API</code>来手动管理线程。</p>
</blockquote>
<h6 id="dispatch-get-global-queue全局方法"><a href="#dispatch-get-global-queue全局方法" class="headerlink" title="dispatch_get_global_queue全局方法"></a>dispatch_get_global_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取系统的并发队列。<br><strong>原型：</strong><code>/usr/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long&#125; identifier 优先级选项</span><br><span class="line">* @param &#123;unsigned long&#125; flags 标记（可以为0）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">long</span> identifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_global_queue;</span><br><span class="line"><span class="comment">// 获取并发队列（默认优先级）</span></span><br><span class="line">my_global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h5><h6 id="dispatch-get-current-queue全局方法"><a href="#dispatch-get-current-queue全局方法" class="headerlink" title="dispatch_get_current_queue全局方法"></a>dispatch_get_current_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取<code>当前运行的</code>队列代码块，如果在代码块的对象之外调用了这个函数，则它会返回<code>主队列</code>。<br><strong>注意：</strong>该方法在从<code>OS X 10.9</code>和<code>ios 6</code>开始被废弃，因为GCD队列本身是不可重入的，同步阻塞会导致死锁。<br><strong>用途：</strong>仍然可以作为调试手段在代码中使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取主线程或当前队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> theQueue = dispatch_get_current_queue();</span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-队列也要内存管理"><a href="#14-2-2-队列也要内存管理" class="headerlink" title="14.2.2    队列也要内存管理"></a>14.2.2    队列也要内存管理</h3><blockquote>
<p><strong>说明：</strong><code>调度队列</code>是引用计数对象，可以使用<code>dispatch_retain()</code>和<code>dispatch_release()</code>来修改队列的保留计数器的值。</p>
</blockquote>
<h4 id="14-2-2-1-队列的上下文"><a href="#14-2-2-1-队列的上下文" class="headerlink" title="14.2.2.1    队列的上下文"></a>14.2.2.1    队列的上下文</h4><blockquote>
<p><strong>说明：</strong>可以向<code>调度对象（包括调度队列）</code>指派<code>全局数据上下文</code>，可以在上下文中指派任意类型的数据，比如<code>Objective-C</code>对象或指针。<br><strong>内存管理：</strong>必须在需要<code>队列上下文</code>的时候分配内存并在队列销毁之前进行清理。</p>
</blockquote>
<h5 id="dispatch-set-context全局方法"><a href="#dispatch-set-context全局方法" class="headerlink" title="dispatch_set_context全局方法"></a>dispatch_set_context全局方法</h5><blockquote>
<p><strong>说明：</strong>为指定队列设置<code>全局上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_set_context(dispatch_object_t object, <span class="keyword">void</span> *context);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-get-context全局方法"><a href="#dispatch-get-context全局方法" class="headerlink" title="dispatch_get_context全局方法"></a>dispatch_get_context全局方法</h5><blockquote>
<p><strong>说明：</strong>获得<code>调度队列</code>的<code>全局数据上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @return &#123;void *&#125; 全局数据上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> * dispatch_get_context(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可变字典（作为全局数据上下文）</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *myContext = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 为全局上下文添加队列需要的数据</span></span><br><span class="line">[myContext setObject:<span class="string">@"My Context"</span> forKey:<span class="string">@"title"</span>];</span><br><span class="line">[myContext setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>] forKey:<span class="string">@"value"</span>];</span><br><span class="line"><span class="comment">// 为连续队列 my_serial_queue 设置全局数据上下文</span></span><br><span class="line">dispatch_set_context(my_serial_queue, (__bridge_retained <span class="keyword">void</span> *)myContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取全局数据上下文(桥接转换__bridge，告诉ARC不想自己来管理上下文的内存)</span></span><br><span class="line">myContext = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-2-全局数据上下文内存管理"><a href="#14-2-2-2-全局数据上下文内存管理" class="headerlink" title="14.2.2.2    全局数据上下文内存管理"></a>14.2.2.2    全局数据上下文内存管理</h4><blockquote>
<p><strong>说明：</strong>编写一个<code>终结器(finalizer)</code>函数，在<code>dealloc</code>中调用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 终结器函数</span><br><span class="line">* @param &#123;void *&#125; context 全局数据上下文对象</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> myFinalizerFunction(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"myFinalizerFunction"</span>);</span><br><span class="line">	<span class="comment">// 桥接转换：将全局数据上下文对象桥接转换为具体类型</span></span><br><span class="line">	<span class="comment">// 其中，__bridge_transfer 将拥有权限转移到了本函数中，意味着该对象的内存管理由全局释放池换成了我们的函数</span></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *theData = (__bridge_transfer <span class="built_in">NSMutableDictionary</span>*)context;</span><br><span class="line">	<span class="comment">// 清空作为全局数据上下文的对象</span></span><br><span class="line">	[theData removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-向调度队列添加任务"><a href="#14-2-2-3-向调度队列添加任务" class="headerlink" title="14.2.2.3    向调度队列添加任务"></a>14.2.2.3    向调度队列添加任务</h4><blockquote>
<p><strong>说明：</strong>有两种方式可以向队列中添加任务，每种方式针对<code>代码块</code>和<code>函数</code>各有一个调度函数（共4个）</p>
<ul>
<li><strong>同步：</strong>队列会一直等待前面任务结束</li>
<li><strong>异步：</strong>添加任务后，不必等待任务，函数会立刻返回（推荐，因为不会阻塞其他代码的运行）</li>
</ul>
</blockquote>
<p>|<em>**</em>|同步|异步|<br>|代码块|<code>dispatch_sync</code>|<code>dispatch_async</code>|<br>|函数|<code>dispatch_sync_f</code>|<code>dispatch_async_f</code>|</p>
<h5 id="dispatch-sync全局函数"><a href="#dispatch-sync全局函数" class="headerlink" title="dispatch_sync全局函数"></a>dispatch_sync全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async全局函数"><a href="#dispatch-async全局函数" class="headerlink" title="dispatch_async全局函数"></a>dispatch_async全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步添加代码块：内联方式</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步添加代码块：非内联</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^dispatch_block_t)(<span class="keyword">void</span>);</span><br><span class="line">dispatch_block_t myBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"My Prefined block"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, myBlock);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-sync-f全局函数"><a href="#dispatch-sync-f全局函数" class="headerlink" title="dispatch_sync_f全局函数"></a>dispatch_sync_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async-f全局函数"><a href="#dispatch-async-f全局函数" class="headerlink" title="dispatch_async_f全局函数"></a>dispatch_async_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义好要添加到队列的函数</span></span><br><span class="line"><span class="keyword">void</span> myDispatchFunction (<span class="keyword">void</span> *argument) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task %@"</span>, (__bridge <span class="built_in">NSNumber</span> *)argument);</span><br><span class="line">    <span class="comment">// 获得当前队列的全局数据上下文</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *context = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(dispatch_get_current_queue());</span><br><span class="line">    <span class="comment">// 在字典中索引</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *value = [context objectForKey:<span class="string">@"value"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步向队列中添加函数</span></span><br><span class="line">dispatch_async_f(my_serial_queue, (__bridge <span class="keyword">void</span> *)[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>], (dispatch_function_t)myDispatchFunction);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-调度队列的暂停和重启"><a href="#14-2-2-3-调度队列的暂停和重启" class="headerlink" title="14.2.2.3    调度队列的暂停和重启"></a>14.2.2.3    调度队列的暂停和重启</h4><h5 id="dispatch-suspend全局方法"><a href="#dispatch-suspend全局方法" class="headerlink" title="dispatch_suspend全局方法"></a>dispatch_suspend全局方法</h5><blockquote>
<p><strong>说明：</strong>暂停队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_suspend(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-resume全局方法"><a href="#dispatch-resume全局方法" class="headerlink" title="dispatch_resume全局方法"></a>dispatch_resume全局方法</h5><blockquote>
<p><strong>说明：</strong>重启队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_resume(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停队列</span></span><br><span class="line">dispatch_suspend(my_serial_queue);</span><br><span class="line"><span class="comment">// 重启队列</span></span><br><span class="line">dispatch_resume(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-操作队列"><a href="#14-2-3-操作队列" class="headerlink" title="14.2.3    操作队列"></a>14.2.3    操作队列</h3><blockquote>
<p><strong>说明：</strong>有一些称为<code>操作（operation）</code>的<code>API</code>，可以让队列使用起来更加简单。</p>
<ol>
<li>创建一个<code>操作</code>对象</li>
<li>将其指派给<code>操作队列</code></li>
<li><code>操作</code>被队列执行</li>
</ol>
</blockquote>
<h4 id="操作的创建方式"><a href="#操作的创建方式" class="headerlink" title="操作的创建方式"></a><code>操作</code>的创建方式</h4><blockquote>
<p><strong>说明：</strong>一共有3种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用操作（<code>NSInvocationOperation</code>）</td>
<td>前提是已经拥有一个可以完成工作的类，并且想在队列上执行</td>
</tr>
<tr>
<td>代码块操作（<code>NSBlockOperation</code>）</td>
<td>类似包含了要执行代码块的<code>dispatch_async</code>函数</td>
</tr>
<tr>
<td>自定义的<code>操作</code></td>
<td>通过继承<code>NSOperation</code>定义自己的<code>操作</code></td>
</tr>
</tbody>
</table>
<h5 id="方式一：创建调用操作"><a href="#方式一：创建调用操作" class="headerlink" title="方式一：创建调用操作"></a>方式一：创建<code>调用操作</code></h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyCustomClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span> *)operationWithData: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget: <span class="keyword">self</span> selectorL <span class="keyword">@selector</span>(myWorkerMethod:)object:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做具体工作的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)myWorkerMethod: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"My Worker Method %@"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="方式二：创建代码块操作"><a href="#方式二：创建代码块操作" class="headerlink" title="方式二：创建代码块操作"></a>方式二：创建<code>代码块操作</code></h5><blockquote>
<p><strong>说明：</strong>创建时作为参数的<code>代码块</code>的类型和在<code>调度队列</code>中使用的相同。</p>
<ul>
<li>一旦创建了第一个<code>代码块操作</code>，便可以通过<code>addExecutionBlock</code>方法继续添加更多的<code>代码块</code></li>
<li>根据<code>队列</code>的类型，代码块会分别以连续或并行的方式运行</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock: ^ &#123;</span><br><span class="line">	<span class="comment">// 具体工作内容</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过代码块操作，继续添加代码块</span></span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">	<span class="comment">// 更多要做工作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="向队列中添加操作"><a href="#向队列中添加操作" class="headerlink" title="向队列中添加操作"></a>向队列中添加操作</h4><blockquote>
<p><strong>说明：</strong>可以使用<code>NSOperationQueue</code>来取代之前使用的<code>dispatch_queue</code>函数，特点如下</p>
<ul>
<li>并发执行<code>操作</code></li>
<li>具有<code>相关性</code>，也就是说，如果某个<code>操作</code>是基于其它<code>操作</code>的，则也会先被执行</li>
</ul>
<p><strong>技巧：</strong>如果要确保添加的<code>操作</code>是连续执行（串行）的，可以设置最大并发操作数为1，这样会按照<code>先入先出</code>的规范执行</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *currentQueue = [<span class="built_in">NSOperation</span> currentQueue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line">[theQueue addOperation:blockOperation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加代码块替代操作对象</span></span><br><span class="line">[theQueue addOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"my work"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="14-3-小结"><a href="#14-3-小结" class="headerlink" title="14.3    小结"></a>14.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_13 协议/" itemprop="url">
                  13 协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:50+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_13 协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_13 协议/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="13-1-正式协议"><a href="#13-1-正式协议" class="headerlink" title="13.1    正式协议"></a>13.1    正式协议</h2><blockquote>
<p><strong>说明：</strong>正式协议类似<code>Java</code>的接口。</p>
<ul>
<li><strong>声明协议：</strong>通过<code>@protocol</code>创建协议的声明。</li>
<li><strong>采用协议：</strong>在类的<code>@interface</code>声明中列出协议的名称。</li>
<li><strong>遵守协议：</strong>在类的<code>@implementation</code>中实现协议的所有方法（否则编译器会生成警告）。</li>
</ul>
</blockquote>
<h3 id="13-1-1-声明协议"><a href="#13-1-1-声明协议" class="headerlink" title="13.1.1    声明协议"></a>13.1.1    声明协议</h3><blockquote>
<p><strong>说明：</strong>类似类或类别的声明</p>
<ul>
<li>可以继承父协议，类似继承父类</li>
<li>内部是方法声明列表</li>
<li>在协议中不会引入新的实例变量</li>
</ul>
<p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> 协议名 &lt;父协议名</span></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="Cocoa的NSCopying协议"><a href="#Cocoa的NSCopying协议" class="headerlink" title="Cocoa的NSCopying协议"></a>Cocoa的<code>NSCopying</code>协议</h4><blockquote>
<p><strong>说明：</strong>如果采用了该协议，对象就会知道如何创建自己的副本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCopying</span></span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone: (<span class="built_in">NSZone</span> *) zone;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="Cocoa的NSCoding协议"><a href="#Cocoa的NSCoding协议" class="headerlink" title="Cocoa的NSCoding协议"></a>Cocoa的<code>NSCoding</code>协议</h4><blockquote>
<p><strong>说明：</strong>能够对自身进行编码和解码</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCoding</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 接收对象的实例变量并将其转换为NSCoder类的对象</span><br><span class="line">*</span><br><span class="line">* @param &#123;NSCoder *&#125; encoder</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) encoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 从NSCoder对象中提取经过转换雪藏的实例变量，并使用它们去初始化新的对象</span><br><span class="line">*</span><br><span class="line">* @param &#123;NSCoder *&#125; decoder</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-采用协议"><a href="#13-1-2-采用协议" class="headerlink" title="13.1.2    采用协议"></a>13.1.2    采用协议</h3><blockquote>
<p><strong>说明：</strong>要采用某个协议，可以在类的声明中列出该协议的名称，并用<code>&lt;&gt;</code>括起来<br><strong>语法：</strong>可以同时实现多个协议，中间用<code>,</code>分隔</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 类名: 父类明 &lt;协议1, 协议2, ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守协议实现的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span>: <span class="title">NSObject</span> &lt;<span class="title">NSCoping</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 实例变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守协议实现的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-实现协议"><a href="#13-1-3-实现协议" class="headerlink" title="13.1.3    实现协议"></a>13.1.3    实现协议</h3><h2 id="13-2-复制"><a href="#13-2-复制" class="headerlink" title="13.2    复制"></a>13.2    复制</h2><blockquote>
<p><strong>说明：</strong>复制分为两类，<code>浅层复制（shallow copy）</code>和<code>深层复制（deep copy）</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>复制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅层复制</td>
<td>只会复制指向引用对象的指针</td>
</tr>
<tr>
<td>深层复制</td>
<td>将复制引用的对象</td>
</tr>
</tbody>
</table>
<h3 id="13-2-1-复制-Engine"><a href="#13-2-1-复制-Engine" class="headerlink" title="13.2.1    复制 Engine"></a>13.2.1    复制 Engine</h3><blockquote>
<p><strong>说明：</strong>没有实例变量或属性。</p>
</blockquote>
<p><em>Engine.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  采纳 NSCopying 协议</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Engine</span></span><br></pre></td></tr></table></figure>
<p><em>Engine.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  遵守协议，实现复制自身的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param zone 内存区域</span><br><span class="line"> *</span><br><span class="line"> *  @return &#123;id&#125; 复制的对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Engine *engineCopy;</span><br><span class="line">    <span class="comment">// 创建一个当前类（Engine或其子类）创建一个新对象</span></span><br><span class="line">    engineCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] init];</span><br><span class="line">    <span class="keyword">return</span> engineCopy;</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-2-复制-Tire"><a href="#13-2-2-复制-Tire" class="headerlink" title="13.2.2    复制 Tire"></a>13.2.2    复制 Tire</h3><blockquote>
<p><strong>说明：</strong>有属性，要考虑实例变量（包括子类的）的复制，需要选择合适的构造函数或者使用<code>setter</code>修改对象的属性。<br><strong>扩展：</strong>可以使用<code>C</code>语言风格的<code>指针运算符</code>直接访问实例变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tireCopy-&gt;pressure = presssure;</span><br><span class="line">tireCopy-&gt;treadDepth = treadDepth;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>一般来说，当设置属性不太可能涉及额外工作时，我们尽量使用init方法和访问器方法。</p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> pressure;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> treadDepth;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure:(<span class="keyword">float</span>)pressure treadDepth:(<span class="keyword">float</span>)treadDepth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  遵守协议，实现复制自身的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param zone 内存区域</span><br><span class="line"> *</span><br><span class="line"> *  @return 复制的对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Tire *tireCopy;</span><br><span class="line">    <span class="comment">// 调用便利构造器创建对象（属性相同）</span></span><br><span class="line">    tireCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] initWithPressure:<span class="keyword">self</span>.pressure treadDepth:<span class="keyword">self</span>.treadDepth];</span><br><span class="line">    <span class="keyword">return</span> (tireCopy);</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-3-复制-Car"><a href="#13-2-3-复制-Car" class="headerlink" title="13.2.3    复制 Car"></a>13.2.3    复制 Car</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Car *carCopy;</span><br><span class="line">    <span class="comment">// 创建车身</span></span><br><span class="line">    carCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] init];</span><br><span class="line">    <span class="comment">// 基本设置</span></span><br><span class="line">    carCopy.name = <span class="keyword">self</span>.name;</span><br><span class="line">    Engine *engineCopy;</span><br><span class="line">    engineCopy = [engine <span class="keyword">copy</span>];</span><br><span class="line">    carCopy.engine = engineCopy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Tire *tireCopy;</span><br><span class="line">        tireCopy = [[<span class="keyword">self</span> tireAtIndex:i] <span class="keyword">copy</span>];</span><br><span class="line">        [carCopy setTire:tireCopy atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (carCopy);</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-4-协议和数据"><a href="#13-2-4-协议和数据" class="headerlink" title="13.2.4    协议和数据"></a>13.2.4    协议和数据</h3><blockquote>
<p><strong>说明：</strong>可以在实例变量和方法参数的后面添加<code>&lt;协议名&gt;</code>来对对象是够遵守协议进行类型检查。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求 object 遵守 NSCopying 协议,否则编译器会给出警告</span></span><br><span class="line">- (<span class="keyword">void</span>) setObjectValue: (<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;) object;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-Objective-C-2-0-的新特性"><a href="#13-3-Objective-C-2-0-的新特性" class="headerlink" title="13.3    Objective-C 2.0 的新特性"></a>13.3    Objective-C 2.0 的新特性</h2><blockquote>
<p><strong>说明：</strong><code>Objective-C 2.0</code>中增加了两个新的协议修饰符：<code>@optional</code>和<code>@required</code>，用来取代<code>非正式协议</code></p>
<ul>
<li><code>@optional</code>：后面的方法声明列表可以实现也可以不实现</li>
<li><code>@required</code>后面的方法列表中的方法必须被实现</li>
</ul>
<p><strong>优点(相比非正式协议)：</strong>可以用来在类声明中明确表达我们的意图。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@proptocol BaseballPlayer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line">- (<span class="keyword">void</span>) drawHugeSalary;</span><br><span class="line"><span class="comment">// 可以实现</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>) slideeHome;</span><br><span class="line">- (<span class="keyword">void</span>) catchBall;</span><br><span class="line">- (<span class="keyword">void</span>) throwBall;</span><br><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>) swingBat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h2 id="13-4-委托方法"><a href="#13-4-委托方法" class="headerlink" title="13.4    委托方法"></a>13.4    委托方法</h2><blockquote>
<p><strong>说明：</strong><code>委托</code>是一个经常与<code>协议</code>共用的特性。<br><strong>举例：</strong><code>管理者</code>将部分具体工作委托给<code>工作人员</code>完成，<code>工作人员类</code>采纳了指定<code>协议</code>。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-22%20%E4%B8%8B%E5%8D%886.19.00.png" alt="Alt text"></p>
</blockquote>
<p><em>WorkerProtocol.h：工作人员类采纳的协议</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WorkerProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomeOptionalWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Worker1.h + Worker1.m</em> </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"><span class="comment">// 采纳了协议 WorkerProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Worker1</span> : <span class="title">NSObject</span> &lt;<span class="title">WorkerProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Worker1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Worker1</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker1 doing required work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Worker2.h + Worker2.m</em> </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"><span class="comment">// 采纳了协议 WorkerProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Worker2</span> : <span class="title">NSObject</span> &lt;<span class="title">WorkerProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Worker2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Worker2</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker2 doing required work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeOptionalWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker2 doing optional work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Manager.h + Manager.m：管理者（会委托部分工作给设置的委托对象）</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Manager</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">id</span> &lt;WorkerProtocol&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doWork;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Manager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Manager</span> ()</span></span><br><span class="line">- (<span class="keyword">void</span>)myWork;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doWork</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用委托对象完成必要工作</span></span><br><span class="line">    [delegate doSomeRequiredWork];</span><br><span class="line">    <span class="comment">// 检查是否有额外工作，有则做</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">YES</span> == [delegate respondsToSelector:<span class="keyword">@selector</span>(doSomeOptionalWork)])</span><br><span class="line">    &#123;</span><br><span class="line">        [delegate doSomeOptionalWork];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行自己的私有方法</span></span><br><span class="line">    [<span class="keyword">self</span> myWork];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I am a manager and I am working"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Manager.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Worker1.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Worker2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 管理者</span></span><br><span class="line">        Manager *manager = [[Manager alloc] init];</span><br><span class="line">        <span class="comment">// 委托对象</span></span><br><span class="line">        Worker1 *worker1 = [[Worker1 alloc] init];</span><br><span class="line">        <span class="comment">// 为管理者设置委托对象</span></span><br><span class="line">        manager.delegate = worker1;</span><br><span class="line">        <span class="comment">// 工作（内部委托 worker1 工作）</span></span><br><span class="line">        [manager doWork];</span><br><span class="line">        </span><br><span class="line">        Worker2 *worker2 = [[Worker2 alloc] init];</span><br><span class="line">        manager.delegate = worker2;</span><br><span class="line">        [manager doWork];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-小结"><a href="#13-5-小结" class="headerlink" title="13.5    小结"></a>13.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_12 类别/" itemprop="url">
                  12 类别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:26+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_12 类别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_12 类别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>利用<code>Objective-C</code>的动态运行时分配机制，你可以为现有的类添加<code>方法</code>或<code>计算属性</code>，这种机制称为<code>类别(category)</code>。</p>
<ul>
<li>可以在类中添加属性（<code>@property</code>），且只能是<code>计算属性</code>（不能添加<code>实例变量</code>）</li>
<li>可以向一个<code>类</code>添加任意数量的<code>类别</code></li>
<li><code>类别</code>可以访问其扩展的类的<code>实例变量</code></li>
</ul>
<p><strong>总结：</strong>我将<code>类别</code>分3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>种类</th>
<th><code>@interface</code></th>
<th><code>@implementation</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>类别</td>
<td><code>@interface 类名(类别名)</code></td>
<td><code>@implementation 类名(类别名)</code></td>
</tr>
<tr>
<td>类扩展（匿名类别）</td>
<td><code>@interface 类名()</code></td>
<td>无</td>
</tr>
<tr>
<td>前向引导</td>
<td><code>@interface 类名(类别名)</code></td>
<td><code>@implementation 类名</code></td>
</tr>
</tbody>
</table>
<h2 id="12-1-创建类别"><a href="#12-1-创建类别" class="headerlink" title="12.1    创建类别"></a>12.1    创建类别</h2><blockquote>
<p><strong>说明：</strong>可以为人和类添加新的方法，包括那些没有源代码的类。<br><strong>技巧：</strong>通常把类别代码放在<code>独立</code>的文件中，通常以<code>类名称+类别名称</code>的风格命名。</p>
</blockquote>
<h3 id="12-1-1-开始创建类别独立文件"><a href="#12-1-1-开始创建类别独立文件" class="headerlink" title="12.1.1    开始创建类别独立文件"></a>12.1.1    开始创建类别独立文件</h3><blockquote>
<p><strong>说明：</strong>使用<code>Xcode</code>往项目中添加类别非常容易，甚至可以<code>类名称+类别名称</code>命名类别文件。</p>
<ol>
<li>新建文件<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.23.09.png" alt="Alt text"></li>
<li>选择模版<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.23.39.png" alt="Alt text"></li>
<li>文件相关<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.24.00.png" alt="Alt text"></li>
<li>完成<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.24.16.png" alt="Alt text"></li>
</ol>
</blockquote>
<h3 id="12-1-2-interface部分"><a href="#12-1-2-interface部分" class="headerlink" title="12.1.2    @interface部分"></a>12.1.2    @interface部分</h3><p><em>NSString+NumberConvience.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">NumberConvience</span>)</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *) lengthAsNumber;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// NumberConvience</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-implementation部分"><a href="#12-1-3-implementation部分" class="headerlink" title="12.1.3    @implementation部分"></a>12.1.3    @implementation部分</h3><p><em>NSString+NumberConvience.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSString+NumberConvience.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">NumberConvience</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取NSNumber 类型的字符串长度</span><br><span class="line"> * @return &#123;NSNumber *&#125; 字符串长度</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *) lengthAsNumber &#123;</span><br><span class="line">    <span class="comment">// 获得字符串长度：NSInteger 底层是个 long int</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [<span class="keyword">self</span> length];</span><br><span class="line">    <span class="comment">// 将字符串长度转换为 NSNumber 类型</span></span><br><span class="line">    <span class="keyword">return</span> ([<span class="built_in">NSNumber</span> numberWithUnsignedLong: length]);</span><br><span class="line">&#125;<span class="comment">// lengthAsNumber</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSString+NumberConvience.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 可变字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="comment">// 添加键/值对</span></span><br><span class="line">        [dict setObject:[<span class="string">@"hello"</span> lengthAsNumber] forKey:<span class="string">@"hello"</span>];</span><br><span class="line">        [dict setObject:[<span class="string">@"iLikeFish"</span> lengthAsNumber] forKey:<span class="string">@"iLikeFish"</span>];</span><br><span class="line">        [dict setObject:[<span class="string">@"Once upon a time"</span> lengthAsNumber] forKey:<span class="string">@"Once upon a time"</span>];</span><br><span class="line">        <span class="comment">// 打印字典</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-类别的缺陷"><a href="#12-1-4-类别的缺陷" class="headerlink" title="12.1.4    类别的缺陷"></a>12.1.4    类别的缺陷</h3><blockquote>
<p><strong>说明：</strong>类别有2个局限性</p>
<ul>
<li>无法向类中添加实例变量</li>
<li>当类别添加的方法和类中原有的方法重名时，类别具有更高的优先级</li>
</ul>
<p><strong>解决命名冲突：</strong>可以在类别的方法名中添加一个前缀，以确保不会发生名称冲突。<br><strong>添加实例变量：</strong>使用全局字典来存储对象与想关联的额外变量之间的映射。</p>
</blockquote>
<h3 id="12-1-5-类别的优势"><a href="#12-1-5-类别的优势" class="headerlink" title="12.1.5    类别的优势"></a>12.1.5    类别的优势</h3><blockquote>
<p><strong>说明：</strong>类别主要有3个用途</p>
<ul>
<li>将类的实现代码分散到多个不同文件或框架中</li>
<li>创建对私有方法的前向引用</li>
<li>向对象添加非正式协议（informal protocol）</li>
</ul>
</blockquote>
<h3 id="12-1-6-类扩展"><a href="#12-1-6-类扩展" class="headerlink" title="12.1.6    类扩展"></a>12.1.6    类扩展</h3><blockquote>
<p><strong>说名：</strong><code>类扩展（class extension）</code>是一个特殊的<code>类别</code>，它不需要命名(只有<code>@interface</code>没有<code>@implementation</code>)。</p>
<ul>
<li>可以包含源代码的类中使用</li>
<li>可以添加实例变量</li>
<li>可以将只读权限改成可读写的权限</li>
<li>创建数量不限</li>
</ul>
<p><strong>信息隐藏：</strong>分2种情况</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>类扩展</code>所在文件</th>
<th>可访问性</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩展的目标类的<code>@implementation</code>所在<code>.m</code>文件</td>
<td>目标类的内部</td>
</tr>
<tr>
<td>单独的私有<code>.h</code>文件</td>
<td>目标类的内部、目标类的子类和友类</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>可以拥有多个<code>类扩展</code>，不过这样会引发很难察觉的<code>bug</code>，所以请理智使用。</p>
</blockquote>
<p><em>Things.h：类的<code>@interface</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Things</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing2;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)resetAllValues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Things.m：类的<code>@implementation</code>和类扩展</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Things.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  在实现文件中添加类扩展（匿名类别）</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Things</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加实例变量</span></span><br><span class="line">    <span class="built_in">NSInteger</span> thing4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原有属性的特性（只读－&gt;读写）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing2;</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Things ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类的原始定义</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Things</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) resetAllValues &#123;</span><br><span class="line">    thing1 = <span class="number">100</span>;</span><br><span class="line">    thing2 = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Things</span></span><br></pre></td></tr></table></figure>
<p><em>main.m：使用被扩展后的<code>NSString</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Things *things = [[Things alloc] init];</span><br><span class="line">        things.thing1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, things);</span><br><span class="line">        [things resetAllValues];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, things);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-2-利用类别分散实现代码"><a href="#12-2-利用类别分散实现代码" class="headerlink" title="12.2    利用类别分散实现代码"></a>12.2    利用类别分散实现代码</h2><blockquote>
<p><strong>说明：</strong>如果想将大型的单个类分散到多个不同的<code>.m</code>文件中，可以使用<code>类别</code>。<br><strong>举例：</strong><code>AppKit</code>中的<code>NSWindow</code>，拥有大量的<code>类别</code>声明</p>
<ul>
<li><code>@interface NSWindow(NSKeyboardUI)</code></li>
<li><code>@interface NSWindow(NSToolbarSupport)</code></li>
<li><code>@interface NSWindow(NSDrag)</code></li>
<li><code>@interface NSWindow(NSCarbonExtensions)</code></li>
</ul>
<p><strong>扩展：</strong><code>类别</code>还可以将<code>方法</code>分散到<code>逻辑群组</code>中，使编程人员可以更加容易地阅读头<code>文件</code>。</p>
</blockquote>
<h3 id="在项目中使用类别"><a href="#在项目中使用类别" class="headerlink" title="在项目中使用类别"></a>在项目中使用类别</h3><blockquote>
<p><strong>说明：</strong>将类的<code>类别</code>的实现部分分散在三个独立的文件中。<br><img src="./屏幕快照 2016-01-20 下午10.54.50.png" alt="Alt text"></p>
</blockquote>
<p><em>CategoryThing.h：类的<code>@interface</code>和3个类别的<code>@interface</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing1;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing2;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// CategoryThing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing1</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing1</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing1: (<span class="built_in">NSInteger</span>) thing1;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing2</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing2</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing2: (<span class="built_in">NSInteger</span>) thing2;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing3</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing3</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing3: (<span class="built_in">NSInteger</span>) thing3;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing3;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing.m：类的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  描述</span><br><span class="line"> *</span><br><span class="line"> *  @return 字符串表示的描述内容</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld %ld %ld"</span>, thing1, thing2, thing3];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;<span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// CategoryThing</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing1.m：类别Thing1的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing1</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setThing1:(<span class="built_in">NSInteger</span>)t1</span><br><span class="line">&#123;</span><br><span class="line">    thing1 = t1;</span><br><span class="line">&#125; <span class="comment">// setThing1</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (thing1);</span><br><span class="line">&#125; <span class="comment">// thing1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// CategoryThing</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing2.m：类别Thing2的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing2</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setThing2:(<span class="built_in">NSInteger</span>)t2 &#123;</span><br><span class="line">    thing2 = t2;</span><br><span class="line">&#125; <span class="comment">// setthing2</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing2 &#123;</span><br><span class="line">    <span class="keyword">return</span> (thing2);</span><br><span class="line">&#125; <span class="comment">// thing2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing3.m：类别Thing3的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing3</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setThing3:(<span class="built_in">NSInteger</span>)t3 &#123;</span><br><span class="line">    thing3 = t3;</span><br><span class="line">&#125; <span class="comment">// setthing3</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing3 &#123;</span><br><span class="line">    <span class="keyword">return</span> (thing3);</span><br><span class="line">&#125; <span class="comment">// thing3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m：调用<code>类</code>通过<code>类别</code>扩展的功能</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 创建物品集合</span></span><br><span class="line">        CategoryThing *thing = [[CategoryThing alloc] init];</span><br><span class="line">        <span class="comment">// 调用通过“类别”扩展来的方法</span></span><br><span class="line">        [thing setThing1: <span class="number">5</span>];</span><br><span class="line">        [thing setThing2: <span class="number">23</span>];</span><br><span class="line">        [thing setThing3: <span class="number">42</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Things are %@"</span>, thing);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-通过类别创建前向引用"><a href="#12-3-通过类别创建前向引用" class="headerlink" title="12.3    通过类别创建前向引用"></a>12.3    通过类别创建前向引用</h2><blockquote>
<p><strong>背景：</strong><code>Objective-C</code>的<code>私有方法</code>分两种</p>
<ul>
<li>如果在一个类的<code>@implementation</code>部分定义了某个方法，而对应的<code>@interface</code>部分没有相应的方法声明</li>
<li>通过<code>类扩展（匿名类别）</code>扩展的方法</li>
</ul>
<p>然而，<code>O-C</code>并不真的支持<code>私有方法</code>，所以<code>私有方法</code>仍然可以通过对象调用，只不过这时<code>Xcode</code>会给出警告。<br><strong>说明：</strong>当从外部访问某个<code>类</code>的<code>私有方法</code>时，为了避免<code>Xcode</code>给出警告，可以通过<code>类别</code>补充一个声明，即<code>前向引导</code>。<br><strong>扩展：</strong>实际上，苹果公司官网在知道方针中指出，应用程序不能访问类里面的私有变量和方法，如果你的应用程序有这样的行为，那么苹果公司会拒绝让它上架。<br><em>main.m：在最前面创建<code>类别</code>来补充<code>私有方法</code>的声明</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> (<span class="title">Private</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) moveTireFromPosition: (<span class="keyword">int</span>) pos1 toPosition: (<span class="keyword">int</span>) pos2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>Car.m：方法的实现部分是Car的<code>私有方法</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>) moveTireFromPosition: (<span class="keyword">int</span>) pos1 toPosition: (<span class="keyword">int</span>) pos2 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="12-4-非正式协议和委托类别"><a href="#12-4-非正式协议和委托类别" class="headerlink" title="12.4    非正式协议和委托类别"></a>12.4    非正式协议和委托类别</h2><blockquote>
<p><strong>委托：</strong>将某些工作交给另一个类执行就叫做<code>委托(delegate)</code>。<br><strong>委托对象：</strong><code>委托</code>技术中，被委托用来执行某些工作的<code>对象</code>。<br><strong>说明：</strong>除了通过<code>继承</code>创建<code>委托对象</code>外，可以通过<code>类别</code>扩展<code>NSObject</code>（即创建了一个<code>非正式协议</code>），使其获得<code>委托方法</code>，从而将任何对象都变成<code>委托对象</code>。</p>
</blockquote>
<h3 id="12-4-1-iTunesFinder项目"><a href="#12-4-1-iTunesFinder项目" class="headerlink" title="12.4.1    iTunesFinder项目"></a>12.4.1    iTunesFinder项目</h3><blockquote>
<p><strong>说明：</strong>用来说明<code>Cocoa</code>中是如何使用<code>委托</code>技术的。</p>
</blockquote>
<h4 id="Bonjour"><a href="#Bonjour" class="headerlink" title="Bonjour"></a>Bonjour</h4><blockquote>
<p><strong>说明：</strong>查找由<code>Bonjour</code>发布的网络服务的<code>Cocoa类</code>是<code>NSNetServiceBrowser</code>。<br><strong>用法：</strong>告诉<code>网络服务浏览器</code>你需要的服务，并为其提供一个<code>委托对象</code>。<code>浏览器对象</code>将会向该<code>委托对象</code>发送消息，告知其发现新服务的时间。<br><em>ITunesFinder.h</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ITunesFinder</span> : <span class="title">NSObject</span> &lt;<span class="title">NSNetServiceBrowserDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ITunesFinder.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ITunesFinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ITunesFinder</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  找到了网络服务时的回调方法</span><br><span class="line"> *</span><br><span class="line"> *  @param b          网络服务浏览器对象</span><br><span class="line"> *  @param service    被发现的服务</span><br><span class="line"> *  @param moreComing 一批通知是否已经完成的标记</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b</span><br><span class="line">            didFindService:(<span class="built_in">NSNetService</span> *) service</span><br><span class="line">                moreComing:(<span class="built_in">BOOL</span>) moreComing &#123;</span><br><span class="line">    <span class="comment">// 获取关于该服务的所有有趣的属性</span></span><br><span class="line">    [service resolveWithTimeout:<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"found one! Name is %@"</span>, [service name]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// didFindService</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  某个网络服务消失时的回调方法（用于状态刷新）</span><br><span class="line"> *</span><br><span class="line"> *  @param b          网络服务浏览器对象</span><br><span class="line"> *  @param service    被发现的服务</span><br><span class="line"> *  @param moreComing 一批通知是否已经完成的标记</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b</span><br><span class="line">          didRemoveService:(<span class="built_in">NSNetService</span> *) service</span><br><span class="line">                moreComing:(<span class="built_in">BOOL</span>) moreComing</span><br><span class="line">&#123;</span><br><span class="line">    [service resolveWithTimeout:<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"lost one! Name is %@"</span>, [service name]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// didRemoveService</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// ITunesFinder</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ITunesFinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建 网络服务浏览器对象</span></span><br><span class="line">        <span class="built_in">NSNetServiceBrowser</span> *browser = [[<span class="built_in">NSNetServiceBrowser</span> alloc] init];</span><br><span class="line">        <span class="comment">// 创建 委托对象（自定义的查找iTunes资源的对象）</span></span><br><span class="line">        ITunesFinder *finder = [[ITunesFinder alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 网络服务浏览器对象所使用的委托对象为自定义的 ITunes 对象</span></span><br><span class="line">        [browser setDelegate:finder];</span><br><span class="line">        <span class="comment">// 搜索 iTunes 共享（使用TCP协议、只在本地网络中）</span></span><br><span class="line">        [browser searchForServicesOfType:<span class="string">@"_daap._tcp"</span></span><br><span class="line">                                inDomain:<span class="string">@"local."</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"begun browsing"</span>);</span><br><span class="line">        <span class="comment">// run循环（在 网络服务浏览器 发现新的 iTunes 共享之前会一直保持运行而不返回，即阻塞在此处而不执行后面的代码）</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-2-委托和类别"><a href="#12-4-2-委托和类别" class="headerlink" title="12.4.2    委托和类别"></a>12.4.2    委托和类别</h3><blockquote>
<p><strong>说明：</strong>除了通过<code>继承</code>创建<code>委托对象</code>外，可以通过<code>类别</code>扩展<code>NSObject</code>（即创建了一个<code>非正式协议</code>），使其获得<code>委托方法</code>，从而将任何对象都变成<code>委托对象</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSNetServerBrowserDelegateMethods</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowserWillSearch: (<span class="built_in">NSNetServiceBrowser</span> *) browser;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b didFindService:(<span class="built_in">NSNetService</span> *) service moreComing:(<span class="built_in">BOOL</span>) moreComing;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowserDidStopSearch: (<span class="built_in">NSNetServiceBrowser</span> *) browser;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b didRemoveService:(<span class="built_in">NSNetService</span> *) service moreComing:(<span class="built_in">BOOL</span>) moreComing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="12-4-3-响应选择器"><a href="#12-4-3-响应选择器" class="headerlink" title="12.4.3    响应选择器"></a>12.4.3    响应选择器</h3><blockquote>
<p><strong>说明：</strong><code>NSNetServiceBrowser</code>为了确定其<code>委托对象</code>是否能够处理那些发送给它的消息，会首先检查对象，询问其能否响应该选择器，是泽发送消息，否则忽略这个委托对象，程序继续运行。</p>
</blockquote>
<h4 id="选择器（selector）"><a href="#选择器（selector）" class="headerlink" title="选择器（selector）"></a>选择器（selector）</h4><blockquote>
<p><strong>说明：</strong>只是一个方法名称，但以<code>Objective-C</code>运行时使用的特殊方式编码，以快速执行查询。<br><strong>语法：</strong><code>@selector(方法名)</code><br><strong>用途：</strong><code>NSObject</code>提供了一个名为<code>responendsToSelector</code>的方法，该方法询问对象以确定其是否能够响应某个特定的消息。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br><span class="line"><span class="keyword">if</span> ([car responengsToSelector: <span class="keyword">@selector</span>(setEngine:)]) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"yowza!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-4-选择器的其它应用"><a href="#12-4-4-选择器的其它应用" class="headerlink" title="12.4.4    选择器的其它应用"></a>12.4.4    选择器的其它应用</h3><blockquote>
<p><strong>说明：</strong>选择器可以</p>
<ul>
<li>被传递</li>
<li>作为方法的参数</li>
<li>作为实例变量被存储</li>
</ul>
<p><strong>举个例子：</strong><code>Foundation</code>框架中的<code>NSTimer</code></p>
</blockquote>
<h2 id="12-5-小结"><a href="#12-5-小结" class="headerlink" title="12.5    小结"></a>12.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_11 属性/" itemprop="url">
                  11 属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:03+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_11 属性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_11 属性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>O-C 2.0</code>引入了<code>属性（property）</code>，即<code>@property</code>预编译指令，它组合了新的预编译指令和新的属性访问器语法。<br><strong>用途：</strong>除非自己定义了相关代码，否则<code>@property</code>会根据<code>特性</code>自动生成属性及其<code>setter</code>和<code>getter</code>的声明和实现。<br><strong>兼容性：</strong><code>10.5+</code><br><strong>语法：</strong><code>@property[(特性)] 实例变量类型 实例变量名;</code><br><strong>注意：</strong>还有一个编译指令<code>@synthesize</code>，用来配合<code>@property</code>生成<code>getter</code>和<code>setter</code>的实现，可以省略（<code>XCode 4.4</code>之后）。</p>
</blockquote>
<h2 id="11-1-使用属性值"><a href="#11-1-使用属性值" class="headerlink" title="11.1    使用属性值"></a>11.1    使用属性值</h2><p><em>AllWeatherRadial.h</em></p>
<blockquote>
<p><strong>说明：</strong>对需要设置<code>setter</code>和<code>getter</code>的实例变量使用<code>@property</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎再潮湿的道路上的性能</span></span><br><span class="line">    <span class="keyword">float</span> rainHandling;</span><br><span class="line">    <span class="keyword">float</span> snowHandling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对需要设置setter和getter的实例变量使用@property(不在需要为每个属性分别声明setter和getter)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> rainHandling;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> snowHandling;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// AllWeatherRadial</span></span><br></pre></td></tr></table></figure>
<p><em>AllWeatherRadial.m</em></p>
<blockquote>
<p><strong>说明：</strong>不需要实现被设置了<code>@propery</code>的实例属性的<code>getter</code>和<code>setter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithPressure: p treadDepth:td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>, [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth], [<span class="keyword">self</span> rainHandling], [<span class="keyword">self</span> snowHandling]];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<blockquote>
<p><strong>说明：</strong>调用相应的属性的<code>setter</code>和<code>getter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 车身</span></span><br><span class="line">        Car *car = [[Car alloc] init];</span><br><span class="line">        <span class="comment">// 安装轮胎</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            AllWeatherRadial *tire;</span><br><span class="line">            tire = [[AllWeatherRadial alloc] init];</span><br><span class="line">            <span class="comment">// 调用通过@property指令获得的setter和getter</span></span><br><span class="line">            [tire setRainHandling:<span class="number">23</span> + i];</span><br><span class="line">            [tire setSnowHandling:<span class="number">33</span> - i];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"tire %d's handling is %.f %.f"</span>, i, [tire rainHandling], [tire snowHandling]);</span><br><span class="line">            [car setTire:tire atIndex:i];</span><br><span class="line">            [tire release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安装引擎</span></span><br><span class="line">        Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">        [car setEngine:engine];</span><br><span class="line">        <span class="comment">// 使用Car</span></span><br><span class="line">        [car print];</span><br><span class="line">        [car release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-1-1-简化接口代码"><a href="#11-1-1-简化接口代码" class="headerlink" title="11.1.1    简化接口代码"></a>11.1.1    简化接口代码</h3><h3 id="11-1-2-简化实现代码"><a href="#11-1-2-简化实现代码" class="headerlink" title="11.1.2    简化实现代码"></a>11.1.2    简化实现代码</h3><h3 id="11-1-3-点表达式的妙用"><a href="#11-1-3-点表达式的妙用" class="headerlink" title="11.1.3    点表达式的妙用"></a>11.1.3    点表达式的妙用</h3><blockquote>
<p><strong>说明：</strong><code>O-C 2.0</code>引入的新的语法特性，可以更加容易地访问对象的属性。<br><strong>限制：</strong>只能用于对象属性的<code>setter</code>或<code>getter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter</span></span><br><span class="line">tire.rainHandling = <span class="number">20</span> + i;</span><br><span class="line">tire.snowHandling = <span class="number">28</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"tire %d's handling is %.f %.f"</span>, i, tire.rainHandling, tire.snowHandling);</span><br></pre></td></tr></table></figure>
<h2 id="11-2-属性扩展"><a href="#11-2-属性扩展" class="headerlink" title="11.2    属性扩展"></a>11.2    属性扩展</h2><blockquote>
<p><strong>说明：</strong><code>@property</code>对如何生成代码还有一些<code>特性</code>可以指定，这些<code>特性</code>将影响<code>setter</code>代码的生成。</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>@property</code>特性</th>
<th>说明</th>
<th>适用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>简单赋值，不更改<code>引用计数</code></td>
<td>基础数据类型和C数据类型</td>
<td>默认</td>
</tr>
<tr>
<td>copy</td>
<td>通过就对象复制出一个新对象（引用计数为1），并<code>释放</code>旧对象</td>
<td>不可变对象（例如NSString）</td>
<td></td>
</tr>
<tr>
<td>retain</td>
<td><code>释放</code>旧对象，将旧对象的值赋予输入对象，再<code>保留</code>输入对象</td>
<td>其它<code>O-C</code>对象</td>
<td></td>
</tr>
<tr>
<td>nonatomic</td>
<td>非线程安全</td>
<td>所有类型</td>
<td>默认，性能更好</td>
</tr>
<tr>
<td>atomic</td>
<td>某种程度的线程安全</td>
<td>所有类型</td>
<td>在多线程的环境保证<code>get</code>和<code>set</code>正确执行，但前提是是使用<code>@synthesize</code>生成的实现</td>
</tr>
<tr>
<td>readwrite</td>
<td>可读写</td>
<td>所有类型</td>
<td>默认</td>
</tr>
<tr>
<td>readonly</td>
<td>只读</td>
<td>所有类型</td>
<td>只生成<code>getter</code></td>
</tr>
<tr>
<td>getter=getter名称</td>
<td>指定生成的<code>getter</code>方法名</td>
<td>所有类型</td>
<td>默认为<code>属性名</code></td>
</tr>
<tr>
<td>setter=setter名称</td>
<td>指定生成的<code>setter</code>方法名</td>
<td>所有类型</td>
<td><code>set属性名</code>，匈牙利命名法</td>
</tr>
</tbody>
</table>
<h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用<code>@property</code></h4><blockquote>
<p><strong>说明：</strong><code>name</code>属性为<code>@property(copy)</code>，<code>engine</code>属性为<code>@property(retain)</code></p>
</blockquote>
<p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *) name;</span><br><span class="line">- (<span class="keyword">void</span>) setName: (<span class="built_in">NSString</span> *) newName;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (retain) Engine *engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="built_in">NSString</span> *) name &#123;</span><br><span class="line">	<span class="keyword">return</span> (name);</span><br><span class="line">&#125;<span class="comment">// name</span></span><br><span class="line">- (<span class="keyword">void</span>) setName: (<span class="built_in">NSString</span> *) newName &#123;</span><br><span class="line">	[name release];</span><br><span class="line">	name = [newName <span class="keyword">copy</span>];</span><br><span class="line">&#125;<span class="comment">// setName</span></span><br><span class="line"></span><br><span class="line">- (Engine *) engine &#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine &#123;</span><br><span class="line">    [newEngine retain];</span><br><span class="line">    [engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h4 id="不使用-property"><a href="#不使用-property" class="headerlink" title="不使用@property"></a>不使用<code>@property</code></h4><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用copy特性</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSString</span> name;</span><br><span class="line"><span class="comment">// 使用retain特性</span></span><br><span class="line"><span class="keyword">@property</span>(retain) Engine *engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<blockquote>
<p><strong>说明：</strong><code>@synthesize</code>用来生成成员变量的<code>setter</code>和<code>getter</code>的实现。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="comment">// xcode4.4 之后@synthesize就不再需要了</span></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"><span class="keyword">@synthesize</span> engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-1-名称的使用"><a href="#11-2-1-名称的使用" class="headerlink" title="11.2.1    名称的使用"></a>11.2.1    名称的使用</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appellation;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> name = appellation;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-只读属性"><a href="#11-2-2-只读属性" class="headerlink" title="11.2.2    只读属性"></a>11.2.2    只读属性</h3><blockquote>
<p><strong>说明：</strong>假设某个属性，不想让任何人修改它，则可以对这个<code>@property</code>使用<code>readonly</code>特性，这时，只生成一个<code>getter</code>方法而不会生成<code>setter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Me</span>: <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> showSize;</span><br><span class="line">	<span class="built_in">NSString</span> *licenseNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">float</span> showSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *licenseNumber;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-自己动手有时更好"><a href="#11-2-3-自己动手有时更好" class="headerlink" title="11.2.3    自己动手有时更好"></a>11.2.3    自己动手有时更好</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><blockquote>
<p><strong>说明：</strong>可以通过<code>@property</code>配合<code>@dynamic</code>指令告诉编译器不生成人和代码或实例变量，通过自定义的<code>getter</code>创建一个能在运行时计算出此值的访问方法。<br><strong>注意：</strong>如果使用了<code>@dynamic</code>指令，并企图调用不存在的<code>getter</code>或<code>setter</code>方法，你将会的到一个报错。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @property</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">float</span> bodyMassIndex;</span><br><span class="line"><span class="comment">// @dynamic</span></span><br><span class="line"><span class="keyword">@dynamic</span> bodyMassIndex;</span><br><span class="line"><span class="comment">// getter</span></span><br><span class="line">- (<span class="keyword">float</span>) bodyMassIndex &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定getter和setter方法名"><a href="#指定getter和setter方法名" class="headerlink" title="指定getter和setter方法名"></a>指定getter和setter方法名</h4><blockquote>
<p><strong>说明：</strong>可以通过<code>@property(getter=getter名称)</code>和<code>@property(setter=setter名称)</code>自定义<code>geter</code>和<code>setter</code>方法的名称。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter为isHidden，setter为setHidden（默认）</span></span><br><span class="line"><span class="keyword">@property</span> (getter=isHidden) <span class="built_in">BOOL</span> hidden;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-4-特性不是万能的"><a href="#11-2-4-特性不是万能的" class="headerlink" title="11.2.4    特性不是万能的"></a>11.2.4    特性不是万能的</h3><blockquote>
<p><strong>说明：</strong><code>@property</code>只能生成严格意义上的<code>getter</code>和<code>setter</code>，不支持那些需要接收额外参数的方法。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setter有额外的参数</span></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"><span class="comment">// getter有额外的参数</span></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-小结"><a href="#11-3-小结" class="headerlink" title="11.3    小结"></a>11.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_10 对象初始化/" itemprop="url">
                  10 对象初始化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:39:41+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_10 对象初始化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_10 对象初始化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>创建对象有两种方式</p>
<ul>
<li><code>类名 new</code></li>
<li><code>[[类名 alloc] init]</code></li>
</ul>
<p><strong>技巧：</strong><code>Cocoa</code>惯例是使用后一种方式</p>
</blockquote>
<h2 id="10-1-分配对象"><a href="#10-1-分配对象" class="headerlink" title="10.1    分配对象"></a>10.1    分配对象</h2><blockquote>
<p><strong>说明：</strong>就是从操作系统获得一块内存，并将其指定为存放对象的实例变量的位置。<br><strong>语法：</strong>像某个类发送<code>alloc</code>消息</p>
</blockquote>
<h4 id="alloc实例方法"><a href="#alloc实例方法" class="headerlink" title="alloc实例方法"></a>alloc实例方法</h4><blockquote>
<p><strong>说明：</strong>为类实例分配一块足够大的内存，并将这块内存区域全部初始化为对应的<code>0</code>值</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例变量类型</th>
<th><code>0</code>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>BOOL</td>
<td>NO</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>指针</td>
<td>nil</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>刚刚分配的对象不能立即使用，初始化后才能使用。<code>Objective-C</code>将对象的创建拆分为两个明确的步骤：<code>分配</code>和<code>初始化</code>。<br><strong>扩展：</strong>有些语言（包括<code>c++</code>和<code>java</code>）使用构造函数在一次操作中便执行完对象的分配和初始化。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配</span></span><br><span class="line">Car *car = [Car alloc];<span class="comment">// 还需要init，之后才能使用</span></span><br></pre></td></tr></table></figure>
<h3 id="10-1-1-初始化对象"><a href="#10-1-1-初始化对象" class="headerlink" title="10.1.1    初始化对象"></a>10.1.1    初始化对象</h3><blockquote>
<p><strong>说明：</strong>从操作系统取得一块内存（不一定是<code>分配</code>的内存）用于存储对象。<br><strong>语法：</strong>通过嵌套方式向<code>分配</code>操作的返回值发送<code>init</code>消息。<br><strong>注意：</strong><code>init</code>方法返回的对象可能与<code>分配</code>的对象不同，因为某些类型底层其实是<code>类蔟</code>。</p>
</blockquote>
<p><em>错误示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [Car alloc];</span><br><span class="line"><span class="comment">// 我们需要的是init后的对象，car指向的对象未必和init返回的是一个对象</span></span><br><span class="line">[car init];</span><br></pre></td></tr></table></figure>
<p><em>正确示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-编写初始化方法"><a href="#10-1-2-编写初始化方法" class="headerlink" title="10.1.2    编写初始化方法"></a>10.1.2    编写初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">id</span>) init &#123;</span><br><span class="line">	<span class="comment">// 1. 兼容超类返回nil的情况</span></span><br><span class="line">	<span class="comment">// 2. 更新self表示的内存位置（因为超类的init可能返回另一个位置）</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		<span class="comment">// ...	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-3-初始化时要做些什么"><a href="#10-1-3-初始化时要做些什么" class="headerlink" title="10.1.3    初始化时要做些什么"></a>10.1.3    初始化时要做些什么</h3><blockquote>
<p><strong>说明：</strong>有两种方式可以选择，取决于灵活性和性能的权衡</p>
</blockquote>
<table>
<thead>
<tr>
<th>是否为实例变量创建对象</th>
<th>说明</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>方便，一步到位，出产即用</td>
<td>实例变量不需要定制</td>
</tr>
<tr>
<td>否</td>
<td>在某些情况下避免资源的浪费</td>
<td>实例变量需要定制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong><code>惰性求值</code>，指的是即是目前没有设置自定义属性的值，也等到调用着需要时再创建对象，可以提高程序的性能。</p>
</blockquote>
<h2 id="10-2-便利初始化函数"><a href="#10-2-便利初始化函数" class="headerlink" title="10.2    便利初始化函数"></a>10.2    便利初始化函数</h2><blockquote>
<p><strong>说明：</strong>相比<code>init</code>，完成某些额外的初始化工作，名称以<code>init</code>开头。<br><strong>适用：</strong>加入对象必须要用某些信息进行初始化，那么应该将这些信息作为init方法的一部分添加进来。</p>
</blockquote>
<h3 id="initWithContentsofFile便利初始化方法"><a href="#initWithContentsofFile便利初始化方法" class="headerlink" title="initWithContentsofFile便利初始化方法"></a>initWithContentsofFile便利初始化方法</h3><blockquote>
<p><strong>说明：</strong>打开指定路径上的文本文件，读取文件内容，并即用文件内容初始化为一个字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;/**</span><br><span class="line">&gt;* @param &#123;nonnull NSString *&#125; 非空字符串</span><br><span class="line">&gt;* @param &#123;nullable NSStringEncoding *&#125; usedEncoding 编码方式</span><br><span class="line">&gt;* @param &#123;NSError * _Nullable __autoreleasing * _Nullable&#125; error 错误对象</span><br><span class="line">&gt;* @return &#123;instancetype _Nullable&#125; 字符串对象（可以为空）</span><br><span class="line">&gt;*/</span><br><span class="line">&gt;- (instancetype _Nullable) initWithContentsOfFile:(nonnull NSString *) usedEncoding: (nullable NSStringEncoding *) error:(NSError * _Nullable __autoreleasing * _Nullable);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:<span class="string">@"/tmp/words.txt"</span> usedEncoding:&amp;encoding error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取出错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unable to read data from file, %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取成功</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-3-更多部件改进"><a href="#10-3-更多部件改进" class="headerlink" title="10.3    更多部件改进"></a>10.3    更多部件改进</h2><blockquote>
<p><strong>注意：</strong>如果做<code>iOS</code>开发，由于不支持垃圾回收，必须使用<code>ARC</code>技术。</p>
</blockquote>
<h3 id="10-3-1-Tire类的初始化"><a href="#10-3-1-Tire类的初始化" class="headerlink" title="10.3.1    Tire类的初始化"></a>10.3.1    Tire类的初始化</h3><p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎压力</span></span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="comment">// 轮胎花纹</span></span><br><span class="line">    <span class="keyword">float</span> treadDepth;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) setPressure: (<span class="keyword">float</span>) pressure;</span><br><span class="line">- (<span class="keyword">float</span>) pressure;</span><br><span class="line">- (<span class="keyword">void</span>) setTreadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">float</span>)treadDepth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">- (<span class="keyword">id</span>) init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = <span class="number">34.0</span>;</span><br><span class="line">        treadDepth = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setPressure:(<span class="keyword">float</span>) p &#123;</span><br><span class="line">    pressure = p;</span><br><span class="line">&#125;<span class="comment">// setPressure</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) pressure &#123;</span><br><span class="line">    <span class="keyword">return</span> (pressure);</span><br><span class="line">&#125;<span class="comment">// pressure</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTreadDepth:(<span class="keyword">float</span>) td &#123;</span><br><span class="line">    treadDepth = td;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">float</span>) treadDepth &#123;</span><br><span class="line">    <span class="keyword">return</span> treadDepth;</span><br><span class="line">&#125;<span class="comment">// treadDepth</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    <span class="comment">// 不是通过alloc、copy、new创建的，按照内存管理规则，不需要做什么（可以认为它被加入到了自动释放池中）</span></span><br><span class="line">    desc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Tire: Pressure: %.1f TreadDepth: %1f"</span>, pressure, treadDepth];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;<span class="comment">// description</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-2-更新main-函数"><a href="#10-3-2-更新main-函数" class="headerlink" title="10.3.2    更新main()函数"></a>10.3.2    更新main()函数</h3><p><em>既没有启用<code>ARC</code>，也没有启用<code>垃圾回收</code>的情形－手动管理</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 车身</span></span><br><span class="line">        Car *car = [[Car alloc] init];</span><br><span class="line">        <span class="comment">// 安装轮胎</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Tire *tire;</span><br><span class="line">            tire = [[Tire alloc] init];</span><br><span class="line">            [tire setPressure:<span class="number">23</span> + i];</span><br><span class="line">            [tire setTreadDepth:<span class="number">33</span> - i];</span><br><span class="line">            [car setTire:tire atIndex:i];</span><br><span class="line">            <span class="comment">// 按照内存管理规则，应当释放一次，其余交给自动释放池</span></span><br><span class="line">            [tire release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安装引擎</span></span><br><span class="line">        Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">        [car setEngine:engine];</span><br><span class="line">        <span class="comment">// 使用Car</span></span><br><span class="line">        [car print];</span><br><span class="line">        <span class="comment">// 按照内存管理规则，应当释放一次，其余交给自动释放池</span></span><br><span class="line">        [car release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>启用了<code>ARC</code>或<code>垃圾回收</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 车身</span></span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    <span class="comment">// 安装轮胎</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Tire *tire;</span><br><span class="line">        tire = [[Tire alloc] init];</span><br><span class="line">        [tire setPressure:<span class="number">23</span> + i];</span><br><span class="line">        [tire setTreadDepth:<span class="number">33</span> - i];</span><br><span class="line">        [car setTire:tire atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 安装引擎</span></span><br><span class="line">    Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">    [car setEngine:engine];</span><br><span class="line">    <span class="comment">// 使用Car</span></span><br><span class="line">    [car print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-3-清理Car类"><a href="#10-3-3-清理Car类" class="headerlink" title="10.3.3    清理Car类"></a>10.3.3    清理Car类</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用可变数组代替C数组（Tire *tires[4]），就不用上限检查了</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tires;</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        tires = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">// 将每个轮胎初始化为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            [tires addObject: [<span class="built_in">NSNull</span> null]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine &#123;</span><br><span class="line">    [newEngine retain];</span><br><span class="line">    [engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [tires replaceObjectAtIndex:index withObject:tire];</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Tire *tire;</span><br><span class="line">    tire = [tires objectAtIndex:index];</span><br><span class="line">    <span class="keyword">return</span> (tire);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 不直接访问数组，避免代码收到将来更改的影响</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> tireAtIndex: i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 确保car对象呗销毁时所有的内存都被回收</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">    [tires release];</span><br><span class="line">    [engine release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h2 id="10-4-Car-类的内存清理（垃圾回收方式和ARC方式）"><a href="#10-4-Car-类的内存清理（垃圾回收方式和ARC方式）" class="headerlink" title="10.4    Car 类的内存清理（垃圾回收方式和ARC方式）"></a>10.4    Car 类的内存清理（垃圾回收方式和ARC方式）</h2><blockquote>
<p><strong>说明：</strong>启用了<code>垃圾回收</code>或<code>ARC</code>，则不用手动管理内存。</p>
<ul>
<li>不再需要手动<code>释放</code>或<code>保留</code></li>
<li>不需要重写<code>dealloc</code>方法完成内存的清理，如果要销毁时执行一些特别的操作，可以重写<code>-finalize</code>方法</li>
</ul>
<p><strong>注意：</strong>启用了<code>垃圾回收</code>则不需要<code>@autoreleasepool</code>；启用<code>ARC</code>，则代码中必要时仍然可以使用<code>@autoreleasepool</code>。</p>
</blockquote>
<h3 id="构造便利初始化函数"><a href="#构造便利初始化函数" class="headerlink" title="构造便利初始化函数"></a>构造便利初始化函数</h3><blockquote>
<p><strong>说明：</strong>构造一个能同时获取轮胎压力和花纹深度的便利初始化函数。</p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) pressure treadDepth: (<span class="keyword">float</span>) treadDepth;</span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tire *tire;</span><br><span class="line">tire = [[Tire alloc] initWithPressure: <span class="number">23</span> + i treadDepth: <span class="number">33</span> - i];</span><br></pre></td></tr></table></figure>
<h2 id="10-5-指定初始化函数"><a href="#10-5-指定初始化函数" class="headerlink" title="10.5    指定初始化函数"></a>10.5    指定初始化函数</h2><blockquote>
<p><strong>说明：</strong>先增加几个<code>便利初始化函数</code></p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) pressure treadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure:(<span class="keyword">float</span>)pressure;</span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithTreadDepth</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-1-子类化问题"><a href="#10-5-1-子类化问题" class="headerlink" title="10.5.1    子类化问题"></a>10.5.1    子类化问题</h3><blockquote>
<p><strong>说明：</strong><code>指定初始化函数</code>，即该中的某个初始化方法被指派为指定初始化函数，该类的所有初始化方法都调用指定初始化函数完成初始化。<br><strong>技巧：</strong>通常，接收参数最多的初始化方法是最终的指定初始化函数。</p>
</blockquote>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p><strong>说明：</strong><code>AllWeatherRadial</code>的超类<code>Tire</code>中的构造器都没有使用<code>指定初始化函数</code>，导致<code>AllWeatherRadial</code>需要重写所有<code>Tire</code>的构造器完成对自身实例变量的初始化。</p>
</blockquote>
<p><em>AllWeatherRadial.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎再潮湿的道路上的性能</span></span><br><span class="line">    <span class="keyword">float</span> rainHandling;</span><br><span class="line">    <span class="keyword">float</span> snowHandling;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) setRainHandling: (<span class="keyword">float</span>) rainHandling;</span><br><span class="line">- (<span class="keyword">float</span>) rainHandling;</span><br><span class="line">- (<span class="keyword">void</span>) setSnowHandling: (<span class="keyword">float</span>) snowHandling;</span><br><span class="line">- (<span class="keyword">float</span>) snowHandling;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// AllWeatherRadial</span></span><br></pre></td></tr></table></figure>
<p><em>AllWeatherRadial.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line">- (<span class="keyword">void</span>) setRainHandling:(<span class="keyword">float</span>) rh &#123;</span><br><span class="line">    rainHandling = rh;</span><br><span class="line">&#125;<span class="comment">// setRainHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) rainHandling &#123;</span><br><span class="line">    <span class="keyword">return</span> (rainHandling);</span><br><span class="line">&#125;<span class="comment">// rainHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setSnowHandling: (<span class="keyword">float</span>) sh &#123;</span><br><span class="line">    snowHandling = sh;</span><br><span class="line">&#125;<span class="comment">// setSnowHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) snowHandling &#123;</span><br><span class="line">    <span class="keyword">return</span> (snowHandling);</span><br><span class="line">&#125;<span class="comment">// snowHandling</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>, [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth], [<span class="keyword">self</span> rainHandling], [<span class="keyword">self</span> snowHandling]];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-2-Tire-类的初始化函数改进后的版本"><a href="#10-5-2-Tire-类的初始化函数改进后的版本" class="headerlink" title="10.5.2    Tire 类的初始化函数改进后的版本"></a>10.5.2    Tire 类的初始化函数改进后的版本</h3><blockquote>
<p><strong>说明：</strong>要解决上述问题，首先需要将<code>Tire</code>改造为使用<code>指定初始化函数</code>的版本。</p>
</blockquote>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: <span class="number">34.0</span> treadDepth: <span class="number">20.0</span>]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// init</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure: (<span class="keyword">float</span>) p &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: p treadDepth: <span class="number">20</span>]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: <span class="number">34</span> treadDepth: td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithTreadDepth</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 参数最多的作为指定初始化函数</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-3-添加AllWeatherPressure类的初始化函数"><a href="#10-5-3-添加AllWeatherPressure类的初始化函数" class="headerlink" title="10.5.3    添加AllWeatherPressure类的初始化函数"></a>10.5.3    添加AllWeatherPressure类的初始化函数</h3><blockquote>
<p><strong>说明：</strong>然后，将<code>AllWeatherPressure</code>改造为使用<code>指定初始化函数</code>的版本。只需要重载父类的<code>指定初始化函数</code>，所有构造器就可以正常使用了（因为其他构造器都调用的<code>指定初始化函数</code>）。<br><em>AllWeatherPressure.m</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithPressure: p treadDepth:td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-6-初始化函数规则"><a href="#10-6-初始化函数规则" class="headerlink" title="10.6    初始化函数规则"></a>10.6    初始化函数规则</h2><blockquote>
<p><strong>说明：</strong>不是一定要为自己的类创建初始化函数</p>
<ul>
<li>如果不需要设置任何状态，或者<code>alloc</code>方法将内存清零的默认行为相当不错，则不可以不设置<code>指定初始化函数</code>。</li>
<li>如果子类中创建类<code>指定初始化函数</code>，则一定要在这个<code>制定初始化函数</code>中调用超类的<code>指定初始化函数</code>。</li>
</ul>
</blockquote>
<h2 id="10-7-小结"><a href="#10-7-小结" class="headerlink" title="10.7    小结"></a>10.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_09  内存管理/" itemprop="url">
                  9 内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:39:18+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_09  内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_09  内存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="9-1-对象生命周期"><a href="#9-1-对象生命周期" class="headerlink" title="9.1    对象生命周期"></a>9.1    对象生命周期</h2><blockquote>
<p><strong>说明：</strong>4个过程</p>
<ol>
<li>诞生：通过<code>alloc</code>或<code>new</code>方法实现</li>
<li>生存：接收消息并执行操作</li>
<li>交友：通过复合以及向方法传递参数</li>
<li>死去：被释放掉</li>
</ol>
</blockquote>
<h3 id="9-1-1-引用计数"><a href="#9-1-1-引用计数" class="headerlink" title="9.1.1    引用计数"></a>9.1.1    引用计数</h3><blockquote>
<p><strong>说明：</strong>也叫<code>保留计数</code>，每个对象都有一个与之想关联的整数，被称作它的<code>引用计数器</code>或<code>保留计数器</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关操作</th>
<th>说明</th>
<th>相关方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>引用计数器</code>初始化</td>
<td>被设置为1</td>
<td><code>alloc</code>、<code>new</code>、<code>copy</code></td>
</tr>
<tr>
<td><code>引用计数器</code>+1</td>
<td>新增对象引用时</td>
<td><code>retain</code></td>
</tr>
<tr>
<td><code>引用计数器</code>-1</td>
<td>引用生命周期结束或引用被断开时</td>
<td><code>release</code></td>
</tr>
<tr>
<td>销毁对象</td>
<td>释放掉已经分配的全部相关资源</td>
<td><code>dealloc</code></td>
</tr>
</tbody>
</table>
<h4 id="retain实例方法"><a href="#retain实例方法" class="headerlink" title="retain实例方法"></a>retain实例方法</h4><blockquote>
<p><strong>说明：</strong>增加对象的<code>引用计数器</code>的值。<br><strong>注意：</strong><code>Objective-C</code> 会在需要的时候自动调用它。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 接收消息的对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) retain;</span><br></pre></td></tr></table></figure>
<h4 id="release实例方法"><a href="#release实例方法" class="headerlink" title="release实例方法"></a>release实例方法</h4><blockquote>
<p><strong>说明：</strong>减少对象的<code>引用计数器</code>的值。<br><strong>注意：</strong><code>Objective-C</code> 会在需要的时候自动调用它。<br><strong>技巧：</strong>因为<code>retain</code>方法返回一个id类型的值，可以在接收其他消息的同时进行<code>retain</code>调用，增加对象的<code>引用计数器</code>的值并执行其他操作。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release;</span><br></pre></td></tr></table></figure>
<h4 id="retainCount实例方法"><a href="#retainCount实例方法" class="headerlink" title="retainCount实例方法"></a>retainCount实例方法</h4><blockquote>
<p><strong>说明：</strong>获取对象的<code>引用计数器</code>的值。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSUInteger&#125; 引用计数器当前值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>) retaonCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RetainTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RetainTracker</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"init: Retain count of %lu."</span>, [<span class="keyword">self</span> retainCount]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写dealloc,当引用计数器的值为0时将被自动调用</span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"dealloc called. Bye Bye."</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    RetainTracker *tracker = [RetainTracker new];</span><br><span class="line">    <span class="comment">// count: 1</span></span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count: 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count: 3</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 1</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count 1</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 0, dealloc it</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-对象所有权"><a href="#9-1-2-对象所有权" class="headerlink" title="9.1.2    对象所有权"></a>9.1.2    对象所有权</h3><blockquote>
<p><strong>说明：</strong>如果一个对象（或函数）内有指向其他对象的实例变量，则称该对象（或函数）拥有这些对象，并负责确保对其拥有的对象进行清理。</p>
</blockquote>
<h3 id="9-1-3-访问方法中的保留和释放"><a href="#9-1-3-访问方法中的保留和释放" class="headerlink" title="9.1.3    访问方法中的保留和释放"></a>9.1.3    访问方法中的保留和释放</h3><blockquote>
<p><strong>说明：</strong><code>setEngine</code>方法的第一个内存管理版本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// newEngin引用计数器加1</span></span><br><span class="line">	[newEngin retain];</span><br><span class="line">	<span class="comment">// engine应用计数器减1</span></span><br><span class="line">	[engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-自动释放"><a href="#9-1-4-自动释放" class="headerlink" title="9.1.4    自动释放"></a>9.1.4    自动释放</h3><blockquote>
<p><strong>说明：</strong>有些情况下，拥有对象的实体并不能负责清理拥有的对象，如下</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能在description中释放对象，因为先释放decription字符串对象再返回它，则保留计数器的值归0，对象马上被销毁。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *description;</span><br><span class="line">	description = [[<span class="built_in">NSString</span> alloc] initWithFormat: <span class="string">@"I'm %d years old"</span>, <span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> (description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>解决办法：不够优雅</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将返回的字符串赋在某个变量中</span></span><br><span class="line"><span class="built_in">NSString</span> *desc = [someObject description];</span><br><span class="line"><span class="comment">// 使用这个字符串</span></span><br><span class="line"><span class="built_in">NSSLog</span>(<span class="string">@"%@"</span>, desc);</span><br><span class="line"><span class="comment">// 销毁它</span></span><br><span class="line">[desc release];</span><br></pre></td></tr></table></figure>
<h3 id="9-1-5-所有对象放入池中"><a href="#9-1-5-所有对象放入池中" class="headerlink" title="9.1.5    所有对象放入池中"></a>9.1.5    所有对象放入池中</h3><blockquote>
<p><strong>关键字：</strong><code>@autoreleasepool</code>、<code>NSAutoreleasePool</code><br><strong>说明：</strong><code>自动释放池</code>是一个用来存放对象的池子（集合），并且能够自动释放。当自动释放池被销毁时，会想该池中所有的对象发送<code>release</code>消息。</p>
</blockquote>
<h4 id="autorelease实例方法"><a href="#autorelease实例方法" class="headerlink" title="autorelease实例方法"></a>autorelease实例方法</h4><blockquote>
<p><strong>说明：</strong>当向一个对象发送<code>autorelease</code>消息时，实际上是将该对象添加到自动释放池中。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 接收对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) autorelease;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *description;</span><br><span class="line">	description = [[<span class="built_in">NSString</span> alloc] initWithFormat: <span class="string">@"I'm %d years old"</span>, <span class="number">4</span>];</span><br><span class="line">	<span class="comment">// 通过autorelease方法将字符串加入到自动释放池</span></span><br><span class="line">	<span class="keyword">return</span> ([description autorelease]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSLog函数的代码运行结束以后，自动释放池会被自动销毁（假设上下文存在已经创建好的自动释放池）</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [someObject description]);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-自动释放池的创建和销毁"><a href="#9-1-6-自动释放池的创建和销毁" class="headerlink" title="9.1.6    自动释放池的创建和销毁"></a>9.1.6    自动释放池的创建和销毁</h3><blockquote>
<p><strong>说明：</strong>自动释放池应该什么时候创建？什么时候销毁？</p>
</blockquote>
<h4 id="9-1-6-1-创建"><a href="#9-1-6-1-创建" class="headerlink" title="9.1.6.1    创建"></a>9.1.6.1    创建</h4><blockquote>
<p><strong>说明：</strong>有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>自动释放池的创建</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@autorelease{}</code></td>
<td><code>{}</code>内的代码都会被放入这个新池子中</td>
<td>定义在<code>{}</code>内的变量在外部无法使用</td>
</tr>
<tr>
<td><code>NSAutoreleasePool</code>对象</td>
<td>创建和释放<code>NSAutoreleasePool</code>对象之间的代码会使用这个新的池子</td>
<td>性能不如<code>@autorelease{}</code>方式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>可以使用<code>drain方法</code>清空自定释放池中的对象而不销毁自动释放池（Mac OS 10.4+）</p>
</blockquote>
<h4 id="9-1-6-2-销毁"><a href="#9-1-6-2-销毁" class="headerlink" title="9.1.6.2    销毁"></a>9.1.6.2    销毁</h4><blockquote>
<p><strong>说明：</strong>使用<code>AppKit</code>时，<code>Cocoa</code>定期自动地为你创建和销毁自动释放池，通常是在程序处理完当前事件（如鼠标单击或者键盘按下）以后执行这些操作。</p>
</blockquote>
<h3 id="9-1-7-自动释放池的工作流程"><a href="#9-1-7-自动释放池的工作流程" class="headerlink" title="9.1.7    自动释放池的工作流程"></a>9.1.7    自动释放池的工作流程</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RetainTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RetainTracker</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"init: Retain count of %lu."</span>, [<span class="keyword">self</span> retainCount]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"dealloc called. Bye Bye."</span>);</span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 方式一：NSAutoreleasePool对象 */</span></span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	</span><br><span class="line">    RetainTracker *tracker = [RetainTracker new]; <span class="comment">// count: 1</span></span><br><span class="line">	</span><br><span class="line">    [tracker retain]; <span class="comment">// count: 2</span></span><br><span class="line">    [tracker autorelease]; <span class="comment">// count: still 2</span></span><br><span class="line">    [tracker release]; <span class="comment">// count: 1</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"releasing pool"</span>);</span><br><span class="line">    [pool release];<span class="comment">// 销毁自动释放池</span></span><br><span class="line">    <span class="comment">// gets nuked, sends release to tracker</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 方式二：@autorelease代码块 */</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        RetainTracker *tracker2 = [RetainTracker new]; <span class="comment">// count: 1</span></span><br><span class="line">        </span><br><span class="line">        [tracker2 retain]; <span class="comment">// count: 2</span></span><br><span class="line">        [tracker2 autorelease]; <span class="comment">// count: still 2</span></span><br><span class="line">        [tracker2 release]; <span class="comment">// count: 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"auto releasing pool"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-Cocoa-的内存管理规则"><a href="#9-2-Cocoa-的内存管理规则" class="headerlink" title="9.2    Cocoa 的内存管理规则"></a>9.2    Cocoa 的内存管理规则</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>有一些内存管理约定，它们都是一些很简单的规则，可用用于整个工具集內。</p>
<ul>
<li>如果使用<code>new</code>、<code>alloc</code>、<code>copy</code>方法创建了一个对象：当不再使用该对象时，应该向该对象发送一条<code>release</code>或<code>autorelease</code>消息</li>
<li>如果通过其他方法获得一个对象：如果对象的保留计数器的值为1，而且已经被设置为自动释放，那么你不需要执任何操作来确保对象的到清理，除非打算在一段时间内拥有该对象，则需要<code>保留</code>它并确保在操作完成时<code>释放</code>它。</li>
<li>如果<code>保留</code>了某个对象：需要（最终）<code>释放</code>或<code>自动释放</code>该对象（即保持<code>retain</code>方法和<code>release</code>方法使用次数相等）。<br><strong>技巧：</strong>以上规则可以归结为下表(两个维度：对象的来历？用完就销毁还是保留？)</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>对象的来历</th>
<th>用完就销毁</th>
<th>和拥有者同命</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alloc</code>、<code>new</code>、<code>copy</code></td>
<td>不在使用时释放对象</td>
<td>在<code>dealloc方法中释放对象</code></td>
</tr>
<tr>
<td><strong>其它方法</strong></td>
<td>不需要执行任何操作</td>
<td>获得对象时<code>保留</code>，在<code>dealloc</code>方法中<code>释放</code>对象</td>
</tr>
</tbody>
</table>
<h3 id="9-2-1-临时对象"><a href="#9-2-1-临时对象" class="headerlink" title="9.2.1    临时对象"></a>9.2.1    临时对象</h3><blockquote>
<p><strong>说明：</strong>临时对象指的是，在代码中使用某个对象，但是并未打算长期拥有该对象。<br><strong>内存管理：</strong>如果是用<code>new</code>、<code>alloc</code>、<code>copy</code>方法获得这个对象，就需要安排好该对象的内存释放（通常使用<code>release</code>）。<br><em>alloc</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维度1:通过alloc创建可变数组</span></span><br><span class="line"><span class="comment">// 维度2:临时使用</span></span><br><span class="line">KSMutableArray *array;</span><br><span class="line">array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="comment">// 使用array</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用时销毁</span></span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure>
<p><em>其它方法</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维度1:其它方法（工厂方法arrayWithCapacity已经将该对象的引用计数器设置为1且设置了自动释放，即已经放在了自动释放池中）</span></span><br><span class="line"><span class="comment">// 维度2:临时使用</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array;</span><br><span class="line">array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">17</span>];</span><br><span class="line"><span class="comment">// 使用array</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><em>其它方法（全局单例）</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSColor</span> *color;</span><br><span class="line"><span class="comment">// blueColor方法返回一个全局单例对象，这个对象永远不会被销毁，也不需要手动销毁</span></span><br><span class="line">color = [<span class="built_in">NSColor</span> blueColor];</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-拥有对象"><a href="#9-2-2-拥有对象" class="headerlink" title="9.2.2    拥有对象"></a>9.2.2    拥有对象</h3><blockquote>
<p><strong>说明：</strong><code>拥有对象</code>指的是希望在多个代码中一直拥有某个对象，比如</p>
<ul>
<li>将对象放进<code>集合</code>中（<code>NSArray</code>、<code>NSDictionary</code>等）</li>
<li>作为其它对象的<code>实例变量</code>使用</li>
<li>作为<code>全局变量</code>使用（比较罕见）</li>
</ul>
<p><strong>内存管理：</strong>见<a href="">9.2-技巧</a></p>
<ul>
<li>使用<code>new</code>、<code>alloc</code>、<code>copy</code>方法获得一个对象：只需保证在拥有者的<code>dealloc</code>方法中释放它</li>
<li>其它方法获得一个对象：获得后<code>保留</code>该对象，并保证在拥有者的<code>dealloc</code>方法中释放它<br><em><code>new</code>、实例变量</em></li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) doStuff &#123;</span><br><span class="line">	<span class="comment">// 通过new获得一个对象并赋值给实例变量</span></span><br><span class="line">	flonkArray = [<span class="built_in">NSMutableArray</span> new];<span class="comment">// count 1, autoreleased</span></span><br><span class="line">	[flonkArray retain];<span class="comment">// count 2, autoreleased</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	<span class="comment">// 释放实例变量指向的空间</span></span><br><span class="line">	[flonkArray release];<span class="comment">// count 0</span></span><br><span class="line">	<span class="comment">// 重写了dealloc别忘记调用超类的dealloc</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>其它方法、实例变量</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) doStuff &#123;</span><br><span class="line">	<span class="comment">// 通过new获得一个对象并赋值给实例变量</span></span><br><span class="line">	flonkArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">17</span>];<span class="comment">// count 1</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	<span class="comment">// 释放实例变量指向的空间</span></span><br><span class="line">	[flonkArray release];<span class="comment">// count 0</span></span><br><span class="line">	<span class="comment">// 重写了dealloc别忘记调用超类的dealloc</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理自动释放池"><a href="#清理自动释放池" class="headerlink" title="清理自动释放池"></a>清理自动释放池</h4><blockquote>
<p><strong>说明：</strong>自动释放池被清理的时间是完全确定的</p>
<ul>
<li>在代码中手动销毁</li>
<li>使用AppKit时是在循环结束时销毁</li>
</ul>
<p><strong>原理：</strong>自动释放池存放在栈中，新建的自动释放池被添加到栈顶，接收<code>autorelease</code>消息的对象将被放入最顶端的自动释放池。<br><strong>注意：</strong>自动释放池的分配和销毁操作代价很小，如果一个循环中会创建大量对象，可以创建在循环中常见自己的自动释放池，每创建一批就释放一批。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自动释放池</span></span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool;</span><br><span class="line">pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 创建字符串对象</span></span><br><span class="line">	<span class="keyword">id</span> object = [someArray objectAtIndex: i];</span><br><span class="line">	<span class="built_in">NSString</span> *desc = [object description];</span><br><span class="line">	<span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 每创建1000个对象清理到上一个自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">		<span class="comment">// 并新建一个自动释放池</span></span><br><span class="line">		pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放最后一个自动释放池</span></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-垃圾回收"><a href="#9-2-3-垃圾回收" class="headerlink" title="9.2.3    垃圾回收"></a>9.2.3    垃圾回收</h3><blockquote>
<p><strong>说明：</strong><code>Objective-C2.0</code>引入了自动内存管理机制，也称为<code>垃圾回收</code><br><strong>触发：</strong>类似自动释放池</p>
<ul>
<li>在时间循环结束时触发</li>
<li>也可以自己触发（如果不是GUI程序）</li>
</ul>
<p><strong>开启：</strong><code>垃圾回收</code>是一个可选择的是否启动的功能（项目信息窗口-&gt;Build Settings选项卡-&gt;Require[-fobjc-gc-only]选项）<br><strong>限制：</strong>只支持<code>OS X</code>应用开发，无法在<code>iOS</code>应用程序上应用。<br><strong>扩展：</strong>苹果对<code>iOS</code>开发的一些建议</p>
<ul>
<li>不要在自己的代码中使用<code>autorelease</code>方法</li>
<li>不要使用会返回自动释放对象的一些便利方法（比如<code>NSString</code>中以<code>stringWith</code>开头的工厂方法）</li>
</ul>
</blockquote>
<h3 id="9-2-4-自动引用计数"><a href="#9-2-4-自动引用计数" class="headerlink" title="9.2.4    自动引用计数"></a>9.2.4    自动引用计数</h3><blockquote>
<p><strong>背景：</strong><code>iOS</code>不支持垃圾回收，因为移动设备比电脑更加私人化、资源更少，垃圾回收存在潜在的体验问题。但苹果提供了另外一个方案来祢补，那就是<code>自动引用计数（automatic regerence counting, ARC）</code><br><strong>说明：</strong><code>ARC</code>不是垃圾回收器，它是在编译期（而不是运行期）工作的，它在代码中插入了合适的<code>retain</code>和<code>release</code>语句。<br><strong>注意：</strong><code>ARC</code>是一个可选的功能，必需明确地启用或禁用。<br><strong>开发环境限制：</strong>以下是编写（或运行）<code>ARC</code>代码所需的条件</p>
<ul>
<li>Xcode4.2 以上的版本</li>
<li>Apple LLVM 3.0 以上版本的编译器</li>
<li><code>OS X 10.7</code>以上版本的系统</li>
</ul>
<p><strong>运行环境限制：</strong>以下是运行移动设备必需满足的条件</p>
<ul>
<li>ios 4.0以上的移动设备或<code>OS X10.6</code>以上版本的64位系统的电脑</li>
<li><code>归零弱引用</code>需要<code>iOS 5.0</code>或<code>OS X 10.7</code>以上版本的系统</li>
</ul>
<p><strong>作用对象限制：</strong><code>ARC</code>只对可保留的对象指针<code>(ROPs)</code>有效</p>
<ul>
<li>代码块指针</li>
<li><code>Objective-C</code>对象指针</li>
<li>通过<code>_attribute((NSObject))</code>类型定义的指针</li>
</ul>
<p><strong>技巧：</strong>如果想在代码中使用<code>ARC</code>，必需满足以下三个条件</p>
<ul>
<li>能够确定哪些对象需要进行内存管理</li>
<li>能够表明如何去管理对象：就是说必需能够对某个对象的引用计数器的值进行加1和减1的操作（<code>NSObject</code>的子类都可以）</li>
<li>有可行的办法传递对象的所有权（在调用者和接受者之间）</li>
</ul>
<p><strong>注意：</strong>如果使用的指针不支持<code>ARC</code>，那么你不得不亲自手动管理它们。</p>
</blockquote>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote>
<p><strong>说明：</strong>通常变量和<code>Objective-C</code>对象之间都是<code>强引用</code>，可以通过对属性使用了<code>assign</code>特性声明为<code>弱引用</code>。<br><strong>用途：</strong>处理<code>保留循环（retain cycle）</code>带来的内存泄漏。<br><strong>限制：</strong><code>弱引用</code>指向的对象有可能被提前释放，直接使用会导致问题。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-14%20%E4%B8%8B%E5%8D%8811.14.20.png" alt="Alt text"></p>
</blockquote>
<h4 id="归零弱引用"><a href="#归零弱引用" class="headerlink" title="归零弱引用"></a>归零弱引用</h4><blockquote>
<p><strong>说明：</strong>在指向的对象被释放之后，这种弱引用就会被设置为<code>nil</code>，然后就可以像平常的指针一样被处理了。<br><strong>语法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_weak</code>关键字</td>
<td>声明变量时使用<code>_weak</code>修饰</td>
<td><code>_weak NSString *myString;</code></td>
</tr>
<tr>
<td><code>@property(weak)</code></td>
<td>对属性使用<code>weak</code>特性</td>
<td><code>@property(weak) NSString *myString;</code></td>
</tr>
<tr>
<td><code>_unsafe_unretained</code>关键字和<code>unsafe_unretained</code>特性</td>
<td>告诉<code>ARC</code>这个特殊的引用是弱引用</td>
<td>前提是：不支持弱引用、使用了ARC</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>兼容性：</strong><code>iOS 5+</code>和<code>OS X 10.7+</code><br><strong>属性命名限制：</strong>使用<code>ARC</code>的时候，有两种命名规则</p>
<ul>
<li>属性名称不能以<code>new</code>开头</li>
<li>属性不能只有一个<code>read-only</code>而没有内存管理特性（除非启用了<code>ARC</code>功能）</li>
</ul>
<p><strong>注意：</strong>内存管理的<code>关键字</code>和<code>特性</code>是不能一起使用的，两者相互排斥。<br><strong>扩展：</strong><code>强引用</code>也有自己的<code>_strong</code>关键字和<code>strong</code>特性</p>
</blockquote>
<h4 id="将已有的项目转换成支持ARC的"><a href="#将已有的项目转换成支持ARC的" class="headerlink" title="将已有的项目转换成支持ARC的"></a>将已有的项目转换成支持<code>ARC</code>的</h4><blockquote>
<p><strong>前提：</strong>必须确保垃圾回收机制没有启动（<code>垃圾回收</code>和<code>ARC</code>是无法一同使用的）。<br><strong>说明：</strong><code>ARC</code>默认是启动了的，如果一个项目没有是在没有启动<code>ARC</code>的情况下开发的，可以转换（通过Edit-&gt;Convert-&gt;To Objective-C ARC…）</p>
</blockquote>
<h4 id="桥接转换"><a href="#桥接转换" class="headerlink" title="桥接转换"></a>桥接转换</h4><blockquote>
<p><strong>指针分两类：</strong><code>ROP</code>和<code>non-ROP</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>是否被<code>ARC</code>（启用了的话）管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>可保留对象指针(<code>ROP</code>)</td>
<td>NSobject的所有子类</td>
<td>是</td>
</tr>
<tr>
<td>不可保留对象指针(<code>non-ROP</code>)</td>
<td>C语言集合类型</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>拥有者权限：</strong>这个概念只有在启用了<code>ARC</code>的情况下才有意义。指的是<code>ROP</code>和<code>non-ROP</code>相互转换时指针所有权情况，用来告诉<code>ARC</code>如何工作</p>
<p><strong>用途：</strong>通过<code>桥接转换</code>，可以在转换类型的同时控制<code>拥有者权限</code><br><strong>说明：</strong>有3种类型的桥接转换</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>语法</th>
<th>对象的保留计数器</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_bridge</code></td>
<td><code>non-ROP变量=(__bridge)ROP变量;</code>或<code>ROP变量=(__bridge)non-ROP变量;</code></td>
<td>不变化</td>
<td>指针的所有权仍会留在原变量</td>
</tr>
<tr>
<td><code>_bridge_restained</code></td>
<td><code>non-ROP变量=(__bridge_restained)ROP变量;</code></td>
<td>加1</td>
</tr>
<tr>
<td><code>_bridge_transfer</code></td>
<td><code>ROP变量=(__bridge_transfer)non-ROP变量;</code></td>
<td>减1</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>结构体（<code>struct</code>）和集合体（<code>union</code>）不能使用<code>ROP</code>作为成员。可以通过使用<code>void *</code>和<code>桥接转换</code>来解决这个问题</li>
<li>有时需要释放不支持<code>ARC</code>的对象或执行其他清理操作，所以仍要实现<code>dealloc</code>方法，但是不能直接调用<code>[super dealloc]</code></li>
</ul>
<p><strong>注意：</strong><code>ARC</code>中的代码存在如下限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>内存管理方法</th>
<th>不能调用</th>
<th>不能重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>retain</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>retainCount</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>release</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>autorelease</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>dealloc</td>
<td>- [x]</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ROP</span></span><br><span class="line"><span class="built_in">NSString</span> *theString = <span class="string">@"Learn Objective-C"</span>;</span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    int32_t foo;</span><br><span class="line">    <span class="keyword">char</span> *bar;</span><br><span class="line">    <span class="built_in">NSString</span> *baz;</span><br><span class="line">&#125; MyStruct;</span><br><span class="line"><span class="comment">// 转成C语言提供的类型（void *），并指定所有权</span></span><br><span class="line">MyStruct.baz = (_bridge_restained <span class="keyword">void</span> *)theString;</span><br><span class="line"><span class="comment">// non-ROP 转 ROP</span></span><br><span class="line"><span class="built_in">NSString</span> *myString = (_bridge_transfer <span class="built_in">NSString</span> *)MyStruct.baz;</span><br></pre></td></tr></table></figure>
<h2 id="9-3-异常"><a href="#9-3-异常" class="headerlink" title="9.3    异常"></a>9.3    异常</h2><blockquote>
<p><strong>说明：</strong>异常就是异常事件，比如数组溢出，如果<code>捕捉</code>并<code>处理</code>，就会痰乱程序流程。</p>
<ul>
<li>异常对象：<code>Cocoa</code>中使用<code>NSException</code>类来表示异常，可以创建<code>NSException</code>子类作为自己的异常（如果通过其它类型的对象来<code>抛出异常</code>，<code>Cocoa</code>不会处理它们）</li>
<li>抛出异常：在运行时系统中创建并处理异常的行为</li>
<li>捕捉异常：处理被<code>抛出</code>的异常的行为</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果要项目支持异常特性，要确保<code>-fobj-exceptions</code>（Enable Objecytive-C Exception）项被打开</li>
<li><code>Cocoa</code>框架处理错误的方式通常是退出程序</li>
<li>如果一个异常被抛出但没有被捕捉，程序会在异常断点处停止运行并通知有这个异常</li>
</ul>
</blockquote>
<h3 id="9-3-1-与异常有关的关键字"><a href="#9-3-1-与异常有关的关键字" class="headerlink" title="9.3.1    与异常有关的关键字"></a>9.3.1    与异常有关的关键字</h3><blockquote>
<p><strong>说明：</strong>都以<code>@</code>开头</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@try</code></td>
<td>定义可能包含异常的代码块</td>
</tr>
<tr>
<td><code>@catch</code></td>
<td>定义处理已抛出异常的代码块，接收一个参数，通常是<code>NSException</code>或其子类</td>
</tr>
<tr>
<td><code>@finally</code></td>
<td>定义无论是够有抛出异常都会执行的代码块</td>
</tr>
<tr>
<td><code>@throw</code></td>
<td>抛出异常</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>语法：</strong><code>@try-catch-finally</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-捕捉不同类型的异常"><a href="#9-3-2-捕捉不同类型的异常" class="headerlink" title="9.3.2    捕捉不同类型的异常"></a>9.3.2    捕捉不同类型的异常</h3><blockquote>
<p><strong>说明：</strong>可以根据需要处理的异常类型过使用多个<code>@catch</code>代码块。处理代码应该按照从具体到抽象的顺序排序，并在最后使用一个通用的处理代码</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (myCustomException) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="keyword">id</span> value) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>C语言程序员经常会在异常处理代码中使用<code>setjmp</code>和<code>longjmp</code>语句。在<code>@try</code>中则不可以，但可以使用<code>goto</code>和<code>return</code>语句退出异常处理代码。</p>
</blockquote>
<h3 id="9-3-3-抛出异常"><a href="#9-3-3-抛出异常" class="headerlink" title="9.3.3    抛出异常"></a>9.3.3    抛出异常</h3><blockquote>
<p><strong>说明：</strong>异常的抛出分两种，<code>自动</code>和<code>手动</code>，后者有<code>2</code>中方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>手动抛出异常</th>
<th>异常对象类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@throw 异常对象</code></td>
<td>id</td>
</tr>
<tr>
<td>向某个异常对象发送<code>raise</code>消息</td>
<td><code>NSException</code>或其子类</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>在<code>@try</code>和<code>@catch</code>中都可以抛出异常，后者会引发下一个异常处理调用（<code>@finally</code>会在<code>@throw</code>之前被调用）<br><strong>扩展：</strong><code>Objective-C</code>的异常机制与<code>C++</code>的异常机制兼容。<br><strong>性能问题：</strong><code>@try</code>建立异常不会产生消耗，但捕捉异常会消耗大量资源并影响程序运行的速度。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSExceptionn</span> *theException = [<span class="built_in">NSException</span> exceptionWithName: _];</span><br><span class="line"><span class="keyword">@throw</span> theException;<span class="comment">// 或者[theException raise]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">	<span class="built_in">NSException</span> *e = _;</span><br><span class="line">	<span class="keyword">@throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">	<span class="comment">// 可以不指定异常对象（默认重复抛出）</span></span><br><span class="line">	<span class="keyword">@throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-异常也需要内存管理"><a href="#9-3-4-异常也需要内存管理" class="headerlink" title="9.3.4    异常也需要内存管理"></a>9.3.4    异常也需要内存管理</h3><blockquote>
<p><strong>说明：</strong>如果代码出现了异常，程序会被中断，原本没有内存问题的代码或许会因此出现内存泄漏。</p>
</blockquote>
<p><em>问题描述</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mySimpleMethod &#123;</span><br><span class="line">	<span class="comment">// 创建一个字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *dictionary = [[<span class="built_in">NSDictionary</span> alloc] initWith_.];</span><br><span class="line">	<span class="comment">// 对字典进行操作，假设操作中出现了异常，则程序会从方法中跳出寻找异常处理代码</span></span><br><span class="line">	[<span class="keyword">self</span> processDictionary: dictionary];</span><br><span class="line">	<span class="comment">// 释放字典：由于方法已经退出来了，所以字典没有释放</span></span><br><span class="line">	[dictionary release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>解决方式：<code>@try-@finally</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mySimpleMethod &#123;</span><br><span class="line">	<span class="comment">// 创建一个字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *dictionary = [[<span class="built_in">NSDictionary</span> alloc] initWith_.];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 对字典进行操作，假设操作中出现了异常，则程序会从方法中跳出寻找异常处理代码</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionary: dictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放字典：由于方法已经退出来了，所以字典没有释放</span></span><br><span class="line">		[dictionary release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-5-异常和自动释放池"><a href="#9-3-5-异常和自动释放池" class="headerlink" title="9.3.5    异常和自动释放池"></a>9.3.5    异常和自动释放池</h3><blockquote>
<p><strong>说明：</strong>通常，开发人员并不知道异常对象何时释放，所以异常几乎总是作为自动释放对象创建。<br><strong>注意：</strong><code>@finally</code>代码块会在<code>@catch</code>中的<code>@throw</code>语句执行之前被调用，因此如果在<code>@finally</code>将自动释放池销毁，那么就会导致<code>僵尸异常</code>。</p>
</blockquote>
<p><em>僵尸异常示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMechod &#123;</span><br><span class="line">	<span class="comment">// 自动释放池</span></span><br><span class="line">	<span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	<span class="comment">// 字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *myDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKey: <span class="string">@"asdfads"</span>, <span class="literal">nil</span>];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 操作字典</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionaty: myDictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">		<span class="comment">// pool在下面的@throw被调用之前就被释放了，释放池中的异常对象随之被销毁，导致僵尸异常</span></span><br><span class="line">		<span class="keyword">@throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 销毁自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>避免僵尸异常：在<code>自动释放池</code>外<code>保留</code>异常对象</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMechod &#123;</span><br><span class="line">	<span class="keyword">id</span> savedException = <span class="literal">nil</span>;</span><br><span class="line">	<span class="comment">// 自动释放池</span></span><br><span class="line">	<span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	<span class="comment">// 字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *myDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKey: <span class="string">@"asdfads"</span>, <span class="literal">nil</span>];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 操作字典</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionaty: myDictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">		<span class="comment">// 通过retain方法，将异常对象放入当前池而不是pool中，因为savedException定义的位置在pool定义之前。</span></span><br><span class="line">		savedException = [e retain];</span><br><span class="line">		<span class="comment">// pool在下面的@throw被调用之前就被释放了</span></span><br><span class="line">		<span class="keyword">@throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 销毁自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4    小结"></a>9.4    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/" itemprop="url">
                  8 Foundation Kit介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:55+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Cocoa</code>的几个重要框架</p>
</blockquote>
<table>
<thead>
<tr>
<th>框架</th>
<th>说明</th>
<th>兼容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Foundation Kit</td>
<td>两类UI框架的基础，包含很多有用的、面向数据的简单类和数据类型</td>
<td>ios和OS X</td>
<td>基于CoreFoundation框架</td>
</tr>
<tr>
<td>Application Kit(Appkit)</td>
<td>包含所有用户界面对象和高级类</td>
<td>OS X</td>
<td><a href="">16章</a></td>
</tr>
<tr>
<td>User Interface Kit(UIKit)</td>
<td>用户界面</td>
<td>ios</td>
<td><a href="">15章</a></td>
</tr>
</tbody>
</table>
<h2 id="8-1-稳固的-Foundation"><a href="#8-1-稳固的-Foundation" class="headerlink" title="8.1    稳固的 Foundation"></a>8.1    稳固的 Foundation</h2><blockquote>
<p><strong>说明：</strong>两类UI框架的基础，包含很多有用的、面向数据的简单类和数据类型。包含<code>NSString</code>、<code>NSArray</code>、<code>NSEnumerator</code>、和<code>NSNumber</code>等100多个类。<br><strong>扩展：</strong><code>Foundation</code>框架以<code>CoreFoundation</code>框架为（纯C编写）基础，<code>CoreFoundation</code>中的函数和变量的名称以<code>CF</code>开头。</p>
</blockquote>
<h2 id="8-2-使用项目样本代码"><a href="#8-2-使用项目样本代码" class="headerlink" title="8.2    使用项目样本代码"></a>8.2    使用项目样本代码</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-一些有用的数据类型"><a href="#8-3-一些有用的数据类型" class="headerlink" title="8.3    一些有用的数据类型"></a>8.3    一些有用的数据类型</h2><h3 id="8-3-1-范围"><a href="#8-3-1-范围" class="headerlink" title="8.3.1    范围"></a>8.3.1    范围</h3><blockquote>
<p><strong>类型：</strong><code>NSRange</code><br><strong>原型描述：</strong><code>Foundation.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span> _<span class="built_in">NSRange</span> &#123;</span><br><span class="line">&gt;    <span class="keyword">unsigned</span> <span class="keyword">int</span> location;</span><br><span class="line">&gt;    <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">&gt;&#125; <span class="built_in">NSRange</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>用来表示相关事物的范围，通常是字符串里字符范围或者数组里的元素范围。有<code>3</code>中创建方式</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：直接给字段赋值</span></span><br><span class="line"><span class="built_in">NSRange</span> range1;</span><br><span class="line">range.location = <span class="number">17</span>;</span><br><span class="line">range.length = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 方式二：利用c语言的聚合结构赋值机制</span></span><br><span class="line"><span class="built_in">NSRange</span> range2 = &#123;<span class="number">17</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 方式三：Cocoa提供的一个快捷函数NSMakeRange，优点是能够在任何能够使用函数的地方使用</span></span><br><span class="line"><span class="built_in">NSRange</span> range3 = <span class="built_in">NSMakeRange</span>(<span class="number">17</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h3 id="8-3-2-几何数据类型"><a href="#8-3-2-几何数据类型" class="headerlink" title="8.3.2    几何数据类型"></a>8.3.2    几何数据类型</h3><blockquote>
<p><strong>源：</strong><code>Cocoa</code>（引用<code>C</code>语言编写的<code>Core Graphics</code>框架）<br><strong>说明：</strong>包括一些用来处理图形的<code>数据类型</code>和创建这些数据类型的<code>快捷方法</code>。<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">CGPoint</span> &#123;</span><br><span class="line">	<span class="keyword">float</span> x;</span><br><span class="line">	<span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGSize</span> &#123;</span><br><span class="line">	<span class="keyword">float</span> width;</span><br><span class="line">	<span class="keyword">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</span><br><span class="line">	<span class="built_in">CGPoint</span> origin;</span><br><span class="line">	<span class="built_in">CGSize</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>所有的<code>O-C</code>对象都是动态分配的，而动态分配是一个代价较大的操作，会消耗大量的时间。所以为了性能，<code>GUI</code>程序更倾向使用结构体。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 矩形原点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 矩形大小</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 矩形</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-字符串"><a href="#8-4-字符串" class="headerlink" title="8.4    字符串"></a>8.4    字符串</h2><h3 id="8-4-1-创建字符串"><a href="#8-4-1-创建字符串" class="headerlink" title="8.4.1    创建字符串"></a>8.4.1    创建字符串</h3><h4 id="stringWithFormat方法"><a href="#stringWithFormat方法" class="headerlink" title="stringWithFormat方法"></a>stringWithFormat方法</h4><blockquote>
<p><strong>说明：</strong>通过格式字符串和参数来创建<code>NSString</code><br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; format 格式串</span><br><span class="line">* @param &#123;...&#125; 对应参数</span><br><span class="line">* @reuturn &#123;id&#125; NSString对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) stringWithFormat: (<span class="built_in">NSString</span> *) format, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *height;</span><br><span class="line">height = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Your height is %d feet, %d inches"</span>, <span class="number">5</span>, <span class="number">11</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-类方法"><a href="#8-4-2-类方法" class="headerlink" title="8.4.2    类方法"></a>8.4.2    类方法</h3><blockquote>
<p><strong>说明：</strong>如果在声明方法时添加了<code>+</code>，就是把这个方法定义为<code>类方法(class method)</code>。</p>
<ul>
<li>通常用于工厂方法</li>
<li>也可以用来访问全局数据</li>
</ul>
<p><strong>原理：</strong><code>Objective-C</code>运行时生成一个类的时候，会创建一个代表该类的<code>类对象（class object）</code>，包含了指向超类、类名和类方法列表的指针，还包含一个<code>long</code>类型的数据，为新创建的实例对象指定大小（以字节为单位）。</p>
<p><strong>扩展：</strong>类方法和实例方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>标识</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>类方法</td>
<td>属于类的方法</td>
</tr>
<tr>
<td>-</td>
<td>实例方法</td>
<td>将会在指定的对象实例中起作用</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIColor的类方法：redColor（访问全局数据）</span></span><br><span class="line"><span class="built_in">NSColor</span> *haveTheBlues = [<span class="built_in">NSColor</span> blueColor];</span><br><span class="line"><span class="built_in">UIColor</span> *blueMan = [<span class="built_in">UIColor</span> blueColor];</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-关于大小"><a href="#8-4-4-关于大小" class="headerlink" title="8.4.4    关于大小"></a>8.4.4    关于大小</h3><h4 id="length实例方法"><a href="#length实例方法" class="headerlink" title="length实例方法"></a>length实例方法</h4><blockquote>
<p><strong>说明：</strong>返回字符串中字符的个数，能够准确无误地处理各种语言的字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return &#123;NSUInter&#125; 字符串中字符的数目</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;- (<span class="built_in">NSUInter</span>) length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>在C语言中处理这些国际字符串很麻烦，因为一个字符占用的空间可能多于一个字节，使用<code>strlen</code>只能计算字节数的函数会返回错误的数值。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> height = <span class="string">@"Hello world!"</span>;</span><br><span class="line"><span class="keyword">if</span> ([height length] &gt; <span class="number">35</span>) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"wow, you're really tail!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-字符串比较"><a href="#8-4-4-字符串比较" class="headerlink" title="8.4.4    字符串比较"></a>8.4.4    字符串比较</h3><h4 id="isEqualToString实例方法"><a href="#isEqualToString实例方法" class="headerlink" title="isEqualToString实例方法"></a>isEqualToString实例方法</h4><blockquote>
<p><strong>说明：</strong>比较接收方和作为参数传递过来的字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @return &#123;BOOL&#125; YES 内容相同，NO 内容不同</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) isEqualToString: (<span class="built_in">NSString</span> *) aString</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong><code>==</code>运算符用来检查两个对象是否为同一事物；<code>isEqualToString</code>用来检查两个字符串的内容是否相等。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="built_in">NSString</span> *thing1 = <span class="string">@"hello 5"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *thing2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello %d"</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([thing1 isEqualToString:thing2]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"They are the same."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="compare实例方法"><a href="#compare实例方法" class="headerlink" title="compare实例方法"></a>compare实例方法</h4><blockquote>
<p><strong>说明：</strong>将接收对象和传递过来的字符串逐个进行比较</p>
<ul>
<li>区分大小写</li>
<li>返回一个显示比较结果的枚举类型</li>
</ul>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @return &#123;NSComparisonResult&#125; 包含比较结果的枚举类型</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>) compare: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>返回值原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">NSOrderedAscending</span> = <span class="number">-1</span>;<span class="comment">// 左侧小于右侧</span></span><br><span class="line">    <span class="built_in">NSOrderdSame</span>,<span class="comment">// 两侧字符串相同</span></span><br><span class="line">    <span class="built_in">NSOrderdDescending</span><span class="comment">// 左侧大于右侧</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span> <span class="built_in">NSComparisonResult</span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-5-不区分大小写的比较"><a href="#8-4-5-不区分大小写的比较" class="headerlink" title="8.4.5    不区分大小写的比较"></a>8.4.5    不区分大小写的比较</h3><h4 id="compare实例方法（2个参数）"><a href="#compare实例方法（2个参数）" class="headerlink" title="compare实例方法（2个参数）"></a>compare实例方法（2个参数）</h4><blockquote>
<p><strong>说明：</strong>比较字符串，有更多选择权，可以使用<code>位</code>或<code>bitwise-OR远端符（|）</code>来添加选项标记。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSCaseInsensitiveSearch</td>
<td>不区分大小写字符</td>
</tr>
<tr>
<td>NSLiteralSearch</td>
<td>进行完全比较，区分大小写</td>
</tr>
<tr>
<td>NSNumericSearch</td>
<td>比较字符串的字符个数，而不是字符串值</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @option &#123;NSStringCompareOption&#125; mask 比较选项</span><br><span class="line">* @return &#123;NSComparisonResult&#125; 包含比较结果的枚举类型</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>) compare: (<span class="built_in">NSString</span> *) aString</span><br><span class="line">options: (<span class="built_in">NSStringCompareOption</span>) mask;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不区分大小写、比较字符串的字符个数（而不是值）</span></span><br><span class="line"><span class="keyword">if</span> ([thing1 compare:thing2 options:<span class="built_in">NSCaseInsensitiveSearch</span> | <span class="built_in">NSNumericSearch</span>] == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"They match!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-6-字符串是否还包含别的字符串"><a href="#8-4-6-字符串是否还包含别的字符串" class="headerlink" title="8.4.6    字符串是否还包含别的字符串"></a>8.4.6    字符串是否还包含别的字符串</h3><h3 id="hasPrefix实例方法"><a href="#hasPrefix实例方法" class="headerlink" title="hasPrefix实例方法"></a>hasPrefix实例方法</h3><blockquote>
<p><strong>说明：</strong>检查字符串是否是以另一个字符串开头<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*@return &#123;BOOL&#125; YES， NO</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) hasPrefix: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<h3 id="hasSuffix实例方法"><a href="#hasSuffix实例方法" class="headerlink" title="hasSuffix实例方法"></a>hasSuffix实例方法</h3><blockquote>
<p><strong>说明：</strong>检查字符串是否是以另一个字符串结尾<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*@return &#123;BOOL&#125; YES ， NO</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) hasSuffix: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *fileName = <span class="string">@"draft-chapter.pages"</span>;</span><br><span class="line"><span class="keyword">if</span> ([fileName hasPrefix:<span class="string">@"draft"</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"this is a draft."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ([fileName hasSuffix:<span class="string">@".mov"</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"this is a movie"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rangeOfString实例方法"><a href="#rangeOfString实例方法" class="headerlink" title="rangeOfString实例方法"></a>rangeOfString实例方法</h4><blockquote>
<p><strong>说明：</strong>查看字符串的某处是否包含指定子字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; rangeOfString 子字符串</span><br><span class="line">* @return &#123;NSRange&#125; 包含匹配的位置信息和能够匹配上的字符个数</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSRange</span>) rangeOfString: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意位置</span></span><br><span class="line"><span class="built_in">NSRange</span> range = [fileName rangeOfString:<span class="string">@"chapter"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"range.location:%d, range.length: %d"</span>, range.location, range.length);</span><br></pre></td></tr></table></figure>
<h3 id="8-4-7-可变性"><a href="#8-4-7-可变性" class="headerlink" title="8.4.7    可变性"></a>8.4.7    可变性</h3><blockquote>
<p><strong>说明：</strong><code>NSString</code>是不可变（不能通过删除字符或添加字符的方式改变它）。的，<code>NSMutableString</code>是可变的。<br><strong>注意：</strong><code>NSMutableString</code>是<code>NSString</code>的子类。</p>
</blockquote>
<h4 id="stringWithCapacity类方法"><a href="#stringWithCapacity类方法" class="headerlink" title="stringWithCapacity类方法"></a>stringWithCapacity类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个新的<code>NSMutableString</code></p>
<ul>
<li><strong>参数：</strong>字符串的大小并不限于所提供的容量，这个容量仅是最优值，用来预分配一块内存，这样后续操作的速度会快很多。</li>
</ul>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSInteger&#125; 最优容量</span><br><span class="line">* @return &#123;id&#125; NSMutable对象</span><br><span class="line">*/</span></span><br><span class="line">+ <span class="keyword">id</span> stringWithCapacity: (<span class="built_in">NSUInteger</span>) capacity;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可变字符串对象</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithCapacity: <span class="number">42</span>];</span><br></pre></td></tr></table></figure>
<h4 id="appendString实例方法"><a href="#appendString实例方法" class="headerlink" title="appendString实例方法"></a>appendString实例方法</h4><blockquote>
<p><strong>说明：</strong>接收参数<code>aString</code>，然后将其复制到接收对象的末尾。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) appendString: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<h4 id="appendFormat实例方法"><a href="#appendFormat实例方法" class="headerlink" title="appendFormat实例方法"></a>appendFormat实例方法</h4><blockquote>
<p><strong>说明：</strong>将格式化的字符串附加在接收字符串的末尾<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; format 格式串</span><br><span class="line">* @param &#123;...&#125; 格式串对应的值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) appendFormat: (<span class="built_in">NSString</span> *) format, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变字符串方法</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> stringWithCapacity:<span class="number">50</span>];</span><br><span class="line">[mString appendString:<span class="string">@"Hello there!"</span>];</span><br><span class="line">[mString appendFormat:<span class="string">@"human %d"</span>, <span class="number">42</span>];</span><br></pre></td></tr></table></figure>
<h4 id="deleteCharactersInRange实例方法"><a href="#deleteCharactersInRange实例方法" class="headerlink" title="deleteCharactersInRange实例方法"></a>deleteCharactersInRange实例方法</h4><blockquote>
<p><strong>说明：</strong>删除字符串中的字符。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSRange&#125; aRange 指定删除的部分坐在的区域</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) deleteCharactersInRange: (<span class="built_in">NSRange</span>) aRange;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可变字符串对象</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *friends = [<span class="built_in">NSMutableString</span> stringWithCapacity: <span class="number">50</span>];</span><br><span class="line"><span class="comment">// 查找子串</span></span><br><span class="line"><span class="built_in">NSRange</span> jackRange = [friends tangeOfString: <span class="string">@"Jack"</span>];</span><br><span class="line">jackRange.length++;<span class="comment">// eat the space that follows</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除"Jack"</span></span><br><span class="line">[friends deleteCharactersInRange: jackRange];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承自NSString的实例方法</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> strringWithFormat: <span class="string">@"jo%dy"</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h2 id="8-5-集合大家族"><a href="#8-5-集合大家族" class="headerlink" title="8.5    集合大家族"></a>8.5    集合大家族</h2><h3 id="8-5-1-NSArray"><a href="#8-5-1-NSArray" class="headerlink" title="8.5.1    NSArray"></a>8.5.1    NSArray</h3><blockquote>
<p><strong>说明：</strong>一个<code>Cocoa</code>类，用来存储对象的有序列表</p>
<ul>
<li>通过<code>工厂方法</code>创建</li>
<li>通过<code>字面量</code>创建（不需要在结尾处不上<code>nil</code>）</li>
</ul>
<p><strong>限制：</strong>有2个限制</p>
<ul>
<li>只能存储<code>Object-C</code>对象，不能存储原始的C语言基础数据类型</li>
<li>不能使用<code>nil（对象的零值）</code></li>
</ul>
<p><strong>技巧：</strong>可以通过一些<code>NSArray</code>的方法避开这些限制<br><strong>注意：</strong>为什么不能在<code>NSArray</code>中存放<code>nil</code>？</p>
<ul>
<li>使用工厂方法创建数组时，最后一个参数<code>nil</code>用来表示参数列表的末尾</li>
<li>没有办法判断<code>nil</code>是存储在数组中的数值还是代表循环结束的标志。</li>
</ul>
</blockquote>
<h4 id="arrayWithObjects类方法"><a href="#arrayWithObjects类方法" class="headerlink" title="arrayWithObjects类方法"></a>arrayWithObjects类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个新的<code>NSArray</code>，可以发送一个以<code>,</code>分隔的对象列表，在列表结尾添加<code>nil</code>代表列表结束。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id ...&#125; 对象列表</span><br><span class="line">* @return &#123;NSArray&#125; 数组</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>) arrayWithObjects(<span class="keyword">id</span> ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工厂方法创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array2 = @[<span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="objectAtIndex实例方法"><a href="#objectAtIndex实例方法" class="headerlink" title="objectAtIndex实例方法"></a>objectAtIndex实例方法</h4><blockquote>
<p><strong>说明：</strong>索引数组元素。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数组中的对象</span></span><br><span class="line"><span class="keyword">id</span> *myObject = array1[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (NAInteger i = <span class="number">0</span>; i &lt; [array count]; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过方法索引</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %d has %@."</span>, i, [array1 objectAtIndex:i]);</span><br><span class="line">    <span class="comment">// 通过下标（字面量方式）索引</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %d has %@."</span>, i, array1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切分数组"><a href="#切分数组" class="headerlink" title="切分数组"></a>切分数组</h3><h4 id="componentsSepartedByString实例方法"><a href="#componentsSepartedByString实例方法" class="headerlink" title="componentsSepartedByString实例方法"></a>componentsSepartedByString实例方法</h4><blockquote>
<p><strong>说明：</strong>将字符串切分为数组。</p>
</blockquote>
<h4 id="componentsJoinedByString实例方法"><a href="#componentsJoinedByString实例方法" class="headerlink" title="componentsJoinedByString实例方法"></a>componentsJoinedByString实例方法</h4><blockquote>
<p><strong>说明：</strong>合并<code>NSArray</code>中的元素并创建字符串。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"oop:ack:bork:greeble:poines"</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *chunks = [string componentsSeparatedByString:<span class="string">@":"</span>];</span><br><span class="line">string = [chunks componentsJoinedByString:<span class="string">@":-)"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-2-可变数组"><a href="#8-5-2-可变数组" class="headerlink" title="8.5.2    可变数组"></a>8.5.2    可变数组</h3><blockquote>
<p><strong>说明：</strong><code>NSArray</code>是不可变对象的数组，<code>NSMutableArray</code>是可变数组。<br><strong>注意：</strong>没有可以用来创建<code>NSMutableArray</code>对象的字面量语法。</p>
</blockquote>
<h4 id="arrayWithCapacity类方法"><a href="#arrayWithCapacity类方法" class="headerlink" title="arrayWithCapacity类方法"></a>arrayWithCapacity类方法</h4><blockquote>
<p><strong>说明：</strong>创建新的可变数组。<br><strong>原型：</strong><code>NSMutableString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSInteger&#125; 容量</span><br><span class="line">* @return &#123;id&#125; 可变数组</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) arrayWithCapacity: (<span class="built_in">NSInteger</span>) numItems;</span><br></pre></td></tr></table></figure>
<h4 id="removeObjectAtIndex实例方法"><a href="#removeObjectAtIndex实例方法" class="headerlink" title="removeObjectAtIndex实例方法"></a>removeObjectAtIndex实例方法</h4><blockquote>
<p><strong>说明：</strong>删除指定索引处的对象。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSUInteger&#125; index 下标</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) removeObjectAtIndex: (<span class="built_in">NSUInteger</span>) index;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-遍历"><a href="#8-5-3-遍历" class="headerlink" title="8.5.3    遍历"></a>8.5.3    遍历</h3><blockquote>
<p><strong>说明：</strong>有<code>4</code>种方式</p>
<ul>
<li>从0到<code>[array count]</code>循环</li>
<li>使用迭代器：<code>NSEnumerator</code></li>
<li>使用快速迭代：<code>for-in</code>（10.5+）</li>
<li>使用代码块（依赖苹果最新的编译器：基于<code>CLang</code>和<code>LLVM</code>项目）</li>
</ul>
</blockquote>
<h4 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h4><blockquote>
<p><strong>说明：</strong>迭代器，<code>Cocoa</code>用它来表示集合中迭代出的对象。</p>
</blockquote>
<h4 id="objectEnumerator实例方法"><a href="#objectEnumerator实例方法" class="headerlink" title="objectEnumerator实例方法"></a>objectEnumerator实例方法</h4><blockquote>
<p><strong>说明：</strong>获取数组对应的迭代器(从前往后迭代)。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSEnumerator *&#125; 迭代器</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)objectEnumerator;</span><br></pre></td></tr></table></figure>
<h4 id="reverseObjectEnumerator实例方法"><a href="#reverseObjectEnumerator实例方法" class="headerlink" title="reverseObjectEnumerator实例方法"></a>reverseObjectEnumerator实例方法</h4><blockquote>
<p><strong>说明：</strong>获取数组对应的迭代器(从后往前迭代)。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSEnumerator *&#125; 迭代器</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)reverseObjectEnumerator;</span><br></pre></td></tr></table></figure>
<h4 id="nextObject实例方法"><a href="#nextObject实例方法" class="headerlink" title="nextObject实例方法"></a>nextObject实例方法</h4><blockquote>
<p><strong>说明：</strong>请求迭代器的下一个对象，返回<code>nil</code>时迭代结束。<br><strong>原型：</strong><code>NSEnumerator</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 迭代器迭代的一个对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) nextObject;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>获取<code>可变数组</code>的迭代器后，如果再通过添加或删除对象<code>改变了数组的容量</code>，枚举起就会出现混乱。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过字面量创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>];</span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *enumerator = [array objectEnumerator];</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">id</span> thingie = [enumerator nextObject]) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, thingie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-4-快速迭代"><a href="#8-5-4-快速迭代" class="headerlink" title="8.5.4    快速迭代"></a>8.5.4    快速迭代</h3><blockquote>
<p><strong>说明：</strong>在<code>Mac OS x 10.5</code>，<code>O-C</code>升级到<code>2.0</code>，引入了<code>快速枚举（迭代）</code>，类似一些脚本语言的<code>for-in</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> array) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enumerateObjectsUsingBlock实例方法"><a href="#enumerateObjectsUsingBlock实例方法" class="headerlink" title="enumerateObjectsUsingBlock实例方法"></a>enumerateObjectsUsingBlock实例方法</h4><blockquote>
<p><strong>说明：</strong>为了支持C语言的代码块功能，苹果公司添加了一个能在<code>NSArray</code>中通过<code>代码块</code>迭代对象的方法。<br><strong>优点：</strong>通过代码块可以让循环操作并发执行，而通过快速枚举，执行操作要一项项线性完成。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; string 迭代项</span><br><span class="line">* @param &#123;NSUInteger&#125; index 下标</span><br><span class="line">* @param &#123;BOOL *&#125; stop </span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) enumerateObjectUsingBlock:^(<span class="built_in">NSString</span> *string, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *string, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, string);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-5-NSDictionary"><a href="#8-5-5-NSDictionary" class="headerlink" title="8.5.5    NSDictionary"></a>8.5.5    NSDictionary</h3><blockquote>
<p><strong>说明：</strong>字典是关键字及其定义的合集。<br><strong>扩展：</strong>字典使用的是键查询的优化方式，可以立即找到要查询的数据，而不需要遍历整个数组。</p>
</blockquote>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><blockquote>
<p><strong>说明：</strong>创建字典最简单的方式就是用字典字面量。<br><strong>语法：</strong><code>@{key: value, ...}</code></p>
</blockquote>
<h4 id="dictionaryWithObjectsAndKeys类方法"><a href="#dictionaryWithObjectsAndKeys类方法" class="headerlink" title="dictionaryWithObjectsAndKeys类方法"></a>dictionaryWithObjectsAndKeys类方法</h4><blockquote>
<p><strong>说明：</strong>创建字典对象<br><strong>原型：</strong><code>NSDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id ...&#125; 键值对列表</span><br><span class="line">* @return &#123;id&#125; 字典对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) dictionaryWithObjectsAndKeys: (<span class="keyword">id</span>) firstObject, ...;</span><br></pre></td></tr></table></figure>
<h4 id="objectForKey实例方法"><a href="#objectForKey实例方法" class="headerlink" title="objectForKey实例方法"></a>objectForKey实例方法</h4><blockquote>
<p><strong>说明：</strong>根据<code>关键字</code>访问字典中的<code>值</code>。<br><strong>原型：</strong><code>NSDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; aKey 键</span><br><span class="line">* @return &#123;id&#125; 值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) objectForKey: (<span class="keyword">id</span>) aKey;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">Tire *t1 = [Tire new];</span><br><span class="line">Tire *t2 = [Tire new];</span><br><span class="line">Tire *t3 = [Tire new];</span><br><span class="line">Tire *t4 = [Tire new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象实例构建字典（工厂方法）</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *tires1 = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: t1, <span class="string">@"front-left"</span>, t2, <span class="string">@"front-right"</span>, t3, <span class="string">@"back-left"</span>, t3, <span class="string">@"back-left"</span>, t4, <span class="string">@"back-right"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用对象实例构建字典（字面量）</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *tires2 = @&#123;<span class="string">@"front-left"</span>: t1, <span class="string">@"front-right"</span>: t2, <span class="string">@"back-left"</span>: t3, <span class="string">@"back-right"</span>: t4&#125;;</span><br><span class="line"><span class="comment">// 通过方法索引</span></span><br><span class="line">Tire *tire = [tires objectForKey: <span class="string">@"back-right"</span>];</span><br><span class="line"><span class="comment">// 通过字面量索引</span></span><br><span class="line">tire = tires[<span class="string">@"back-right"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="可变字典"><a href="#可变字典" class="headerlink" title="可变字典"></a>可变字典</h4><blockquote>
<p><strong>说明：</strong><code>NSDictionary</code>容量是不可变的，<code>NSMutableDictionary</code>是可变的。<br><strong>注意：</strong>没有适用于<code>NSMutableDictionary</code>的字面量初始化语法。</p>
</blockquote>
<h5 id="dictionary类方法"><a href="#dictionary类方法" class="headerlink" title="dictionary类方法"></a>dictionary类方法</h5><blockquote>
<p><strong>说明：</strong>创建<code>NSMutableDictionary</code>实例。<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; NSMutableDictionary实例</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) dictionary;</span><br></pre></td></tr></table></figure>
<h5 id="dictionaryWithCapacity类方法"><a href="#dictionaryWithCapacity类方法" class="headerlink" title="dictionaryWithCapacity类方法"></a>dictionaryWithCapacity类方法</h5><blockquote>
<p><strong>说明：</strong>创建新的可变字典并告诉<code>Cocoa</code>该字典的最优大小。<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSUInteger&#125; numItems 最优容量</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) dictionaryWithCapacity: (<span class="built_in">NSUInteger</span>) numItems;</span><br></pre></td></tr></table></figure>
<h5 id="setObject实例方法"><a href="#setObject实例方法" class="headerlink" title="setObject实例方法"></a>setObject实例方法</h5><blockquote>
<p><strong>说明：</strong>为字典添加（设置）元素<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; anObject 值</span><br><span class="line">* @param &#123;id&#125; aKey  键</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) setObject: (<span class="keyword">id</span>)anObject forKey: (<span class="keyword">id</span>)aKey;</span><br></pre></td></tr></table></figure>
<h5 id="removeObjectForKey实例方法"><a href="#removeObjectForKey实例方法" class="headerlink" title="removeObjectForKey实例方法"></a>removeObjectForKey实例方法</h5><blockquote>
<p><strong>说明：</strong>在可变字典中删除元素<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; aKey 要删除的元素的键</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) removeObjectForKey: (<span class="keyword">id</span>) aKey;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可变字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *tires = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">Tire *t1 = [Tire new];</span><br><span class="line">Tire *t2 = [Tire new];</span><br><span class="line">Tire *t3 = [Tire new];</span><br><span class="line">Tire *t4 = [Tire new];</span><br><span class="line"><span class="comment">// 为字典添加元素</span></span><br><span class="line">[tires setObject: t1 forKey: <span class="string">@"front-left"</span>];</span><br><span class="line">[tires setObject: t2 forKey: <span class="string">@"front-right"</span>];</span><br><span class="line">[tires setObject: t3 forKey: <span class="string">@"back-left"</span>];</span><br><span class="line">[tires setObject: t4 forKey: <span class="string">@"back-right"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">[tires removeObjectForKey: <span class="string">@"back-left"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-6-请不要乱来"><a href="#8-5-6-请不要乱来" class="headerlink" title="8.5.6    请不要乱来"></a>8.5.6    请不要乱来</h3><blockquote>
<p><strong>类蔟：</strong>一群隐藏在通用接口之下与实现相关的类。<br><strong>说明：</strong>在<code>Cocoa</code>中，许多类实际上是以<code>类蔟</code>的方式实现。比如，创建<code>NSString</code>对象时，实际上获得的可能是<code>NSLiteralString</code>、<code>NSCFString</code>、<code>NSSimpleCString</code>、<code>NSBallOfString</code>或者其他未写入文档的与实现相关的对象。<br><strong>技巧：</strong>不要尝试给一个<code>类蔟</code>创建子类，可以将<code>NSString</code>或<code>NSArray</code>复合到某个类中或者使用别类。</p>
</blockquote>
<h2 id="8-6-其他数值"><a href="#8-6-其他数值" class="headerlink" title="8.6    其他数值"></a>8.6    其他数值</h2><blockquote>
<p><strong>说明：</strong><code>NSArray</code>和<code>NSDictionary</code>只能存储对象，而不能直接存储任何基本类型的数据，如<code>int</code>、<code>float</code>和<code>struct</code>。<br><strong>技巧：</strong>可以用对象封装基本数据类型，然后再放入<code>NSArray</code>或<code>NSDictionary</code>。<br><strong>注意：</strong><code>Objective-C</code>不支持<code>自动开箱</code>和<code>自动装箱</code>。</p>
</blockquote>
<h3 id="8-6-1-NSNumber"><a href="#8-6-1-NSNumber" class="headerlink" title="8.6.1    NSNumber"></a>8.6.1    NSNumber</h3><blockquote>
<p><strong>说明：</strong>可以用来封装和数字相关的一些基本数据类型。<br><strong>工厂方法：</strong>以最常用的为例</p>
<ul>
<li><code>+ (NSNumber *) numberWithChar: (char) value;</code></li>
<li><code>+ (NSNumber *) numberWithInt: (int) value;</code></li>
<li><code>+ (NSNumber *) numberWithFloat: (float) value;</code></li>
<li><code>+ (NSNumber *) numberWithBool: (BOOL) value;</code></li>
</ul>
<p><strong>实例方法：</strong>从<code>NSNumber</code>中提取数值</p>
<ul>
<li><code>- (char) charValue</code></li>
<li><code>- (int) intValue</code></li>
<li><code>- (float) floatValue</code></li>
<li><code>- (BOOL) boolValue</code></li>
<li><code>- (NSString *) stringValue</code></li>
</ul>
<p><strong>字面量：</strong>可以使用字面量语法创建<code>NSNumber</code>对象</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装几本类型</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number;</span><br><span class="line">number = @<span class="string">'X'</span>;<span class="comment">// 字符型</span></span><br><span class="line">number = @<span class="number">12345</span>;<span class="comment">// 整型</span></span><br><span class="line">number = @<span class="number">12345</span>ul;<span class="comment">// 无符号长整数</span></span><br><span class="line">number = @<span class="number">12345</span>ll;<span class="comment">// long long</span></span><br><span class="line">number = @<span class="number">123</span>,<span class="number">45</span>f;<span class="comment">// 浮点型</span></span><br><span class="line">number = @<span class="number">123</span>,<span class="number">45</span>;<span class="comment">// 双浮点型</span></span><br><span class="line">number = @YES;<span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity];</span><br><span class="line"><span class="comment">// 存储到数组中</span></span><br><span class="line">[array addObject number];</span><br><span class="line">[dictionary setObject: number forKey: @:<span class="string">"Bork"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-6-2-NSValue"><a href="#8-6-2-NSValue" class="headerlink" title="8.6.2    NSValue"></a>8.6.2    NSValue</h3><blockquote>
<p><strong>说明：</strong><code>NSValue</code>可以封装任意值。<br><strong>扩展：</strong><code>NSNumber</code>是<code>NSValue</code>的子类。</p>
</blockquote>
<h4 id="valueWithBytes类方法"><a href="#valueWithBytes类方法" class="headerlink" title="valueWithBytes类方法"></a>valueWithBytes类方法</h4><blockquote>
<p><strong>说明：</strong>创建新的<code>NSValue</code>对象。<br><strong>原型：</strong><code>NSValue</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;const void *&#125; value 要存储的变量的地址</span><br><span class="line">* @param &#123;const char *&#125; type 描述数据类的字符串</span><br><span class="line">* @return &#123;NSValue *&#125; NSValue对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSValue</span> *) valueWithBytes: (<span class="keyword">const</span> <span class="keyword">void</span> *) value objCType: (<span class="keyword">const</span> <span class="keyword">char</span> *) type;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>工厂方法：</strong><code>NSValue</code>，举例</p>
<ul>
<li><code>(NSValue *)valueWithPoint: (NSPoint) aPoint;</code></li>
<li><code>(NSValue *)valueWithSize: (NSSize) size;</code></li>
<li><code>(NSValue *)valueWithRect: (NSRect);</code></li>
</ul>
<p><strong>实例方法：</strong><code>NSValue</code>, 会进行类型转换</p>
<ul>
<li><code>(NSPoint)pointValue;</code></li>
<li><code>(NSSize)sizeValue;</code></li>
<li><code>(NSRect)rectValue;</code></li>
</ul>
</blockquote>
<h4 id="getValue实例方法"><a href="#getValue实例方法" class="headerlink" title="getValue实例方法"></a>getValue实例方法</h4><blockquote>
<p><strong>说明：</strong>提取数值，返回一个<code>NSValue</code>型值。<br><strong>注意：</strong>方法名中使用了<code>get</code>，表明我们提供的是一个指针，而指针所指向的空间则用来存储该方法生成的数据。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象（struct）</span></span><br><span class="line"><span class="built_in">NSRect</span> rect = <span class="built_in">NSMakeRect</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">// 包装包NSValue型值中</span></span><br><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithBytes:&amp;rect objCType:@encode(<span class="built_in">NSRect</span>)];</span><br><span class="line"><span class="comment">// 添加到数组中</span></span><br><span class="line">[array addObject:value];</span><br><span class="line">value = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 提取数值</span></span><br><span class="line">[value getValue:&amp;rect];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疯转NSRect</span></span><br><span class="line">value = [<span class="built_in">NSValue</span> valueWithRect:rect];</span><br><span class="line"><span class="comment">// 添加到数组</span></span><br><span class="line">[array addObject:value];</span><br><span class="line"><span class="comment">// 提取NSRect型值</span></span><br><span class="line"><span class="built_in">NSRect</span> anotherRect = [value rectValue];</span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-NSNull"><a href="#8-6-3-NSNull" class="headerlink" title="8.6.3    NSNull"></a>8.6.3    NSNull</h3><blockquote>
<p><strong>说明：</strong>集合中不能放入<code>nil</code>，但可以放入<code>NSNull</code>。</p>
</blockquote>
<h4 id="null类方法"><a href="#null类方法" class="headerlink" title="null类方法"></a>null类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个<code>NSNull</code>实例<br><strong>原型：</strong><code>NSNull</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSNull *&#125; NSNull实例</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSNull</span> *) null;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想通讯录中加入一条信息（没有传真号）</span></span><br><span class="line">[contact setObject: [<span class="built_in">NSNull</span> null] forKey: <span class="string">@"home fax machine"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引这条信息</span></span><br><span class="line"><span class="keyword">id</span> homefax = [contact objectForKey: <span class="string">@"home fax machine"</span>];</span><br><span class="line"><span class="keyword">if</span> (homefax == [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">	<span class="comment">// 确实没有传真机</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-7-示例：查找文件"><a href="#8-7-示例：查找文件" class="headerlink" title="8.7    示例：查找文件"></a>8.7    示例：查找文件</h2><h3 id="8-7-1-使用迭代器的版本"><a href="#8-7-1-使用迭代器的版本" class="headerlink" title="8.7.1    使用迭代器的版本"></a>8.7.1    使用迭代器的版本</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建文件管理器</span></span><br><span class="line">        <span class="built_in">NSFileManager</span> *manager;</span><br><span class="line">        manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将~替换为相应的绝对目录</span></span><br><span class="line">        <span class="built_in">NSString</span> *home;</span><br><span class="line">        home = [<span class="string">@"~"</span> stringByExpandingTildeInPath];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取相应路径下文件集合的迭代器</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *direnum;</span><br><span class="line">        direnum = [manager enumeratorAtPath:home];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建存放文件的可变数组</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *files;</span><br><span class="line">        files = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">42</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过迭代器遍历寻找目标文件</span></span><br><span class="line">        <span class="built_in">NSString</span> *filename;</span><br><span class="line">        <span class="keyword">while</span> (filename = [direnum nextObject])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看扩展名是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> ([[filename pathExtension] isEqualTo: <span class="string">@"jpg"</span>]) &#123;</span><br><span class="line">                [files addObject: filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过迭代器遍历匹配到的文件的文件名</span></span><br><span class="line">        <span class="built_in">NSEnumerator</span> *fileenum;</span><br><span class="line">        fileenum = [files objectEnumerator];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (filename = [fileenum nextObject])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-7-2-使用快速迭代的版本"><a href="#8-7-2-使用快速迭代的版本" class="headerlink" title="8.7.2    使用快速迭代的版本"></a>8.7.2    使用快速迭代的版本</h3><blockquote>
<p><strong>说明：</strong>不支持<code>Leopard</code>之前的版本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8    小结"></a>8.8    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_07  深入了解Xcode/" itemprop="url">
                  7 深入了解Xcode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:28+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_07  深入了解Xcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_07  深入了解Xcode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="7-1-窗口布局一览"><a href="#7-1-窗口布局一览" class="headerlink" title="7.1    窗口布局一览"></a>7.1    窗口布局一览</h2><blockquote>
<p><strong>说明：</strong>窗口的组成部分</p>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
<th>相关功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>工具栏</td>
<td>位于窗口的最顶端</td>
<td>上面由很多工具按钮</td>
</tr>
<tr>
<td>导航器面板</td>
<td>位于窗口的左边，通常用来显示项目中的文件列表，也可以浏览其他内容</td>
<td>符号(symbol)、搜索(Search)、问题(Issue)、调试(Debug)、断点(BreakPoints)、和日志(Logs)</td>
</tr>
<tr>
<td>编辑器面板</td>
<td>卫浴中间偏右的位置</td>
<td>大部分时间都在这里工作</td>
</tr>
<tr>
<td>检查器面板</td>
<td>位于窗口右边</td>
<td>显示的是与上下文有关的信息，以及修改选中项属性值的按钮</td>
</tr>
<tr>
<td>调试器面板</td>
<td>位于底部居中位置</td>
<td>调试器运行的时候，堆栈和调试器控制器会出现在这里</td>
</tr>
<tr>
<td>库面板</td>
<td>隐藏在窗口右下角</td>
<td>列有项目资源、对象、代码片段和其他在项目中可能会用到的东西</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-03%20%E4%B8%8B%E5%8D%8810.16.15.png" alt="Alt text"></p>
<h2 id="7-2-改变公司名称"><a href="#7-2-改变公司名称" class="headerlink" title="7.2    改变公司名称"></a>7.2    改变公司名称</h2><blockquote>
<p><strong>说明：</strong>公司的名称会出现在创建文件时自动生成的注释中。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-04%20%E4%B8%8A%E5%8D%8810.02.06.png" alt="Alt text"></p>
</blockquote>
<h2 id="7-3-使用编辑器的技巧"><a href="#7-3-使用编辑器的技巧" class="headerlink" title="7.3    使用编辑器的技巧"></a>7.3    使用编辑器的技巧</h2><blockquote>
<p><strong>说明：</strong>列举一下不同区域的使用的技巧<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-03%20%E4%B8%8B%E5%8D%8810.16.15.png" alt="Alt text"></p>
</blockquote>
<h3 id="7-3-1-导航器面板"><a href="#7-3-1-导航器面板" class="headerlink" title="7.3.1    导航器面板"></a>7.3.1    导航器面板</h3><blockquote>
<ol>
<li>导航器视图中使用<code>过滤搜索框</code>过滤列表文件（可以在任意导航器视图中使用）</li>
<li>双击源文件在新窗口中打开它</li>
</ol>
</blockquote>
<h3 id="7-3-2-工具栏"><a href="#7-3-2-工具栏" class="headerlink" title="7.3.2    工具栏"></a>7.3.2    工具栏</h3><blockquote>
<ol>
<li>右上方有一组标记为View的工具栏按钮，用来显示／隐藏部分窗口</li>
</ol>
</blockquote>
<h3 id="7-3-2-其它"><a href="#7-3-2-其它" class="headerlink" title="7.3.2    其它"></a>7.3.2    其它</h3><blockquote>
<ol>
<li>窗口顶端的工具栏下面看文件的路径</li>
<li>在多个标签页中打开多个视图：View(菜单) -&gt; Show Tab Bar -&gt; +</li>
</ol>
</blockquote>
<h2 id="7-4-在Xcode的帮助下编写代码"><a href="#7-4-在Xcode的帮助下编写代码" class="headerlink" title="7.4    在Xcode的帮助下编写代码"></a>7.4    在Xcode的帮助下编写代码</h2><h3 id="7-4-1-首行缩进（美观排版）"><a href="#7-4-1-首行缩进（美观排版）" class="headerlink" title="7.4.1    首行缩进（美观排版）"></a>7.4.1    首行缩进（美观排版）</h3><blockquote>
<p><strong>说明：</strong><code>O-C</code>并不要求缩进代码，但这么做是个好习惯。</p>
</blockquote>
<table>
<thead>
<tr>
<th>整理缩进</th>
<th>快捷键</th>
<th>菜单</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动整理缩进</td>
<td>Control + I</td>
<td>右键（代码编辑区）-&gt; Structure -&gt; Re Indent</td>
</tr>
<tr>
<td>向左缩进</td>
<td>Command + [</td>
<td>右键（代码编辑区）-&gt; Structure -&gt; Shift Right</td>
</tr>
<tr>
<td>向右缩进</td>
<td>Command + [</td>
<td>左键（代码编辑区）-&gt; Structure -&gt; Shift Left</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>设置<code>自动整理</code>的风格：Xcode(菜单) -&gt; Preferences -&gt; Text Editing -&gt; Indentation</p>
</blockquote>
<h3 id="7-4-2-代码自动完成"><a href="#7-4-2-代码自动完成" class="headerlink" title="7.4.2    代码自动完成"></a>7.4.2    代码自动完成</h3><blockquote>
<p><strong>说明：</strong>当输入代码时，Xcode 会不断地比较你输入的代码和它生成的符号索引，如果两者匹配，Xcode就会给出建议。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关快捷键</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Control + .(半角句号)</td>
<td>使推荐列表向后翻页</td>
</tr>
<tr>
<td>Shift + Control + .(半角句号)</td>
<td>使推荐列表向前翻页</td>
</tr>
<tr>
<td>esc</td>
<td>切换推荐列表的显示和隐藏</td>
</tr>
<tr>
<td>tap(或Enter)</td>
<td>使用推荐列表中高，亮的推荐项</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong></p>
<ol>
<li>查看对象或类可用消息：<code>[对象或类 + 空格 + esc键</code></li>
<li>打开推荐列表中推荐方法的迷你帮助窗口：将鼠标悬停在推荐列表中的方法名上，便会看法哦窗口右边由一个<code>?</code>，点击它</li>
</ol>
</blockquote>
<h3 id="7-4-3-括号配对"><a href="#7-4-3-括号配对" class="headerlink" title="7.4.3    括号配对"></a>7.4.3    括号配对</h3><blockquote>
<p><strong>说明：</strong>输入某些<code>闭括号</code>（比如<code>)、}、]</code>）时，如果匹配到对应的<code>开括号</code>，屏幕会闪烁。如果没有正确闭合，<code>Xcode</code>会发出警报声。这个功能叫做<code>括号配对</code>。<br><strong>技巧：</strong>双击某个<code>分隔符</code>，<code>Xcode</code>会选定它以及与它匹配的货号之间的全部代码。</p>
</blockquote>
<h3 id="7-4-4-批量编辑"><a href="#7-4-4-批量编辑" class="headerlink" title="7.4.4    批量编辑"></a>7.4.4    批量编辑</h3><blockquote>
<p><strong>注意：</strong>批量操作是一件危险的操作，因此可以先创建一个<code>快照</code>用来恢复项目，但是<code>Xcode7</code>已经将此功能移除。</p>
</blockquote>
<h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><blockquote>
<p><strong>说明：</strong><code>Edit -&gt; Find</code>子菜单中包含几个非常方便的选项</p>
</blockquote>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find in Workspace…</td>
<td>Command + Shift + F</td>
<td>在当前工作区中搜索</td>
</tr>
<tr>
<td>Find and Replace in Workspace…</td>
<td>Command + Alt + Shift + F</td>
<td>在当前工作区中搜索并替换</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>缺点：</strong>对于一些替换任务，查找和替换的功能并不好用</p>
<ul>
<li>修改的过于彻底，比如只想重命名函数中的变量，但事实上整个文件中的变量名都被修改了</li>
<li>不能修改文件名（修改类需要同时修改文件名）</li>
</ul>
</blockquote>
<h4 id="Edit-all-in-Scope"><a href="#Edit-all-in-Scope" class="headerlink" title="Edit all in Scope"></a>Edit all in Scope</h4><blockquote>
<p><strong>说明：</strong>在范围内编辑全部内容。</p>
<ol>
<li>在编辑器中选中要修改的<code>标记名</code></li>
<li>点击它，右边出现一个向下的箭头，点击箭头出现一个菜单</li>
<li>选择菜单，选择Edit all in Scope</li>
</ol>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%888.14.05.png" alt="Alt text"><br><strong>注意：</strong>如果Xcode中的语法高亮功能被关闭或改动很多，<code>Edit in all Scope</code>功能也许就会拒绝工作</p>
</blockquote>
<h4 id="Xcode内置的重构工具"><a href="#Xcode内置的重构工具" class="headerlink" title="Xcode内置的重构工具"></a>Xcode内置的重构工具</h4><blockquote>
<p><strong>说明：</strong>不仅能重命名类，还能重命名相应源文件。</p>
<ol>
<li>打开存在要修改的类名的文件，将光标放到类名中</li>
<li>Edit(菜单)-&gt;Refactor-&gt;Rename</li>
</ol>
<p><strong>注意：</strong>重构不能重命名注释中的文字。所以，<code>类里面的注释</code>、<code>Xcode生成的文件头注释</code>或者任何你编写的<code>文档注释</code>都需要手工编辑（可以通过查找和替换简化这一过程）。</p>
</blockquote>
<h3 id="7-4-5-代码导航"><a href="#7-4-5-代码导航" class="headerlink" title="7.4.5    代码导航"></a>7.4.5    代码导航</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><blockquote>
<p><strong>说明：</strong>源自<code>emacs</code>，同时适用于Xcode、TextEdit、Safari的地址栏和文本域、Pages和Keynote文本域。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%888.44.02.png" alt="Alt text"></p>
</blockquote>
<h4 id="快速打开"><a href="#快速打开" class="headerlink" title="快速打开"></a>快速打开</h4><blockquote>
<p><strong>说明：</strong>大致有2种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>用途</th>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>项目文件搜索</td>
<td>File(菜单)-&gt;Open Quickly</td>
<td>Command + Shift + D</td>
</tr>
<tr>
<td>辅助窗口（默认打开当前文件对应的<code>.m</code>文件或<code>.h</code>文件）</td>
<td>View(菜单)-&gt;Assistant Editor-&gt;Show Assistant Editor</td>
<td><strong>打开：</strong>Command + alt + Enter  <strong>关闭：</strong>Command + Enter</td>
</tr>
</tbody>
</table>
<h3 id="7-4-6-集中精力"><a href="#7-4-6-集中精力" class="headerlink" title="7.4.6    集中精力"></a>7.4.6    集中精力</h3><blockquote>
<p><strong>说明：</strong><code>边栏（gutter）</code>和<code>聚焦栏（focus ribbon）</code></p>
</blockquote>
<table>
<thead>
<tr>
<th><em>**</em></th>
<th>说明</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>边栏</td>
<td>代码调试</td>
</tr>
<tr>
<td>聚焦栏</td>
<td>代码折叠</td>
<td><strong>显示聚焦栏：</strong><code>Xcode(菜单)-&gt;Preferences...-&gt;Text Editing-&gt;勾选Code folding ribbon</code>；<strong>更多代码折叠操作：</strong><code>Editor-&gt;Code Folding</code></td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%889.13.08.png" alt="Alt text"></p>
<h3 id="7-4-7-使用导航条"><a href="#7-4-7-使用导航条" class="headerlink" title="7.4.7    使用导航条"></a>7.4.7    使用导航条</h3><blockquote>
<p><strong>说明：</strong>里面的很多空间可以让你在项目中的原文件之间快速切换。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2011.05.05.png" alt="Alt text"></p>
</blockquote>
<h4 id="pragma指令"><a href="#pragma指令" class="headerlink" title="#pragma指令"></a><code>#pragma</code>指令</h4><blockquote>
<p><strong>说明：</strong>可以将<code>O-C</code>常规代码之外的一些信息或说明传递给编译器和代码编辑器。</p>
<ul>
<li><code>#pragma mark 说明</code>：添加标记到功能菜单</li>
<li><code>#pragma mark -</code>：在菜单中插入一条分割线</li>
</ul>
</blockquote>
<h4 id="注释中使用特殊字符"><a href="#注释中使用特殊字符" class="headerlink" title="注释中使用特殊字符"></a>注释中使用特殊字符</h4><blockquote>
<p><strong>说明：</strong>会将相应的注释信息放入功能菜单中，类似<code>#pragma mark</code>的效果。例如：</p>
<ul>
<li><code>MARK:说明</code></li>
<li><code>TODO:说明</code></li>
<li><code>FIXME:说明</code></li>
<li><code>!!!:说明</code></li>
<li><code>???:说明</code></li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2013.13.37.png" alt="Alt text"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#pragma mark 初始化父类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        <span class="comment">// MARK:初始化实例属性</span></span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-8-获取信息"><a href="#7-4-8-获取信息" class="headerlink" title="7.4.8    获取信息"></a>7.4.8    获取信息</h3><h4 id="7-4-8-1-获得帮助"><a href="#7-4-8-1-获得帮助" class="headerlink" title="7.4.8.1    获得帮助"></a>7.4.8.1    获得帮助</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2013.52.23.png" alt="Alt text"></p>
<h4 id="7-4-8-2-文档管理程序"><a href="#7-4-8-2-文档管理程序" class="headerlink" title="7.4.8.2    文档管理程序"></a>7.4.8.2    文档管理程序</h4><blockquote>
<p><strong>说明：</strong>访问苹果官方API文档有以下方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>情景</th>
<th>操作</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>quick search</td>
<td>option + 单击某个标记</td>
<td>只弹出一个包含概要信息的帮助窗口</td>
</tr>
<tr>
<td>在文档浏览窗口查看相应文档</td>
<td>option + 双击某个标记（或 将光标移动到标记內  + control + option + command + /）</td>
</tr>
</tbody>
</table>
<h2 id="7-5-调试"><a href="#7-5-调试" class="headerlink" title="7.5    调试"></a>7.5    调试</h2><h3 id="7-5-1-暴力测试"><a href="#7-5-1-暴力测试" class="headerlink" title="7.5.1    暴力测试"></a>7.5.1    暴力测试</h3><blockquote>
<p><strong>说明：</strong>在程序中写入语句（如<code>NSLog</code>）来输出程序中的控制流程和一些数据值。</p>
</blockquote>
<h3 id="7-5-2-Xcode的调试器"><a href="#7-5-2-Xcode的调试器" class="headerlink" title="7.5.2    Xcode的调试器"></a>7.5.2    Xcode的调试器</h3><blockquote>
<p><strong>调试器：</strong>位于程序和操作系统之间的程序，能够</p>
<ul>
<li>中断程序，这样就可以检查程序的数据，甚至修改程序，然后恢复程序并查看运行结果</li>
<li>可以单步执行代码，减缓程序运行的速度，细致地查看代码会对数据进行哪些改动</li>
</ul>
<p><strong>调试窗口：</strong>可以提供大量概述信息<br><strong>调试控制台：</strong>可以直接向调试器发送调试命令的调试控制台。<br><strong>说明：</strong>调试窗口可以选择两种调试器，<code>GDB</code>和<code>LLDB</code>，区别主要是精细度和内联性。</p>
<ul>
<li><strong>GDB：</strong>GNU计划的一部分，可以在各种平台上兼容，享誉已久</li>
<li><strong>LLDB：</strong>LLVM计划多个Xcode工具中的一员</li>
</ul>
</blockquote>
<h3 id="7-5-3-精巧的调试符号"><a href="#7-5-3-精巧的调试符号" class="headerlink" title="7.5.3    精巧的调试符号"></a>7.5.3    精巧的调试符号</h3><blockquote>
<p><strong>说明：</strong>调试程序时可以让编译器发出额外的调试符号，可以使用Debug构建配置（Product-&gt;Schema-&gt;Edit Schema）。</p>
</blockquote>
<h3 id="7-5-4-开始调试"><a href="#7-5-4-开始调试" class="headerlink" title="7.5.4    开始调试"></a>7.5.4    开始调试</h3><blockquote>
<p><strong>说明：</strong>使用GUI比命令行进行调试更加容易一些</p>
<ol>
<li>设置断点</li>
<li>运行程序</li>
<li>调试</li>
</ol>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8A%E5%8D%8810.52.03.png" alt="Alt text"></p>
<h3 id="7-5-5-检查程序"><a href="#7-5-5-检查程序" class="headerlink" title="7.5.5    检查程序"></a>7.5.5    检查程序</h3><blockquote>
<p><strong>说明：</strong>在调试状态下，将鼠标放在变量名上时，会弹出一个<code>显示</code>当前数值信息的弹出窗，点击里面的值还可以<code>修改</code>当前值。</p>
</blockquote>
<h2 id="7-6-备忘表"><a href="#7-6-备忘表" class="headerlink" title="7.6    备忘表"></a>7.6    备忘表</h2><blockquote>
<p><strong>说明：</strong>Xcode键盘快捷键<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8B%E5%8D%8812.14.31.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8B%E5%8D%8812.15.11.png" alt="Alt text"></p>
</blockquote>
<h2 id="7-7-小结"><a href="#7-7-小结" class="headerlink" title="7.7    小结"></a>7.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_06  源文件组织/" itemprop="url">
                  6 源文件组织
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:06+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_06  源文件组织/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_06  源文件组织/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>将程序拆分为多个小文件有助于更快地找到重要的代码。</p>
</blockquote>
<h2 id="6-1-拆分接口与实现"><a href="#6-1-拆分接口与实现" class="headerlink" title="6.1    拆分接口与实现"></a>6.1    拆分接口与实现</h2><blockquote>
<p><strong>说明：</strong>接口放在<code>.h</code>文件，实现放在<code>.m</code>文件。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件</th>
<th>存放代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>头文件(.h)</td>
<td>类的<code>@interface</code>指令、公共<code>struct</code>定义、<code>enum</code>常量、<code>#defines</code>和<code>extern</code>全局变量等</td>
</tr>
<tr>
<td>和类同名的.m(或.mm)文件</td>
<td>类的<code>@implementation</code>指令、全局变量的定义、私有struct等</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>如果用<code>.mm</code>做文件扩展名，编译器就会认为你是用<code>Objective-C++</code>（同时使用<code>C++</code>和<code>Objective-C</code>）编写的代码</p>
</blockquote>
<h3 id="在Xcode中创建新文件"><a href="#在Xcode中创建新文件" class="headerlink" title="在Xcode中创建新文件"></a>在Xcode中创建新文件</h3><blockquote>
<p><strong>说明：</strong>创建包含类的文件</p>
<ol>
<li>File（菜单）-&gt; New -&gt; File…</li>
<li>选择模版：ios -&gt; Source -&gt; Cocoa Class</li>
<li>填写类名</li>
<li>选择父类（默认NSObject）</li>
<li>选择群组和目标</li>
<li>选择存储位置并保存</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>群组（Group）</td>
<td>文件都放在群组内的文件夹中，将代码分组存放可以帮助组织项目中的源文件</td>
<td><code>1.</code> 设置群组时，Xcode并不会在硬盘上移动文件或者创建目录，群组关系仅仅是Xcode负责管理的一项奇妙的功能；<code>2.</code> 可以设置群组指向文件系统中某个特定的目录，Xcode会新建的文件放入该目录中</td>
</tr>
<tr>
<td>目标（Target）</td>
<td>复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同</td>
</tr>
</tbody>
</table>
<h2 id="6-2-拆分-Car-程序"><a href="#6-2-拆分-Car-程序" class="headerlink" title="6.2    拆分 Car 程序"></a>6.2    拆分 Car 程序</h2><blockquote>
<p><strong>说明：</strong>每个类都由头文件（<code>.h</code>）和实现文件（<code>.m</code>）组成，入口在<code>main.m</code></p>
<ul>
<li><strong>头文件（<code>.h</code>文件）：</strong>通过<code>import</code>引入模块的过程放在头文件</li>
<li><strong>实现文件（<code>.m</code>文件）：</strong>文件中需要引入相应的头文件（<code>.h</code>）文件</li>
</ul>
<p><strong>技巧：</strong>复合的程序文件中使用了其它类，如果只是通过指针引用了相应的类实例，可以用<code>@class</code>声明引用的类而不需要<code>import</code>，从而提升重新编译时的性能。</p>
<p><strong>导入文件：</strong><code>import</code>文件有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>导入</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#import &quot;文件&quot;</code></td>
<td>导入项目本地的头文件</td>
</tr>
<tr>
<td><code>#import &lt;文件&gt;</code></td>
<td>导入系统文件（只读）</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 6.2\ CarPaers-Split<span class="comment"># 存放代码的群组</span></span><br><span class="line">│   ├── AllWeatherRadial.h</span><br><span class="line">│   ├── AllWeatherRadial.m</span><br><span class="line">│   ├── Car.h</span><br><span class="line">│   ├── Car.m</span><br><span class="line">│   ├── Engine.h</span><br><span class="line">│   ├── Engine.m</span><br><span class="line">│   ├── Slant6.h</span><br><span class="line">│   ├── Slant6.m</span><br><span class="line">│   ├── Tire.h</span><br><span class="line">│   ├── Tire.m</span><br><span class="line">│   └── main.m<span class="comment"># 入口文件</span></span><br><span class="line">└── 6.2\ CarPaers-Split.xcodeproj</span><br><span class="line">    ├── project.pbxproj</span><br><span class="line">    └── xcuserdata</span><br><span class="line">        └── tonyearth.xcuserdatad</span><br></pre></td></tr></table></figure>
<h2 id="6-3-使用快文件依赖关系"><a href="#6-3-使用快文件依赖关系" class="headerlink" title="6.3    使用快文件依赖关系"></a>6.3    使用快文件依赖关系</h2><blockquote>
<p><strong>说明：</strong>依赖关系可以存在于两个或多个文件之间，并且具有传递性，如果其中一个文件发生变化，其它文件都会被重新编译。</p>
</blockquote>
<h3 id="6-3-1-重新编译须知"><a href="#6-3-1-重新编译须知" class="headerlink" title="6.3.1    重新编译须知"></a>6.3.1    重新编译须知</h3><blockquote>
<p><strong>说明：</strong>文件导入过于混乱会延长编译时间，也会导致不必要的重复编译，可以通过<code>@class</code>减少必需导入的头文件的数量，从而可以缩短编译时间。</p>
</blockquote>
<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><blockquote>
<p><strong>说明：</strong>创建一个前向引导，用在程序不需要知道类的所有信息的场景（比如创建了相应的变量，但没有向变量发送消息）。<br><strong>技巧：</strong>如果试图通过<code>#import</code>语句让两个类相互引用，那么就会出现编译错误，可以用<code>@class</code>替代。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">         atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-让汽车跑一会儿"><a href="#6-3-2-让汽车跑一会儿" class="headerlink" title="6.3.2    让汽车跑一会儿"></a>6.3.2    让汽车跑一会儿</h3><p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Tire *tires[<span class="number">4</span>];</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line"></span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">         atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tires[index] = tire;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (tires[index]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-导入和继承"><a href="#6-3-3-导入和继承" class="headerlink" title="6.3.3    导入和继承"></a>6.3.3    导入和继承</h3><blockquote>
<p><strong>说明：</strong>如果当前的文件头文件中的类会<code>继承</code>要引入的类，则不能通过<code>@class</code>引入，因为编译器需要知道父类中实例变量的完整信息。</p>
</blockquote>
<p><em>Slant6.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Slant6</span> : <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4    小结"></a>6.4    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_05  复合/" itemprop="url">
                  5 复合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:37:38+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_05  复合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_05  复合/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>建立类之间的关系除了<code>继承</code>还有<code>复合</code></p>
</blockquote>
<h2 id="5-1-什么是复合"><a href="#5-1-什么是复合" class="headerlink" title="5.1    什么是复合"></a>5.1    什么是复合</h2><blockquote>
<p><strong>说明：</strong>使用复合可组合多个对象，让它们分工协作<br><strong>原理：</strong>在<code>0-C</code> 中，复合是通过包含作为实例变量的对象指针实现的。</p>
</blockquote>
<h2 id="5-2-自定义NSLog"><a href="#5-2-自定义NSLog" class="headerlink" title="5.2    自定义NSLog()"></a>5.2    自定义NSLog()</h2><blockquote>
<p><strong>说明：</strong>在类中提供<code>description方法</code>就可以自定义<code>NSLog()</code>会如何输出对象。</p>
</blockquote>
<h3 id="在init中初始化实例属性"><a href="#在init中初始化实例属性" class="headerlink" title="在init中初始化实例属性"></a>在init中初始化实例属性</h3><blockquote>
<p><strong>说明：</strong>使用<code>new</code>创建新对象时后台进行了两步</p>
<ol>
<li>为对象分配内存，用来存放<code>实例变量</code>（如果实例属性是对象，被初始化为<code>nil</code>）</li>
<li>自动调用<code>init方法</code>，之后对象进入可用状态</li>
</ol>
<p><strong>扩展：</strong>在<code>init方法中</code>使用<code>if (self = [super init])</code>是为了完成父类的初始化并确保父类返回的对象和一开始创建的对象是一致的。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        </span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Car *car;</span><br><span class="line">    </span><br><span class="line">    car = [Car new];</span><br><span class="line">    [car print];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-存取方法"><a href="#5-3-存取方法" class="headerlink" title="5.3    存取方法"></a>5.3    存取方法</h2><blockquote>
<p><strong>说明：</strong>是用来读取或改变某个对象属性的方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>存取方法</th>
<th>方法命名（Cocoa惯例）</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getter</td>
<td>getPropertyName</td>
<td>返回实例变量的值</td>
</tr>
<tr>
<td>setter</td>
<td>propertyName</td>
<td>将实例变量的值赋为参数所指向的值</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>如果要对对象中的属性进行操作，因该尽量使用对象提供的存取方法，而不是直接改变对象里面的值。<br><strong>注意：</strong>不要将<code>get</code>作为getter方法的前缀，因为<code>get</code>出现在<code>Cocoa</code>的方法名称中意味着这个方法会将你传递的参数作为指针来返回数值。</p>
</blockquote>
<h3 id="5-3-1-设置-engine-属性的存取方法"><a href="#5-3-1-设置-engine-属性的存取方法" class="headerlink" title="5.3.1    设置 engine 属性的存取方法"></a>5.3.1    设置 engine 属性的存取方法</h3><blockquote>
<p><strong>说明：</strong>在<code>@interface</code>和<code>@implementation</code>中同时增加存取方法。<br><strong>扩展：</strong>在内存管理和对象的多有权方面<code>Engin</code>的<code>getter</code>方法和<code>setter</code>方法还存在着问题。</p>
</blockquote>
<h3 id="5-3-2-设置-tires-属性的存取方法"><a href="#5-3-2-设置-tires-属性的存取方法" class="headerlink" title="5.3.2    设置 tires 属性的存取方法"></a>5.3.2    设置 tires 属性的存取方法</h3><blockquote>
<p><strong>说明：</strong>不仅要知道新轮胎，还要知道新轮胎的位置。<br><strong>注意：</strong><code>防御式编程</code><br>对无效索引进行防御。</p>
</blockquote>
<h3 id="5-3-3-Car-类代码的其他变化"><a href="#5-3-3-Car-类代码的其他变化" class="headerlink" title="5.3.3    Car 类代码的其他变化"></a>5.3.3    Car 类代码的其他变化</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	Engine *engine;</span><br><span class="line">	Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">		 atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		engine = [Engine new];</span><br><span class="line">		</span><br><span class="line">		tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">		 atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">			   index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tires[index] = tire;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">			   index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (tires[index]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) </span><br><span class="line">&#123;</span><br><span class="line">	Car *car = [Car new];</span><br><span class="line">	</span><br><span class="line">	Engine *engine = [Engine new];</span><br><span class="line">	[car setEngine: engine];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		Tire *tire = [Tire new];</span><br><span class="line">		</span><br><span class="line">		[car setTire: tire atIndex: i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	[car print];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-扩展-CarParts-程序"><a href="#5-4-扩展-CarParts-程序" class="headerlink" title="5.4    扩展 CarParts 程序"></a>5.4    扩展 CarParts 程序</h2><blockquote>
<p><strong>说明：</strong>结合<code>继承</code>和<code>复合</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 新型轮胎</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// AllWeatherRadial</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am a tire for rain or shine."</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// AllWeatherRadial</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 新型引擎</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Slant6</span> : <span class="title">Engine</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Slant6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Slant6</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am a slant-6. VROOOM!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Slant6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	Engine *engine;</span><br><span class="line">	Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		engine = [Engine new];</span><br><span class="line">		</span><br><span class="line">		tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>, index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tires[index] = tire;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>, index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (tires[index]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) </span><br><span class="line">&#123;</span><br><span class="line">	Car *car = [Car new];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		Tire *tire = [AllWeatherRadial new];</span><br><span class="line">		</span><br><span class="line">		[car setTire: tire</span><br><span class="line">			 atIndex: i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Engine *engine = [Slant6 new];</span><br><span class="line">	[car setEngine: engine];</span><br><span class="line">	</span><br><span class="line">	[car print];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-5-复合还是继承"><a href="#5-5-复合还是继承" class="headerlink" title="5.5    复合还是继承"></a>5.5    复合还是继承</h2><blockquote>
<p><strong>说明：</strong>在进行面向对象编程时通常会犯这样的错误－任何东西都想使用继承。</p>
</blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th>类之间的关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td><code>is a</code></td>
</tr>
<tr>
<td>复合</td>
<td><code>has a</code></td>
</tr>
</tbody>
</table>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6    小结"></a>5.6    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_04  继承/" itemprop="url">
                  4 继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:36:44+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_04  继承/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_04  继承/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>处理类和对象的关系时，要重视<code>OOP</code>的两个方面</p>
<ul>
<li><strong>继承：</strong>定义一个具有父类所有功能的新类</li>
<li><strong>复合：</strong>在对象中引用其他对象</li>
</ul>
</blockquote>
<h2 id="4-1-为何使用继承"><a href="#4-1-为何使用继承" class="headerlink" title="4.1    为何使用继承"></a>4.1    为何使用继承</h2><blockquote>
<p><strong>说明：</strong>将所有重复的内容合并在一起，并在需要的地方拥有自定义的方法。<br><strong>不使用继承的架构</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.34.10.png" alt="Alt text"><br><strong>使用继承后的架构</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.35.04.png" alt="Alt text"></p>
</blockquote>
<h2 id="4-2-继承的语法格式"><a href="#4-2-继承的语法格式" class="headerlink" title="4.2    继承的语法格式"></a>4.2    继承的语法格式</h2><blockquote>
<p><strong>说明：</strong><code>@interface 子类名: 父类名</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>超类（或父类）</td>
<td>继承的类</td>
</tr>
<tr>
<td>子类（或孩子类）</td>
<td>执行继承的类</td>
</tr>
<tr>
<td>重写</td>
<td>如果想改变方法的实现，需要重写继承的方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>O-C</code>不支持多继承（可以使用类别和协议模拟多继承效果）</p>
</blockquote>
<h2 id="4-3-继承的工作机制"><a href="#4-3-继承的工作机制" class="headerlink" title="4.3    继承的工作机制"></a>4.3    继承的工作机制</h2><h3 id="4-3-1-方法调度"><a href="#4-3-1-方法调度" class="headerlink" title="4.3.1    方法调度"></a>4.3.1    方法调度</h3><blockquote>
<p><strong>说明：</strong>当发送消息时，<code>O-C</code>的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。<br><strong>注意：</strong>如果在最顶层的<code>NSObject</code>类中也没有找到该方法，则会出现一个运行时错误。</p>
</blockquote>
<h3 id="4-3-2-实例变量"><a href="#4-3-2-实例变量" class="headerlink" title="4.3.2    实例变量"></a>4.3.2    实例变量</h3><blockquote>
<p><strong>说明：</strong><code>O-C</code> 中图和访问实例变量</p>
<ul>
<li>子类会从父类继承实例变量</li>
<li>子类根据自己的情况添加额外的自己的实例变量</li>
<li>每个方法被调用时都获得了一个名为<code>self</code>的参数，<code>self</code>指向继承链中第一个类中的第一个实例变量。</li>
</ul>
<p><strong>多态性：</strong>使用更具体种类的对象来代替一般类型，这种能力被称为<code>多态性</code>。<br><strong>扩展：</strong>通过<code>对象基地址</code>（第一个实例变量的首个字节在内存中的位置）加上<code>偏移地址</code>，编译器就可以查找其他实例变量的位置。这个机制叫做<code>基地址加偏移</code>，通过硬编码实现，但存在<code>脆弱的基类问题</code>，<code>Leopard</code>系统中通过引入64位<code>Objective-C</code>运行时（使用间接寻址方式确定变量的位置）解决了这个问题。</p>
</blockquote>
<h2 id="4-4-重写方法"><a href="#4-4-重写方法" class="headerlink" title="4.4    重写方法"></a>4.4    重写方法</h2><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><blockquote>
<p><strong>说明：</strong>利用<code>super</code>，既可以重写方法的实现，又能调用超类中的实现方式。<br><strong>原理：</strong>既不是参数也不是实例变量，而是由<code>Objective-C</code>编译器提供的一种神奇的功能。当想<code>super</code>发送消息时，实际上是在请求<code>Obective-C</code>向该类的超类发送消息。如果超类中没有定义该消息，则向平常一样继续在<code>继承链</code>上一级中查找。</p>
</blockquote>
<h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5    小结"></a>4.5    小结</h2><h2 id="4-6-举个栗子"><a href="#4-6-举个栗子" class="headerlink" title="4.6    举个栗子"></a>4.6    举个栗子</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/" itemprop="url">
                  3 面向对象编程的基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:35:54+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>OOP历史：</strong>演变自20世纪60年代的<code>Simula</code>、70年代的<code>SmallTalk</code>、80年代的<code>Clascal</code>以及其他相关语言。<code>C++</code>、<code>Java</code>、<code>Python</code>和<code>Objective-C</code>等现代编程语言都从这个早期的语言中获得了灵感。</p>
</blockquote>
<h2 id="3-1-间接"><a href="#3-1-间接" class="headerlink" title="3.1    间接"></a>3.1    间接</h2><p><code>只要在多加一层间接，计算机科学中就没有解决不了的问题</code>。</p>
<blockquote>
<p><strong>说明：</strong>指的就是面向对象的<code>多态性</code>。<br><strong>原理：</strong>在程序运行期间，通过指针间接获取某个值，而不是直接获取（<code>指针指向</code>的变化对程序员不可见）。</p>
</blockquote>
<h3 id="3-1-1-变量与间接"><a href="#3-1-1-变量与间接" class="headerlink" title="3.1.1    变量与间接"></a>3.1.1    变量与间接</h3><blockquote>
<p><strong>说明：</strong>基本变量就是间接思想的一种实际应用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 通过修改 count 间接控制后面循环的次数，本身就蕴含着间接的思想</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The numbers from 1 to %d:"</span>, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-使用文件名的间接"><a href="#3-1-2-使用文件名的间接" class="headerlink" title="3.1.2    使用文件名的间接"></a>3.1.2    使用文件名的间接</h3><blockquote>
<p><strong>说明：</strong>程序中使用文件（而不是写死在代码中）也是间接思想的运用。<br><strong>技巧：</strong><code>xcode</code>中运行程序时提供文件路径的方式</p>
<ol>
<li>打开设置面板：Product（菜单）-&gt; Scheme -&gt; Edit Scheme</li>
<li>在面板中添加参数：Arguments -&gt; Arguments Passed On Launch—&gt;点击<code>+</code>添加</li>
</ol>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 命令中没有提供文件名，则退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"you need to provide a file name"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 打开文件</span></span><br><span class="line">    FILE *wordFile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 访问文件</span></span><br><span class="line">    <span class="keyword">char</span> word[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一行一行地读区</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(word, <span class="number">100</span>, wordFile)) &#123;</span><br><span class="line">        <span class="comment">// 将每行最后的换行符替换为字符串结束符（从而不会被后面的 strlen 计入字符串的长度）</span></span><br><span class="line">        word[strlen(word) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s is %lu characters long"</span>, word, strlen(word));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭文件</span></span><br><span class="line">    fclose(wordFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-在面向对象编程中使用间接"><a href="#3-2-在面向对象编程中使用间接" class="headerlink" title="3.2    在面向对象编程中使用间接"></a>3.2    在面向对象编程中使用间接</h2><blockquote>
<p><strong>说明：</strong><code>OOP</code>的核心在于使用间接来调用代码（而不是直接调用函数）</p>
</blockquote>
<h3 id="3-2-1-过程式编程"><a href="#3-2-1-过程式编程" class="headerlink" title="3.2.1    过程式编程"></a>3.2.1    过程式编程</h3><blockquote>
<p><strong>说明：</strong>在过程式编程中，数据通常保存在简单的数据结构中。要花时间连接数据和用来处理数据的函数。<br><strong>语言举例：</strong><code>BASIC</code>、<code>C</code>、<code>Tcl</code>和<code>Perl</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/******* 枚举：图形的基本元素 *******/</span></span><br><span class="line"><span class="comment">// 图形类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kCircle,</span><br><span class="line">    kRectangle,</span><br><span class="line">    kEgg</span><br><span class="line">&#125; ShapeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kRedColor,</span><br><span class="line">    kGreenColor,</span><br><span class="line">    kBlueColor</span><br><span class="line">&#125; ShapeColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 结构体：图形类型 ******/</span></span><br><span class="line"><span class="comment">// 绘图区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, width, height;<span class="comment">// 坐标和边长</span></span><br><span class="line">&#125; ShapeRect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ShapeType type;<span class="comment">// 类型</span></span><br><span class="line">    ShapeColor fillColor;<span class="comment">// 填充色</span></span><br><span class="line">    ShapeRect bounds;<span class="comment">// 边框</span></span><br><span class="line">&#125; Shape;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将传入的颜色值转换为字符串描述</span><br><span class="line"> * @param &#123;ShapeColor&#125; colorName 图形颜色</span><br><span class="line"> * @return &#123;NSString&#125; 枚举类型的颜色对应的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *colorName (ShapeColor colorName) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (colorName) &#123;</span><br><span class="line">        <span class="keyword">case</span> kRedColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kGreenColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"green"</span>;</span><br><span class="line">        <span class="keyword">case</span> kBlueColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"blue"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制圆形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawCircle (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a circle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制矩形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawRectangle (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a rectangle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制椭圆形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawEgg (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a egg at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  绘制图形</span><br><span class="line"> * @param &#123;Shape[]&#125; shapes 要绘制的一组图形</span><br><span class="line"> * @param &#123;int&#125; count 绘制数组中的前count个图形</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawShapes (Shape shapes[], <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (shapes[i].type) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCircle:</span><br><span class="line">                drawCircle (shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kRectangle:</span><br><span class="line">                drawRectangle (shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kEgg:</span><br><span class="line">                drawEgg(shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 存放图形实例的数组</span></span><br><span class="line">    Shape shapes[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 红色圆形</span></span><br><span class="line">    ShapeRect rect0 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    shapes[<span class="number">0</span>].type = kCircle;</span><br><span class="line">    shapes[<span class="number">0</span>].fillColor = kRedColor;</span><br><span class="line">    shapes[<span class="number">0</span>].bounds = rect0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绿色矩形</span></span><br><span class="line">    ShapeRect rect1 = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    shapes[<span class="number">1</span>].type = kRectangle;</span><br><span class="line">    shapes[<span class="number">1</span>].fillColor = kGreenColor;</span><br><span class="line">    shapes[<span class="number">1</span>].bounds = rect1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 蓝色椭圆</span></span><br><span class="line">    ShapeRect rect2 = &#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    shapes[<span class="number">2</span>].type = kEgg;</span><br><span class="line">    shapes[<span class="number">2</span>].fillColor = kBlueColor;</span><br><span class="line">    shapes[<span class="number">2</span>].bounds = rect2;</span><br><span class="line">    </span><br><span class="line">    drawShapes(shapes, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-01-02 00:50:43.911 3.2.1-procedureOriented[834:55458] drawing a circle at (0 0 30 10) <span class="keyword">in</span> red</span><br><span class="line">2016-01-02 00:50:43.912 3.2.1-procedureOriented[834:55458] drawing a rectangle at (30 40 60 50) <span class="keyword">in</span> green</span><br><span class="line">2016-01-02 00:50:43.912 3.2.1-procedureOriented[834:55458] drawing a egg at (15 18 29 37) <span class="keyword">in</span> blue</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-实现面向对象编程"><a href="#3-2-2-实现面向对象编程" class="headerlink" title="3.2.2    实现面向对象编程"></a>3.2.2    实现面向对象编程</h3><blockquote>
<p><strong>说明：</strong>过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。<br><strong>原理：</strong>数据通过<code>间接方式</code>引用相应代码对数据进行操作（数据能够知道如何查找相应的函数）。</p>
</blockquote>
<h4 id="id（标识符）"><a href="#id（标识符）" class="headerlink" title="id（标识符）"></a>id（标识符）</h4><blockquote>
<p><strong>说明：</strong><code>identifier</code>，是一种泛型，可以用来定义引用任何类型对象的变量。</p>
</blockquote>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><blockquote>
<p><strong>说明：</strong>通知对象执行某种操作，也叫做<code>调用方法</code></p>
</blockquote>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><blockquote>
<p><strong>说明：</strong>不同于其他<code>OOP</code>系统，在<code>O-C</code>中，如果在运行时改变某个类，则该类的所有对象会<code>自动继承这些变化</code>。</p>
</blockquote>
<h2 id="3-3-有关术语"><a href="#3-3-有关术语" class="headerlink" title="3.3    有关术语"></a>3.3    有关术语</h2><blockquote>
<p><strong>说明：</strong>有关<code>面向对象</code>的术语</p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类(class)</strong></td>
<td>一种表示对象类型的结构体</td>
<td>类名首字母大写</td>
<td>对象通过它的类来获取自身的各种信息</td>
</tr>
<tr>
<td><strong>对象或实例(object)</strong></td>
<td>一种包含值和指向其类的隐藏指针的结构体</td>
<td>指向对象的变量通常首字母不要大些</td>
<td></td>
</tr>
<tr>
<td><strong>消息(message)</strong></td>
<td>对象可以执行的操作，用于通知对象做什么</td>
<td></td>
</tr>
<tr>
<td><strong>方法(method)</strong></td>
<td>响应消息运行的代码</td>
<td></td>
<td>根据对象的类，消息可以调用不同的方法</td>
</tr>
<tr>
<td><strong>方法调度(method dispatcher)</strong></td>
<td>用于推测执行什么方法以响应某个特定的消息</td>
<td></td>
</tr>
<tr>
<td><strong>接口(interface)</strong></td>
<td>类为对象提供的特性描述</td>
<td></td>
</tr>
<tr>
<td><strong>实现(implementation)</strong></td>
<td>使接口能正常工作的代码</td>
</tr>
</tbody>
</table>
<h2 id="3-4-Object-C语言中的OOP"><a href="#3-4-Object-C语言中的OOP" class="headerlink" title="3.4    Object-C语言中的OOP"></a>3.4    Object-C语言中的OOP</h2><h3 id="3-4-1-interface部分"><a href="#3-4-1-interface部分" class="headerlink" title="3.4.1    @interface部分"></a>3.4.1    @interface部分</h3><blockquote>
<p><strong>说明：</strong>定义类的公共接口，真正运行的代码位于<code>@implementation</code>中。<br><strong>用途：</strong>在特定类的对象被创建时，为编译器提供有关该类的信息，尤其是对象的数据成员及其提供的功能。<br><strong>组成：</strong>语法上包含以下几个部分</p>
<ul>
<li>继承其它<code>interface</code></li>
<li>实现<code>protocol</code></li>
<li>实例变量</li>
<li>方法声明</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 类名: 父类名 </span>&#123;</span><br><span class="line">	<span class="comment">// 实例属性</span></span><br><span class="line">	属性类型 属性名;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (返回值类型) 方法名: (参数<span class="number">1</span>类型)参数<span class="number">1</span>名称, (参数<span class="number">2</span>类型)参数<span class="number">2</span>名称;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// 类名（便于代码阅读）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>在声明方法时，如果方法有参数，则需要冒号，否则不需要。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Circle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Circle</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-implementation部分"><a href="#3-4-2-implementation部分" class="headerlink" title="3.4.2    @implementation部分"></a>3.4.2    @implementation部分</h3><blockquote>
<p><strong>说明：</strong><code>@implementation</code>是一个编译器指令，表明将为某个类提供代码</p>
<ul>
<li>方法的定义不必按照在<code>@interface</code>指令中的顺序出现</li>
<li>可以定义没有在<code>@interface</code>中声明过的方法</li>
<li>同一个类中，方法的参数名不可以和实例属性名相同，否则方法被调用时会覆盖实例属性的值</li>
</ul>
<p><strong>扩展：</strong></p>
<ul>
<li><strong>实例变量名：</strong>如果实例变量取一个和方法名相同的名字，<code>Cocoa</code>还可以发挥出某些神奇的威力</li>
<li><strong>运行时：</strong><code>O-C运行时</code>是指用户应用程序时，支持这些应用程序的代码块</li>
<li><strong>self：</strong>类的方法被调用时，一个名为<code>self</code>的秘密隐藏参数将被传递给接受对象，而这个参数引用的就是该接收对象</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Circle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-实例化对象"><a href="#3-4-3-实例化对象" class="headerlink" title="3.4.3    实例化对象"></a>3.4.3    实例化对象</h3><blockquote>
<p><strong>说明：</strong>实例化对象时，需要分配内存，然后将这些内存初始化并保存为有用的默认值。<br><strong>语法：</strong>向相应的<code>类</code>(或已经存在的<code>对象</code>)发送<code>new</code>消息，该类接收并处理完<code>new</code>消息后，我们就会得到一个可以使用的新对象实例。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 图形类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kCircle,</span><br><span class="line">    kRectangle,</span><br><span class="line">    kEgg</span><br><span class="line">&#125; ShapeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 图形颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kRedColor,</span><br><span class="line">    kGreenColor,</span><br><span class="line">    kBlueColor</span><br><span class="line">&#125; ShapeColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 绘图区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, width, height;<span class="comment">// 坐标和边长</span></span><br><span class="line">&#125; ShapeRect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将传入的颜色值转换为字符串描述</span><br><span class="line"> * @param &#123;ShapeColor&#125; colorName 图形颜色</span><br><span class="line"> * @return &#123;NSString&#125; 枚举类型的颜色对应的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *colorName (ShapeColor colorName) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (colorName) &#123;</span><br><span class="line">        <span class="keyword">case</span> kRedColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kGreenColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"green"</span>;</span><br><span class="line">        <span class="keyword">case</span> kBlueColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"blue"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Circle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Circle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Circle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a circle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Rectangle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Rectangle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Rectangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Rectangle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a rectangle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Egg类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Egg</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Egg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Egg类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Egg</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a egg at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  绘制图形</span><br><span class="line"> * @param &#123;id[]&#125; shapes 要绘制的一组图形</span><br><span class="line"> * @param &#123;int&#125; count 绘制数组中的前count个图形</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawShapes (<span class="keyword">id</span> shapes[], <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">id</span> shape = shapes[i];</span><br><span class="line">        [shape draw];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> shapes[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 红色圆形</span></span><br><span class="line">    ShapeRect rect0 =&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    shapes[<span class="number">0</span>] = [Circle new];</span><br><span class="line">    [shapes[<span class="number">0</span>] setBounds: rect0];</span><br><span class="line">    [shapes[<span class="number">0</span>] setFillCollor:kRedColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绿色矩形</span></span><br><span class="line">    ShapeRect rect1 = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    shapes[<span class="number">1</span>] = [Rectangle new];</span><br><span class="line">    [shapes[<span class="number">1</span>] setBounds: rect1];</span><br><span class="line">    [shapes[<span class="number">1</span>] setFillCollor:kGreenColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 蓝色椭圆</span></span><br><span class="line">    ShapeRect rect2 = &#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    shapes[<span class="number">2</span>] = [Egg new];</span><br><span class="line">    [shapes[<span class="number">2</span>] setBounds: rect2];</span><br><span class="line">    [shapes[<span class="number">2</span>] setFillCollor:kBlueColor];</span><br><span class="line">    </span><br><span class="line">    drawShapes(shapes, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-4-扩展-Shapes-Object-程序"><a href="#3-4-4-扩展-Shapes-Object-程序" class="headerlink" title="3.4.4    扩展 Shapes-Object 程序"></a>3.4.4    扩展 Shapes-Object 程序</h3><blockquote>
<p><strong>说明：</strong>软件实体应该对扩展开放，而对修改关闭</p>
</blockquote>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5    小结"></a>3.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="url">
                  2 对c的扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T22:36:43+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-1-最简单的-Objective-C-程序"><a href="#2-1-最简单的-Objective-C-程序" class="headerlink" title="2.1   最简单的 Objective-C 程序"></a>2.1   最简单的 Objective-C 程序</h2><blockquote>
<p><strong>说明：</strong>项目创建过程如下</p>
<ol>
<li>创建 workspace：File-New-Workspace</li>
<li>创建 project：File-New-&gt;Project</li>
</ol>
<ul>
<li>选择模版：OS X-&gt;Applicetion-&gt; Command Line</li>
<li>选择语言：Object-C</li>
<li>选择 Workspace</li>
</ul>
</blockquote>
<h2 id="2-2-解构-Hello-Objective-C-程序"><a href="#2-2-解构-Hello-Objective-C-程序" class="headerlink" title="2.2   解构 Hello Objective-C 程序"></a>2.2   解构 Hello Objective-C 程序</h2><blockquote>
<p><strong>默认编译器：</strong> XCode 的默认编译器为<code>LLVM</code>，可以处理<code>C</code>（.c文件）、<code>C++</code>（.cpp）、<code>Objective-C</code>（.m）。<br><strong>扩展：</strong>扩展名<code>.m</code>代表<code>message</code>，它值得是<code>Object-C</code>的一个主要特征。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O-C 支持的模块导入方式</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main 的声明语句和结尾的 return 语句和 C 一样</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-1-import-语句"><a href="#2-2-1-import-语句" class="headerlink" title="2.2.1    #import 语句"></a>2.2.1    #import 语句</h3><blockquote>
<p><strong>功能：</strong>通知编译器查询头文件中相应的代码并导入，一个文件中只会被包含一次（无论调用多少次<code>#import</code>语句）<br><strong>说明：</strong>相比<code>C</code>的<code>#include</code>，<code>#import</code>能避免文件相互包含的情况导致的错误（<code>C</code>语言通过<code>ifdef</code>实现）。<br><strong>注意：</strong><code>Foundation</code>框架的头文件占用了近1MB的磁盘空间，使用<code>#import &lt;Foundation/Foundation.h&gt;</code>包含头文件时，Xcode使用<code>预编译头文件</code>加快读取速度。</p>
</blockquote>
<h3 id="2-2-2-框架"><a href="#2-2-2-框架" class="headerlink" title="2.2.2    框架"></a>2.2.2    框架</h3><blockquote>
<p><strong>框架：</strong>是一种把<code>头文件、库、图片、声音等内容</code>聚集在一个独立单元中的集合体。<br><strong>框架集：</strong>一系列框架的集合。</p>
</blockquote>
<h4 id="苹果公司提供的框架集"><a href="#苹果公司提供的框架集" class="headerlink" title="苹果公司提供的框架集"></a>苹果公司提供的框架集</h4><blockquote>
<p><strong>说明：</strong>苹果公司将<code>Cocoa</code>、<code>Carbon</code>、<code>QuickTime</code>、<code>OpenGL</code>等技术作为框架集来提供。<br><strong>Cocoa框架集：</strong>包括以下框架</p>
<ul>
<li>Foundation</li>
<li>Application Kit（简称AppKit）</li>
<li>支持性框架（Core Animation 和 Core Image）</li>
</ul>
<p><strong>扩展：</strong><a href="">Learn Cocoa On The Mac</a></p>
</blockquote>
<h3 id="2-2-3-NSLog-和-quot-字符串-quot"><a href="#2-2-3-NSLog-和-quot-字符串-quot" class="headerlink" title="2.2.3    NSLog()和@&quot;字符串&quot;"></a>2.2.3    <code>NSLog()</code>和<code>@&quot;字符串&quot;</code></h3><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>给其所有函数、常量和类型名都添加了<code>NS前缀</code>（使用<code>NS</code>而不是<code>Cocoa</code>源自历史遗留：<code>Cocoa</code>的前身为<code>NextSTEP</code>工具包）。</p>
</blockquote>
<h4 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h4><blockquote>
<p><strong>说明：</strong>用于向控制台输出内容<br><strong>原型：</strong><code>NSObjCRuntime.h</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">** @param &#123;NSString *&#125; format 字符串（可以包含格式说明符） </span><br><span class="line">** @param &#123;...&#125; 对应格式串中格式说明符可变参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...)</span><br></pre></td></tr></table></figure></p>
<p><strong>技巧：</strong>建议在<code>O-C</code>中使用<code>NSLog</code>替代<code>printf</code>，因为它添加了一些特性，比如</p>
<ul>
<li>时间戳</li>
<li>日期戳</li>
<li>自动附带换行符<code>\n</code>等</li>
</ul>
</blockquote>
<h4 id="NSString-quot-字符串-quot"><a href="#NSString-quot-字符串-quot" class="headerlink" title="NSString(@&quot;字符串&quot;)"></a>NSString(<code>@&quot;字符串&quot;</code>)</h4><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>提供的<code>NSString</code>集成了大量<code>C</code>语言字符串没有的特性。<code>@&quot;字符串&quot;</code>表明其中的<code>字符串</code>作为<code>Cocoa</code>的<code>NSString</code>元素来处理。</p>
<ul>
<li>字符串的长度</li>
<li>字符串比较</li>
<li>转换为整数和浮点数</li>
</ul>
<p><strong>格式串：</strong>输出对象使用<code>%@</code>，会调用对象的<code>description</code>方法</p>
</blockquote>
<h2 id="2-3-布尔类型"><a href="#2-3-布尔类型" class="headerlink" title="2.3   布尔类型"></a>2.3   布尔类型</h2><blockquote>
<p><strong>关键字：</strong><code>BOOL</code>(比<code>C</code>语言的<code>bool</code>早十多年)<br><strong>说明：</strong>本质是<code>signed char</code>（通过<code>typedef</code>定义），使用8位存储空间</p>
<ul>
<li><code>NO</code>：本质是<code>signed char</code>值0</li>
<li><code>YES</code>：本质是<code>signed char</code>值1</li>
</ul>
<p><strong>注意：</strong><code>O-C</code>的<code>BOOL</code>不仅能保存<code>NO</code>和<code>YES</code>，编译器将其作为<code>8位二进制数</code>处理，也就是说可以赋值其它整数和<code>char</code>类型值（大于一个字节将溢出）。</p>
</blockquote>
<h3 id="2-3-1-BOOL-强大的实用功能"><a href="#2-3-1-BOOL-强大的实用功能" class="headerlink" title="2.3.1    BOOL 强大的实用功能"></a>2.3.1    BOOL 强大的实用功能</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较两个 int 型值是否相等</span><br><span class="line"> * @param &#123;int&#125; thing1 第一个值</span><br><span class="line"> * @param &#123;int&#125; thing2 第二个值</span><br><span class="line"> * @return &#123;BOOL&#125; YES 相等， NO 不相等</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> areIntsDifferent (<span class="keyword">int</span> thing1, <span class="keyword">int</span> thing2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thing1 == thing2) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NO</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 输出 BOOL 值对应的描述</span><br><span class="line"> * @param &#123;BOOL&#125; yesNo BOOL值</span><br><span class="line"> * @return &#123;NSString&#125; YES "YES", NO "NO"</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *boolString (<span class="built_in">BOOL</span> yesNo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (yesNo == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"NO"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"YES"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> areTheyDifferent;</span><br><span class="line">    <span class="comment">// 调用areTheDifferent函数</span></span><br><span class="line">    areTheyDifferent = areIntsDifferent(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 调用boolString函数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"are %d and %d different? %@"</span>, <span class="number">5</span>, <span class="number">5</span>, boolString(areTheyDifferent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4   小结"></a>2.4   小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_01 启程/" itemprop="url">
                  1 启程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T11:14:49+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_01 启程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_01 启程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-预备知识"><a href="#1-1-预备知识" class="headerlink" title="1.1 预备知识"></a>1.1 预备知识</h2><h2 id="1-2-历史"><a href="#1-2-历史" class="headerlink" title="1.2 历史"></a>1.2 历史</h2><blockquote>
<p><strong>Objective-C：</strong>20世纪80年代，<code>Brad Cox</code>为了融合流行的、可移植的<code>C语言</code>和<code>Smalltalk语言</code>的优势，设计出了<code>Objective-C语言</code>。 <strong>NeXT公司：</strong>1985年，<code>史蒂夫.乔布斯</code>创建，致力于创建功能强大且经济实惠的工作站。<br><strong>NextSTEP：</strong>使用<code>Object-C</code>开发的一款功能强大的用户界面工具包。 <strong>Cocoa：</strong>1996年，苹果收购了<code>NeXT</code>,之后<code>NextSTEP</code>更名为<code>Cocoa</code>。</p>
</blockquote>
<h2 id="1-3-内容简介"><a href="#1-3-内容简介" class="headerlink" title="1.3 内容简介"></a>1.3 内容简介</h2><h2 id="1-4-准备工作"><a href="#1-4-准备工作" class="headerlink" title="1.4 准备工作"></a>1.4 准备工作</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/25 国际化特性/" itemprop="url">
                  25 国际化特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:30:56+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/25 国际化特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/25 国际化特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>地区：</strong>可能是国家、洲或省活着一种特定的文化。<br><strong>扩展：</strong>1994年通过的<code>ISO C标准修正草案1</code>提供了编写额外国际化程序增加的额外库</p>
<ul>
<li>iso646.h</li>
<li>wctype.h</li>
<li>wchar.h</li>
</ul>
</blockquote>
<h2 id="25-1-locale-h：本地化"><a href="#25-1-locale-h：本地化" class="headerlink" title="25.1 locale.h：本地化"></a>25.1 locale.h：本地化</h2><blockquote>
<p><strong>标准库中依赖地区的部分：</strong></p>
<ul>
<li><strong>数值的格式：</strong>例如，一些地区小数点是一个圆点（297.48），而在另一些地方则是逗号（297,48）<br><strong>货币的格式：</strong>例如，不同国家的货币符号不同<br><strong>字符集：</strong>例如，亚洲国家通常比西方国家需要更大的字符集<br><strong>日期和时间的表示形式：</strong>例如，一些地方习惯在写日期时先写月（8/24/97），而另一些地方习惯先写日（24/8/97）</li>
</ul>
</blockquote>
<h3 id="25-1-1-类别"><a href="#25-1-1-类别" class="headerlink" title="25.1.1    类别"></a>25.1.1    类别</h3><blockquote>
<p><strong>说明：</strong><code>locale.h</code>提供了一系列的以<code>LC_</code>开头的宏来，这些宏分别对某些库的某些方面的行为产生影响。<br><strong>扩展：</strong>C语言的实现提供了其它类型并且定义了上面未列出的以<code>LC_</code>开头的宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>影响</th>
<th>头文件</th>
<th>相关章节</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE</td>
<td>strcoll函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td></td>
<td>strxfrm函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td>LC_CTYPES</td>
<td>isdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>isxdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>多字节函数</td>
<td>stdlib.h</td>
<td><a href="">25.2.1</a></td>
<td></td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>影响该函数返回的货币格式信息</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>格式化输入输出函数中使用的小数点字符</td>
<td>stdio.h</td>
<td><a href="">22</a></td>
<td>比如<code>printf</code>和<code>scanf</code></td>
</tr>
<tr>
<td></td>
<td>字符串转换函数</td>
<td>stdlib.h</td>
<td><a href="">26.2.1</a></td>
<td><code>atof</code>和<code>strtod</code></td>
</tr>
<tr>
<td></td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>该函数返回的非货币格式信息</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>strftime函数</td>
<td>time.h</td>
<td><a href="">26.3.2</a></td>
<td>该函数用于将时间转换为字符串</td>
</tr>
</tbody>
</table>
<h3 id="25-1-2-setlocale函数"><a href="#25-1-2-setlocale函数" class="headerlink" title="25.1.2    setlocale函数"></a>25.1.2    setlocale函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>用来修改当前的地区，也可以用来获取当前地区的信息。<br><strong>参数：</strong><br><strong>1：</strong> 可以针对一种类型，也可以针对所有类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数1取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE、LC_CTYPE、LC_MONETARY 、LC_NUMERIC、LC_TIME</td>
<td>针对一种类型</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>针对所有类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>2：</strong> C语言标准为第二个参数仅定义了两种可能值：”c”或” “。其他地区可以针对不同的实现定义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数二取值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;C&quot;</code></td>
<td>按正常方式执行，小数点是一个句点</td>
<td></td>
</tr>
<tr>
<td><code>&quot; &quot;</code></td>
<td>换到<code>本地模式（native locale）</code></td>
<td><code>C语言标准</code>没有定义切换到本地模式的具体影响</td>
</tr>
<tr>
<td><code>&quot;Germany&quot;</code></td>
<td>德国</td>
<td>部分编译器支持</td>
</tr>
<tr>
<td>类似<code>en_GB.WIN1252</code>格式的字符串</td>
<td>英语_英国.Windows多语言字符集</td>
<td>一些常用编译器支持</td>
</tr>
<tr>
<td><code>NULL</code></td>
<td>不设置任何东西</td>
<td>仅仅返回指向与当前地区类型的设置相关联的字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>如果需要获得与当前地区关联字符串，可以在调用setlocale函数时第一个参数给<code>LC_ALL</code>，第二个参数给<code>NULL</code>.<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; category  指定影响哪些库的哪些方面</span><br><span class="line">* @param &#123;char *&#125; locale 指定地区</span><br><span class="line">* @return &#123;char *&#125; 指向字符串（可能是地点名字自身）：成功；空指针：调用失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setlocale</span><span class="params">(<span class="keyword">int</span> category, <span class="keyword">const</span> <span class="keyword">char</span> *locale)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意程序执行开始时，都会隐含执行调用</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取地区信息字符串 */</span></span><br><span class="line"><span class="keyword">char</span> *temp, *old_locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前地区信息 */</span></span><br><span class="line">temp = setlocale(LC_ALL, NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查是否获取到信息 */</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为信息的副本分配空间 */</span></span><br><span class="line">old_locale = <span class="built_in">malloc</span>(strlen(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (old_locale == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* 分配内存失败 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将信息拷贝进去 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(old_locale, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换到本地模式 */</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按照存储的信息恢复就的地区设置 */</span></span><br><span class="line">setlocale(LU_ALL, old_locale);</span><br></pre></td></tr></table></figure>
<h3 id="25-1-3-localeconv函数"><a href="#25-1-3-localeconv函数" class="headerlink" title="25.1.3    localeconv函数"></a>25.1.3    localeconv函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>获取当前地区的各种信息<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;struct lconv *&#125; 指向包含当前地区的详细信息的结构体指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> lconv *<span class="title">localeconv</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="struct-lconv"><a href="#struct-lconv" class="headerlink" title="struct lconv"></a>struct lconv</h4><hr>
<blockquote>
<p><strong>说明：</strong>存储当前地区的各种信息的结构体<br><strong>结构成员：</strong>有<code>char *</code>和<code>char</code>两种类型</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">char *型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.50.57.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">char型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.53.18.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>p_sign_posn和n_sign_posn的值：</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.56.18.png" alt="Alt text"></p>
</blockquote>
<p><strong>案例：用于美国和意大利两国的lconv结构成员的货币型常用值</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.57.34.png" alt="Alt text"></p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.59.18.png" alt="Alt text"></p>
<h2 id="25-2-多字节字符和宽字符"><a href="#25-2-多字节字符和宽字符" class="headerlink" title="25.2 多字节字符和宽字符"></a>25.2 多字节字符和宽字符</h2><blockquote>
<p><strong>字符集（美国）：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>地位</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII</td>
<td>主流计算机采用</td>
</tr>
<tr>
<td>EBCDIC</td>
<td>其他计算机</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>可扩展字符集：</strong>C语言允许编译器提供一种可扩展的字符集</p>
</blockquote>
<table>
<thead>
<tr>
<th>可扩展字符集编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>多字节字符（multibyte character）</td>
<td>一个或多个字节表示一个可扩展的字符</td>
</tr>
<tr>
<td>宽字符（wide character）</td>
<td>一种其值表示字符的整数，具有相同的字节数</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>基本字符：</strong>任何可扩展的字符集必须包含C语言要求的<code>基本字符</code>（即<code>字母</code>、<code>数字</code>、<code>运算符</code>、<code>标点符</code>、<code>空白字符</code>），而且这些字符要求是单字节的。<br><strong>用途：</strong>c语言同时提供了多字节字符和宽字符用于不同的目的</p>
<ul>
<li><strong>多字节字符：</strong>多用于输入／输出，因为输入／输出设备经常是面向字节的</li>
<li><strong>宽字符：</strong>更适用于程序内部，因为没个宽字符占有相同的空间，便于程序内部操作。</li>
</ul>
<p><strong>技巧：</strong>程序可以读入多字节字符，然后转为便于程序内部操作的宽字符格式，谈后再把宽字符转换回用于输出的多字节格式。</p>
</blockquote>
<h3 id="25-2-1-多字节字符"><a href="#25-2-1-多字节字符" class="headerlink" title="25.2.1    多字节字符"></a>25.2.1    多字节字符</h3><blockquote>
<p><strong>空字符(<code>\0</code>)：</strong>无论移位状态如何，c标准都要求<code>\0</code>始终用来表示空字符。而且，<code>\0</code>不能是多字节字符的第二个（或之后）字节。<br><strong>按是否依赖状态分类：</strong><code>mblen函数</code>、<code>mbtowc函数</code>、<code>wctomb函数</code>都可用检测对字节字符是否是依赖状态的。只要其char *型参数给予NULL实参，则返回非零说明依赖状态；返回零说明依赖状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖状态编码（state-dependent enciding）</td>
<td>每个多字节字符序列都以<code>初始移位状态（initial shift state）</code>开始，序列中稍后遇到的一些多字节字符会改变移位状态，并且会影响后续字节的含义</td>
<td>日本的JIS编码</td>
</tr>
<tr>
<td>不依赖状态编码</td>
<td>每个字符要求一个或者两个字节，但是双字节字符的第一个字节可以始终区别与单字节字符</td>
<td>日本的Shift-JIS编码</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关宏：</strong>两个</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>头文件</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>MB_LEN_MAX</td>
<td>limit.h</td>
<td>任意支持区域的最大值</td>
<td></td>
</tr>
<tr>
<td>MB_CUR_MAX</td>
<td>stdlib.h</td>
<td>当前区域的最大值</td>
<td>改变地区可能会影响多字节字符的解释</td>
</tr>
</tbody>
</table>
<h3 id="25-2-2-宽字符"><a href="#25-2-2-宽字符" class="headerlink" title="25.2.2    宽字符"></a>25.2.2    宽字符</h3><blockquote>
<p><strong>说明：</strong>采用特殊实现（比如<code>unsigned short int</code>）支持的所有宽字符都要求相同的字节数。<br><strong>宽字符类型：</strong><code>wchar_t</code> (<code>stddef.h</code>、<code>stdlib.h</code>)<br><strong>宽字符常量和宽字符串常量：</strong><code>L字符（串）常量</code></p>
<ul>
<li>宽字符常量：<code>L&#39;a&#39;</code></li>
<li>宽字符串常量：<code>L&quot;abc&quot;</code></li>
</ul>
</blockquote>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><blockquote>
<p><strong>说明：</strong>非常重要的固定长度编码的字符集。<br><strong>字符宽度：</strong>两个字节</p>
</blockquote>
<h3 id="25-2-3-多字节字符／宽字符转换函数"><a href="#25-2-3-多字节字符／宽字符转换函数" class="headerlink" title="25.2.3    多字节字符／宽字符转换函数"></a>25.2.3    多字节字符／宽字符转换函数</h3><h4 id="mblen函数"><a href="#mblen函数" class="headerlink" title="mblen函数"></a>mblen函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>检测s是否指向形成由效多字节字符的字节序列<br><strong>原型：</strong><code>stdlib.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符的字节序列</span><br><span class="line">* @param &#123;size_t&#125; a 最多能将测的字节的数量（通常为MB_CUR_MAX）</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符序列；0:空字符；-1：不是多字节字符序列</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mblen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, size_t a)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 确定字符串是否由有效的多字节字符构成</span><br><span class="line">* @param &#123;char *s&#125; 指向以空字符结尾的普通字符串</span><br><span class="line">* @return &#123;int&#125; 0或－1</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbcheck</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 通过mblen(NULL, 0)设置该函数的移位状态，以便可以正确解释字符串中稍后的字符</span></span><br><span class="line">	<span class="keyword">for</span> (mblen(NULL, <span class="number">0</span>); ; s += n) &#123;</span><br><span class="line">		<span class="comment">// 当</span></span><br><span class="line">		<span class="keyword">if</span> ((n = mblen(s, MB_CUR_MAX)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mbtowc函数"><a href="#mbtowc函数" class="headerlink" title="mbtowc函数"></a>mbtowc函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将多字节字符串转换为宽字符<br><strong>原型：</strong><code>stdlib.h.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;wchar_t *&#125; pwc 函数将存储结果的变量</span><br><span class="line">* @para &#123;char *&#125; s 多字节字符</span><br><span class="line">* @param &#123;size_t&#125; n 最大将检测的字节的数量</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符；0:空字符；-1：不是多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbtowc</span><span class="params">(wchar_t *pwc, <span class="keyword">const</span> <span class="keyword">char</span> *s, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="wctomb函数"><a href="#wctomb函数" class="headerlink" title="wctomb函数"></a>wctomb函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把宽字符转换为多字节字符<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储结果的变量（不回附加空字符）</span><br><span class="line">* @param &#123;wchar_t&#125; wchar 多字节字符</span><br><span class="line">* @return &#123;int&#125; 字符中的字节数：有效；1：空字符；-1：无效</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wctomb</span><span class="params">(<span class="keyword">char</span> *s, wchar_t wchar)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将测是否可以把宽字符的字符串转换为有效的多字节字符</span><br><span class="line">* @param &#123;wchar_t *&#125; wcs 宽字符序列</span><br><span class="line">* @return &#123;int&#125; -1：不可以；0：可以</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wccheck</span> <span class="params">(wchar_t *wcs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[MB_len_max];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span> (wctpmb (NULL, <span class="number">0</span>); ; ++wcs) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((n = wctomb(buf, *wcs)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (buf[n - <span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">			return <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-2-4-多字节字符／宽字符串函数"><a href="#25-2-4-多字节字符／宽字符串函数" class="headerlink" title="25.2.4    多字节字符／宽字符串函数"></a>25.2.4    多字节字符／宽字符串函数</h3><h4 id="mbstowcs函数"><a href="#mbstowcs函数" class="headerlink" title="mbstowcs函数"></a>mbstowcs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把多字节字符序列转换为宽字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（存储在宽字符数组中的)<code>\0</code>时，函数停止</li>
<li>假设要转换的字符串以初始迁移状态开始</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 宽字符数组</span><br><span class="line">* @param &#123;char *&#125; s 待转换的多字节字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的宽字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无效的多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> mbstowcs(<span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h4 id="wcstombs函数"><a href="#wcstombs函数" class="headerlink" title="wcstombs函数"></a>wcstombs函数</h4><blockquote>
<p><strong>说明：</strong>把宽字符序列转换为多字节字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（自己存入的)<code>\0</code>时，函数停止</li>
<li>产生的字符串是以初始迁移状态开始的</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符数组</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 待转换的宽字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的多字节字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无法转换为对应多字节字符的宽字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> wcstombs(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h2 id="25-3-三字符序列"><a href="#25-3-三字符序列" class="headerlink" title="25.3    三字符序列"></a>25.3    三字符序列</h2><blockquote>
<p><strong>三字符序列（trigraph sequence）：</strong>简称“三字符”，是一种三个字符的字符码。以<code>??字符</code>的形式出现。<br><strong>用途：</strong>可以替换ASCII中的一些特殊字符。<br><strong>兼容性：</strong>尽管不是一直需要，但是所有标准C编译器都要求接受三字符序列。<br><strong>技巧：</strong>字符串中的<code>??</code>可能会被编译器作为三字符序列的开始标志，可以通过使用<code>\</code>将第二个<code>?</code>转义（即<code>?\?</code>）来避免。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-21%20%E4%B8%8A%E5%8D%889.53.05.png" alt="Alt text"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">??=include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main () ??&lt;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world??/n"</span>); </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">??&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/26 其它库函数/" itemprop="url">
                  26 其他库函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:25:08+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/26 其它库函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/26 其它库函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="26-1-stdarg-h：可变实参"><a href="#26-1-stdarg-h：可变实参" class="headerlink" title="26.1    stdarg.h：可变实参"></a>26.1    stdarg.h：可变实参</h2><blockquote>
<p><strong>带有可变参数的函数：</strong>带有可变数量参数的函数必须至少有一个“正常的”形式参数，在最后一个正常参数的后边始终会有省略号出现在参数列表的末尾。<br><strong>可变部分实参提升：</strong>当调用带有可变实参列表的函数时，编译器会在匹配省略号的全部参数上执行默认的<code>实参提升</code>（<a href="">9.3</a>）</p>
<ul>
<li>char -&gt; int</li>
<li>short -&gt; int</li>
<li>float -&gt; double</li>
</ul>
</blockquote>
<h4 id="va-arg宏（函数）"><a href="#va-arg宏（函数）" class="headerlink" title="va_arg宏（函数）"></a>va_arg宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>获得所在函数的可变参数中的下一个参数<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 指向可变参数列表的某个位置</span><br><span class="line">* @param &#123;类型&#125; 期待相应位置实参的类型</span><br><span class="line">* @return &#123;类型&#125; 相应位置(下一个)实参</span><br><span class="line">*/</span></span><br><span class="line">类型 va_arg(va_list ap, 类型);</span><br></pre></td></tr></table></figure>
<h4 id="va-start宏（函数）"><a href="#va-start宏（函数）" class="headerlink" title="va_start宏（函数）"></a>va_start宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过支持实参列表中可变长度部分开始的位置初始化<code>va_list</code>类型的实参列表。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 存储参数列表的变量</span><br><span class="line">* @param &#123;*&#125; paramN 可变参数前的最后一个正常实参</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(va_list ap, paramN)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="va-end宏（函数）"><a href="#va-end宏（函数）" class="headerlink" title="va_end宏（函数）"></a>va_end宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>执行对<code>va_list</code>类型变量的清理，使其无法被继续使用。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 可变实参部分的列表</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; n 后面可变参数的数量</span><br><span class="line">* @param &#123;*&#125; ... 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 可变实参中的最大值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span> <span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明存储可变实参列表的变量</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">int</span> i, current, largest;</span><br><span class="line">	<span class="comment">// 初始化存储可变部分的实参的列表</span></span><br><span class="line">	va_start(ap, n);</span><br><span class="line">	<span class="comment">// 遍历寻找最大值</span></span><br><span class="line">	largest = va_arg(ap, int);</span><br><span class="line">	<span class="keyword">for</span> (i = i; i &lt; n; i ++) &#123;</span><br><span class="line">		current = va_arg(ap, int);</span><br><span class="line">		<span class="keyword">if</span> (current &gt; largest) &#123;</span><br><span class="line">			largest = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清理存储可变实参的列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	return largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-1-1-调用可变实参列表的函数"><a href="#26-1-1-调用可变实参列表的函数" class="headerlink" title="26.1.1    调用可变实参列表的函数"></a>26.1.1    调用可变实参列表的函数</h3><blockquote>
<p><strong>说明：</strong>调用带有可变实参列表的函数带有一定风险，需要一些措施规避</p>
<ul>
<li><p>确定可变参数数量</p>
<blockquote>
<p><strong>例子：</strong>max_int函数依靠第一个是惨知名跟随其后的其他参数的数量</p>
</blockquote>
</li>
<li><p>确定每种参数的类型</p>
<blockquote>
<p><strong>例子：</strong>像printf函数和scanf函数依靠格式化字符串来描述其他的参数的数量和每种参数的类型</p>
</blockquote>
</li>
<li><p>特别处理<code>NULL</code>作为参数：当把<code>NULL</code>(0)传递给带有可变实参列表的函数时，编译器会假定它表示的是一个整数</p>
<blockquote>
<p><strong>强制类型转换：</strong><code>(void *) NULL</code>代替<code>NULL</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="26-1-2-v…printf类函数"><a href="#26-1-2-v…printf类函数" class="headerlink" title="26.1.2    v…printf类函数"></a>26.1.2    v…printf类函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...printf类函数</code>相比，由一个<code>va_list</code>类型的参数取代了可变参数部分。<br><strong>用途：</strong>编写“包装”函数。外部的包装函数接受可变数量的实参，并且稍后把这些参数传递给<code>v...printf类函数</code>。</p>
</blockquote>
<h4 id="vfprintf函数"><a href="#vfprintf函数" class="headerlink" title="vfprintf函数"></a>vfprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向第一个参数说明的流（任何输出流）中写输出。<br><strong>关联的函数：</strong><code>vfprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（流）</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE * <span class="keyword">restrict</span> stream, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vprintf函数"><a href="#vprintf函数" class="headerlink" title="vprintf函数"></a>vprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向stdout输出，利用格式串控制输出的形式<br><strong>关联的函数：</strong><code>vprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @param &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list rga)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vsprintf函数"><a href="#vsprintf函数" class="headerlink" title="vsprintf函数"></a>vsprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>类似printf函数和fprintf函数，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定制错误输出</span><br><span class="line">* @param &#123;char *&#125; format 格式化字符串</span><br><span class="line">* @param &#123;...*&#125; 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 输出的字符数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">errorf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num_errors = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 声明可变数组列表</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	num_errors++;</span><br><span class="line">	<span class="comment">// 打印需要增强的部分</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"** Error %d: "</span>, num_errors);</span><br><span class="line">	<span class="comment">// 初始化可变数组列表</span></span><br><span class="line">	va_start(ap, format);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入字符串（打印到屏幕）</span></span><br><span class="line">	n = <span class="built_in">vfprintf</span>(stderr, format, ap);</span><br><span class="line">	<span class="comment">// 清理可变参数列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入“换行”</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-2-stdlib-h-通用的使用工具"><a href="#26-2-stdlib-h-通用的使用工具" class="headerlink" title="26.2    stdlib.h:    通用的使用工具"></a>26.2    stdlib.h:    通用的使用工具</h2><blockquote>
<p><strong>说明：</strong>涵盖累全部不适合于任何其他头的函数。</p>
<ul>
<li>字符串转换函数</li>
<li>伪随机序列生成函数</li>
<li>内存管理函数</li>
<li>与外部环境的通信</li>
<li>搜索与排序使用工具</li>
<li>整数算术运算函数(<a href="">17</a>)</li>
<li>多子节字符和字符串函数(<a href="">25.2</a>)</li>
</ul>
</blockquote>
<h3 id="26-2-1-字符串转换函数"><a href="#26-2-1-字符串转换函数" class="headerlink" title="26.2.1    字符串转换函数"></a>26.2.1    字符串转换函数</h3><blockquote>
<p><strong>字符串中的特殊子串：</strong></p>
<ul>
<li><strong>十六进制浮点数</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>0x(X)</code></th>
<th>一个或多个<code>十六进制数字</code>（可能包括<code>小数点</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>无穷数</strong>：<code>INF</code>（不要求大小写）或`INFINITY（不要求大小写）</li>
<li><strong>NaN</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>NAN</code></th>
<th><code>(</code></th>
<th><code>空</code>或<code>一系列字符</code></th>
<th><code>)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>不要求大小写</td>
<td></td>
<td>可以包含字母、数组或下划线，用于<code>为NaN值的二进制表示指定某些位</code>或被<code>nan函数</code>(<a href="">23.4</a>)调用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="atof函数（c89之前）"><a href="#atof函数（c89之前）" class="headerlink" title="atof函数（c89之前）"></a>atof函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>double</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;double&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoi函数（c89之前）"><a href="#atoi函数（c89之前）" class="headerlink" title="atoi函数（c89之前）"></a>atoi函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span><br><span class="line">int atoi (const chat *nptr)；</span><br></pre></td></tr></table></figure>
<h4 id="atol函数（c89之前）"><a href="#atol函数（c89之前）" class="headerlink" title="atol函数（c89之前）"></a>atol函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>long int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtod函数（c89）"><a href="#strtod函数（c89）" class="headerlink" title="strtod函数（c89）"></a>strtod函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>double</code>，相比<code>atof函数（c89之前）</code></p>
<ul>
<li>返回值为<code>double</code>而不是<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtold</code>、<code>strtof</code>)</li>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回正或负的<code>HUGE_VAL</code>(<a href="">23.3</a>)</li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）<br><strong>原型：</strong><code>stdlib.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">strtod</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtol函数（c89）"><a href="#strtol函数（c89）" class="headerlink" title="strtol函数（c89）"></a>strtol函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code>，相比<code>atol函数（c89之前）</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoul函数（c89）"><a href="#strtoul函数（c89）" class="headerlink" title="strtoul函数（c89）"></a>strtoul函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtold函数-C99"><a href="#strtold函数-C99" class="headerlink" title="strtold函数(C99)"></a>strtold函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long double</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>long double</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtof</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;long double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">strtold</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoll函数-c99"><a href="#atoll函数-c99" class="headerlink" title="atoll函数(c99)"></a>atoll函数(c99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，和<code>atol函数（c89之前）</code>相比</p>
<ul>
<li>转换为<code>long long int</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code></li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtof函数-C99"><a href="#strtof函数-C99" class="headerlink" title="strtof函数(C99)"></a>strtof函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>float</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtold</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;float&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">strtof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoll函数-C99"><a href="#strtoll函数-C99" class="headerlink" title="strtoll函数(C99)"></a>strtoll函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，类似<code>strtol函数（c89）</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoull函数-C99"><a href="#strtoull函数-C99" class="headerlink" title="strtoull函数(C99)"></a>strtoull函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>unsigned long long int</code>，类似<code>strtoul函数(c89)</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoull</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试数值转换函数"><a href="#程序：测试数值转换函数" class="headerlink" title="程序：测试数值转换函数"></a>程序：测试数值转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Test c89 numeric conversion functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHK_VALID printf(<span class="string">"    %s        %s\n"</span>, \</span><br><span class="line"> 					     errno != ERANGE ? <span class="string">"Yes"</span> : <span class="string">"No "</span>, \</span><br><span class="line"> 					     *ptr == <span class="string">'\0'</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="comment">/* 检测程序启动方式是否正确 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: tnumconv string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使用c89之前的3个旧转换函数 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function Return Value\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------    --------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atof        %g\n"</span>, atof(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atoi        %d\n"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atol        %ld\n"</span>, atol(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function    Return Value    Valid?    "</span></span><br><span class="line">		   <span class="string">"String Consumed?\n"</span></span><br><span class="line">		   <span class="string">"--------    ------------    ------    "</span></span><br><span class="line">		   <span class="string">"------------------\n"</span>);</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtod    %-12g\n"</span>, strtod(argv[<span class="number">1</span>], &amp;ptr));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtol    %-12ld\n"</span>, strtol(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtoul    %-12lu\n"</span>, strtoul(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-24%20%E4%B8%8A%E5%8D%8810.36.50.png" alt="Alt text"></p>
<h3 id="26-2-3-伪随机序列生成函数"><a href="#26-2-3-伪随机序列生成函数" class="headerlink" title="26.2.3    伪随机序列生成函数"></a>26.2.3    伪随机序列生成函数</h3><h4 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>返回一个<code>0～RAND_MAX(stdlib.h)</code>的随机数。<br><strong>说明：</strong><code>rand函数</code>返回的数事实上不是随机的，这些数是由“种子”值（默认为1）产生的，但对于偶然的观察者而言，rand函数似乎能能够产生不相关的数值序列。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;int&#125; `0～RAND_MAX(stdlib.h)`的随机数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="srand函数"><a href="#srand函数" class="headerlink" title="srand函数"></a>srand函数</h4><blockquote>
<p><strong>描述：</strong>在<code>rand函数</code>执行前执行该函数来为<code>rand函数</code>提供种子值。<br><strong>注意：</strong>同一个种子值对应着一组特定的随机序列<br><strong>技巧：</strong>把<code>time函数</code>的返回值传递给<code>srand函数</code>设置“随机化”的种子值，这样可以使<code>rand函数</code>在每次运行时的行为都不相同。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests the pseudo-random sequence generation functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program displays the first five value of "</span></span><br><span class="line">		   <span class="string">"rand.\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter new seed value (0 to terminate):"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seed);</span><br><span class="line">		<span class="keyword">if</span> (seed == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		srand(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-3-与环境的通信"><a href="#26-2-3-与环境的通信" class="headerlink" title="26.2.3    与环境的通信"></a>26.2.3    与环境的通信</h3><blockquote>
<p><strong>说明：</strong>一组简单的操作系统接口。</p>
<ol>
<li>正常或不正常地终止程序，并且想操作系统反悔一个状态码</li>
<li>从用户的外部环境获取信息</li>
<li>执行操作系统的命令</li>
</ol>
</blockquote>
<h4 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统。<br><strong>细节：</strong>通常还会在后台做一些最后的动作</p>
<ul>
<li>清洗包好未输出数据的输出缓冲区</li>
<li>关闭打开的流</li>
<li>删除临时文件</li>
<li>调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
</ul>
<p><strong>说明：</strong>通常等价于在<code>main函数</code>中执行<code>return n</code>，具有可移植性的状态码包括</p>
<ul>
<li><strong>EXIT_SUCCESS宏：</strong>正常退出(整数0)</li>
<li><strong>EXIT_FAILURE宏：</strong>非正常退出</li>
</ul>
<p><strong>注意：</strong><code>exit函数</code>和<code>return语句</code>的不同表现在</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>exit函数</th>
<th>return语句</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main函数</code>中局部变量的生命周期</td>
<td>不结束</td>
<td>结束（如果用<code>atexit函数</code>注册的函数或<code>清洗输出流的缓冲区</code>访问这些变量就会出现问题）</td>
</tr>
<tr>
<td>使用<code>int</code>之外的类型</td>
<td>可以</td>
<td>必须和<code>mian函数</code>的返回类型保持一致，否则</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>当把函数指针传递给<code>aexit函数</code>时，它会把指针保存起来，当程序正常终止时会被调用。</p>
<ul>
<li>通过<code>exit函数</code>被调用或<code>main函数</code>中的<code>return</code>语句触发</li>
<li>如果注册了两个或更多函数，那么将按照与注册顺序<code>相反</code>的顺序调用它们</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void (*func)(void)&#125; func 函数指针</span><br><span class="line">* @return &#123;int&#125; 未知</span><br><span class="line">*/</span><br><span class="line">int atexit (void (*func)(void));</span><br></pre></td></tr></table></figure>
<h4 id="Exit函数（c99）"><a href="#Exit函数（c99）" class="headerlink" title="_Exit函数（c99）"></a>_Exit函数（c99）</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统<br><strong>说明：</strong>类似<code>exit函数</code></p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
<li>不会调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
<li>不回发送信号触发<code>signal函数</code>（<a href="">24.3</a>）注册的函数</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> _Exit (<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>通常会导致异常的程序终止，长生<code>SIGABRT信号</code>并向系统返回一个表示“不成功”的状态码。<br><strong>注意：</strong>有一种情况下不会导致程序终止，那就是通过<code>signal函数</code>为<code>SIGABRT信号</code>注册处理函数，且处理函数调用了<code>longjmp函数</code>恢复到之前的执行环境。<br><strong>说明：</strong>类似<code>exit</code>函数，特点是</p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a>getenv函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>提供了访问用户环境中的任意字符串（环境变量）的功能。<br><strong>说明：</strong>获得的指针指向的字符串是静态的，有可能会被其它函数调用或系统自身修改。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; name 环境变量名</span><br><span class="line">* @return &#123;char *&#125; 指向静态分配的字符串的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "/usr/local/bin:/bin:/usr/bin:." */</span></span><br><span class="line"><span class="keyword">char</span> *p = getenv(<span class="string">"PATH"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>运行另一个c程序（可以是操作系统命令）<br><strong>说明：</strong>类似在操作系统终端使用命令行</p>
<ul>
<li><strong>参数：</strong>以<code>NULL</code>作为参数有特殊含义</li>
<li><strong>返回值</strong>：（由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; string 命令</span><br><span class="line">* @return &#123;int&#125; 由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用UNIX(Linux)的ls命令，并将结果存入myfiles</span></span><br><span class="line">system(<span class="string">"ls &gt;myfiles"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="26-2-4-搜索和排序使用工具"><a href="#26-2-4-搜索和排序使用工具" class="headerlink" title="26.2.4    搜索和排序使用工具"></a>26.2.4    搜索和排序使用工具</h3><h4 id="bsearch函数"><a href="#bsearch函数" class="headerlink" title="bsearch函数"></a>bsearch函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据键在<code>有序数组</code>中搜索一个特定的值。<br><strong>说明：</strong>通常会使用<code>二分搜索算法</code>来搜索在数组中搜索<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; key 指向键（匹配依据）的指针</span><br><span class="line">* @param &#123;void *&#125; base 数组</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @param &#123;Function *&#125; compar 指向比较函数的指针</span><br><span class="line">* @return &#123;void *&#125; 指向与键匹配的指针：匹配到；NULL：没匹配到</span><br><span class="line">*/</span><br><span class="line">void *bsearch (const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h4 id="qsort函数"><a href="#qsort函数" class="headerlink" title="qsort函数"></a>qsort函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>为数组进行排序<br><strong>相关：</strong><a href="">17.1</a><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;Function *&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h3 id="程序：确定航空里程"><a href="#程序：确定航空里程" class="headerlink" title="程序：确定航空里程"></a>程序：确定航空里程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine air mileage from New York City.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> city_info &#123;</span><br><span class="line">	<span class="keyword">char</span> *city;</span><br><span class="line">	<span class="keyword">int</span> miles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> city_name[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">struct</span> city_info *ptr;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> city_info mileage[] = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Berlin"</span>, <span class="number">3965</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Buenos Aires"</span>, <span class="number">5297</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cairo"</span>, <span class="number">5602</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Calcutta"</span>, <span class="number">7918</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cape Town"</span>, <span class="number">7764</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter city name:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%80[^\n]"</span>, city_name);</span><br><span class="line">	ptr = bsearch(city_name, mileage, sizeof(mileage) / sizeof(mileage[<span class="number">0</span>]), sizeof(mileage[<span class="number">0</span>]), compare_cityes);</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is %d miles from New York City.\n"</span>, city_name, ptr-&gt;miles);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s wasn't found."</span>, city_name);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">strcmp</span>((char *) key_ptr, ((struct city_info *) element_ptr)-&gt;city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-5-整数运算函数"><a href="#26-2-5-整数运算函数" class="headerlink" title="26.2.5    整数运算函数"></a>26.2.5    整数运算函数</h3><h4 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; j 需要求绝对值的整数</span><br><span class="line">* @return &#123;int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="labs函数"><a href="#labs函数" class="headerlink" title="labs函数"></a>labs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="llabs函数"><a href="#llabs函数" class="headerlink" title="llabs函数"></a>llabs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="div函数"><a href="#div函数" class="headerlink" title="div函数"></a>div函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>ldiv</code><br>|比较|<code>div(ldiv)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>div（ldiv）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; number 除数</span><br><span class="line">* @param &#123;int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> div (<span class="keyword">int</span> number, <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="ldiv函数（c99）"><a href="#ldiv函数（c99）" class="headerlink" title="ldiv函数（c99）"></a>ldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>div</code><br>|比较|<code>ldiv(div)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>ldiv（div）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; number 除数</span><br><span class="line">* @param &#123;long  int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="lldiv函数（c99）"><a href="#lldiv函数（c99）" class="headerlink" title="lldiv函数（c99）"></a>lldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; number 除数</span><br><span class="line">* @param &#123;long long int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h2 id="26-3-time-h：日期和时间"><a href="#26-3-time-h：日期和时间" class="headerlink" title="26.3    time.h：日期和时间"></a>26.3    time.h：日期和时间</h2><blockquote>
<p><strong>说明：</strong>存储时间的数据结构。</p>
<ul>
<li><code>clock_t</code>：按照“时钟滴答”进行度量的时间值。</li>
<li><code>time_t</code>：紧凑的时间和日期编码（日历时间）</li>
<li><code>struct tm</code>：包含分解的时间的结构体<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-02%20%E4%B8%8B%E5%8D%889.40.49.png" alt="Alt text"><br>❶ 允许两个额外的“闰秒”。c99中最大值为60。<br>❷ 如果夏令时有效，就为正数；如果无效，为零；如果这一信息未知，就为负数。</li>
</ul>
</blockquote>
<h3 id="26-3-1-时间处理函数"><a href="#26-3-1-时间处理函数" class="headerlink" title="26.3.1    时间处理函数"></a>26.3.1    时间处理函数</h3><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回程序从开始执行到当前时刻的处理器时间（时钟数）。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;clock_t&#125; 程序从此启动到当前经过的处理器时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">clock_t</span> clock (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>为了将处理器时间转换为秒，将其除以<code>CLOCK_PER_SEC</code>(定义在<code>time.h</code>)。</li>
<li>当用<code>clock</code>函数来确定程序已经运行多长时间时（不包括到达<code>main函数</code>之前的时间），习惯做法时调用<code>clock函数</code>两次：一次在<code>main函数</code>开始处，一次在程序要终止之前。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 第一次调用 */</span></span><br><span class="line">	<span class="keyword">clock_t</span> start_clock = clock();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* 第二次调用 */</span></span><br><span class="line">	<span class="comment">/* CLOCK_PER_SEC：类型由实现定义，c99指定其为clock_t类型 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Processor time used: %g sec.\n"</span>, (clock() - start_clock / (double) CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回当前的日历时间。</p>
<ul>
<li>如果参数不为<code>NULL</code>,那么<code>time函数</code>还会把日历时间存储在实参指向的空间中。</li>
</ul>
<p><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t *&#125; timer 指向存储当前日历时间的存储空间（可以为NULL）</span><br><span class="line">* @return &#123;time_t&#125; 当前的日历时间 </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">time_t</span> time (<span class="keyword">time_t</span> *timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用返回值</span></span><br><span class="line">cur_time = time(NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过参数指定存储的位置</span></span><br><span class="line">time(&amp;cur_time);</span><br></pre></td></tr></table></figure>
<h4 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过两个时间点的日历时间，返回两个时间点之间的时间差（秒）<br><strong>用途：</strong>计算程序的运行时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; 日历时间</span><br><span class="line">* @param &#123;time_t&#125; 日历时间（较早的时间）</span><br><span class="line">* @return &#123;double&#125; time0和time1之间按秒衡量的差值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(time_t time1, time_t time0)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第一个日历时间</span></span><br><span class="line">	<span class="keyword">time_t</span> start_time = time(NUULL);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 第二个日历时间，并计算时间差</span></span><br><span class="line">	ptintf(<span class="string">"Return time: %g sec.\n"</span>, difftime(NULL), start_time);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把<code>struct tm</code>(分解时间)类型的时间转换为日历时间并返回。<br><strong>用途：</strong>对于和时间、日期相关的计算非常有用。<br><strong>副作用：</strong>会按照一定规则调整结构的成员</p>
<ul>
<li><strong>改变值不在合法范围内的成员：</strong>一个成员的数值的调整可能会导致接连对其它成员的调整，直到全部合法。</li>
<li>初始化<code>tm_wday</code>（一星期的第几天）和<code>tm_yday</code>（一年中的第几天）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明分解时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化分解时间 */</span></span><br><span class="line">t.tm_mday = <span class="number">27</span>;<span class="comment">/* 日 */</span></span><br><span class="line">t.tm_mon = <span class="number">6</span>;<span class="comment">/* 月 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保证其他成员被正确初始化 */</span></span><br><span class="line">t.tm_sec = <span class="number">0</span>;</span><br><span class="line">t.tm_min = <span class="number">0</span>;</span><br><span class="line">t.tm_hour = <span class="number">0</span>;</span><br><span class="line">t.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 制造超出取值范围的情况 */</span></span><br><span class="line">t.tm_mday = += <span class="number">16</span>; <span class="comment">/* 43 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将分解时间转为日历时间，将导致原本的分解时间成员被修改 */</span></span><br><span class="line">mktime(&amp;t);</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.42.02.png" alt="Alt text"></p>
<h3 id="26-3-2-时间转换函数"><a href="#26-3-2-时间转换函数" class="headerlink" title="26.3.2    时间转换函数"></a>26.3.2    时间转换函数</h3><blockquote>
<p><strong>说明：</strong>转换示意图<br> <img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.44.39.png" alt="Alt text"><br><strong>注意：</strong>其中的<code>mktime函数</code>被C标准定义为<code>处理函数</code>而不是<code>转换函数</code>。</p>
</blockquote>
<h4 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是<code>UTC</code>(协调世界时间)。<br><strong>注意：</strong>返回值指向的是一个静态分配的结构，会被后续的<code>getime函数</code>或<code>localtime函数</code>调用修改。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; timer 日历时间</span><br><span class="line">* @return &#123;struct tm&#125; 分解时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是本地时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;&#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asctime函数"><a href="#asctime函数" class="headerlink" title="asctime函数"></a>asctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将分解时间转换为字符串格式。</p>
<blockquote>
<p><code>Sun Jun 3 17:48:34 2007\n</code></p>
</blockquote>
<p><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 指向分解时间结构体的指针</span><br><span class="line">* @return &#123;char *&#125; 字符串形式的时间(ASCII时间)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ctime函数"><a href="#ctime函数" class="headerlink" title="ctime函数"></a>ctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为字符串格式。<br><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; time 日历时间</span><br><span class="line">* @return &#123;char *&#125; 描述本地时间的字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span> <span class="params">(<span class="keyword">const</span> time_t *time)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strftime函数"><a href="#strftime函数" class="headerlink" title="strftime函数"></a>strftime函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>把分解时间转换成字符串格式。<br><strong>注意：</strong>函数对地区敏感，改变<code>LC_TIME</code>可能会影响转换说明符的行为。<br><strong>转换说明符：</strong></p>
<ul>
<li>针对<code>&quot;C&quot;</code>地区（c89~c99），支持<code>ISO 8601</code><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.54.27.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.55.24.png" alt="Alt text"></li>
<li>一些转换说明符在<code>&quot;C&quot;</code>地区的替换字符串（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.58.53.png" alt="Alt text"></li>
<li><code>E</code>或<code>O</code>修饰符：修改特定的转换说明符，替换为依赖当前地区的备选格式（<code>&quot;C&quot;</code>地区忽略<code>E</code>或<code>O</code>）（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8811.04.15.png" alt="Alt text"></li>
</ul>
<p><strong>说明：</strong>类似<code>asctime函数</code>，但提供了大量对时间进行格式化的控制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 指向用来存储字符串形式的时间的空间</span><br><span class="line">* @param &#123;size_t&#125; maxsize 存储在s中的字符数量上限</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 分解时间</span><br><span class="line">* @return &#123;size_t&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strftime (<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, <span class="keyword">const</span> <span class="keyword">struct</span> tm * restricy timeptr);</span><br></pre></td></tr></table></figure>
<h3 id="程序：显示日期和时间"><a href="#程序：显示日期和时间" class="headerlink" title="程序：显示日期和时间"></a>程序：显示日期和时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Display the current date and time in three formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 1. 获得日历时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> current = time(NULL);</span><br><span class="line">	<span class="keyword">struct</span> tm *ptr;</span><br><span class="line">	<span class="keyword">char</span> date_time[<span class="number">21</span>];</span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="keyword">char</span> am_or_pm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：ctime默认的的字符串形式 */</span></span><br><span class="line">	<span class="built_in">puts</span>(ctime(&amp;current));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：strftime默认的字符串形式 */</span></span><br><span class="line">	strftime(date_time, <span class="keyword">sizeof</span>(date_time), <span class="string">"%m-%d-%Y %I:%M%p\n"</span>, localtime(&amp;current));</span><br><span class="line">	<span class="built_in">puts</span>(date_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期和时间：使用printf结合分解时间 */</span></span><br><span class="line">	ptr = localtime(&amp;current);</span><br><span class="line">	hour = ptr-&gt;tm_hour;</span><br><span class="line">	<span class="keyword">if</span> (hour &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">		am_or_pm = <span class="string">'a'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hour -= <span class="number">12</span>;</span><br><span class="line">		am_or_pm = <span class="string">'p'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour == <span class="number">0</span>) &#123;</span><br><span class="line">		hour = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2d-%.2d-%.2d %2d:%.2d%c\n"</span>, ptr-&gt;tm_mon + <span class="number">1</span>, ptr-&gt;tm_mday, ptr-&gt;tm_year + <span class="number">1900</span>, hour, ptr-&gt;tm_min, am_or_pm);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./datetime</span><br><span class="line"> Wed Nov  4 10:41:12  2015</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41AM</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41a</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/24 错误处理/" itemprop="url">
                  24 错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T11:42:41+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/24 错误处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/24 错误处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>C语言的弱项：</strong>错误的检测和处理并不是c语言的强项</p>
<ul>
<li>C语言对运行时错误以多种形式表示，而没有提供一种统一的方式</li>
<li>程序员必须将检测错误的代码编写在程序代码中，因此很容易忽略一些错误</li>
</ul>
<p><strong>扩展：</strong>C++语言对C语言的这一弱点进行了改进，提供了一种新的错误错误的方式－异常处理（exception handling）。</p>
</blockquote>
<h2 id="24-1-assert-h：诊断"><a href="#24-1-assert-h：诊断" class="headerlink" title="24.1    assert.h：诊断"></a>24.1    <code>assert.h</code>：诊断</h2><h4 id="assert宏（函数）"><a href="#assert宏（函数）" class="headerlink" title="assert宏（函数）"></a>assert宏（函数）</h4><blockquote>
<p><strong>断言：</strong>一个我们认为在正常情况下一顶为真的表达式。<br><strong>错误信息：</strong>标准C要求在显示的消息中指明以下内容</p>
<ul>
<li>传递给assert函数的参数</li>
<li>包括assert调用的文件名</li>
<li>assert调用所在的行号</li>
</ul>
<p><strong>说明：</strong>检查断言，如果值不为0，会向<code>stderr</code>输出一条信息，并调用<code>abort函数</code>终止程序。<br><strong>技巧：</strong>因为引入了额外的检查，因此会增加程序的运行时间。可以在测试没问题后通过<code>NDEBUG</code>（宏）进制<code>assert</code>调用。<br><strong>注意：</strong>因为assert可能会被禁用，因此不要在assert调用中使用有副作用的表达式。<br><strong>原型</strong><code>assert.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; expresstion 断言</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i];</span><br><span class="line">assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; N);<span class="comment">// 保证下标不回溢出</span></span><br><span class="line">a [i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><em>禁止assert调用</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG<span class="comment">// 值不重要，定义了就行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="24-2-errno-h：错误"><a href="#24-2-errno-h：错误" class="headerlink" title="24.2    errno.h：错误"></a>24.2    <code>errno.h</code>：错误</h2><blockquote>
<p><strong>说明：</strong>除了<code>EDOM</code>和<code>ERANGE</code>,还定义了其他宏，这是合法的，但命名要遵循C标准，即<code>E数组或大写字母</code></p>
</blockquote>
<h4 id="errno宏"><a href="#errno宏" class="headerlink" title="errno宏"></a>errno宏</h4><hr>
<blockquote>
<p><strong>描述：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和变量一样使用。<br><strong>说明：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和普通变量一样使用。<br><strong>用途：</strong>函数被调用后会会为<code>errno</code>赋值，如果<code>errno</code>不为0，代表函数调用过程中有错误发生。<br><strong>应用：</strong>大部分使用<code>errno</code>变量的函数集中在<code>math.h</code>，也有一些在标准库的其他部分。<br><strong>相关宏：</strong><code>EDOM</code>和<code>ERANGE</code>,errno中存储的值通常是这两个宏</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏（errno的值）</th>
<th>错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDOM</td>
<td>定义域错误</td>
<td>传递给函数的一个参数不属于函数的定义域</td>
</tr>
<tr>
<td>ERANGE</td>
<td>取值范围错误</td>
<td>函数的返回值太大，无法用double</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用库函数</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sqrt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>向<code>stderr</code>输出一条错误信息。<br><strong>错误信息：</strong><code>sqrt error: Math argument</code>（定义域错误）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">perror的参数</th>
<th style="text-align:center">分号</th>
<th style="text-align:center">空格</th>
<th style="text-align:center">出错消息</th>
<th style="text-align:center">换行符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sqrt error</td>
<td style="text-align:center">:</td>
<td style="text-align:center"></td>
<td style="text-align:center">Math argument</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 错误描述</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sqrt</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测运行状况</span></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"sqrt error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据错误类型行值返回指向错误字符串的指针。<br><strong>原型：</strong><code>string.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; errnum 错误类型值</span><br><span class="line">* @return &#123;char *&#125; 对应的错误字符串 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="24-3-signal-h：信号处理"><a href="#24-3-signal-h：信号处理" class="headerlink" title="24.3    signal.h：信号处理"></a>24.3    <code>signal.h</code>：信号处理</h2><blockquote>
<p><strong>信号（signal）：</strong>处理异常情况的工具</p>
<ul>
<li><p>运行时错误</p>
<blockquote>
<p>例如：除以0</p>
</blockquote>
</li>
<li><p>程序以外导致的事件</p>
<blockquote>
<p>例如：许多操作系统都允许用户终端或终止运行的程序</p>
</blockquote>
</li>
</ul>
<p><strong>异步的：</strong>它们可以在程序执行过程中的任意时刻发生，而不仅是在程序员所知道的特定时刻发生</p>
</blockquote>
<h3 id="24-3-1-信号宏"><a href="#24-3-1-信号宏" class="headerlink" title="24.3.1    信号宏"></a>24.3.1    信号宏</h3><blockquote>
<p><strong>兼容性：</strong>C标准不要求下面列表中的信号都会发生，大多数C语言的实现都至少支持其中一部分。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>异常终止（可能由于调用abort导致）</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>在数学运算中发生错误（可能是除以0或溢出）</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGINT</td>
<td>中断</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法存储访问</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止请求</td>
</tr>
</tbody>
</table>
<h3 id="24-3-2-signal函数"><a href="#24-3-2-signal函数" class="headerlink" title="24.3.2    signal函数"></a>24.3.2    signal函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>为指定信号注册指定处理函数。<br><strong>相关宏：</strong><code>SIG_ERR</code></p>
<blockquote>
<p><strong>说明：</strong>当注册失败时会返回该值<br><strong>用途：</strong>检测注册处理函数是否成功</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p><strong>多对一：</strong><code>信号</code>与处理函数是<code>多对一</code>的关系</p>
<ul>
<li>可以对多种信号绑定同一个处理函数，处理函数可以根据传入的参数（信号类型）决定进行哪种操作</li>
<li>也可以对同一个信号注册多个处理程序，但前面注册的会被后面注册的处理函数覆盖。</li>
</ul>
<p><strong>同步性：</strong>发出信号的行为是异步的，但处理函数处理的过程是同步的。也就是说，注册了处理函数的信号出现后，程序会暂停并执行信号处理函数，返回后暂停的程序从信号发生点恢复并继续执行。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>处理函数返回后程序行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>终止</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>处理函数返回后的程序行为未定义</td>
</tr>
<tr>
<td>其它</td>
<td>暂停的程序从信号发生点恢复并继续执行</td>
</tr>
</tbody>
</table>
<blockquote>
<blockquote>
<p><strong>一次性：</strong>信号处理完之后，除非处理函数被重新注册，否则该信号不回被同一个函数处理两遍。<br><strong>无限递归问题：</strong>如果信号是由处理这个信号的函数引发的，如果没有其它机制将会发生无限递归。所以，C语言要求，除了<code>SIGTLL</code>，当一个信号的处理函数被调用时，该信号对应的处理函数要么要被重置为<code>SIG_DFL</code>或以其它方式加以封锁。</p>
</blockquote>
<p><strong>限制：</strong>处理函数和普通函数相比多了一些限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>可以</th>
<th>不可以</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以忽略该信号</td>
<td>自由调用库函数</td>
</tr>
<tr>
<td>执行一些错误修复</td>
<td>访问静态存储期限的变量</td>
</tr>
<tr>
<td>终止程序</td>
<td></td>
</tr>
<tr>
<td>可以调用<code>signal</code>，只要第一个参数为正被处理的信号</td>
<td></td>
</tr>
<tr>
<td>调用库函数，只要信号处理函数是由raise或abort调用的</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @param &#123;func *&#125; func 处理函数</span><br><span class="line">* @return &#123;func *&#125; 指向注册过同样信号的上一个处理函数的指针：成功；SIG_ERR：注册失败（同时会在errno中存储一个正值）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> *(*signal)(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(int));<span class="comment">// 书上写法是：void (*signal(int sig, void (*func)(int)))(int);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为中断注册处理函数，并将之前的处理函数存储下来</span></span><br><span class="line">orig_handler = signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orig_handler == SIG_ERR) &#123;</span><br><span class="line">	<span class="comment">// 注册处理函数失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成原来的处理函数</span></span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-3-预定义的信号处理函数"><a href="#24-3-3-预定义的信号处理函数" class="headerlink" title="24.3.3    预定义的信号处理函数"></a>24.3.3    预定义的信号处理函数</h3><blockquote>
<p><strong>说明：</strong>出了编写我们自己的信号处理函数，我们还可以选择使用<code>signal.h</code>提供的预定义的处理函数。<br><strong>预定义的信号处理函数命名规则：</strong></p>
<blockquote>
<p><code>SIG_</code>大写字母</p>
</blockquote>
</blockquote>
<h4 id="SIG-DFL宏（函数）"><a href="#SIG-DFL宏（函数）" class="headerlink" title="SIG_DFL宏（函数）"></a>SIG_DFL宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>按“默认”的方式处理<br><strong>描述：</strong>行为由实现定义，大多数情况下会导致程序终止。<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_DFL</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN); <span class="comment">// 使用默认行为响应“中断”信号</span></span><br></pre></td></tr></table></figure>
<h4 id="SIG-IGN宏（函数）"><a href="#SIG-IGN宏（函数）" class="headerlink" title="SIG_IGN宏（函数）"></a>SIG_IGN宏（函数）</h4><hr>
<blockquote>
<p><strong>描述：</strong>什么都不做，忽略信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_IGN</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="24-3-4-raise函数"><a href="#24-3-4-raise函数" class="headerlink" title="24.3.4    raise函数"></a>24.3.4    raise函数</h3><hr>
<blockquote>
<p><strong>说明：</strong>触发信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发SIGABORT</span></span><br><span class="line">raise(SIGABOUT);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-5-程序：测试信号"><a href="#24-3-5-程序：测试信号" class="headerlink" title="24.3.5    程序：测试信号"></a>24.3.5    程序：测试信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests signals</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明函数指针</span></span><br><span class="line">	<span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1. 第一次实验*/</span></span><br><span class="line">	<span class="comment">// 注册处理函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---first--- %d\n"</span>, SIGILL);</span><br><span class="line">	signal(SIGILL, handler);</span><br><span class="line">	<span class="comment">// 触发信号</span></span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2. 第二次实验*/</span></span><br><span class="line">	<span class="comment">// 再次注册,忽略相应信号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---second---\n"</span>);</span><br><span class="line">	orig_handler = signal(SIGILL, SIG_IGN);</span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3. 第三次实验*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---third---\n"</span>);</span><br><span class="line">	<span class="comment">// 更改为第一次实验使用的处理函数</span></span><br><span class="line">	signal(SIGILL, orig_handler);</span><br><span class="line">	raise_sig();</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Handler called for signal %d\n"</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	raise(SIGILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsignal</span><br><span class="line"> ---first--- 4</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br><span class="line"> ---second---</span><br><span class="line"> ---third---</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br></pre></td></tr></table></figure>
<h2 id="24-4-setjmp-h：非局部跳转"><a href="#24-4-setjmp-h：非局部跳转" class="headerlink" title="24.4    setjmp.h：非局部跳转"></a>24.4    setjmp.h：非局部跳转</h2><blockquote>
<p><strong>说明：</strong>通常情况下，函数调用后会回到它被调用的位置。但<code>setjmp.h</code>提供了使一个函数直接跳转到另一个函数（而且不需要返回）的方式。<br><strong>goto：</strong>只能配合标记实现<code>局部跳转</code>，也就是在同一个函数内部跳转。</p>
</blockquote>
<h3 id="setjmp宏（函数）"><a href="#setjmp宏（函数）" class="headerlink" title="setjmp宏（函数）"></a>setjmp宏（函数）</h3><blockquote>
<p><strong>描述：</strong>标记程序中的一个“位置”<br><strong>应用：</strong>生成标记位置，稍后提供给<code>longjmp函数</code><br><strong>限制：</strong>按照<code>标准C</code>，只有两种使用setjmp的方式是合法的(否则不具备可移植性)</p>
<ul>
<li>作为表达式语句（可能会前置转换成void）</li>
<li>作为<code>if、switch、while、do、for</code>语句中控制表达式的一部分(<code>constexp</code>：计算结果为整数的<em>常量表达式</em>；<code>op</code>：<em>关系</em>或<em>判等</em>运算符)</li>
</ul>
<ol>
<li>setjmp(…)</li>
<li>!setjmp(…)</li>
<li><code>constexp</code> <code>op</code> <code>constexp</code></li>
<li>setjmp(…) <code>op</code> <code>constexp</code></li>
</ol>
<p><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env 用来保存生成的被调用时所处的“位置”(数组)</span><br><span class="line">* @return &#123;int&#125; 0：第一次调用时返回；非0：longjmp将控制权重新转给最初的setjmp宏调用，后者这次的返回值非零</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a>longjmp函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>首先根据参数env的值恢复当前环境，然后从<code>setjmp宏</code>调用中返回<br><strong>注意：</strong>一定要确保参数env已经被<code>setjmp宏</code>初始化了，否则程序可能会崩溃。<br><strong>应用：</strong>可以由多种潜在的用途，但主要被用于错误处理。<br><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env</span><br><span class="line">* @param &#123;int&#125; val</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试setjmp和longjmp"><a href="#程序：测试setjmp和longjmp" class="headerlink" title="程序：测试setjmp和longjmp"></a>程序：测试setjmp和longjmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests setjmp/longjmp</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @type &#123;jmp_buf&#125; env 存储位置数据的全局变量</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">// 获得存储位置</span></span><br><span class="line">	ret = setjmp(env);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"setjmp returned %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次执行到这里的时候值不为0</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Program terminates: longjmp called\n"</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f1();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这句不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Program terminates normally\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 begins\n"</span>);</span><br><span class="line">	f2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 returns\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 begins\n"</span>);</span><br><span class="line">	<span class="comment">// 按照env的值跳转到指定的环境</span></span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 returns\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsetjmp               </span><br><span class="line"> setjmp returned <span class="number">0</span></span><br><span class="line"> f1 begins</span><br><span class="line"> f2 begins</span><br><span class="line"> setjmp returned <span class="number">1</span></span><br><span class="line"> Program terminates: longjmp called</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/23 库对数值和字符数据的支持/" itemprop="url">
                  23 库对数值和字符数据的支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:31:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/23 库对数值和字符数据的支持/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/23 库对数值和字符数据的支持/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="23-1-float-h-浮点型的特性"><a href="#23-1-float-h-浮点型的特性" class="headerlink" title="23.1    float.h:浮点型的特性"></a>23.1    <code>float.h</code>:浮点型的特性</h2><p><strong>说明：</strong>提供了用来定义浮点型的范围和精度的宏（没有类型和函数的定义）。<br><strong>应用：</strong>由于只有进行数值分析的专家才会对上述<code>float.h</code>中定义的宏感兴趣，这可能是标砖哭中最不常用的宏。</p>
<h3 id="23-1-1-对浮点数通用的宏"><a href="#23-1-1-对浮点数通用的宏" class="headerlink" title="23.1.1    对浮点数通用的宏"></a>23.1.1    对浮点数通用的宏</h3><h4 id="FLT-ROUND宏"><a href="#FLT-ROUND宏" class="headerlink" title="FLT_ROUND宏"></a>FLT_ROUND宏</h4><p><strong>说明：</strong>浮点加法的舍入模式，存在5中可能<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.12.40.png" alt="Alt text"></p>
<h4 id="FLT-RADIX宏"><a href="#FLT-RADIX宏" class="headerlink" title="FLT_RADIX宏"></a>FLT_RADIX宏</h4><p><strong>说明：</strong>指定了基数的形式，最小值是2（二进制）</p>
<h3 id="23-1-2-其它宏"><a href="#23-1-2-其它宏" class="headerlink" title="23.1.2    其它宏"></a>23.1.2    其它宏</h3><p><strong>说明：</strong>其他宏用来描述特定类型的特性。<br><strong>宏命名：</strong>根据宏是针对的浮点类型有不同的前缀</p>
<table>
<thead>
<tr>
<th>宏前缀</th>
<th>针对的浮点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT</td>
<td>float</td>
</tr>
<tr>
<td>DBL</td>
<td>double</td>
</tr>
<tr>
<td>LDBL</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h4 id="与有效数字个数相关的宏"><a href="#与有效数字个数相关的宏" class="headerlink" title="与有效数字个数相关的宏"></a>与有效数字个数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.19.57.png" alt="Alt text"></p>
<h4 id="与指数相关的宏"><a href="#与指数相关的宏" class="headerlink" title="与指数相关的宏"></a>与指数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="Alt text"></p>
<h4 id="其它宏"><a href="#其它宏" class="headerlink" title="其它宏"></a>其它宏</h4><p><strong>说明：</strong>描述了最大值、最接近0的值（最小正数），两个数之间的最小差值。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.22.22.png" alt="Alt text"></p>
<h2 id="23-2-limit-h：整值类型的大小"><a href="#23-2-limit-h：整值类型的大小" class="headerlink" title="23.2    limit.h：整值类型的大小"></a>23.2    <code>limit.h</code>：整值类型的大小</h2><p><strong>说明：</strong>提供了用于定义每种整型和字符型取值范围的宏（没有类型或函数）。</p>
<h3 id="23-2-1-用于字符型的宏"><a href="#23-2-1-用于字符型的宏" class="headerlink" title="23.2.1    用于字符型的宏"></a>23.2.1    用于字符型的宏</h3><p><strong>说明：</strong><code>char、signed char、unsigned char</code><br><strong>注意：</strong>char类型在有些机器上默认为unsigned char，有些默认为signed char。CHAR_MIN和CHAR_MAX的值因不同情况有所不同。<br>①</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MIN</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MIN</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MAX</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MAX</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR_MAX</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.08.05.png" alt="Alt text"></p>
<h3 id="23-2-2-用于整型的宏"><a href="#23-2-2-用于整型的宏" class="headerlink" title="23.2.2    用于整型的宏"></a>23.2.2    用于整型的宏</h3><p><strong>说明：</strong><code>[{signed|unsigned}] [{short|long}] int</code><br><strong>用途：</strong>在查看编译器是否支持特定大小的整数时十分方便<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.27.34.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用预处理指令判断int型是否可以用来存储100 000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small<span class="comment">// 终止编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择正确的类型定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &gt;= 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="23-3-math-h：数学计算"><a href="#23-3-math-h：数学计算" class="headerlink" title="23.3    math.h：数学计算"></a>23.3    <code>math.h</code>：数学计算</h2><p><strong>说明：</strong>包含5中类型</p>
<ol>
<li>三角函数</li>
<li>双曲函数</li>
<li>指数和对数函数</li>
<li>幂函数</li>
<li>就近取整函数绝对值函数和取余函数</li>
</ol>
<h3 id="23-3-1-错误"><a href="#23-3-1-错误" class="headerlink" title="23.3.1    错误"></a>23.3.1    错误</h3><p><strong>相关库：</strong><code>errno.h</code><br><strong>特点：</strong><code>math.h</code>中，大多数函数会将一个错误代码存储到一个名字为<code>errno</code>（<code>math.h</code>）的特定变量中（这一点不同于其他库）。<br><strong>相关宏：</strong><code>HUGE_VAL</code>(<code>math.h</code>， IEEE标准)</p>
<blockquote>
<p><strong>说明：</strong>在<code>math.h</code>中定义，double类型，不一定是一个普通的数，代表无穷大（<a href="">7.2</a>）。<br><strong>用途：</strong>当函数的返回值大于double类型的最大值时，会返回<code>HUGE_VAL</code>。<br><strong>更多错误：</strong><a href="">附录D</a></p>
</blockquote>
<h4 id="参数超出定义域"><a href="#参数超出定义域" class="headerlink" title="参数超出定义域"></a>参数超出定义域</h4><p><strong>描述：</strong>函数的是惨超出了函数的定义域。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>EDOM</code>(定义域错误)<br><strong>返回值：</strong><code>NAN</code>(<code>math.h</code>， IEEE标准)</p>
<h4 id="返回值超出取值范围"><a href="#返回值超出取值范围" class="headerlink" title="返回值超出取值范围"></a>返回值超出取值范围</h4><p><strong>描述：</strong>函数的返回值超出了double类型的取值范围。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>ERANGE</code>(取值范围错误)，绝对值过小（下溢出）的情况又可能不存储<code>ERANGE</code><br><strong>返回值：</strong>分两种情况</p>
<ol>
<li><strong>绝对值过大：</strong>根据返回值的正负返回正或负的<code>HIGE_VAL</code></li>
<li><strong>绝对值过小：</strong>返回0</li>
</ol>
<h3 id="23-3-2-三角函数"><a href="#23-3-2-三角函数" class="headerlink" title="23.3.2    三角函数"></a>23.3.2    三角函数</h3><h4 id="cos函数"><a href="#cos函数" class="headerlink" title="cos函数"></a>cos函数</h4><p><strong>说明：</strong>余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sin函数"><a href="#sin函数" class="headerlink" title="sin函数"></a>sin函数</h4><p><strong>说明：</strong>正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tan函数"><a href="#tan函数" class="headerlink" title="tan函数"></a>tan函数</h4><p><strong>说明：</strong>正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="acos函数"><a href="#acos函数" class="headerlink" title="acos函数"></a>acos函数</h4><p><strong>说明：</strong>反余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 余弦值</span><br><span class="line">* @return &#123;double&#125; 余弦值对应的弧度（0~π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asin函数"><a href="#asin函数" class="headerlink" title="asin函数"></a>asin函数</h4><p><strong>说明：</strong>反正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正弦值</span><br><span class="line">* @return &#123;double&#125; 正弦值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan函数"><a href="#atan函数" class="headerlink" title="atan函数"></a>atan函数</h4><p><strong>说明：</strong>反正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正切值</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan2函数"><a href="#atan2函数" class="headerlink" title="atan2函数"></a>atan2函数</h4><p><strong>说明：</strong>反正切，<code>atan(x)&lt;==&gt;atan2(x, 1.0)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; y y</span><br><span class="line">* @param &#123;double&#125; x x</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π～π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cos</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(PI/<span class="number">4</span>);<span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">1.0</span>);<span class="comment">// 0.0</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">1.0</span>);<span class="comment">// 1.5708</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1.0</span>);<span class="comment">// 0.785398</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-4-双曲函数"><a href="#23-3-4-双曲函数" class="headerlink" title="23.3.4    双曲函数"></a>23.3.4    双曲函数</h3><h4 id="cosh函数"><a href="#cosh函数" class="headerlink" title="cosh函数"></a>cosh函数</h4><p><strong>说明：</strong>计算双曲余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cosh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sinh函数"><a href="#sinh函数" class="headerlink" title="sinh函数"></a>sinh函数</h4><p><strong>说明：</strong>计算双曲正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sinh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p><strong>说明：</strong>计算双曲正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tanh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cosh</span>(<span class="number">0.5</span>);<span class="comment">// 1.12763</span></span><br><span class="line"><span class="built_in">sinh</span>(<span class="number">0.5</span>);<span class="comment">// 0.521095</span></span><br><span class="line"><span class="built_in">tanh</span>(<span class="number">0.5</span>);<span class="comment">// 0.462117</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-指数函数和对数函数"><a href="#22-3-4-指数函数和对数函数" class="headerlink" title="22.3.4 指数函数和对数函数"></a>22.3.4 指数函数和对数函数</h3><h4 id="exp函数"><a href="#exp函数" class="headerlink" title="exp函数"></a>exp函数</h4><p><strong>说明：</strong>返回e的幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 指数</span><br><span class="line">* @return &#123;double&#125; e的x次幂</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e的3次幂</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">3.0</span>);<span class="comment">// 20.0855</span></span><br></pre></td></tr></table></figure>
<h4 id="log函数"><a href="#log函数" class="headerlink" title="log函数"></a>log函数</h4><p><strong>说明：</strong>以e为底的对数（exp函数的逆运算）<br><strong>原型：</strong>math.h``</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return double 以e为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">20.0855</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="log10函数"><a href="#log10函数" class="headerlink" title="log10函数"></a>log10函数</h4><p><strong>说明：</strong>计算常用对数（以10为底的对数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return &#123;double&#125; 以10为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log10</span>(<span class="number">1000</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 对任意的x和b，计算以b为底x的对数</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @param &#123;double&#125; b 底数</span><br><span class="line">* @return &#123;double&#125; 以b为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">logb</span><span class="params">(<span class="keyword">double</span> x. <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">log</span>(x) / <span class="built_in">log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="frexp函数"><a href="#frexp函数" class="headerlink" title="frexp函数"></a>frexp函数</h4><p><strong>说明：</strong>将浮点数拆成小数部分f和指数部分n，使得原始值等于<code>f x 2^n</code>。<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 浮点数原始值</span><br><span class="line">* @param &#123;double *&#125; iptr 存储n的地址</span><br><span class="line">* @return &#123;double&#125; f（0.5&lt;=f&lt;=1）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lfexp</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">frexp</span>(<span class="number">12.0</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// .75, exp: 4</span></span><br><span class="line"><span class="built_in">frexp</span>(<span class="number">0.25</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// 0.5, exp: -1</span></span><br></pre></td></tr></table></figure>
<h4 id="ldexp函数"><a href="#ldexp函数" class="headerlink" title="ldexp函数"></a>ldexp函数</h4><p><strong>说明：</strong>将小数部分f和整数部分exp组合为，一般而言为<code>f x 2^exp</code>(frexp函数的逆函数)<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; f 小数部分</span><br><span class="line">* @param &#123;int&#125; exp 整数部分</span><br><span class="line">* @return &#123;double&#125; f x 2^exp</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ldexp</span><span class="params">(<span class="keyword">double</span> f <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ldexp</span>(<span class="number">.75</span>, <span class="number">4</span>);<span class="comment">// 12.0</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.5</span>, <span class="number">-1</span>);<span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>
<h4 id="modf函数"><a href="#modf函数" class="headerlink" title="modf函数"></a>modf函数</h4><p><strong>说明：</strong>将一个浮点数的整数部分和小数部分拆解开，返回小数部分，并将整数部分存入第二个参数所指向的变量中<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 原始浮点数</span><br><span class="line">* @param &#123;double *&#125; iptr 存储整数部分的地址</span><br><span class="line">* @return &#123;double&#125; 小数部分 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-3-5-幂函数"><a href="#23-3-5-幂函数" class="headerlink" title="23.3.5    幂函数"></a>23.3.5    幂函数</h3><h4 id="pow函数"><a href="#pow函数" class="headerlink" title="pow函数"></a>pow函数</h4><p><strong>说明：</strong>计算x的y次幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 底数</span><br><span class="line">* @param &#123;double&#125; y 指数</span><br><span class="line">* @param &#123;double&#125; x^y</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);<span class="comment">// 9.0</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">0.5</span>);<span class="comment">// 1.73205</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">-3.0</span>);<span class="comment">// 0.037037</span></span><br></pre></td></tr></table></figure>
<h4 id="sqrt函数"><a href="#sqrt函数" class="headerlink" title="sqrt函数"></a>sqrt函数</h4><p><strong>说明：</strong>计算平方根（算数平方根），<code>sqrt(x)</code>相当于<code>pow(x, 0.5)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 开放数</span><br><span class="line">* @return &#123;double&#125; 平方根</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(<span class="number">3.0</span>);<span class="comment">// 1.73205</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-6-就近取整函数、绝对值函数和取余函数"><a href="#23-3-6-就近取整函数、绝对值函数和取余函数" class="headerlink" title="23.3.6    就近取整函数、绝对值函数和取余函数"></a>23.3.6    就近取整函数、绝对值函数和取余函数</h3><h4 id="ceil函数"><a href="#ceil函数" class="headerlink" title="ceil函数"></a>ceil函数</h4><p><strong>说明：</strong>向上舍入（计算大于或等于其参数的最小整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="floor函数"><a href="#floor函数" class="headerlink" title="floor函数"></a>floor函数</h4><p><strong>说明：</strong>向下舍入（计算小于或等于其参数的最大整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.1</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.8</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.1</span>);<span class="comment">// -7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.1</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.8</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.1</span>);<span class="comment">// -8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 实现“四舍五入”（标准库没实现）</span><br><span class="line">* @param &#123;double&#125; x 原始的浮点数</span><br><span class="line">* @return &#123;double&#125; 四舍五入后的</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	return x &lt; <span class="number">0.07</span> ? <span class="built_in">ceil</span>(x - <span class="number">0.5</span>) : <span class="built_in">floor</span>(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fabs函数"><a href="#fabs函数" class="headerlink" title="fabs函数"></a>fabs函数</h4><p><strong>说明：</strong>计算参数的绝对值<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 原始浮点数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="number">7.1</span>);<span class="comment">// 7.1</span></span><br><span class="line"><span class="built_in">fabs</span>(<span class="number">-7.1</span>);<span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<h4 id="fmod函数"><a href="#fmod函数" class="headerlink" title="fmod函数"></a>fmod函数</h4><p><strong>说明：</strong>取余（第一个参数除以第二个参数所得的余数）<br><strong>注意：</strong><code>%</code>只能用于整数，不能用于浮点数<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;double&#125; x 被除数</span><br><span class="line">* @param &#123;double&#125; y 除数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(<span class="number">5.5</span>, <span class="number">2.2</span>);<span class="comment">// 1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="23-4-ctype-h：字符处理"><a href="#23-4-ctype-h：字符处理" class="headerlink" title="23.4    ctype.h：字符处理"></a>23.4    <code>ctype.h</code>：字符处理</h2><p><strong>说明：</strong><code>ctype.h</code>提供了两类函数</p>
<ol>
<li><p>字符测试函数</p>
<blockquote>
<p><strong>举例</strong><br><code>isdigit函数</code>：用来检测一个字符是否是数字</p>
</blockquote>
</li>
<li><p>字符大小写转换函数</p>
<blockquote>
<p><strong>举例</strong><br><code>toupper函数</code>：用来将一个小写字母转换成大写字母</p>
</blockquote>
</li>
</ol>
<p><strong>技巧：</strong>建议使用<code>ctype.h</code>中提供的函数而不是用其他手段测试字符或进行大小写转换</p>
<ol>
<li>性能更好（大多数是用宏实现的）</li>
<li>可移植性更好（可以在任何字符集上运行）</li>
<li>国际化（可以正确运行在世界上不同地点）</li>
</ol>
<p><strong>特点（参数和返回值类型）</strong><code>ctype.h</code>中的函数都以<code>int</code>类型作为参数，并返回一个<code>int</code>类型的值（C语言可以自动将<code>char</code>类型的参数转换为<code>int</code>类型，或将<code>int</code>类型的返回值转换成<code>char</code>类型）。</p>
<h3 id="23-4-1-字符测试函数"><a href="#23-4-1-字符测试函数" class="headerlink" title="23.4.1    字符测试函数"></a>23.4.1    字符测试函数</h3><p><strong>说明：</strong>这些函数具有一样的<code>参数类型</code>和<code>返回值类型</code>。<br><strong>原型：</strong><code>ctype.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 要测试的字符</span><br><span class="line">* @param &#123;int&#125; 1:测试符合期待；0:测试不符合期待</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> 函数名(<span class="keyword">int</span> c);</span><br></pre></td></tr></table></figure>
<h4 id="字符测试函数列表"><a href="#字符测试函数列表" class="headerlink" title="字符测试函数列表"></a>字符测试函数列表</h4><table>
<thead>
<tr>
<th>字符测试函数</th>
<th>测试类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum</code></td>
<td>字母或数字</td>
</tr>
<tr>
<td><code>isalpha</code></td>
<td>字母</td>
</tr>
<tr>
<td><code>iscntrl</code></td>
<td>控制字符</td>
<td>包括<code>\0x00~\0x1f</code>、<code>\0x7f</code></td>
</tr>
<tr>
<td><code>isdigit</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>isgraph</code></td>
<td>可显示字符（除空格外）</td>
</tr>
<tr>
<td><code>islower</code></td>
<td>小写字母</td>
</tr>
<tr>
<td><code>isprint</code></td>
<td>可显示字符（包括空格）</td>
</tr>
<tr>
<td><code>ispunct</code></td>
<td>标点符号</td>
<td>空格、字母、数字以外的可显示字符</td>
</tr>
<tr>
<td><code>isspace</code></td>
<td>空白字符</td>
<td>空格、换页符(<code>\f</code>)、换行符(<code>\n</code>)、回车符(<code>\r</code>)、横向制表符(<code>\t</code>)、纵向制表符(<code>\v</code>)</td>
</tr>
<tr>
<td><code>isupper</code></td>
<td>大写字母</td>
</tr>
<tr>
<td><code>isxdigit</code></td>
<td>十六进制数字</td>
</tr>
</tbody>
</table>
<h3 id="23-4-2-程序：测试字符测试函数"><a href="#23-4-2-程序：测试字符测试函数" class="headerlink" title="23.4.2    程序：测试字符测试函数"></a>23.4.2    程序：测试字符测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(f) printf(<span class="string">"%6c"</span>, f(*p) ? <span class="string">'x'</span> : <span class="string">' '</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   alnum cntrl graph print space xdigit alpha digit lower punc       upper\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"azAZ0	!\t"</span>; *p != <span class="string">'0'</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(*p)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\\x%02x:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%5c:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		TEST(<span class="built_in">isalnum</span>);</span><br><span class="line">		TEST(<span class="built_in">iscntrl</span>);</span><br><span class="line">		TEST(<span class="built_in">isgraph</span>);</span><br><span class="line">		TEST(<span class="built_in">isprint</span>);</span><br><span class="line">		TEST(<span class="built_in">isspace</span>);</span><br><span class="line">		TEST(<span class="built_in">isxdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">isalpha</span>);</span><br><span class="line">		TEST(<span class="built_in">isdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">islower</span>);</span><br><span class="line">		TEST(<span class="built_in">ispunct</span>);</span><br><span class="line">		TEST(<span class="built_in">isupper</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.01.33.png" alt="Alt text"></p>
<h3 id="23-4-3-字符大小写转换函数"><a href="#23-4-3-字符大小写转换函数" class="headerlink" title="23.4.3    字符大小写转换函数"></a>23.4.3    字符大小写转换函数</h3><h4 id="tolower函数"><a href="#tolower函数" class="headerlink" title="tolower函数"></a>tolower函数</h4><p><strong>说明：</strong>返回与作为参数的字母相对应的小写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的小写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="toupper函数"><a href="#toupper函数" class="headerlink" title="toupper函数"></a>toupper函数</h4><hr>
<p><strong>说明：</strong>返回与作为参数的字母相对应的大写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的大写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-4-4-程序：测试大小写转换函数"><a href="#23-4-4-程序：测试大小写转换函数" class="headerlink" title="23.4.4    程序：测试大小写转换函数"></a>23.4.4    程序：测试大小写转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"aA0!"</span>; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tolower('%c') is '%c';\n"</span>, *p, <span class="built_in">tolower</span>(*p));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"toupper('%c') is '%c'\n"</span>, *p, <span class="built_in">toupper</span>(*p));</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.39.11.png" alt="Alt text"></p>
<h2 id="23-5-string-h：字符串处理"><a href="#23-5-string-h：字符串处理" class="headerlink" title="23.5    string.h：字符串处理"></a>23.5    <code>string.h</code>：字符串处理</h2><p><strong>相关章节：</strong><a href="">13.5</a><br><strong>函数分类：</strong>可以分为5类</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复制函数</td>
<td style="text-align:center">将字符从内存中的一处复制到另一处</td>
</tr>
<tr>
<td style="text-align:center">拼接函数</td>
<td style="text-align:center">向字符串末尾追加字符</td>
</tr>
<tr>
<td style="text-align:center">比较函数</td>
<td style="text-align:center">比较字符数组的函数</td>
</tr>
<tr>
<td style="text-align:center">搜索函数</td>
<td style="text-align:center">在字符数组中搜索特定字符、字符组或字符串</td>
</tr>
<tr>
<td style="text-align:center">其他函数</td>
<td style="text-align:center">初始化字符数组或计算字符串的长度</td>
</tr>
</tbody>
</table>
<h3 id="23-5-1-复制函数"><a href="#23-5-1-复制函数" class="headerlink" title="23.5.1    复制函数"></a>23.5.1    复制函数</h3><p><strong>说明：</strong>共4个函数，用于将字符（字节）将内存的一处（源）移动到另一处（目的）。要求第一个参数指向目的，第二个参数指向源，并返回第一个参数（即指向目的的指针）。</p>
<h4 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时无法正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>限制：</strong>当从一块内存区域复制到另一块可能重叠的内存区域时，不能保证正常工作。<br><strong>性能：</strong>比<code>memmove函数</code>快一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">4</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">7</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时仍然可以正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>性能：</strong>比<code>memcpy函数</code>性能差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，会持续肤质字符，知道遇到一个空字符为止。<br><strong>对源的要求：</strong>要求字符串以空字符结尾。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(dest, souce);<span class="comment">// h, o, t, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncpy函数"><a href="#strncpy函数" class="headerlink" title="strncpy函数"></a>strncpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，<code>strcpy函数</code>的增强版<br><strong>对源的要求：</strong>不要求字符串以空字符串结尾，对任意内存块正常工作。<br><strong>安全：</strong>比<code>strcpy函数</code>更安全<br><strong>性能：</strong>比<code>strcpy</code>差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符（如果）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, \0, \0, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-2-拼接函数"><a href="#23-5-2-拼接函数" class="headerlink" title="23.5.2    拼接函数"></a>23.5.2    拼接函数</h3><h4 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h4><hr>
<p><strong>说明：</strong>将第一个参数追加到第一个参数的末尾</p>
<ul>
<li><strong>参数：</strong>要求两个参数都是以<code>\0</code>结尾的字符串</li>
<li><strong>返回值：</strong>返回的字符串会自动在末尾添加<code>\0</code>。</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">"bag"</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncat函数"><a href="#strncat函数" class="headerlink" title="strncat函数"></a>strncat函数</h4><hr>
<p><strong>说明：</strong><code>strcat</code>的增强版，第3个参数会限制复制的字符的个数。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @param &#123;size_t&#125; n 限制复制的字符的个数</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">2</span>);<span class="comment">// t, e, a, b, a, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">3</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">4</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-3-比较函数"><a href="#23-5-3-比较函数" class="headerlink" title="23.5.3    比较函数"></a>23.5.3    比较函数</h3><p><strong>注意：</strong>下面5个函数可以分为两类</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>比较依据</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memcmp函数</code> 、<code>strcmp函数</code>、<code>strncmp函数</code></td>
<td>计算机自身的排序顺序（通常是ACILL）</td>
<td>好</td>
</tr>
<tr>
<td><code>strcoll函数</code>、<code>strxfrm函数</code></td>
<td>依赖当前的本地化设置</td>
<td>差</td>
</tr>
</tbody>
</table>
<h4 id="memcpm函数"><a href="#memcpm函数" class="headerlink" title="memcpm函数"></a>memcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串的大小(具有限制参与比较的字符个数的参数)<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;void *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<h4 id="strcpm函数"><a href="#strcpm函数" class="headerlink" title="strcpm函数"></a>strcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串（不能设置参与比较的字符数上限），在其中一个字符数组遇到<code>\0</code>时停止比较。</p>
<ul>
<li><strong>参数：</strong>必须是以<code>\0</code>结尾的字符串</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strncmp函数"><a href="#strncmp函数" class="headerlink" title="strncmp函数"></a>strncmp函数</h4><hr>
<p><strong>说明：</strong>结合<code>memcmp</code>和<code>strcmp</code>，当比较的字符数达到字符数上限或任意一个字符数组中遇到<code>\0</code>时停止比较。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="strcoll函数"><a href="#strcoll函数" class="headerlink" title="strcoll函数"></a>strcoll函数</h4><hr>
<p><strong>说明：</strong>类似<code>strcmp</code>，不同点在于比较结果依赖本地化设置（通过调用<code>setlocale函数</code><a href="">25.1.2</a>）。<br><strong>缺点：</strong>性能差。<br><strong>应用：</strong>适用于那些根据程序运行的地点不同而可能按不同方式比较的程序。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strxfrm函数"><a href="#strxfrm函数" class="headerlink" title="strxfrm函数"></a>strxfrm函数</h4><hr>
<p><strong>说明：</strong>按照本地化设置转换字符串。<br><strong>技巧：</strong>需要考虑本地化时可以配合<code>strcmp</code>来取代<code>strcoll</code>。因为对两个转化后的参数调用<code>strcmp</code>等价直接调用<code>strcoll</code>。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 转换后的字符串存储到s1</span><br><span class="line">* @return &#123;char *&#125; s2 需要转换的字符串</span><br><span class="line">* @param &#123;char *&#125; size_t 转换的字符数量上限</span><br><span class="line">* @return &#123;size_t&#125; 转换后字符串的长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strxfrm(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * restict s2, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> *transformed;</span><br><span class="line"><span class="comment">// 获取转换后字符串的长度</span></span><br><span class="line">len = strxfrm(NULL, original, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">transformed = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将转换后的字符串存储到分配的内存中</span></span><br><span class="line">strxfrm(transformed, original, len);</span><br></pre></td></tr></table></figure>
<h3 id="23-5-4-搜索函数"><a href="#23-5-4-搜索函数" class="headerlink" title="23.5.4    搜索函数"></a>23.5.4    搜索函数</h3><h4 id="strchr函数"><a href="#strchr函数" class="headerlink" title="strchr函数"></a>strchr函数</h4><hr>
<p><strong>说明：</strong>在字符串中搜索指定字符。<br><strong>停止搜索时机：</strong>遇到首个<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;char *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,  <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">'f'</span>);<span class="comment">// 找到第一个'f'</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">strchr</span>(p + <span class="number">1</span>, <span class="string">'f'</span>);<span class="comment">// 找到第二个'f'</span></span><br></pre></td></tr></table></figure>
<h4 id="memchr函数"><a href="#memchr函数" class="headerlink" title="memchr函数"></a>memchr函数</h4><hr>
<p><strong>说明：</strong>类似<code>strchr</code>，在字符串中搜索指定字符<br><strong>停止搜索时机：</strong>搜索了指定数量的字符后<br><strong>用途：</strong>适用于不希望对整个字符串进行搜索或搜索的内存块不是以<code>\0</code>结尾时<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @param &#123;size_t&#125; n 要搜索的字符数量上限</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strrhrc函数"><a href="#strrhrc函数" class="headerlink" title="strrhrc函数"></a>strrhrc函数</h4><hr>
<p><strong>说明：</strong>函数会首先找到字符串末尾的空字符，然后反向查找字符。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s1, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[<span class="number">22</span>] = <span class="string">"Form follows function"</span>;</span><br><span class="line"><span class="comment">// 反向搜索字符'f'</span></span><br><span class="line">p = <span class="built_in">memchr</span>(strr, <span class="string">'f'</span>, sizeof(str));</span><br></pre></td></tr></table></figure>
<h4 id="strpbrk函数"><a href="#strpbrk函数" class="headerlink" title="strpbrk函数"></a>strpbrk函数</h4><hr>
<p><strong>说明：</strong>返回指向第一个实际参数中与第二个实参中任意一个字符匹配的最左边一个字符的指针。<br><strong>更通用：</strong><code>strchr</code>相当于<code>strpbrk</code>的第二个参数字符串中只给一个字符的情况。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 匹配字符集</span><br><span class="line">* @return &#123;char *&#125; 指向匹配到的字符：匹配到；指针：没有匹配到</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索第一个'm'或'n'</span></span><br><span class="line">p = <span class="built_in">strpbrk</span>(str, <span class="string">"mm"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strspn函数"><a href="#strspn函数" class="headerlink" title="strspn函数"></a>strspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个不属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<h4 id="strcspn函数"><a href="#strcspn函数" class="headerlink" title="strcspn函数"></a>strcspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strcspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">" \t\n"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h4><hr>
<p><strong>说明：</strong>在第一个参数（字符串）中搜索能匹配第二个参数（字符串）的子串，并返回找到的第一处匹配子串的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在str中搜索"fun"</span></span><br><span class="line">p = <span class="built_in">strstr</span>(str, <span class="string">"fun"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><hr>
<p><strong>说明：</strong>分割出一段子字符串。<br><strong>原理：</strong>在s1中搜索，按照s2指定的分隔符找出一系列非空字符（不包含s2中指定的字符）。<code>strtok函数</code>会写入一个<code>\0</code>来标记字符序列的末尾，并返回指向这个序列的首字符的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串（要作为分割字符的字符集合）</span><br><span class="line">* @return &#123;char *&#125; 指向新分割出来的子字符串的指针（指向首字符）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>原始字符串状态</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">" Apri1  28,1990"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th><code> </code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>月</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割出第一个序列，使用" \t"中的字符作为分隔符</span></span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">p = strtok(str, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th><code>A</code></th>
<th><code>p</code></th>
<th><code>r</code></th>
<th><code>i</code></th>
<th><code>1</code></th>
<th><code>\0</code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>日</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th><code>2</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>年</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>\0</th>
<th><code>1</code></th>
<th><code>9</code></th>
<th><code>9</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="23-5-5-其他函数"><a href="#23-5-5-其他函数" class="headerlink" title="23.5.5    其他函数"></a>23.5.5    其他函数</h3><h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><hr>
<p><strong>说明：</strong>将一个字符的多个副本存储到指定区域。<br><strong>应用：</strong>将数组元素全部初始化为0<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 指向用来存储字符副本的空间</span><br><span class="line">* @param &#123;int&#125; c 用于填充的字符</span><br><span class="line">* @param &#123;size_t&#125; n 从s指向的地址往后填充空间大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 第一个参数（空间地址）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为p指向的内存的N哥字节存储空格</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="string">' '</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组a初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>
<h4 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h4><hr>
<p><strong>说明：</strong>返回字符串的长度，不计算字符串末尾的<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @return &#123;size_t&#125; 字符串的常速</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p><strong>说明：</strong><a href="">24.2</a><br><strong>原型：</strong><code>errno.h</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/22 输入／输出/" itemprop="url">
                  22 输入/输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:01:02+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/22 输入／输出/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/22 输入／输出/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="22-1-流"><a href="#22-1-流" class="headerlink" title="22.1    流"></a>22.1    流</h2><blockquote>
<p><strong>说明：</strong>在C语言中，术语流意味着任意输入的源或人意输出的目的地。<code>stdio.h</code>中的许多函数不仅可以处理表示成文件的流，还可以处理所有其它形式的流。<br><strong>流：</strong>流常常表示为磁盘上的文件，但却可以和其它类型的设备相关联：调制解调器、网络端口、打印机、光盘驱动器等。</p>
</blockquote>
<h3 id="22-1-1-文件指针"><a href="#22-1-1-文件指针" class="headerlink" title="22.1.1    文件指针"></a>22.1.1    文件指针</h3><blockquote>
<p><strong>文件指针（file pointer）：</strong><code>File *</code>(<code>File</code>定义在<code>stdio.h</code>中)<br><strong>用途：</strong>C程序中流的访问是通过<code>文件指针</code>实现的<br><strong>限制：</strong>操作系统通常会限制在任意某时刻可以打开的流的数量（但是一个程序中可以声明任意数量的<code>File *</code>型变量）。</p>
</blockquote>
<h3 id="22-1-2-标准流和重定向"><a href="#22-1-2-标准流和重定向" class="headerlink" title="22.1.2    标准流和重定向"></a>22.1.2    标准流和重定向</h3><h4 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h4><blockquote>
<p><strong>说明：</strong>由<code>stdio.h</code>提供，一共3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件指针</th>
<th>流</th>
<th>默认的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输出</td>
<td>屏幕</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关的函数：</strong><code>printf</code>、<code>scanf</code>、<code>putchar</code>、<code>getchar</code>、<code>puts</code>、<code>gets</code></p>
</blockquote>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><blockquote>
<p><strong>说明：</strong>某些操作系统（比如UNIX/Linux/DOS）允许通过所谓的<code>重定向（redirextion）</code>机制来改变标准流默认的含义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入重定向(input redirection)</td>
<td>使<code>stdin流</code>表示为文件(而非键盘)</td>
<td>程序不回意识到正在从文件读取数据</td>
</tr>
<tr>
<td>输出重定向(output redirection)</td>
<td>使<code>stdout流</code>和<code>stderr流</code>表示为文件（而飞屏幕）</td>
<td>程序不会意识到正在向文件中写数据</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入重定向</span></span><br><span class="line">demo &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出重定向</span></span><br><span class="line">demo &gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">demo &lt; in.dat &gt;out.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-1-3-文本文件与二进制文件"><a href="#22-1-3-文本文件与二进制文件" class="headerlink" title="22.1.3    文本文件与二进制文件"></a>22.1.3    文本文件与二进制文件</h3><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>支持两种类型的文件（文本文件和二进制文件）<br><strong>存储方式：</strong>文本文件和二进制文件都是字节的序列，不同点在于存储的数据类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>数据类型（假设字符集为ASCII，16位机器）</th>
<th>空间利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本文件(text file)</td>
<td>字符（占一个字节）</td>
<td>低</td>
</tr>
<tr>
<td>二进制文件(binary file)</td>
<td>字符（占一个字节）、整数（两个字节）、浮点数（四个字节）等</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>结束符：</strong></p>
<ul>
<li><strong>DOS系统：</strong>文本文件和二进制文件不同</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>文本文件</th>
<th>二进制文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>回行符＋回车符</td>
<td>回行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>Ctrl+Z(\x1a)，但不是必需的（有的编辑器会加上</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>UNIX系统：</strong>对文本文件和二进制文件不进行区分</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>换行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>在屏幕上显示文件内容的程序会假设文件为文本文件</li>
<li>复制文件时如果设定文件为文本文件，只会复制到出现文件末尾符出现的地方</li>
</ol>
<p><strong>技巧：</strong>在无法确定文件是文本文件还是二进制文件时，安全的做法是把文件假设为二进制文件。</p>
</blockquote>
<h2 id="22-2-文件操作"><a href="#22-2-文件操作" class="headerlink" title="22.2    文件操作"></a>22.2    文件操作</h2><h3 id="22-2-1-打开文件"><a href="#22-2-1-打开文件" class="headerlink" title="22.2.1    打开文件"></a>22.2.1    打开文件</h3><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><blockquote>
<p><strong>说明：</strong>用流的方式打开文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 含有要大开文件名的字符串（可能包含文件位置的信息，例如驱动号或路径）</span><br><span class="line">* @param &#123;char *&#125; mode 模式字符串，例如"r"代表只读方式</span><br><span class="line">* @return &#123;FILE *&#125; 文件指针（如果文件不存在或未获得打开文件的许可则返回空指针）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>在DOS中的文件名中含有”\”字符要用”\替代”<br><strong>注意：</strong>永远不能假设可以打开文件，为了确保不回返回空指针，需要测试<code>fopen</code>函数的返回值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"c:\\project\\test1.dat"</span>, r); <span class="comment">// 以只读方式打开</span></span><br></pre></td></tr></table></figure>
<h3 id="22-2-2-模式"><a href="#22-2-2-模式" class="headerlink" title="22.2.2    模式"></a>22.2.2    模式</h3><blockquote>
<p><strong>说明：</strong>模式字符串依据文件是文本文件还是二进制文件分为两大类。<br><strong>注意：</strong>可读且可写的模式（包含<code>+</code>）存在如下限制</p>
<ul>
<li>调用<code>文件定位函数</code>后，可读才能转换为可写</li>
<li>调用<code>文件定位函数</code>或<code>fflush函数</code>后，可写才能转换为可读</li>
</ul>
</blockquote>
<h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>rb</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>wb</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>ab</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h3 id="22-2-3-关闭文件"><a href="#22-2-3-关闭文件" class="headerlink" title="22.2.3    关闭文件"></a>22.2.3    关闭文件</h3><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><blockquote>
<p><strong>说明：</strong>关闭不再使用的文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针（来自fopen函数或freopen函数）</span><br><span class="line">* @return 0:关闭成功；EOF(stdio.h宏)：关闭失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="string">"example.dat"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.大开文件</span></span><br><span class="line">	fp = fopen(FILE_NAME, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Cant't open %s\n"</span>, FILE_NAME);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Opened!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.操作文件</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 3.关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-4-为流附加文件"><a href="#22-2-4-为流附加文件" class="headerlink" title="22.2.4    为流附加文件"></a>22.2.4    为流附加文件</h3><h4 id="freopen函数"><a href="#freopen函数" class="headerlink" title="freopen函数"></a>freopen函数</h4><blockquote>
<p><strong>说明：</strong>为已经打开的流附加一个不同的文件<br><strong>应用：</strong>把文件和一个标准流相关联<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;char *&#125; mode 打开模式</span><br><span class="line">* @param &#123;FILE *&#125; stream 标准流（stdin或stdout或stderr）</span><br><span class="line">* @return &#123;FILE *&#125; 附加成功：文件指针；NULL：打开失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,  FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.如果stdout通过命令行重定向或者freopen函数已经和其它文件关联，则先关闭与stdout相关联的文件</span></span><br><span class="line"><span class="comment">// fclose(frp); // fp指向是和stdout关联的流（文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开foo文件，并使此文件和stdout相关联</span></span><br><span class="line"><span class="comment">// 如果无法关闭旧的文件，那么freopen函数会忽略掉错误</span></span><br><span class="line">frp = freopen(<span class="string">"foo"</span>, <span class="string">"w"</span>, stdout)</span><br><span class="line"><span class="keyword">if</span> (frp == NULL) &#123;</span><br><span class="line">	<span class="comment">// 打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-5-从命令行获取文件名"><a href="#22-2-5-从命令行获取文件名" class="headerlink" title="22.2.5    从命令行获取文件名"></a>22.2.5    从命令行获取文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*</span><br><span class="line">* @param &#123;int&#125; argc 实际参数的数量</span><br><span class="line">* @param &#123;[].(char *)&#125;  一个指针数组，argv[0]指向程序的名字，其余指向实际参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv[0]: demo</span></span><br><span class="line"><span class="comment"># argv[1]: name.dat</span></span><br><span class="line"><span class="comment"># argv[2]: dates.dat.dat</span></span><br><span class="line">$ demo name.dat dates.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-6-程序：检查文件是否可以打开"><a href="#22-2-6-程序：检查文件是否可以打开" class="headerlink" title="22.2.6    程序：检查文件是否可以打开"></a>22.2.6    程序：检查文件是否可以打开</h3><blockquote>
<p><strong>说明：</strong>若文件存在就可以打开进行读入，在运行程序时，用户将给出要检测的文件的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks whether a file can be opened for reading</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="comment">// 如果没有正确调用，给出使用提示</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: canopen filanem\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不能以只读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s can't be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果能以只读的方式打开 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s can be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ canopen f1.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-7-临时文件"><a href="#22-2-7-临时文件" class="headerlink" title="22.2.7    临时文件"></a>22.2.7    临时文件</h3><blockquote>
<p><strong>说明：</strong>只在程序运行时存在的文件。<code>stdio.h</code>提供了两个函数用来处理临时文件，即<code>tmpfile</code>和<code>tmpname</code></p>
</blockquote>
<h4 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>产生临时文件，这些临时文件将存到文件关闭时或程序终止时。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @ return &#123;FILE *&#125; 指向临时文件的文件指针(如果创建失败则为NULL)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *tmpptr;</span><br><span class="line">Tempptr = tmpfile(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h4 id="tmpfile函数-1"><a href="#tmpfile函数-1" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>为临时文件产生名字。<br><strong>用途：</strong>解决<code>tmpfile函数</code>无法知道临时文件的名字的问题。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  如果实际参数为NULL，那么tmpnam函数会把文件名存储到静态变量中，并且返回指向此变量的指针；</span><br><span class="line">*  否则，如果提供了字符数组作为参数，函数会把文件名复制到程序员提供的字符数组中。</span><br><span class="line">*</span><br><span class="line">* @param &#123;char *&#125; NULL或者一个字符数组（字符串）</span><br><span class="line">* @return &#123;char *&#125; 指向静态变量（存储着临时文件名）的指针：如果参数为NULL；指向临时文件名的指针（非静态）：如果提供了有效的参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>参数为NULL</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line">filename = tmpnam(NULL); <span class="comment">// 创建临时文件名</span></span><br></pre></td></tr></table></figure>
<p><em>参数为字符数组</em></p>
<blockquote>
<p><strong>说明：</strong><code>tmpnam函数</code>会把声称的临时文件名复制到程序员提供的字符数组中，而且仍然会返回指向临时文件名的指针。<br><strong>注意：</strong>作为参数的字符数组长度至少为<code>L_tmpnam</code>,产生的临时文件名的最大数量不能超过<code>TMP_MAX</code>。</p>
<ul>
<li><code>L_tmpnam</code>：在<code>stdio.h</code>中定义的一个宏，保存着临时文件名的字符数组的长度。</li>
<li><code>TMP_MAX</code>：在<code>stdio.h</code>中定义的一个宏，保存着程序执行期间<code>tmpnam函数</code>产生的临时文件名的最大数量。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> filename[L_tmpnam];</span><br><span class="line">tmpnam(filename);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-8-文件缓冲"><a href="#22-2-8-文件缓冲" class="headerlink" title="22.2.8    文件缓冲"></a>22.2.8    文件缓冲</h3><blockquote>
<p><strong>说明：</strong>缓冲发生在屏幕的后台，而且通常不用担心它的操作。然而，极少的情况下可能需要我们承担更主动的作用，需要使用<code>fflush函数</code>、<code>setbuf函数</code>和<code>setbuf函数</code>。<br><strong>输入流缓存：</strong>从硬盘或磁盘读取，包含来自输入设备（键盘或磁盘）的数据<br><strong>写入（输出）流缓存：</strong>向输出设备（屏幕或磁盘）写入，包含来自</p>
</blockquote>
<h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><blockquote>
<p><strong>说明：</strong>针对输出（写入）流，把缓冲区的内容传递给磁盘（当缓冲区满了或者关闭文件时，缓冲区会自动“清洗”）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 把缓冲区的内容传递给磁盘</span><br><span class="line">* 当参数为NULL时，“清洗”所有缓冲区；否则，只清洗和参数指向的文件相关的缓冲区</span><br><span class="line">*</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 0：成功；EOF：发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fflush(fp); <span class="comment">// 为fp指向的文件</span></span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">// 清洗全部输出流</span></span><br></pre></td></tr></table></figure>
<h4 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h4><blockquote>
<p><strong>说明：</strong>改变缓冲流的方式，控制缓冲区的大小和位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; buf 期望缓冲区的地址</span><br><span class="line">* @param &#123;int&#125; 期望缓冲区的类型&#123;_IOFBF|_IOLBF|IONBF&#125;</span><br><span class="line">* @param &#123;size_t&#125; 缓冲区内字节的数量</span><br><span class="line">* @return &#123;int&#125; 0：成功；非零：要求的缓冲区模式无效或无法提供</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数要点：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>第N个参数</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>缓冲区的地址</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>缓冲区的类型</td>
<td>值为定义在<code>stdio.h</code>中的宏</td>
</tr>
<tr>
<td>4</td>
<td>缓冲区的大小</td>
<td>较大的缓冲区可以提供更好的性能，而较小的缓冲区可以节约时间。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的类型（宏）</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_IOFBF</td>
<td>满缓冲</td>
<td>当缓冲区为空时，从流读入数据；活着当缓冲区满时，向流写入数据</td>
</tr>
<tr>
<td>_IONLF</td>
<td>行缓冲</td>
<td>每次从流读入数据活着直接向流写入数据</td>
</tr>
<tr>
<td>_IOLBF</td>
<td>无缓冲</td>
<td>每次从流读入数据活着直接向流卸乳数据，而没有缓冲区</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的存储特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>存在于程序运行的整个过程中</td>
</tr>
<tr>
<td>自动存储期限</td>
<td>允许在它的空间在块退出时被自动重声明（?）</td>
</tr>
<tr>
<td>动态分配</td>
<td>在不需要时可以释放缓冲区</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>限制：</strong>必需在打开stream之后，在stream上执行任何操作之前调用<code>setvbuf</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建缓冲区</span></span><br><span class="line"><span class="keyword">char</span> buffer[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对缓冲区进行设置（必需在打开stream之后，在stream上执行任何操作之前调用setvbuf）</span></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, N);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-9-其他文件操作"><a href="#22-2-9-其他文件操作" class="headerlink" title="22.2.9    其他文件操作"></a>22.2.9    其他文件操作</h3><h4 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h4><blockquote>
<p><strong>说明：</strong>根据文件名删除文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">"foo"</span>); <span class="comment">// 删除名为foo的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h4><blockquote>
<p><strong>说明：</strong>文件重命名<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; old 旧文件名</span><br><span class="line">* @param &#123;char *&#125; new 新文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *old, <span class="keyword">const</span> <span class="keyword">char</span> *new)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>一定要确保在调用<code>rename函数</code>之前文件是关闭的，否则无法对文件重命名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="22-3-格式化的输入／输出"><a href="#22-3-格式化的输入／输出" class="headerlink" title="22.3    格式化的输入／输出"></a>22.3    格式化的输入／输出</h2><h3 id="22-3-1-…printf类函数"><a href="#22-3-1-…printf类函数" class="headerlink" title="22.3.1    …printf类函数"></a>22.3.1    …printf类函数</h3><h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><blockquote>
<p><strong>说明：</strong>向<code>stdout</code>输出，利用格式串控制输出的形式<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Total: %d\n"</span>, total);</span><br></pre></td></tr></table></figure>
<h4 id="fprintf函数"><a href="#fprintf函数" class="headerlink" title="fprintf函数"></a>fprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>和<code>printf函数</code>唯一的不同就是，<code>printf函数</code>始终向标准输出流<code>stdout</code>向中写入，而<code>fprintf函数</code>则向第一个参数说明的流（任何输出流）中写输出。<br><strong>应用：</strong>向标准错误<code>stderr</code>写出错信息。<br><strong>扩展：</strong><code>stdio.h</code>中还有其他两种函数也可以向流写入格式化的输出，分别是<code>vfprintf函数</code>和<code>vprintf函数</code>,而且它们都还依赖<code>stdarg.h</code>(<a href="">26.1</a>)。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向磁盘中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"Total:%d\n"</span>, total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向stderr中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: data file can't be opened.\n"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="22-3-2-…printf类函数的转换说明"><a href="#22-3-2-…printf类函数的转换说明" class="headerlink" title="22.3.2    …printf类函数的转换说明"></a>22.3.2    …printf类函数的转换说明</h3><blockquote>
<p><strong>说明：</strong>对已知的转换说明内容进行回顾，并把剩余的内容补充完整。<br><strong>注意：</strong>格式串必需遵守规则编写，许多看似可能的转换说明（<code>%le、%lf、%lg</code>等）实际上是无效的。</p>
</blockquote>
<h4 id="转换说明：-012-5Lg"><a href="#转换说明：-012-5Lg" class="headerlink" title="转换说明：%# 012.5Lg"></a><strong>转换说明：</strong><code>%# 012.5Lg</code></h4><table>
<thead>
<tr>
<th>%</th>
<th># 0</th>
<th>12</th>
<th>.5</th>
<th>L</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊标志</td>
<td>➋最小字段宽度</td>
<td>➌精度</td>
<td>➍长度修饰符</td>
<td>➎转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选（可多于一个）</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>转换说明提示符：</strong>标记格式串的开始<br><strong>➊标志：</strong>设置对齐方式、前缀、进制、填充</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>+</code></td>
<td>用<code>+</code>作为正数的前缀</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>用<code>空格</code>作为正数的前缀</td>
</tr>
<tr>
<td><code># 0</code>、<code># 0x(X)</code></td>
<td><code># 0</code>（8进制）、<code># 0x(X)</code>(16进制)，转换说明<code>g(G)</code>转换出的尾部0不能删除</td>
</tr>
<tr>
<td><code>0</code></td>
<td>除非转换说明为<code>d、i、o、u、x(X)</code>且制定了精度，否则用前导0在字段宽度内进行填充</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➋最小字段宽度：</strong>值为<code>有效整数</code>或<code>*</code></p>
<ul>
<li><code>有效整数</code>：**字符数少于最小字段宽度时对字符填充，默认右对齐（在左侧填充<code>空格</code>）；大于最小字段宽度则完整显示。</li>
<li><code>*</code>：格式串中的n个<code>*</code>对应<code>参数2</code>~<code>参数n-1</code>，可以是宏</li>
</ul>
<p><strong>➌精度：</strong>值为<code>.整数</code>或<code>.*</code>(精度的含义即依赖于转换说明符，也依赖于自身的值)</p>
</blockquote>
<table>
<thead>
<tr>
<th>说明符</th>
<th>精度值：<code>.整数</code></th>
<th>精度值：<code>.*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i、o、u、x(X)</code></td>
<td>最小数字位数（如果数字位数少于精度值，则添加前导0）</td>
<td>同<code>最小字段宽度</code>❷中<code>*</code>的含义</td>
</tr>
<tr>
<td><code>e(E)、f</code></td>
<td>小数点后的数字位数</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>最大有效数字位</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>最大字符数</td>
<td>（同上）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➍长度修饰符：</strong>共3个，只能和一些转换说明符搭配</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➎转换说明符：</strong>当对带有可变实参的函数（比如<code>printf</code>）传参时，会发生默认的实际参数的提升。<code>float</code>会转换为<code>double</code>，<code>char</code>会转换为<code>int</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参类型</th>
<th>格式化后的形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i</code></td>
<td>signed int</td>
<td>十进制形式</td>
</tr>
<tr>
<td><code>o、u、x(X)</code></td>
<td>unsigned int</td>
<td><code>o</code>(8进制)、<code>u</code>(10进制)、<code>x</code>(16进制，a-f来显示)、<code>X</code>(16进制，A-F来显示)</td>
</tr>
<tr>
<td><code>f</code></td>
<td>double</td>
<td>十进制形式（默认的精度为小数点后显示6位）</td>
</tr>
<tr>
<td><code>e(E)</code></td>
<td>double</td>
<td>科学计数法表示的double，默认精度为小数点后显示6位（<code>e</code>表示指数前为e，<code>E</code>表示指数前为E)</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>double</td>
<td><code>-4 &gt;= 指数部分 &lt; 精度值</code>则相当于<code>e</code>（对应<code>g</code>）或者<code>E</code>（对应<code>G</code>）；否则相当于<code>f</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>unsigned int</td>
<td>无符号整数</td>
</tr>
<tr>
<td><code>s</code></td>
<td>指向字符串的指针</td>
<td>按照<code>void *</code>型显示，达到精度值（如果存在）或空字符(<code>\0</code>)时停止写操作</td>
</tr>
<tr>
<td><code>p</code></td>
<td>*</td>
<td>转化为可显示格式的<code>void *</code>型值</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>int *</code>(指向int型数的指针)</td>
<td><code>...printf类函数</code>返回值（不会输出到屏幕，而是存储到所指向的int型数中）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>无对应参数</td>
<td>字符串”%”</td>
</tr>
</tbody>
</table>
<h3 id="22-3-3-…printf类函数的转换说明示例"><a href="#22-3-3-…printf类函数的转换说明示例" class="headerlink" title="22.3.3    …printf类函数的转换说明示例"></a>22.3.3    …printf类函数的转换说明示例</h3><h4 id="标志➊"><a href="#标志➊" class="headerlink" title="标志➊"></a>标志➊</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.07.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.22.png" alt="Alt text"></p>
<h4 id="最小字段宽度➋-精度➌"><a href="#最小字段宽度➋-精度➌" class="headerlink" title="最小字段宽度➋ + 精度➌"></a>最小字段宽度➋ + 精度➌</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.29.png" alt="Alt text"></p>
<h4 id="转换说明➎"><a href="#转换说明➎" class="headerlink" title="转换说明➎"></a>转换说明➎</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.08.42.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.45.png" alt="Alt text"></p>
<h4 id="最小字符宽度❷和精度❸中"><a href="#最小字符宽度❷和精度❸中" class="headerlink" title="最小字符宽度❷和精度❸中*"></a>最小字符宽度❷和精度❸中*</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小字符宽度❷和精度❸中*的用法示例</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.4d"</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.4d"</span>, <span class="number">6</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.*d"</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, <span class="number">6</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, WIDTH, I, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, page_width/num_cols, I, i); <span class="comment">// ..1234</span></span><br></pre></td></tr></table></figure>
<h4 id="转换说明p和n"><a href="#转换说明p和n" class="headerlink" title="转换说明p和n"></a>转换说明<code>p</code>和<code>n</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (void *)ptr); <span class="comment">// 显示指针ptr的值（可能会以8进制或16进制形式显示）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%n"</span>, <span class="number">123</span>, &amp;len); <span class="comment">// 将printf函数显示的字符数存储到len</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-…scanf类函数"><a href="#22-3-4-…scanf类函数" class="headerlink" title="22.3.4    …scanf类函数"></a>22.3.4    …scanf类函数</h3><h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><blockquote>
<p><strong>说明：</strong>从<code>stdin</code>（键盘）读入内容，根据格式串中的转换说明进行转换并存储在指针指定的位置上。<br><strong>原型：</strong><code>stdio.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;char *&#125; format 格式串</span><br><span class="line">&gt;* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">&gt;* return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> chat *format, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取一串整数，在首个"?"处停止</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;I) == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fscanf函数"><a href="#fscanf函数" class="headerlink" title="fscanf函数"></a>fscanf函数</h4><blockquote>
<p><strong>说明：</strong><code>scanf函数</code>从<code>stdin</code>读入数据，而<code>fscanf函数</code>则从它自己的第一个实参所指定的流中妇孺内容。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 指定的流</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="22-3-5-…scanf类函数的格式化字符串"><a href="#22-3-5-…scanf类函数的格式化字符串" class="headerlink" title="22.3.5    …scanf类函数的格式化字符串"></a>22.3.5    …scanf类函数的格式化字符串</h3><table>
<thead>
<tr>
<th>比较</th>
<th><code>...printf类函数</code></th>
<th><code>...scanf类函数</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>格式串的作用</td>
<td>转换数据形式并拼接</td>
<td>模式匹配和数据类型转换</td>
</tr>
<tr>
<td>数据源</td>
<td>指定的实参（不定参数部分）的值</td>
<td><code>stdin</code>（键盘输入）</td>
</tr>
<tr>
<td>数据源类型</td>
<td>多种类型</td>
<td>字符</td>
</tr>
</tbody>
</table>
<h4 id="格式串"><a href="#格式串" class="headerlink" title="格式串"></a>格式串</h4><blockquote>
<p><strong>例子：</strong><code>ISBN %d-%d-%ld-%d</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>ISBN</th>
<th>空格</th>
<th>%d</th>
<th>-</th>
<th>%d</th>
<th>-</th>
<th>%ld</th>
<th>-</th>
<th>%d</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISBN</td>
<td>空白字符（0或多个）</td>
<td>一个整数</td>
<td>-</td>
<td>一个整数</td>
<td>-</td>
<td>一个长整数</td>
<td>-</td>
<td>一个整数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
</tr>
</tbody>
</table>
<h5 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h5><blockquote>
<p><strong>说明：</strong>类似<code>...printf函数</code>格式串中中的转换说明。<br><strong>特点：</strong></p>
<ul>
<li>大多数转换说明会在输入项的开始出跳过空白字符（<code>%[、%c、%n</code>除外）</li>
<li>转换说明从来不回跳过尾部的空白字符（遇到换行符时，不会读区之并停止匹配返回）</li>
</ul>
</blockquote>
<h5 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h5><blockquote>
<p><strong>说明：</strong>格式串中的一个（或多个）空白字符匹配0个或多个输入流中的空白字符。</p>
</blockquote>
<h5 id="非空白字符"><a href="#非空白字符" class="headerlink" title="非空白字符"></a>非空白字符</h5><blockquote>
<p><strong>说明：</strong>非空白字符和输入流中相同字符进行匹配（<code>%</code>除外）</p>
</blockquote>
<h3 id="22-3-6-…scanf类函数的转换说明"><a href="#22-3-6-…scanf类函数的转换说明" class="headerlink" title="22.3.6    …scanf类函数的转换说明"></a>22.3.6    …scanf类函数的转换说明</h3><h4 id="转换说明：-12Ld"><a href="#转换说明：-12Ld" class="headerlink" title="转换说明：%*12Ld"></a><strong>转换说明：</strong><code>%*12Ld</code></h4><table>
<thead>
<tr>
<th>%</th>
<th>＊</th>
<th>12</th>
<th>L</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊赋值屏蔽</td>
<td>➋最小字段宽度</td>
<td>➌长度修饰符</td>
<td>❹转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❶赋值屏蔽（assignment suppression）：</strong>使用符号<code>*</code>，匹配空白符之外的连续字符，直到遇到空白符为止。</p>
<ul>
<li>匹配的数据项会被读入，但不会被赋值给变量</li>
<li>用*匹配到的数据相不回包含在<code>...scanf类函数</code>返回的计数中</li>
</ul>
<p><strong>❷最大字段宽度：</strong>限制转换说明匹配的输入项的字符数量（不计算跳过的空白符），达到限制的字符数量后便停止当前输入项的转换。<br><strong>❸长度修饰符：</strong>共3个，只能和一些转换说明符搭配，同时长度修饰符的选择取决于要存储为相匹配实参所指向的变量类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>对应实参（指针）的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>double</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❹转换说明符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参指针应当指向类型</th>
<th>匹配的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数</td>
<td>十进制整数</td>
</tr>
<tr>
<td>i</td>
<td>整数</td>
<td>自动判断进制（0打头：8进制；0x(X)打头：16进制；否则十进制）</td>
</tr>
<tr>
<td>o</td>
<td>unsigned int</td>
<td>八进制整数</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>十进制整数</td>
</tr>
<tr>
<td>x(X)</td>
<td>unsigned int</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>float</td>
<td>float型小数</td>
</tr>
<tr>
<td>s</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>一系列非空白字符</td>
</tr>
<tr>
<td>[</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>来自<code>扫描集合</code>的非空字符序列。<code>扫描集合</code>可以包含任何字符集，特别的是如果<code>扫描集合</code>中包含<code>]</code>，则要放在首位，例如<code>[]abc]</code>（<code>[abc]</code>：表示匹配只含有字母<code>a、b、c</code>的字符序列；<code>[^abc]</code>：表示匹配<code>a、b、c</code>都不存在的字符序列）</td>
</tr>
<tr>
<td>c</td>
<td>char *(指定<code>❷最大字段宽度</code>n，则在末尾添加<code>\0</code>，否则不添加)</td>
<td>指定<code>❷最大字段宽度</code>n，则匹配n个字符，否则旧就匹配一个字符</td>
</tr>
<tr>
<td>p</td>
<td>void *</td>
<td><code>...printf类函数</code>可以打印出的指针值（地址）</td>
</tr>
<tr>
<td>n</td>
<td>int(不指定<code>❸长度修饰符</code>)、short int(<code>❸长度修饰符</code>为<code>h</code>)、long int(<code>❸长度修饰符</code>为<code>l</code>)</td>
<td>不匹配任何字符，因而也不回影响<code>...scanf类函数</code>的放回值（对应的变量存储的是到目前为止已经读入的字符数）</td>
</tr>
<tr>
<td>%</td>
<td>char</td>
<td>匹配字符%</td>
</tr>
</tbody>
</table>
<h4 id="strtol函数-26-2-1"><a href="#strtol函数-26-2-1" class="headerlink" title="strtol函数(26.2.1)"></a>strtol函数(<a href="">26.2.1</a>)</h4><blockquote>
<p><strong>说明：</strong>将字符串根据参数base来转换成长整型数<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; nptr 要转换的字符串</span><br><span class="line">* @param &#123;int&#125; base 基数（0或2~36）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr,<span class="keyword">char</span> **endptr,<span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>和<code>...scanf类函数</code>转换说明符之间的对应关系</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>strol的参数base的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>10</td>
</tr>
<tr>
<td>i</td>
<td>0</td>
</tr>
<tr>
<td>o</td>
<td>8</td>
</tr>
<tr>
<td>u</td>
<td>10</td>
</tr>
<tr>
<td>x(X)</td>
<td>16</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="22-3-7-…scanf函数的示例"><a href="#22-3-7-…scanf函数的示例" class="headerlink" title="22.3.7    …scanf函数的示例"></a>22.3.7    …scanf函数的示例</h3><h4 id="转换说明、空白字符、非空白字符组合效果"><a href="#转换说明、空白字符、非空白字符组合效果" class="headerlink" title="转换说明、空白字符、非空白字符组合效果"></a>转换说明、空白字符、非空白字符组合效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.10.png" alt="Alt text"></p>
<h4 id="赋值屏蔽和指定字段宽度效果"><a href="#赋值屏蔽和指定字段宽度效果" class="headerlink" title="赋值屏蔽和指定字段宽度效果"></a>赋值屏蔽和指定字段宽度效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.25.png" alt="Alt text"></p>
<h4 id="难懂的转换说明：i、-、n"><a href="#难懂的转换说明：i、-、n" class="headerlink" title="难懂的转换说明：i、[、n"></a>难懂的转换说明：<code>i、[、n</code></h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.38.png" alt="Alt text"></p>
<h3 id="22-3-8-检测文件末尾和错误条件"><a href="#22-3-8-检测文件末尾和错误条件" class="headerlink" title="22.3.8    检测文件末尾和错误条件"></a>22.3.8    检测文件末尾和错误条件</h3><blockquote>
<p><strong>错误指示器（error indicator）：</strong>打开流时被清除，遇到错误时会被设置。<br><strong>文件末尾指示器（end of file indicator）：</strong>打开流时被清除，遇到文件末尾时被设置。<br><strong><code>...scanf类函数</code>出错分类：</strong>当<code>...scanf类函数</code>的返回值小于不定参数（要匹配）的数量时，由3中可能</p>
<ol>
<li><strong>提前遇到文件末尾：</strong>函数在完全匹配格式串之前遇到了文件末尾</li>
<li><strong>匹配失败：</strong>数据相的格式错误（比如函数在搜索整数的第一个数字期间遇到了一个字母）</li>
<li><strong>错误：</strong>错误的发生超出了函数控制的范围</li>
</ol>
</blockquote>
<h4 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h4><blockquote>
<p><strong>说明：</strong>清除文件末尾指示器和错误指示器<br><strong>注意：</strong><code>Q&amp;A</code>某些其他库函数因为副作用可以清除某种指示器或两种都可以清除，所以不回需要经常使用该函数。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>末尾指示器</code>，判断是否已经到达输入流（文件或<code>stdin</code>）末尾。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入文件的末尾</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ferror函数"><a href="#ferror函数" class="headerlink" title="ferror函数"></a>ferror函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>错误指示器</code>，判断输入过程是否发生错误<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入过程发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 搜索文件中以某个整数起始的行并返回行号</span><br><span class="line">* </span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;int *&#125; ptr 指向要将找到的整数存储到变量的指针</span><br><span class="line">* @return &#123;int&#125; 以整数起始的行的行号</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	<span class="function">FILE *fp <span class="title">fopen</span> <span class="params">(filename, <span class="string">"r"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, ptr) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果是输入错误</span></span><br><span class="line">		<span class="keyword">if</span> (ferror (fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是到达文件末尾</span></span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-3</span>; <span class="comment">// 整数没找到</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">"%*[^\n]"</span>); <span class="comment">// 跳过一行的其余部分</span></span><br><span class="line">		line++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">n = find_int(<span class="string">"foo"</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<h2 id="22-4-字符的输入／输出"><a href="#22-4-字符的输入／输出" class="headerlink" title="22.4    字符的输入／输出"></a>22.4    字符的输入／输出</h2><blockquote>
<p><strong>说明：</strong>本节的所有函数用于文本流和二进制流是等效的。</p>
</blockquote>
<h3 id="22-4-1-输出函数"><a href="#22-4-1-输出函数" class="headerlink" title="22.4.1    输出函数"></a>22.4.1    输出函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...scanf类函数</code>一样，<code>fputc、putc、putchar</code>出现错误都会为流设置<code>错误指示器</code>并返回<code>EOF</code>。</p>
</blockquote>
<h4 id="fputc函数"><a href="#fputc函数" class="headerlink" title="fputc函数"></a>fputc函数</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符（<code>putc</code>和<code>putchar</code>更通用的版本）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE * stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putc宏"><a href="#putc宏" class="headerlink" title="putc宏"></a>putc宏</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符(宏实现)<br><strong>优点和缺点：</strong><a href="">14.3</a><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putchar宏"><a href="#putchar宏" class="headerlink" title="putchar宏"></a>putchar宏</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>（屏幕）写一个字符，通常作为宏来实现（底层是<code>fputc</code>，因此性能不如<code>putc</code>）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> putchat(c) putc((c), stdout);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @return &#123;int&#125; </span><br><span class="line">int putchar(int c);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-2-输入函数"><a href="#22-4-2-输入函数" class="headerlink" title="22.4.2    输入函数"></a>22.4.2    输入函数</h3><blockquote>
<p><strong>注意：</strong><code>Q&amp;A</code>把char型变量与<code>EOF</code>比较可能会产生错误的结果。</p>
</blockquote>
<h4 id="getc宏"><a href="#getc宏" class="headerlink" title="getc宏"></a>getc宏</h4><blockquote>
<p><strong>说明：</strong>从指定流中读入一个字符（宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读入字符直到遇到文件末尾</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fgetc函数"><a href="#fgetc函数" class="headerlink" title="fgetc函数"></a>fgetc函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读如一个字符。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = fgetc(fp); <span class="comment">// 从fp中读取一个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="getchar（宏）"><a href="#getchar（宏）" class="headerlink" title="getchar（宏）"></a>getchar（宏）</h4><blockquote>
<p><strong>说明：</strong>从标准输出流<code>stdout</code>（键盘）中获得一个字符（通常是用宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar getc(stdin);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-3-程序：复制文件"><a href="#22-4-3-程序：复制文件" class="headerlink" title="22.4.3    程序：复制文件"></a>22.4.3    程序：复制文件</h3><blockquote>
<p><strong>说明：</strong>采用”rb”和”wb”作为文件的模式使<code>fcopy</code>程序既可以复制文本文件也可以复制二进制文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Copy a file(既可以是文本文件，也可以是二进制文件)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *source_fp, *dest_fp;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有给出正确的参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: fcopy source dest\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开原始文件</span></span><br><span class="line">	<span class="keyword">if</span> ((source_fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开目标文件</span></span><br><span class="line">	<span class="keyword">if</span> ((dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">"wb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制内容(一个字符一个字符地)</span></span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(source_fp)) != EOF) &#123;</span><br><span class="line">		putc(ch, dest_fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(source_fp);</span><br><span class="line">	fclose(dest_fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./fcopy source.dat dest.dat</span><br></pre></td></tr></table></figure>
<h2 id="22-5-行的输入／输出"><a href="#22-5-行的输入／输出" class="headerlink" title="22.5    行的输入／输出"></a>22.5    行的输入／输出</h2><blockquote>
<p><strong>说明：</strong>读和写行的苦函数（虽然也可以有效地用于二进制文件流，但多数用于文本流）。</p>
</blockquote>
<h3 id="22-5-1-输出函数"><a href="#22-5-1-输出函数" class="headerlink" title="22.5.1    输出函数"></a>22.5.1    输出函数</h3><h4 id="puts函数-13-3"><a href="#puts函数-13-3" class="headerlink" title="puts函数(13.3)"></a>puts函数(<a href="">13.3</a>)</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>写入一串字符（总会在后面添加一个换行符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">puts</span><span class="params">(chat *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Hi, there!"</span>); <span class="comment">// 向stdout(屏幕)输出"Hi, there!"</span></span><br></pre></td></tr></table></figure>
<h4 id="fputs函数"><a href="#fputs函数" class="headerlink" title="fputs函数"></a>fputs函数</h4><blockquote>
<p><strong>说明：</strong>向指定的流输出一串字符（不会在后面自动添加换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fput</span><span class="params">(chat *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">"Hi, there!"</span>, fp); <span class="comment">// 向fp输出"Hi. there!"</span></span><br></pre></td></tr></table></figure>
<h3 id="22-5-2-输入函数"><a href="#22-5-2-输入函数" class="headerlink" title="22.5.2    输入函数"></a>22.5.2    输入函数</h3><blockquote>
<p><strong>返回值：</strong>无论<code>gets</code>还是<code>fgets</code>，如果出现了错误，活着使在存储人和字符之前大道了输入流的末尾，都会返回空指针<code>NULL</code>;否则，返回指向读入字符串的指针。<br><strong>末尾空字符：</strong>两个函数都会在字符串的末尾存储空字符。<br><strong>技巧：</strong>大多数情况下用<code>fgets</code>而不是<code>gets</code>（只有在确保读入的字符正好适合数组大小时才使用），因为后者会超出接收数组范围的可能</p>
</blockquote>
<h4 id="gets函数（13-3）"><a href="#gets函数（13-3）" class="headerlink" title="gets函数（13.3）"></a>gets函数（<a href="">13.3</a>）</h4><blockquote>
<p><strong>说明：</strong>从标准输入流<code>stdin</code>中读取一串字符（逐个读取字符，并且把它们存储在字符串中，直到读取到换行符为止，因此不存储换行符）<br><strong>注意：</strong>只有在确保读入的字符正好适合数组大小时才使用，因为会有超出接收数组范围的可能。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储位置（首地址）</span><br><span class="line">* @return &#123;char *&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">chat *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读取一串字符（有时会存储换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;char *&#125; s  存储位置（首地址）</span><br><span class="line">* @param &#123;int&#125; n 限制读取字符的数量(保证不回超过s的存储能力)</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件字符（要读取的目标流）</span><br><span class="line">* @return &#123;char *&#125; 读取到的字符串</span><br><span class="line">*/</span><br><span class="line">char *fget(char *s, int n, FILE *stream));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>可以从任意流中读取信息</li>
<li>比<code>gets</code>更加安全，因为可以限制要存储的字符的数量</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个读入字符，在遇到首个换行符时或已经读入sizeof(str)-1个字符时结束操作</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-6-块的输入／输出"><a href="#22-6-块的输入／输出" class="headerlink" title="22.6    块的输入／输出"></a>22.6    块的输入／输出</h2><blockquote>
<p><strong>说明：</strong><code>fread</code>和<code>fwrite</code>允许程序在一次读和写大的数据块（任意数据类型）。<br><strong>用途：</strong>当程序在终止之前使用<code>fwrite函数</code>把数据存储到文件中，稍后，程序可以把数据从文件读入到内存。<br><strong>注意：</strong><code>Q&amp;A</code>小心使用<code>fread</code>函数和<code>fwrite</code>函数可以用于文本流，但它们主要还是用于二进制的流。</p>
</blockquote>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><blockquote>
<p><strong>说明：</strong>从流读入数据块。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 读入后数据块存储位置的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块的数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要读的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际读入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line">fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从fp指向的流位置读出数组并存储到数组a中</span></span><br><span class="line">n = fread(a, sizeof(a[<span class="number">0</span>], sizeof(a)/sizeof(a[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure>
<h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><blockquote>
<p><strong>说明：</strong>把内存中的数据块复制到流。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 存储数据块的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要写入的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际写入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream );</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内存中数组a复制到fp指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(a, <span class="keyword">sizeof</span>(a[<span class="number">0</span>], sizeof(a)/sizof(a[<span class="number">0</span>]), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存中的结构体（实例）存储到指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(&amp;s, sizeof(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-7-文件的定位"><a href="#22-7-文件的定位" class="headerlink" title="22.7    文件的定位"></a>22.7    文件的定位</h2><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>提供了5个函数允许程序确定当前的文件位置或者改变文件位置，通过这些函数可以实现文件的随机访问（任意访问）。<br><strong>注意：</strong>文件定为函数最适合二进制文件，处理文本流可能出现操作系统差异。<br><strong>文件位置（file position）：</strong>每个流都由文件位置，可以看作当前访问到的位置。在执行读或者写操作时，文件位置会自动推进。</p>
</blockquote>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><blockquote>
<p><strong>说明：</strong>改变指定流的文件位置，相关的宏有3个</p>
<ul>
<li>SEEK_SET：文件的起始处</li>
<li>SEEK_CUR：文件的当前位置</li>
<li>SEEK_END：文件的末尾处</li>
</ul>
<p><strong>注意：</strong>fseek函数对流是<code>文本型</code>还是<code>二进制型</code>非常敏感</p>
<ul>
<li><strong>文本型：</strong>参数必须是以下两种情景之一</li>
</ul>
<ol>
<li>offset必须为0（即只能移动到文件的起始处或末尾）</li>
<li>whence必须是<code>SEEK_SET</code>，且offset是通过<code>ftell函数</code>获取的（即返回前一次访问到的位置）</li>
</ol>
<ul>
<li><strong>二进制型：</strong>不要求支持whience是SEEK_END<br><strong>原型：</strong><code>stdio.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;long int&#125; offset 目标位置距离whence的距离，可以是负值</span><br><span class="line">* @param &#123;int&#125; whence 参照位置，值为SEEK_SET或SEEK_CUR或SEEK_END</span><br><span class="line">* @return &#123;int&#125; 0:成功；非0:产生错误（比如位置不存在）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置移动到文件起始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置移动到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置基于当前位置向后移动10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10</span>L, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><blockquote>
<p><strong>说明：</strong>以长整型返回当前文件位置<br><strong>注意：</strong><code>二进制文件</code>和<code>文本文件</code>的返回值情况有所不同</p>
<ul>
<li><strong>二进制文件：</strong>以字节计算返回当前位置</li>
<li><strong>文本文件：</strong>不一定按照字节计数</li>
</ul>
<p><strong>用途：</strong>可能会存储返回的值并且稍后将其提供给<code>fseek函数</code><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @patam &#123;long int&#125; 当前文件位置：成功；－1L：发生错误（同时会把错误码存储到errno中）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> file_pos;</span><br><span class="line">...</span><br><span class="line">file_pos = ftell(fp); <span class="comment">// 获取当前文件位置</span></span><br><span class="line">...</span><br><span class="line">fseek(fp, file_pos, SEEK_SET); <span class="comment">// 返回到之前存储下的文件位置处</span></span><br></pre></td></tr></table></figure>
<h4 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h4><blockquote>
<p><strong>说明：</strong>把文件位置设置到文件起始处，几乎等价于<code>fseek(fp, 0L, SEEK_SET)</code>,差异是该函数没有返回值，但会为fp清除掉<code>错误指示器</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgetpos函数"><a href="#fgetpos函数" class="headerlink" title="fgetpos函数"></a>fgetpos函数</h4><blockquote>
<p><strong>说明：</strong>将指定流的文件位置存储到fpos_t型变量中<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE * restrict&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t * restrict&#125; fpos_t型变量</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> stream, fpos_t * <span class="keyword">restrict</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsetpos函数"><a href="#fsetpos函数" class="headerlink" title="fsetpos函数"></a>fsetpos函数</h4><blockquote>
<p><strong>说明：</strong>为指定流设置文件fpos_t型位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t&#125; pos 文件位置</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream,  <span class="keyword">const</span> fpos_t *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fpos_t</span> file_pos;</span><br><span class="line">...</span><br><span class="line">fgetpos(fp, &amp;file_pos); <span class="comment">// 获取当前文件位置并保存</span></span><br><span class="line">...</span><br><span class="line">fsetpos(fp, &amp;file_pos); <span class="comment">// 设置文件位置到之前保存的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="程序：修改零件记录文件"><a href="#程序：修改零件记录文件" class="headerlink" title="程序：修改零件记录文件"></a>程序：修改零件记录文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * modify a file of part records by setting the quantity</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NAME_LEN 25	</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"><span class="keyword">struct</span> part &#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_parts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开清单</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"invent.dat"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open inventory file\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取零件(元素为结构体的数组)</span></span><br><span class="line">	num_parts = fread(inventory, sizeof(struct part), MAX_PARTS, fp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line">		inventory[i].on_hand = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动到文件开始处</span></span><br><span class="line">	rewind(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将修改后的清单数据存储到文件中</span></span><br><span class="line">	fwrite(inventory, <span class="keyword">sizeof</span>(struct part), num_parts, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-8-字符串的输入／输出"><a href="#22-8-字符串的输入／输出" class="headerlink" title="22.8    字符串的输入／输出"></a>22.8    字符串的输入／输出</h2><blockquote>
<p><strong>扩展：</strong>还有一个依赖<code>stdarg.h</code>定义<code>va_list</code>的<code>vsprintf函数</code>（<a href="">26.1.2</a>）</p>
</blockquote>
<h4 id="sprintf函数"><a href="#sprintf函数" class="headerlink" title="sprintf函数"></a>sprintf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>printf函数</code>和<code>fprintf函数</code>，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d/%d/%d"</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">94</span>); <span class="comment">// str: 9/20/94</span></span><br></pre></td></tr></table></figure>
<h4 id="sscanf函数"><a href="#sscanf函数" class="headerlink" title="sscanf函数"></a>sscanf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>scanf函数</code>和<code>fscanf函数</code>，唯一的不同是该函数是从字符数组而不是流中读取数据。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败(找到第一个数据项之前到达)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用fgets函数来获取一行输入，然后把此行数据传递给scanf函数进一步处理</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d%d"</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串中读取日期</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str, <span class="string">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sscanf(str, <span class="string">"%d-%d-%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/21 标准库/" itemprop="url">
                  21	标准库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:33:07+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/21 标准库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/21 标准库/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="21-1-标准库的使用"><a href="#21-1-标准库的使用" class="headerlink" title="21.1    标准库的使用"></a>21.1    标准库的使用</h2><blockquote>
<p><strong>标准头：</strong>依据C标准，一个“标准头”不需要一定是文件，有可能内置在编译器自身中。<br><strong>标准库：</strong>C语言的标准库总共划分成<code>15</code>个部分，每个部分用一个头描述。<br><strong>扩展：</strong>许多编译器会使用扩展后的库，这类库（头文件）通常提供一些针对特定畸形或特定操作系统的函数（比如更多对屏幕或键盘操作的函数，用于支持图形或窗口界面的头等）</p>
</blockquote>
<h3 id="21-1-1-包含标准头的程序中使用的名字的一些限制"><a href="#21-1-1-包含标准头的程序中使用的名字的一些限制" class="headerlink" title="21.1.1    包含标准头的程序中使用的名字的一些限制"></a>21.1.1    包含标准头的程序中使用的名字的一些限制</h3><blockquote>
<p><strong>意义：</strong>虽然这些规则并不总是强制性的，但不遵守这些规则可能会导致程序的可移植性下降。</p>
</blockquote>
<h4 id="必需遵守"><a href="#必需遵守" class="headerlink" title="必需遵守"></a>必需遵守</h4><ul>
<li><strong>宏的名字：</strong>不能再使用在头文件中定义过的宏的名字</li>
<li><strong>类型名（<code>typedef</code>）：</strong>具有文件作用域的库名（包括类型名）不可以在文件层次重新定义</li>
</ul>
<h4 id="建议遵守（避开保留字）"><a href="#建议遵守（避开保留字）" class="headerlink" title="建议遵守（避开保留字）"></a>建议遵守（避开保留字）</h4><ul>
<li>由<code>_大写字母</code>或<code>__</code>开头的标识符</li>
<li>由<code>_</code>开头的标识符（除非仅声明在函数内部）</li>
<li>标准库中所有具备外部链接的标识符，特别是所有标准库中的函数</li>
</ul>
<h3 id="21-1-2-使用宏隐藏函数"><a href="#21-1-2-使用宏隐藏函数" class="headerlink" title="21.1.2    使用宏隐藏函数"></a>21.1.2    使用宏隐藏函数</h3><blockquote>
<p><strong>说明：</strong>标准库中经常会为小的实际函数定义同名的宏函数，这是允许的，目的是提高程序的运行速度。<br><strong>取消隐藏：</strong>如果需要尽量缩小可执行代码的大小，或者需要一个指向这个库函数的指针，可以使用<code>undef</code>取消相应的红定义即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> isprint <span class="comment">// 即使isprint没定义过，也不会有负面影响</span></span></span><br></pre></td></tr></table></figure>
<p><strong>绕过宏调用：</strong>可以通过为函数名加圆括号来屏蔽个别宏调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(isptint)(); <span class="comment">// 预处理器无法分辨出带圆括号的宏，而编译器仍可认出isprint函数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-2-标准库概述"><a href="#21-2-标准库概述" class="headerlink" title="21.2    标准库概述"></a>21.2    标准库概述</h2><table>
<thead>
<tr>
<th>概述</th>
<th>标准头（15个）</th>
<th>提供的功能</th>
<th>相关章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>诊断</td>
<td>assert.h</td>
<td>仅包含<code>assert</code>宏，检查程序的状态，一旦任何检查失败，程序终止</td>
<td><a href="">24.1</a></td>
</tr>
<tr>
<td>字符处理</td>
<td>ctype.h</td>
<td>包括用于字符分类及大小写转换的函数</td>
<td><a href="">23.4</a></td>
</tr>
<tr>
<td>错误</td>
<td>errno.h</td>
<td>提供了<code>errno(&quot;errno number&quot;)</code>，errno是一个左值，可以在调用特定苦函数后进行监测，来判断调用过程中是否有错误发生</td>
<td><a href="">24.2</a></td>
</tr>
<tr>
<td>浮点型的特点</td>
<td>float.h</td>
<td>提供了用于描述浮点型特点的宏，包括值的范围及精度</td>
<td><a href="">23.1</a></td>
</tr>
<tr>
<td>整型的大小</td>
<td>limits.h</td>
<td>提供了用于描述整数类型和字符类型的宏，包括它们的最大值和最小值</td>
<td><a href="">23.2</a></td>
</tr>
<tr>
<td>本地化</td>
<td>locale.h</td>
<td>与本地化相关的行为，包括小数点的字符、货币的格式、字符集一集日期和时间的显示</td>
<td><a href="">25.1</a></td>
</tr>
<tr>
<td>数学计算</td>
<td>math.h</td>
<td>大量用于数据计算的函数，大部分使用double类型的实参，并返回一个double类型的值</td>
<td><a href="">23.3</a></td>
</tr>
<tr>
<td>非本地条转</td>
<td>setjmp.h</td>
<td>setjmp函数和longjmp函数<a href="**setjmp函数和long函数：**会“标记”程序中的一个位置，随后可以用`longjmp`返回被标记的位置，这些函数可以用来从一个函数跳转到另一个（仍然活动中的）函数中绕过正常的函数返回机制。`setjmp`函数和`longjmp`函数主要用来处理程序执行过程中的重大问题。">^21-2-7</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>信号处理</td>
<td>signal.h</td>
<td>用于异常情况（信号）处理的函数，包括终端和运行时错误<a href="**sinal函数：**可以设置一个函数，使系统会在给定信号发生后自动调用改函数；`raise函数`用来产生一个信号。">^21-2-8-signal</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>可变实际参数</td>
<td>stdarg.h</td>
<td>提供给函数可以处理不定个参数的的工具，就像<code>printf</code>和<code>scanf</code>函数</td>
<td><a href="">26.1</a></td>
</tr>
<tr>
<td>常用定义</td>
<td>stddef.h</td>
<td>提供了经常使用的类型和宏的定义</td>
<td><a href="">21.3</a></td>
</tr>
<tr>
<td>输入／输出</td>
<td>stdio.h</td>
<td>提供了大量用于输入／输出的函数，包括对顺序读写和随机读写文件的操作</td>
<td><a href="">22.1</a></td>
<td></td>
</tr>
<tr>
<td>常用实用程序</td>
<td>stdlib.h</td>
<td>包含了大量无法华贵其它头的函数[^stdlib]</td>
<td><a href="">26.2</a></td>
</tr>
<tr>
<td>字符串处理</td>
<td>string.h</td>
<td>提供了用于进行字符串操作的函数，包括肤质、拼接、比较以及搜索</td>
<td><a href="">23.5</a></td>
</tr>
<tr>
<td>日期与时间</td>
<td>time.h</td>
<td>提供相应的函数来获取日期和时间、操作时间和以多种方式显示时间等。</td>
<td><a href="">26.3</a></td>
</tr>
</tbody>
</table>
<h2 id="21-3-：常用定义"><a href="#21-3-：常用定义" class="headerlink" title="21.3    ：常用定义"></a>21.3    <stddef.h>：常用定义</stddef.h></h2><blockquote>
<p><strong>说明：</strong><code>stddef.h</code>提供了常用的类型和宏的定义，但没有声明任何函数。</p>
</blockquote>
<h3 id="21-3-1-定义的类型"><a href="#21-3-1-定义的类型" class="headerlink" title="21.3.1    定义的类型"></a>21.3.1    定义的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>原始类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptrdiff_t</td>
<td>当记性指针相减运算时，其结果的类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>size_t</td>
<td>运算符<code>sizeof</code>的返回值类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>wchar_t</td>
<td>一种足够大的、可以用于表示所有支持的地区的所有字符的类型</td>
<td>整数类型</td>
</tr>
</tbody>
</table>
<h3 id="21-3-2-定义的宏"><a href="#21-3-2-定义的宏" class="headerlink" title="21.3.2    定义的宏"></a>21.3.2    定义的宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>空指针</td>
</tr>
<tr>
<td>offsetof</td>
<td>计算结构的起点到指定成员间的字节数</td>
</tr>
</tbody>
</table>
<h4 id="21-3-2-1-offsetof"><a href="#21-3-2-1-offsetof" class="headerlink" title="21.3.2.1    offsetof"></a>21.3.2.1    offsetof</h4><blockquote>
<p><strong>说明：</strong>计算结构成员的偏移量（距结构起点的距离）<br><strong>用途：</strong>对人和编译器都会返回正确的偏移量，使我们可以编写一致性更好的程序。<br><strong>结构体成员的偏移量：</strong>一些编译器会在结构中留下一些空洞（无效字节），从而影响到<code>offsetof</code>产生的值。</p>
</blockquote>
<p><code>@param {struct}</code> 结构类型本身（不是实例）<br><code>@param {*}</code> 结构的成员<br><code>@return {int}</code> 结构的起点到指定成员的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> s &#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetof(<span class="keyword">struct</span> s, a); <span class="comment">// 0，C语言确保结构的第一个成员的地址与结构自身地址相同</span></span><br><span class="line"></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, b); <span class="comment">// 1（或2）</span></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, c); <span class="comment">// 5（或6）</span></span><br></pre></td></tr></table></figure>
<hr>
<p>[^stdlib]:  包含在<code>&lt;stdlib.h&gt;</code>中的函数可以将字符串转换成数、产生随机值、执行内存管理任务、域操作系统通信、执行搜索与排序以及对多字节字符及字符串进行操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/20 低级程序设计/" itemprop="url">
                  20 低级程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:05:58+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/20 低级程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/20 低级程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>位操作和其他一些低级运算在编写系统程序（包括编译器和操作系统）、加密程序、图形程序以及其他一些需要高执行速度或高效地使用空间的程序时非常有用。</p>
</blockquote>
<h2 id="20-1-按位运算符"><a href="#20-1-按位运算符" class="headerlink" title="20.1    按位运算符"></a>20.1    按位运算符</h2><blockquote>
<p><strong>说明：</strong>C语言一共提供了6个按位运算符。</p>
</blockquote>
<h3 id="20-1-1-移位运算符"><a href="#20-1-1-移位运算符" class="headerlink" title="20.1.1    移位运算符"></a>20.1.1    移位运算符</h3><blockquote>
<p><strong>说明：</strong>移位运算符可以改变数的二进制形式，将它的位向左或向右移动。<br><strong>优先级：</strong>低于算数运算符<code>i&lt;&lt;2+1 &lt;==&gt; i&lt;&lt;(2+1)</code><br><strong>操作数类型要求：</strong>可以是任意整型或字符型的<br><strong>副作用：</strong>不存在（不会改变操作数本身）<br>|运算符|名称|示例|返回值|复合移位运算符|<br>|-|-|-|-|-|<br>|<code>&lt;&lt;</code>|左位移|<code>i&lt;&lt;j</code>|<code>i</code>中的位左移<code>j</code>位的结果（左端溢出，右端补0）|<code>&lt;&lt;=</code>|<br>|<code>&gt;&gt;</code>|右位移|<code>i&gt;&gt;j</code>|<code>i</code>中的位右移<code>j</code>位的结果（右端溢出，左端补0或保存符号位而补1）|<code>&gt;&gt;=</code>|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">13</span>; <span class="comment">// 0000000000001101(16位)</span></span><br><span class="line">j = i &lt;&lt; <span class="number">2</span>; <span class="comment">// 0000000000110100(16位)</span></span><br><span class="line">j = i &gt;&gt; <span class="number">2</span>; <span class="comment">// 0000000000000011(16位)</span></span><br></pre></td></tr></table></figure>
<h3 id="20-1-2-按位求反、按位与、按位亦或、按位或"><a href="#20-1-2-按位求反、按位与、按位亦或、按位或" class="headerlink" title="20.1.2    按位求反、按位与、按位亦或、按位或"></a>20.1.2    按位求反、按位与、按位亦或、按位或</h3><blockquote>
<p><strong>优先级：</strong><code>~</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code>，都比<code>关系运算符</code>和<code>判等运算符</code>低。<br><strong>技巧：</strong>使用<code>~</code>创建在位一级具备可移植性的程序（例子）</p>
<ol>
<li>~0：所有位都为1的整数（否则就要最大的整数，但不同位的机器不同）</li>
<li>~0x001f：除了最后5位其它为都为1<br>|符号|名称|返回值|复合运算符|<br>|-|-|-|-|<br>|<code>~</code>|按位求反|将每一个0替换成1，每一个1替换成0|<code>~=</code>|<br>|<code>&amp;</code>|按位与|对两个操作数相应的位执行逻辑与运算|<code>&amp;=</code>|<br>|<code>^</code>|按位亦或|对两个操作数相应的位执行逻辑或操作，都是1时产生0|<code>^=</code>|<br>|<code>\</code>|按位或|对两个操作数相应的位执行逻辑或操作，都是1时产生1|<code>\=</code>|</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设unsigned int类型的值占16位</span></span><br><span class="line">i = <span class="number">21</span>; <span class="comment">//    0000000000010101</span></span><br><span class="line">j = <span class="number">56</span>; <span class="comment">//    0000000000111000</span></span><br><span class="line">k = ~i; <span class="comment">//    1111111111101010</span></span><br><span class="line">k = i &amp; j; <span class="comment">// 0000000000010000</span></span><br><span class="line">k = i ^ j; <span class="comment">// 0000000000101101</span></span><br><span class="line">k = i | j; <span class="comment">// 0000000000111101</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">21</span>;</span><br><span class="line">j = <span class="number">56</span>;</span><br><span class="line">i &amp;= j;</span><br><span class="line">i ^= j;</span><br><span class="line">i |= j;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-3-用按位运算符访问位"><a href="#20-1-3-用按位运算符访问位" class="headerlink" title="20.1.3    用按位运算符访问位"></a>20.1.3    用按位运算符访问位</h3><blockquote>
<p><strong>说明：</strong>通过按位运算，可以提取或修改存储在少数几个位中的数据。<br><strong>用途：</strong>比如，在编写图形程序时，可能会需要讲两个或更多的像素挤在一个字节中，从而降低空间复杂度和时间复杂度。<br><strong>方式：</strong>构造“掩码”，通过按位复合运算修改位</p>
<h4 id="设置位（为1）"><a href="#设置位（为1）" class="headerlink" title="设置位（为1）"></a>设置位（为1）</h4><p><strong>说明：</strong> 通过与“掩码”进行<code>按位或运算</code>设置某一位为1<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>0000000000001000</code>）。<br><strong>相关按位运算：</strong><code>按位或运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x0000</span>;</span><br><span class="line"><span class="comment">// 将第4位设置为1</span></span><br><span class="line"><span class="comment">// 0000000000000000 (i)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (按位或运算结果)</span></span><br><span class="line">i |= <span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算灵活构造掩码</span></span><br><span class="line">i |= <span class="number">1</span> &lt;&lt; j; <span class="comment">// 使用移位运算构造掩码</span></span><br></pre></td></tr></table></figure>
<h4 id="将位清零"><a href="#将位清零" class="headerlink" title="将位清零"></a>将位清零</h4><blockquote>
<p><strong>说明：</strong>通过与“掩码”进行<code>按位且运算</code>设置某一位为0<br><strong>掩码：</strong>除要清零的位外都为1的掩码（可以通过<code>移位运算</code>和<code>按位非运算</code>）构造（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x00ff</span>;  <span class="comment">// 0000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000000011111111（i）</span></span><br><span class="line"><span class="comment">// 1111111111110111 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000011110111 (按位且运算结果)</span></span><br><span class="line">i &amp;= ~<span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算和按位非灵活构造掩码</span></span><br><span class="line">i &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br></pre></td></tr></table></figure>
<h4 id="检测位"><a href="#检测位" class="headerlink" title="检测位"></a>检测位</h4><blockquote>
<p><strong>说明：</strong>检测某一位是否被设置过（设置为1）。<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置需要的掩码(假设在16位机器上)</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BLUE = <span class="number">1</span>, <span class="comment">// 0000000000000001</span></span><br><span class="line">	GREN = <span class="number">2</span>, <span class="comment">// 0000000000000010</span></span><br><span class="line">	RED = <span class="number">4</span>   <span class="comment">// 0000000000000100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i |= BULE; <span class="comment">// 设置BLUE bit(最后一位为1)</span></span><br><span class="line">i &amp;= ~BLUE; <span class="comment">// 抹掉BLUE bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测BLUE bit是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; BULUE) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测BLUE bit和GREEN bit是否都被设置了</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (BLUE | GREEN)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-4-用按位运算符访问位域"><a href="#20-1-4-用按位运算符访问位域" class="headerlink" title="20.1.4    用按位运算符访问位域"></a>20.1.4    用按位运算符访问位域</h3><blockquote>
<p><strong>位域：</strong>连续的几个位<br><strong>位域下标记法：</strong>最右边是最低位，记为0位</p>
<h4 id="修改位域"><a href="#修改位域" class="headerlink" title="修改位域"></a>修改位域</h4><p><strong>说明：</strong>不同于修改位，修改位域并不单纯的只是设置位或清除位，目标值中1和0可以并存，因此多了清除先清除位域的操作。<br><strong>相关按位运算：</strong><code>按位与</code>（用来清除位域）；<code>按位或</code>（用来将新的位存入域）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将二进制的值101存入变量i的第4-6位*/</span></span><br><span class="line"><span class="comment">// 0000000000000000，i的值可以使任意的16位整数</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将i的4-6位清零，然后用构造的掩码设置4-6位</span></span><br><span class="line"><span class="comment">// 0000000001110000 (0x0070)</span></span><br><span class="line"><span class="comment">// 1111111110001111 (~0x0070，掩码)</span></span><br><span class="line"><span class="comment">// 0000000001010000 (0x0050，4-6位上为要存储的二进制)</span></span><br><span class="line">i = i &amp; ~<span class="number">0x0070</span> | <span class="number">0x0050</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让上名的例子更加通用*/</span></span><br><span class="line"><span class="comment">// 0000000000000101, 包含需要存储的值</span></span><br><span class="line">j = <span class="number">5</span>;</span><br><span class="line">i = (i &amp; ~<span class="number">0x0070</span>) | (j &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取位域"><a href="#获取位域" class="headerlink" title="获取位域"></a>获取位域</h4><blockquote>
<p><strong>说明：</strong>获得指定位域上的值。<br><strong>相关按位运算：</strong><code>按位与</code><br><strong>技巧：</strong>当位域处在数的末尾区间时，获取值更加方便。如果要获取的位域不在末尾，可以先通过位移移至末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0000000000000111 (0x0007)</span></span><br><span class="line">j = i &amp; <span class="number">0x0007</span>; <span class="comment">// 获取0-2位上的位并放在j的末端</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = (i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0007</span>;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-5-程序：XOR加密"><a href="#20-1-5-程序：XOR加密" class="headerlink" title="20.1.5    程序：XOR加密"></a>20.1.5    程序：XOR加密</h3><blockquote>
<p><strong>说明：</strong>将每一个字符与一个密匙进行亦或（XOR）运算；要将信息解码，只需要再次加密，即可得到原来的字符。<br><strong>注意：</strong>读或写包含控制字符的文件时会在一些操作系统中引发错误，应当避免。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------加密---------------</span><br><span class="line">		<span class="number">01111010</span> (z， 加密前)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 密匙)</span><br><span class="line">		<span class="number">01011100</span> (\, 加密后)</span><br><span class="line">-------------解密---------------</span><br><span class="line">		<span class="number">01011100</span> (\, 解密)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 同样的密匙)</span><br><span class="line">		<span class="number">01111010</span> (z, 解密后)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 以文件作为输入，使用XOR加密(或解密)。并将加密(或解密)后的文本输出</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> KEY <span class="string">'&amp;'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> orig_char, new_char;</span><br><span class="line">	<span class="comment">// 遍历输入流中的每一个字符，加密后输出，直到文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> ((orig_char = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="comment">// 加密</span></span><br><span class="line">		new_char = orig_char ^ KEY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果加密（或解密）后的字符是控制字符则不加密（或解密）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(orig_char) || <span class="built_in">iscntrl</span>(new_char)) &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(orig_char);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(new_char);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./xor &lt; msg.txt</span><br></pre></td></tr></table></figure>
<h2 id="20-2-结构中的位域"><a href="#20-2-结构中的位域" class="headerlink" title="20.2    结构中的位域"></a>20.2    结构中的位域</h2><blockquote>
<p><strong>说明：</strong>C语言提供了可以在结构中声明存储在位域中的成员。<br><strong>语法：</strong>位域的类型必需是<code>int</code>、<code>unsigned int</code>或<code>signed int</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构名 &#123;</span><br><span class="line">	&#123;<span class="keyword">int</span>|<span class="keyword">unsigned</span> <span class="keyword">int</span>|<span class="keyword">signed</span> <span class="keyword">int</span>&#125; [成员名]: 位数;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>使用<code>按位运算</code>可以达到同样的效果，而且可能更快些，当可读性不如<code>结构中的位域</code>。<br><strong>局限性：</strong>通常位域没有地址，因此C语言不允许将<code>&amp;运算符</code>或<code>scanf函数</code>用于位域。<br><strong>可移植性技巧：</strong>将所有的位域声明为<code>unsigned int</code>或<code>signed int</code>而不是<code>int</code>，因为一些编译器将位域的最高位作为符号位，而其它一些编译器则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="位域是如何存储的"><a href="#位域是如何存储的" class="headerlink" title="位域是如何存储的"></a>位域是如何存储的</h3><blockquote>
<p><strong>存储单元：</strong>一个存储单元的大小是由实现定义的，通常是8位、16位或32位。<br><strong>未命名为域：</strong>将无法被赋值和使用，但正常占据空间。经常用来作为成员间的填充，以保证其它位域存储在适当的位置。<br><strong>长度为0的位域：</strong>告诉编译器将下一个位域放在一个存储单元的起始位置，即如果当前存储单元还有空间剩余，无论能否放下长度为0的成员的后面的成员，都会将其放在下一个存储单元中。</p>
</blockquote>
<ul>
<li><strong>存储顺序：</strong>当编译器处理结构实例时，会将位域逐个存入存储单元（从左向右或从右向左）</li>
<li><strong>位域型成员之间的间隙：</strong>位域之间没有间隙，直到剩下的空间不够放下一个位域（这时会跳到下一个存储单元继续存放，即<code>存在间隙</code>或跨存储单元存放，即<code>没有间隙</code>）。</li>
</ul>
<p><strong>案例</strong></p>
<blockquote>
<p><strong>说明：</strong>假设位域是<code>从右至左</code>存储，且当一个存储单元剩余的空间无法存储下一个位域成员时会<code>跨存储单元存储</code>。这时DOS系统上编译常用的方式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构实例</span></span><br><span class="line"><span class="keyword">struct</span> file_date fd;</span><br><span class="line">fd.day = <span class="number">28</span>;</span><br><span class="line">fd.month = <span class="number">12</span>;</span><br><span class="line">fd.year = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>*</th>
<th>year</th>
<th>month</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>0001000</td>
<td>1100</td>
<td>11100</td>
</tr>
<tr>
<td>大小（bit）</td>
<td>7</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>区间</td>
<td>15-9</td>
<td>8-5</td>
<td>4-0</td>
</tr>
</tbody>
</table>
<h2 id="20-3-其他低级技术"><a href="#20-3-其他低级技术" class="headerlink" title="20.3    其他低级技术"></a>20.3    其他低级技术</h2><h3 id="20-3-1-定义依赖机器的类型"><a href="#20-3-1-定义依赖机器的类型" class="headerlink" title="20.3.1    定义依赖机器的类型"></a>20.3.1    定义依赖机器的类型</h3><blockquote>
<p><strong>说明：</strong>可以将<code>char</code>作为一个字节（不一定存储字符）来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-2-用联合从多个视角看待数据"><a href="#20-3-2-用联合从多个视角看待数据" class="headerlink" title="20.3.2    用联合从多个视角看待数据"></a>20.3.2    用联合从多个视角看待数据</h3><h4 id="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"><a href="#案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。" class="headerlink" title="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"></a>案例一：使用<code>联合</code>结合<code>结构体（位域成员）</code>实现文件日期和整数的转换。</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>获取：可以通过成员<code>i</code>以两个字节的形式获得日期的整数形式</li>
<li>设置：可以通过成员<code>fd</code>以结构体的方式设置文件日期（以两个字节的方式存储）</li>
</ul>
</blockquote>
<p><em>文件日期定义</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>封装一个方便读取和设置数据结构</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> int_date &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ;</span><br><span class="line">	<span class="keyword">struct</span> file_date fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>实践</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将整数形式（两个字节）的日期以作为文件日期数据结构打印</span><br><span class="line">* @param &#123;undesigned int&#125; n 存储这日期信息的整数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_date</span> <span class="params">(undesigned <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> int_date u;</span><br><span class="line">	u.i = n;</span><br><span class="line">	<span class="comment">// 年只显示后两位（比如1990年简称90年）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d/%d/%.2d\n"</span>, u.fd.month, u.fd.day, (u.fd.year + <span class="number">1980</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="案例二：模拟对寄存器的访问（Intel-80x86）"><a href="#案例二：模拟对寄存器的访问（Intel-80x86）" class="headerlink" title="案例二：模拟对寄存器的访问（Intel 80x86）"></a>案例二：模拟对寄存器的访问（Intel 80x86）</h4><blockquote>
<p><strong>说明：</strong>需要对16位寄存器和8位寄存器进行访问，同时保留它们之间的关系。<br><strong>寄存器：</strong>Intel 80x86处理器包涵4个16位的寄存器（<code>AX(AH|AL)</code>、<code>BX(BH|BL)</code>、<code>CX(CH|CL)</code>、<code>DX(DH|DL)</code>），其中每个16位寄存器都包含2个8位寄存器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="comment">// 16位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		WORD ax, bx, cx. dx;</span><br><span class="line">	&#125; word;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 8位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		BYTE al, ah, bl, bh, cl, ch, dl, dh;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; regs;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照8位寄存器的方式修改</span></span><br><span class="line">regs.byte.ah = <span class="number">0x12</span>;</span><br><span class="line">regs.byte.al = <span class="number">0x34</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照16位寄存器的方式观察</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AX: %x\n"</span>, regs.word.ax);</span><br></pre></td></tr></table></figure>
<h3 id="20-3-3-将指针作为地址使用（将地址转换为指针使用）"><a href="#20-3-3-将指针作为地址使用（将地址转换为指针使用）" class="headerlink" title="20.3.3    将指针作为地址使用（将地址转换为指针使用）"></a>20.3.3    将指针作为地址使用（将地址转换为指针使用）</h3><blockquote>
<p><strong>说明：</strong>指针按照其自身的构造方式可以分为两类（以16位机器为例）<br>|分类|组成|大小(bit)|地址转换为指针|情景|<br>|-|-|-|-|<br>|近指针|偏移量||16|将整数强制转换为指针|在一些计算机中|<br>|远指针|段地址＋偏移量|32|<code>far(关键字，非标准c)</code>+<code>MK_FP</code>(dos.h中的宏)|Intel CPU的实时模式（DOS使用的模式）|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 近指针</span></span><br><span class="line">BYTE *p;</span><br><span class="line">p = (BYTE *) <span class="number">0x1000</span>; <span class="comment">// 将16位整数地址直接转换为指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远指针</span></span><br><span class="line">BYTE far *p; <span class="comment">// 使用far声明一个远指针</span></span><br><span class="line">p = MKFP(segment, offset); <span class="comment">// 段地址， 偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="20-3-4-程序：设置Num-Lock-键"><a href="#20-3-4-程序：设置Num-Lock-键" class="headerlink" title="20.3.4    程序：设置Num Lock 键"></a>20.3.4    程序：设置Num Lock 键</h3><blockquote>
<p><strong>说明：</strong>在<code>IBM PC</code>机极其兼容机上，<code>Num Lock</code>切换涌来确定数字键盘上的按键是作为数字键使用，还是作为移动光标的方向键。<br><strong>原理：</strong><code>Num Lock</code>的状态保存在地址位地址段为40（16进制）、偏移量为17（16进制）的字节中。该字节的第5位（最低位为0位）用来控制<code>Num Lock</code>的状态。</p>
</blockquote>
<p><strong>开启Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 开启num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0000000000100000 (掩码)</span></span><br><span class="line">	*p |= <span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1111111111011111 (掩码)</span></span><br><span class="line">	*p &amp;= ～<span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-5-volatile类型限定符"><a href="#20-3-5-volatile类型限定符" class="headerlink" title="20.3.5    volatile类型限定符"></a>20.3.5    volatile类型限定符</h3><blockquote>
<p><strong>关键字：</strong><code>volatile</code><br><strong>说明：</strong>通常使用在用于指向易变内存空间的指针的声明中。用来防止编译器优化过程中错误地将易变内容缓存在了寄存器中，而不再读取内存中易变内容。</p>
</blockquote>
<p><em>优化前的逻辑</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前的逻辑</span></span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入; <span class="comment">// 将输入存储到*p</span></span><br><span class="line">	buffer[i] = *p;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>优化后的逻辑</em></p>
<blockquote>
<p><strong>说明：</strong>注意到这个循环中既没有改变p，也没有改变<em>p，因此对程序进行优化，使</em>p只被读取一次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在寄存器中存储*p;</span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入;</span><br><span class="line">	buffer[i] = 存储在寄存器中的值;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/19 程序设计/" itemprop="url">
                  19 程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:00:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/19 程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/19 程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="19-1-模块"><a href="#19-1-模块" class="headerlink" title="19.1    模块"></a>19.1    模块</h2><blockquote>
<p><strong>说明：</strong><code>模块</code>是一组功能（服务）的集合，其中一些功能可以被程序的其它部分（<code>客户</code>）使用。每个模块都有一个<code>接口</code>来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的<code>实现</code>中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td><code>模块名.h</code>(头文件)</td>
</tr>
<tr>
<td>实现</td>
<td>对应头文件<code>模块名.c</code>文件</td>
</tr>
<tr>
<td>客户</td>
<td>通过<code>#include</code>引入模块的文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>优点：</strong>将程序分割成模块有一系列好处</p>
<ul>
<li>抽象：不必了解功能的实现细节，只需对模块的接口达成一致</li>
<li>可复用：每个模块都可以在另一个程序中复用</li>
<li>可维护性（最重要）：当程序出现错误或需要升级时，通常只会影响一个模块</li>
</ul>
<p><strong>扩展：</strong><a href="">Fundamental of SoftWare Engineer</a></p>
</blockquote>
<h3 id="19-1-1-内聚性与耦合性"><a href="#19-1-1-内聚性与耦合性" class="headerlink" title="19.1.1    内聚性与耦合性"></a>19.1.1    内聚性与耦合性</h3><blockquote>
<p><strong>说明：</strong>一个好的模块接口并不是随意的一组声明，应具有下面两个性质</p>
<ul>
<li>高内聚：模块中的元素应该紧密相关</li>
<li>低耦合：模块之间应该尽可能相互独立</li>
</ul>
</blockquote>
<h3 id="19-1-2-模块的类型"><a href="#19-1-2-模块的类型" class="headerlink" title="19.1.2    模块的类型"></a>19.1.2    模块的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据池</td>
<td>一些相关的变量或常量的集合</td>
<td><code>&lt;float.h&gt;</code>(<a href="">23.1</a>)、 <code>&lt;limits.h&gt;</code>(<a href="">23.2</a>)</td>
<td>通常不建议将变量放在头文件</td>
</tr>
<tr>
<td>库</td>
<td>一组相关函数的集合</td>
<td><code>&lt;string.h&gt;</code></td>
<td></td>
</tr>
<tr>
<td>抽象对象</td>
<td>对隐藏的数据结构进行操作的一组函数的集合</td>
<td></td>
<td>如果数据是隐藏起来的，那么这个对象那个就是“抽象的”</td>
</tr>
<tr>
<td>抽象数据类型</td>
<td>将具体数据实现方式隐藏起来的数据类型称为抽象数据类型</td>
<td></td>
<td>抽象数据类型在当今的程序设计中起着非常重要的作用</td>
</tr>
</tbody>
</table>
<h2 id="19-2-信息隐藏"><a href="#19-2-信息隐藏" class="headerlink" title="19.2    信息隐藏"></a>19.2    信息隐藏</h2><blockquote>
<p><strong>说明：</strong>一个设计良好的模块经常会对它的客户隐藏一些信息。谨慎的对客户隐藏信息的方法称为信息隐藏。<br><strong>优点：</strong></p>
<ul>
<li>安全性：<code>客户</code>只能通过<code>模块</code>自身的函数进行参数</li>
<li>灵活性：修改模块通常不必修改接口，对<code>客户</code>没有影响</li>
</ul>
<p><strong>原理：</strong>使用<code>static</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰</th>
<th>链接情况</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数</td>
<td>内部链接</td>
<td>只能在只能被同一文件中被调用</td>
</tr>
<tr>
<td>变量（文件作用域）</td>
<td>内部链接</td>
<td>只能被同一文件中的其它函数访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>使用宏定义“公有”和“私有”可以使程序含义更加清晰（尤其是<code>static</code>，因为它在c语言中有许多用法）</p>
<h3 id="栈模块-实现部分"><a href="#栈模块-实现部分" class="headerlink" title="栈模块(实现部分)"></a>栈模块(实现部分)</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC  <span class="comment">// 定义为空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIVATE static</span></span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> contents[STACK_SIZE] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PRIVATE <span class="keyword">int</span> <span class="title">is_full</span> <span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">pop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-3-抽象数据类型"><a href="#19-3-抽象数据类型" class="headerlink" title="19.3    抽象数据类型"></a>19.3    抽象数据类型</h2><blockquote>
<p><strong>说明：</strong>c语言没有设计专门用于封装类型的特性（<code>class</code>），即无法定义真正的抽象数据类型。<br><strong>案例缺陷：</strong>之前定义的栈模块提供的栈不基于一种抽象数据类型，而是仅仅提供了一个相当于“栈的实例”的数据结构。当需要多个栈实例时就无能为力了。</p>
</blockquote>
<p><em>stack.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 下面定义的Stack不是抽象数据类型，因为stack.h暴露了Stack的具体实现方式（结构体实例的成员是暴露的)</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empyt</span> <span class="params">(Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">const</span> Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(Stack *s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span> <span class="params">(Stack *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>客户</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 理想的使用方式</span></span><br><span class="line">	Stack s1, s2;</span><br><span class="line">	make_empty(&amp;s1);</span><br><span class="line">	make_empty(&amp;s2);</span><br><span class="line">	push(&amp;s1, <span class="number">1</span>);</span><br><span class="line">	push(&amp;s2, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!is_empty(&amp;s1)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(&amp;s1)); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不理想的方式</span></span><br><span class="line">	Stack s3;</span><br><span class="line">	s3.top = <span class="number">0</span>; <span class="comment">//直接访问了暴露出来的成员</span></span><br><span class="line">	s3.contents[top++] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-4-C-语言"><a href="#19-4-C-语言" class="headerlink" title="19.4    C++语言"></a>19.4    C++语言</h2><blockquote>
<p><strong>说明：</strong>C++语言是由<code>AT&amp;T</code>贝尔实验室的Bjqrne Stroustrup在20世纪80年代开发出来的C语言的扩展版。<br><strong>新特性（相对C）：</strong></p>
<ul>
<li>面向对象：允许从已经存在的类“派生”（继承）出新的类</li>
<li>运算符重载：为传统的C语言的运算符赋予新的含义</li>
<li>模版：可以使我们写出通用的、高度可复用的类和函数</li>
<li>异常处理：一种同一的方式用来检测并响应错误</li>
</ul>
<p><strong>兼容C：</strong>C++语言包含了标准C的全部特性，然而不是所有C语言都可以在C++的环境下编译，因为C++语言增加了更多强制限制，比C语言更加安全。</p>
</blockquote>
<h3 id="19-4-1-C语言与C-语言之间的差异"><a href="#19-4-1-C语言与C-语言之间的差异" class="headerlink" title="19.4.1    C语言与C++语言之间的差异"></a>19.4.1    C语言与C++语言之间的差异</h3><h4 id="19-4-1-1-注释"><a href="#19-4-1-1-注释" class="headerlink" title="19.4.1.1    注释"></a>19.4.1.1    注释</h4><blockquote>
<p><strong>新特性：</strong>C++语言支持单行注释</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a Comment</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-2-标记与类型名"><a href="#19-4-1-2-标记与类型名" class="headerlink" title="19.4.1.2    标记与类型名"></a>19.4.1.2    标记与类型名</h4><blockquote>
<p><strong>新特性：</strong>标记（结构、联合或枚举的名字）会自动被认为是类型名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">	<span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 相当于下列形式的c语言</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">typedef struct Complex &#123;</span><br><span class="line">	double re, im;</span><br><span class="line">&#125; Complex;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-3-不带参数的函数"><a href="#19-4-1-3-不带参数的函数" class="headerlink" title="19.4.1.3    不带参数的函数"></a>19.4.1.3    不带参数的函数</h4><blockquote>
<p><strong>新特性：</strong>在声明或定义一个不带参数的<code>C++</code>函数时，可以不使用<code>void</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">()</span></span>; <span class="comment">// 和void相同</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-4-默认实际参数"><a href="#19-4-1-4-默认实际参数" class="headerlink" title="19.4.1.4    默认实际参数"></a>19.4.1.4    默认实际参数</h4><blockquote>
<p><strong>新特性：</strong>C++语言允许函数的实际参数有默认值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示任意数量的换行符，如果没有提供参数，默认为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_line</span> <span class="params">(<span class="keyword">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_line(<span class="number">3</span>); <span class="comment">// 三个换行</span></span><br><span class="line">new_line(); <span class="comment">//一个换行</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-5-引用参数"><a href="#19-4-1-5-引用参数" class="headerlink" title="19.4.1.5    引用参数"></a>19.4.1.5    引用参数</h4><blockquote>
<p><strong>新特性：</strong>允许实际参数被声明为<code>引用</code>，而不是<code>指针</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c语言的方式</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">void swap (int *a, int *b) &#123;</span><br><span class="line">	int temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;i, &amp;j);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(i, j); <span class="comment">// 不需要再参数前加&amp;运算符</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-6-动态存储分配"><a href="#19-4-1-6-动态存储分配" class="headerlink" title="19.4.1.6    动态存储分配"></a>19.4.1.6    动态存储分配</h4><blockquote>
<p><strong>新特性：</strong>使用运算符<code>new</code>（分配空间）、 <code>delete</code>（释放空间）<br><strong>语法：</strong></p>
<ul>
<li>分配内存：<code>new 类型说明符</code></li>
<li>释放内存： <code>delete 指针</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> *int_ptr, *int_array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">int_ptr = new <span class="keyword">int</span>; <span class="comment">// 为整数分配存储空间</span></span><br><span class="line">int_array = new <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 为数组分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="keyword">delete</span> int_ptr; <span class="comment">// 为整数空间释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] int_array; <span class="comment">// 为数组释放空间</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-2-类"><a href="#19-4-2-类" class="headerlink" title="19.4.2    类"></a>19.4.2    类</h3><blockquote>
<p><strong>类：</strong>一个类从根本上说就是一个<code>抽象数据类型</code>：一组数据以及操作这些数据的函数<br><strong>说明：</strong>这个新数据类型的功能可以同基本数据类型同样强大。<br><strong>类的不足：</strong>类的设计和实现比较复杂，这是易用性必须付出的代价，而这也是计算机领域近几年内的妥协。</p>
</blockquote>
<h3 id="19-4-3-类定义"><a href="#19-4-3-类定义" class="headerlink" title="19.4.3    类定义"></a>19.4.3    类定义</h3><blockquote>
<p><strong>类标记（class tag）：</strong>可以直接作为类型名使用，不要求类名以大写开始，但许多C++程序员尊循首字母大写的规范。<br><strong>数据成员（data memeber）：</strong>类似结构的成员（但是默认是隐藏的，即“私有的”）<br><strong>类的实例（instance）：</strong>任何类的实例就是<code>对象</code>（object）<br><strong>访问成员：</strong>使用运算符<code>.</code>或<code>-&gt;</code>来访问公有的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 默认是私有的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 公有成员</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> numeratitor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-4-成员函数"><a href="#19-4-4-成员函数" class="headerlink" title="19.4.4    成员函数"></a>19.4.4    成员函数</h3><blockquote>
<p><strong>成员函数（member function）：</strong>属于类的函数称为成员函数，特别的，那些需要访问类的私有数据成员的函数必须声明在类里面。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 将函数的定义放在类的定义之中</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> denom)</span> </span>&#123;</span><br><span class="line">			numertor = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 只声明不定义（定义部分放在类外部）</span></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		* 乘法函数</span><br><span class="line">		* @param &#123;Fraction f&#125; </span><br><span class="line">		*/</span></span><br><span class="line">		<span class="function">Fraction <span class="title">mul</span><span class="params">(Fraction f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 乘法函数的定义</span><br><span class="line">* Fraction::前缀是必需的，否则C++编译器会将mul作为一个普通函数</span><br><span class="line">* @param &#123;Fraction f&#125; 分数</span><br><span class="line">*/</span></span><br><span class="line">Fraction Fraction::mul(Fraction f) &#123;</span><br><span class="line">	Fraction result;</span><br><span class="line">	result.numerator = numerator * f.numerator;</span><br><span class="line">	result.denominator = denominator * f.denominator;</span><br><span class="line">	result.reduce();</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fraction f1;</span><br><span class="line">f1.create(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Fraction f2 = f1.mul(f1);</span><br></pre></td></tr></table></figure>
<h3 id="19-4-5-构造函数"><a href="#19-4-5-构造函数" class="headerlink" title="19.4.5    构造函数"></a>19.4.5    构造函数</h3><blockquote>
<p><strong>构造函数（controctor）：</strong></p>
<ul>
<li>通常时自动调用的（编译器安排在合适的时机自动调用）</li>
<li>定义在public成员部分，不需要指定返回值类型</li>
<li>命名和类名相同</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		Fraction(<span class="keyword">int</span> num = <span class="number">0</span>, <span class="keyword">int</span> denom = <span class="number">1</span>) &#123;</span><br><span class="line">			numerator = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 通过构造函数声明并初始化实例</span></span><br><span class="line"><span class="function">Fraction <span class="title">f2</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 等同于Fraction f2(3, 1);</span></span><br><span class="line">Fraction f3; <span class="comment">// 等同于 f3(0, 1);</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-6-构造函数和动态存储分配"><a href="#19-4-6-构造函数和动态存储分配" class="headerlink" title="19.4.6    构造函数和动态存储分配"></a>19.4.6    构造函数和动态存储分配</h3><blockquote>
<p><strong>说明：</strong>构造函数和析构函数为那些内存分配和回收函数提供了比较合适的时机。<br><strong>举例：</strong>创建自己的<code>String</code>类型<br>|比较|C++的<code>String</code>（自定义）|C语言实现方式（<code>char</code>数组）|<br>|-|-|-|<br>|字符串长度|任意长度|受限于数组的长度|<br>|获取字符串长度|O(1)|O(n)|<br>|扩展性|需要时可给String类添加操作|无法修改（就算引入<string.h>，但无法扩展）|</string.h></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">	<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="comment">// 分配足够大的空间</span></span><br><span class="line">	text = new Char[len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">	<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-7-析构函数"><a href="#19-4-7-析构函数" class="headerlink" title="19.4.7    析构函数"></a>19.4.7    析构函数</h3><blockquote>
<p><strong>析构函数（destructor）：</strong></p>
<ul>
<li>名字：<code>~类名</code></li>
<li>返回值：没有返回值</li>
<li>参数：没有</li>
</ul>
<p><strong>用途：</strong>自动存储期限的类的实例，当其生存期结束后，普通成员的内存会被释放，但在构造函数中分配内存的成员指向的内存不会被释放（内存泄漏）。所以需要析构函数在对象释放时自动调用，清理构造函数动态分配的内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明并定义构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">			<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">			len = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="comment">// 分配足够大的空间</span></span><br><span class="line">			text = new Char[len + <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">			<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 声明并定义析构函数</span></span><br><span class="line">		~String() &#123;</span><br><span class="line">			<span class="keyword">delete</span> [] text;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-8-重载"><a href="#19-4-8-重载" class="headerlink" title="19.4.8    重载"></a>19.4.8    重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p><strong>说明：</strong>在同一作用域下存在两个或以上同名但参数不同的函数(包括构造函数)叫做函数的重载。<br><strong>用途：</strong>需要记住更少的函数名，编译器会根据实际参数的情况自动判断调用哪一个函数。<br><strong>默认构造函数：</strong>不带时机参数的构造函数，会在声明对象而没有制定初始值时被调用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sring &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	* 重载构造函数（默认）</span><br><span class="line">	* @overload</span><br><span class="line">	*/</span></span><br><span class="line">	String() &#123;</span><br><span class="line">		text = <span class="number">0</span>;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~String() &#123;</span><br><span class="line">		<span class="keyword">delete</span> [] text;</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *text;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s; <span class="comment">// 不带实际参数，会调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p><strong>说明：</strong>重载运算符后，根据操作数类型的不同，同样的运算符号可以代表不同的操作。<br><strong>用途：</strong>更易读，更自然（不需要定义一些难以记住的函数名）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 声明重载操作符：*</span></span><br><span class="line">	Fraction <span class="keyword">operator</span>*(Fraction f);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载操作符：*</span></span><br><span class="line">Fraction Fraction::operation*(Fraction f) &#123;</span><br><span class="line">	<span class="comment">//代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f3 = f1 * f2; <span class="comment">// 定义的*是一个二元运算符(相当于f3 = f1.operator*(f2);)</span></span><br></pre></td></tr></table></figure>
<h4 id="C-语言的输入／输出（）"><a href="#C-语言的输入／输出（）" class="headerlink" title="C++语言的输入／输出（）"></a>C++语言的输入／输出（<stdio.h>）</stdio.h></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/18 声明/" itemprop="url">
                  18 声明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T20:29:30+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/18 声明/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/18 声明/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>通过声明变量和函数，可以再检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。</p>
</blockquote>
<h2 id="18-1-声明的语法"><a href="#18-1-声明的语法" class="headerlink" title="18.1    声明的语法"></a>18.1    声明的语法</h2><blockquote>
<p><strong>语法：</strong><code>声明说明符 声明符;</code></p>
</blockquote>
<h3 id="18-1-1-声明说明符"><a href="#18-1-1-声明说明符" class="headerlink" title="18.1.1    声明说明符"></a>18.1.1    声明说明符</h3><blockquote>
<p><strong>分类：</strong>分3类（可组合）</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>包括</th>
<th>位置</th>
<th>可多个</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>auto static extern register</td>
<td>声明中的首要位置</td>
<td>否</td>
</tr>
<tr>
<td>类型限定符</td>
<td>const volatile</td>
<td>存储类型的后边</td>
<td>是</td>
</tr>
<tr>
<td>类型说明符</td>
<td>void char short int long float double signed unsigned 结构 联合 枚举 typedef创建的类型名</td>
<td>存储类型的后边</td>
<td>是，出现顺序无限制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>类型限定符和类型说明符的顺序没有限制，习惯上前者在前。</p>
</blockquote>
<h3 id="18-1-2-声明符"><a href="#18-1-2-声明符" class="headerlink" title="18.1.2    声明符"></a>18.1.2    声明符</h3><blockquote>
<p><strong>说明：</strong>一次可以声明多个声明符，彼此用<code>,</code>隔开。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>是否可跟初始化式</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单变量名</td>
<td>标识符</td>
<td>是</td>
</tr>
<tr>
<td>数组名</td>
<td>后边跟随[]的标识符</td>
<td>是</td>
</tr>
<tr>
<td>指针名</td>
<td>前放置*的标识符</td>
<td>是</td>
</tr>
<tr>
<td>函数名</td>
<td>后边跟随()的标识符</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="18-1-3-举例"><a href="#18-1-3-举例" class="headerlink" title="18.1.3    举例"></a>18.1.3    举例</h3><p><em>同时声明多个声明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.19.png" alt="Alt text"></p>
<p><em>带有初始化式</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.31.png" alt="Alt text"></p>
<p><em>同时使用多种类型说明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.57.png" alt="Alt text"></p>
<p><em>函数声明</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.09.05.png" alt="Alt text"></p>
<h2 id="18-2-存储类型"><a href="#18-2-存储类型" class="headerlink" title="18.2    存储类型"></a>18.2    存储类型</h2><blockquote>
<p><strong>说明：</strong>可以用于变量、较小范围的函数和形式参数的说明。根据声明位置的不同，在不用存储类型修饰的情况下，变量具有默认的存储类型，当默认的性质无法满足要求时，可以通过指定明确的存储类型来改变变量的性质。<br><strong>关键字：</strong><code>auto</code> <code>static</code> <code>extern</code> <code>register</code><br><strong>块（block）：</strong>表示函数体（大括号闭合的部分）或块语句（包含生命的复合语句）。</p>
</blockquote>
<h3 id="18-2-1-变量的特性"><a href="#18-2-1-变量的特性" class="headerlink" title="18.2.1    变量的特性"></a>18.2.1    变量的特性</h3><blockquote>
<p><strong>说明：</strong>变量的3个性质</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
<th>说明</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储期限</td>
<td>为变量预留和释放内存的时间</td>
<td>自动存储期限、静态存储期限</td>
</tr>
<tr>
<td>作用域</td>
<td>指引用变量的那部分程序文件</td>
<td>块作用域、文件作用域</td>
</tr>
<tr>
<td>链接</td>
<td>程序的不同部分可以共享此变量的范围</td>
<td>外部链接、内部链接、无链接</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>声明位置决定的存储特性：</strong>对许多变量而言，默认的存储期限、作用域和链接是可以符合要求的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>声明位置</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>块内部</td>
<td>自动存储期限、块作用域、无链接</td>
</tr>
<tr>
<td>程序的最外层</td>
<td>静态存储期限、文件作用域、外部链接</td>
</tr>
</tbody>
</table>
<h4 id="1-存储期限"><a href="#1-存储期限" class="headerlink" title="1. 存储期限"></a>1. 存储期限</h4><table>
<thead>
<tr>
<th>存储期限</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
<td>在所属块被执行时获得内存单元，并在块终止时释放内存单元（变量失去值）</td>
<td></td>
</tr>
<tr>
<td>静态存储期限</td>
<td>在程序运行期间占有同样的存储单元</td>
<td>可以允许变量无限期地保留它的值</td>
</tr>
</tbody>
</table>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>块作用域</td>
<td>变量从声明的地方一直到闭合块的末尾都是可见的</td>
<td></td>
</tr>
<tr>
<td>文件作用域</td>
<td>从声明的地方一直到闭合文件的末尾都时可见的</td>
</tr>
</tbody>
</table>
<h4 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h4><table>
<thead>
<tr>
<th>链接</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部链接</td>
<td>可以被程序中的几个（或者全部）文件共享</td>
<td></td>
</tr>
<tr>
<td>内部链接</td>
<td>只能属于单独一个文件</td>
<td></td>
</tr>
<tr>
<td>无链接</td>
<td>属于单独一个函数，而且根本不能被共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 静态存储期限</span><br><span class="line">* 文件作用域</span><br><span class="line">* 外部链接</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	* 自动存储期限</span><br><span class="line">	* 块作用域</span><br><span class="line">	* 无链接</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-2-auto存储类型"><a href="#18-2-2-auto存储类型" class="headerlink" title="18.2.2    auto存储类型"></a>18.2.2    auto存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>auto</code><br>注意：auto存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h3 id="18-2-3-static存储类型"><a href="#18-2-3-static存储类型" class="headerlink" title="18.2.3    static存储类型"></a>18.2.3    static存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>static</code><br><strong>可以修饰：</strong>全部变量<br><strong>特性：</strong>修饰快外部声明的变量和块内部声明的变量会有不同的效果</p>
<ul>
<li><strong>块外部</strong>：static使变量由外部链接变为内部链接（即<code>信息隐藏</code>，因为本质上隐藏了它所在声明文件内的变量，只有出现在同一文件中的函数可以看到此变量）</li>
<li><strong>块内部</strong>：static使变量的存储期限从自动变成静态的(无限期保留值)</li>
</ul>
<ol>
<li>块内的<code>static</code> 型变量只在程序执行前进行一次初始化，而<code>auto</code>型变量则会在每次变成有效时进行初始化</li>
<li>每次函数进行递归调用时，它都会获得一组新的<code>auto</code>型变量的集合。<code>static</code>修饰的变量则会被共用</li>
<li>函数不能返回<code>auto</code>型变量的指针，但可以返回指向<code>static</code>型变量的指针</li>
</ol>
<p><strong>用途：</strong></p>
<ol>
<li><strong>提升性能：</strong>修饰块内部变量，避免函数每次调用都对变量进行初始化</li>
<li><strong>信息隐藏：</strong>修饰块外部变量，用于在“隐藏”区域内的调用之间保留信息</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 内部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 无链接</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 将10进制的数字转换为16进制的</span><br><span class="line">* param &#123;int&#125; digit 10进制数字（16以内）</span><br><span class="line">* return &#123;char&#125; 表示响应16进制数字的字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">digit_to_hex_char</span> <span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 无论函数呗调用多少次，只会初始化一次</span></span><br><span class="line">	<span class="keyword">const</span> chat hex_chars[<span class="number">16</span>] = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">	return hex_chars[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-4-extern存储类型"><a href="#18-2-4-extern存储类型" class="headerlink" title="18.2.4    extern存储类型"></a>18.2.4    extern存储类型</h3><blockquote>
<p><strong>说明：</strong>只声明变量（不初始化）<br><strong>关键字：</strong><code>extern</code><br><strong>用途：</strong>多文件共享同一个变量<br><strong>性质：</strong></p>
<ul>
<li><strong>存储期限：</strong>使变量具有<code>静态存储期限</code>（即使在块中声明的变量）</li>
<li><strong>作用域：</strong><code>extern</code>不影响变量作用域（块内声明为块作用域，否则是文件作用域）</li>
<li><strong>链接：</strong>通常情况为<code>外部链接</code>；当同时被<code>static</code>修饰且声明位置为任何函数外部时为<code>内部链接</code></li>
</ul>
<p><strong>注意：</strong>用<code>extern</code>修饰的变量仍然可以同时初始化（但就没有了用<code>extern</code>的意义）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//等价于int i = 0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 链接？</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 链接？</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-5-register存储类型"><a href="#18-2-5-register存储类型" class="headerlink" title="18.2.5    register存储类型"></a>18.2.5    register存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>register</code><br><strong>用途：</strong>使变量存储在寄存器而不是内存中，提高访问和更新速度。<br><strong>寄存器：</strong>使驻留在计算机CPU中的存储单元。在传统计算机架构中，存储在寄存器中的数据会比存储在普通内存中的数据访问和更新速度更快。<br><strong>特点：</strong></p>
<ul>
<li>具有和<code>auto</code>型变量一样的俄存储期限、作用域和链接</li>
<li>对<code>register</code>型变量使用取地址运动符<code>&amp;</code>使非法的（因为寄存器没有地址）</li>
</ul>
<p><strong>注意：</strong>随着编译器变得更加复杂和高效，一些编译器可以自动决定变量保存在寄存器中还是内存中来达到最优性能。因此<code>register</code>的使用不再流行了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for语句的循环控制变量应用`register`是一个很好的选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-6-函数的存储类型"><a href="#18-2-6-函数的存储类型" class="headerlink" title="18.2.6    函数的存储类型"></a>18.2.6    函数的存储类型</h3><blockquote>
<p><strong>说明：</strong>函数只能用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<table>
<thead>
<tr>
<th>不修饰或<code>extern</code></th>
<th><code>static</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>静态存储期限</td>
</tr>
<tr>
<td>文件作用域</td>
<td>文件作用域</td>
</tr>
<tr>
<td><code>外部链接</code></td>
<td><code>内部链接</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong> 当声明不打算被其他文件调用的任意函数时，建议使用<code>static</code>修饰</p>
<ol>
<li><strong>更容易维护：</strong>稍后修改文件的人可以知道对被<code>static</code>修饰的函数的修改一般不会影响其他文件中的函数（即便该函数所在文件中其它函数将指向该函数的指针传递了出去，也可以在当前文件发现）</li>
<li><strong>减少“命名空间污染”：</strong>可以在其它文件中使用相同的名字命名函数而不会发生冲突<br><strong>注意：</strong>使用<code>extern</code>画蛇添足，不必使用但也无害。</li>
</ol>
<p><strong>扩展：</strong>函数行参的存储类型（只能用<code>register</code>修饰）</p>
</blockquote>
<table>
<thead>
<tr>
<th>默认（等同于块中的<code>auto</code>型变量）</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h2 id="18-3-类型限定符"><a href="#18-3-类型限定符" class="headerlink" title="18.3    类型限定符"></a>18.3    类型限定符</h2><table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const</code></td>
<td>声明只读类型（也称为常量）</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td><a href="">20.3节</a></td>
</tr>
</tbody>
</table>
<h3 id="const介绍"><a href="#const介绍" class="headerlink" title="const介绍"></a><code>const</code>介绍</h3><p><strong>用途：</strong>定义常量</p>
<blockquote>
<ol>
<li>提示阅读程序的人，对象的值不能改变</li>
<li>让编译器检查防止程序改变对象的值</li>
<li>可能的话（特别是嵌入式系统），编译器可以用让<code>const</code>修饰的变量存储到<code>ROM</code>(只读内存)中</li>
</ol>
</blockquote>
<p><code>只读（const）</code>和<code>宏（#define）</code>：如何恰当使用两者？</p>
<blockquote>
<p><strong>技巧：</strong>建议对表示数字（比如数组维数）或字符的常量使用<code>#define</code>;<code>const</code>常用于保护存储在数组中的常量数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>只读（const）</th>
<th>宏(#define)</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>数字常量、字符常量、字符串常量</td>
<td>任何类型（包括常量数组、常量指针、常量结构、常量联合）</td>
</tr>
<tr>
<td>作用域</td>
<td>遵守作用域规则</td>
<td>不遵守，不能产生具有块作用域的常量</td>
</tr>
<tr>
<td>能否在调试器观察</td>
<td>能</td>
<td>不能</td>
</tr>
<tr>
<td>能否用于常量表达式</td>
<td>不能，比如数组大小（常量表达式）不能用<code>const</code>定义的常量</td>
<td>能</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">// 使用错误，只读类型不能用于常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="18-4-声明符"><a href="#18-4-声明符" class="headerlink" title="18.4    声明符"></a>18.4    声明符</h2><h3 id="声明符组成"><a href="#声明符组成" class="headerlink" title="声明符组成"></a>声明符组成</h3><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>标识符</code></td>
<td>声明的变量或函数的名字</td>
<td>是</td>
</tr>
<tr>
<td><code>*</code></td>
<td>声明指针或对指针进行索引</td>
<td>否</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>声明数组</td>
<td>否</td>
</tr>
<tr>
<td><code>()</code></td>
<td>声明函数或提高优先级</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="简单的声明规则"><a href="#简单的声明规则" class="headerlink" title="简单的声明规则"></a>简单的声明规则</h3><table>
<thead>
<tr>
<th>符号(用于声明)</th>
<th>简单规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>用*开头的声明符表示指针</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>用[]结尾的声明符表示数组</td>
</tr>
<tr>
<td><code>()</code></td>
<td>用()结尾的声明符表示函数</td>
</tr>
</tbody>
</table>
<h3 id="不合法的声明符"><a href="#不合法的声明符" class="headerlink" title="不合法的声明符"></a>不合法的声明符</h3><blockquote>
<ol>
<li>函数不能返回数组</li>
<li>函数不能返回函数</li>
<li>数组不能是函数型的</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的情况：标识符就是声明符</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; <span class="comment">//extern int a[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">()</span></span>; <span class="comment">// 空括号形式使得编译器不检查函数调用的参数情况，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 明确告诉编译器没有参数，编译器会检查参数情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>; <span class="comment">// 允许在函数声明中忽略形式参数的名字</span></span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-解释复杂声明"><a href="#18-4-1-解释复杂声明" class="headerlink" title="18.4.1    解释复杂声明"></a>18.4.1    解释复杂声明</h3><blockquote>
<p><strong>规则：</strong>无论多么复杂的声明都可以被下面的两条规则解释</p>
<ol>
<li>从标识符开始，由内往外解读</li>
<li>当符号位于同一层级(一左一右)时，确定声明的是什么东西的优先级是：<code>[] &gt; () &gt; *</code>(数组 &gt; 函数 &gt; 指针)</li>
</ol>
<p><strong>技巧：</strong>作为上面规则的补充，符号<code>()</code>和<code>*</code>有存在歧义的时候，下面是甄别的依据</p>
<ol>
<li><code>()</code>：当位于声明符最右端时代表“函数”；否则是用来进行指针索引的，像这样：<code>(*其它部分)</code></li>
<li><code>*</code>：<code>(*其它部分)</code>代表指针索引，否则是定义函数的返回值类型为指针（如果是函数）或者是指针类型的定义。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则2，ap是数组（元素是int *型的指针）</span></span><br><span class="line"><span class="keyword">int</span> *ap[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，fp是函数（返回值类型为float *）</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> *<span class="title">fp</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过技巧1，(*pf)是函数，所以pf是指向函数的指针（函数的返回值为void）</span></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，(*x[10])是函数（返回值为int *, 参数为void），则x[10]为函数指针，所以x是存储函数指针的数组。</span></span><br><span class="line"><span class="keyword">int</span> *(*x[<span class="number">10</span>])(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-使用类型定义来简化声明"><a href="#18-4-2-使用类型定义来简化声明" class="headerlink" title="18.4.2    使用类型定义来简化声明"></a>18.4.2    使用类型定义来简化声明</h3><blockquote>
<p><strong>说明：</strong>利用一组类型定义拆分复杂的声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价：int *(*x[10])(void);</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">Fcn</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> Fcn *Fcn_ptr;</span><br><span class="line"><span class="keyword">typedef</span> Fcn_ptr Fcn_ptr_array[<span class="number">10</span>];</span><br><span class="line">Fcn_ptr_array x;</span><br></pre></td></tr></table></figure>
<h2 id="18-5-初始化式"><a href="#18-5-初始化式" class="headerlink" title="18.5    初始化式"></a>18.5    初始化式</h2><blockquote>
<p><strong>说明：</strong>可以在声明符的后边书写=, 后边再跟上初始化式（不同于赋值，赋值只要是合法的右值即可，而初始化式存在诸多限制）。<br><strong>变量的默认值（声明时不给初始化式）：</strong>变量的初始化值依赖于变量的存储期限</p>
<ul>
<li><em>自动存储期限</em>：没有默认的初始值，不能预测初始值</li>
<li><em>静态存储期限</em>：基于类型初始化为“零”（整型初始化为0，浮点数初始化为0.0，指针初始化为空指针）</li>
</ul>
<p><strong>技巧：</strong>推荐为静态类型的变量提供初始化式，便于阅读者确定变量的值，也便于查看初始化赋值的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单变量的初始化：一个变量，与变量类型一样的表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型不匹配，采用和赋值运算相同的规则进行自动类型转换（7.5节）</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量的初始化：必须是具有和变量相同类型或void *类型的指针表达式</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组、结构或联合的初始化式通常是遗传封闭在大括号内的值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="额外规则"><a href="#额外规则" class="headerlink" title="额外规则"></a>额外规则</h3><ul>
<li>具有静态存储期限的变量：初始化式必须是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 100</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = LAST - FIRST + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>具有自动存储期限的变量：初始化式不必要是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用大括号闭合的数组、结构或联合的初始化式必须只能包含常量表达式，不允许有变量或函数调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="keyword">int</span> powers[<span class="number">3</span>] = &#123;<span class="number">1</span>, N, N*N, N*N*N&#125;; <span class="comment">// N是常量，所以合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自动类型的结构或联合：初始化式可以是另外一个结构或联合</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">struct</span> <span class="keyword">complex</span> c1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">complex</span> c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/17 指针的高级应用/" itemprop="url">
                  17 指针的高级应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T19:38:12+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/17 指针的高级应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/17 指针的高级应用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-动态存储分配"><a href="#17-1-动态存储分配" class="headerlink" title="17.1    动态存储分配"></a>17.1    动态存储分配</h2><blockquote>
<p><strong>背景：</strong>c语言的数据结构通常是固定大小的，为了扩大数据结构的容量，必须修改程序并且再次编译。<br><strong>说明（行为）：</strong>在程序执行期间分配内存单元<br><strong>用途：</strong>可以根据需要设计可以扩大（和缩小）的数据结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>适用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>数组</td>
<td></td>
</tr>
<tr>
<td>结构</td>
<td>可以链接成表、树和其它数据结构</td>
</tr>
</tbody>
</table>
<h3 id="17-1-1-内存分配函数"><a href="#17-1-1-内存分配函数" class="headerlink" title="17.1.1    内存分配函数"></a>17.1.1    内存分配函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>库</th>
<th>备注</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>malloc</code></td>
<td>分配内存快，但是不对内存块进行初始化</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>最常用，不需要对分配的内存块进行清除，所以它比<code>calloc</code>更高效</td>
<td><code>void *</code>(通用指针，本质上只是内存地址)</td>
</tr>
<tr>
<td><code>calloc</code></td>
<td>分配内存块，并且对内存块进行清除</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
<td></td>
</tr>
<tr>
<td><code>realloc</code></td>
<td>调整先前分配的内存块</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
</tr>
</tbody>
</table>
<h3 id="17-1-2-空指针"><a href="#17-1-2-空指针" class="headerlink" title="17.1.2    空指针"></a>17.1.2    空指针</h3><p><strong>说明：</strong>“指向为空的指针”，这是一个区别于所有有效指针的特殊值。<code>Q&amp;A</code>用<code>NULL</code>（宏）来表示空指针。<br><strong>相关场景：</strong>当调用内存分配函数时，如果无法定位满足我们需要的足够大的内存块，函数会返回空指针（<code>null pointer</code>）。</p>
<p><strong>定义了<code>NULL</code>的库文件：</strong></p>
<ol>
<li><locale.h></locale.h></li>
<li><stddef.h></stddef.h></li>
<li><stdio.h></stdio.h></li>
<li><stdlib.h></stdlib.h></li>
<li><string.h></string.h></li>
<li><time.h></time.h></li>
</ol>
<blockquote>
<p><strong>真假：</strong>所有非空指针都为真，而只有空指针为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) ... </span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (!p) ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != NULL) ...</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (p) ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>更酷的方式</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = malloc(<span class="number">10000</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-2-动态分配字符串"><a href="#17-2-动态分配字符串" class="headerlink" title="17.2    动态分配字符串"></a>17.2    动态分配字符串</h2><h3 id="17-2-1-使用malloc函数为字符串分配内存"><a href="#17-2-1-使用malloc函数为字符串分配内存" class="headerlink" title="17.2.1    使用malloc函数为字符串分配内存"></a>17.2.1    使用malloc函数为字符串分配内存</h3><blockquote>
<p><strong>注意：</strong>为字符串分配内存空间时不要忘记包含空字符串的空间。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">char</span> *p = (char *) <span class="built_in">malloc</span>(n + <span class="number">1</span>);<span class="comment">// malloc返回的通用指针会自动转化为char*型变量，因此强制类型转换的部分可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="17-2-2-在字符串函数中使用动态存储分配"><a href="#17-2-2-在字符串函数中使用动态存储分配" class="headerlink" title="17.2.2    在字符串函数中使用动态存储分配"></a>17.2.2    在字符串函数中使用动态存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 拼接两个字符串并返回一个“新字符串”（不改变原有的两个字符串）</span><br><span class="line"> * @param  s1 要拼接的字符串的第一部分</span><br><span class="line"> * @param  s2 要拼接的字符串的第二部分</span><br><span class="line"> * @return    新字符串地址</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, concat(<span class="string">"abc"</span>, <span class="string">"def"</span>)); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义指向新字符串的临时指针变量</span></span><br><span class="line">	<span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新字符串分配空间</span></span><br><span class="line">	result = <span class="built_in">malloc</span>(strlen(s1) + strlen(s2) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存失败</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in concat \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一部分复制到新字符串的空间中（会有剩余）</span></span><br><span class="line">	<span class="built_in">strcpy</span>(result, s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二部分拼接到后面</span></span><br><span class="line">	<span class="built_in">strcat</span>(result, s2);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-3-动态分配字符串的数组"><a href="#17-2-3-动态分配字符串的数组" class="headerlink" title="17.2.3    动态分配字符串的数组"></a>17.2.3    动态分配字符串的数组</h3><blockquote>
<p><strong>说明：</strong>在数组中存储字符串有两种方式。二维字符数组或者字符串字面量指针数组，相比之下，前者可能会浪费空间。</p>
</blockquote>
<h3 id="17-2-4-程序：显示一个月的提示列表（改进版）"><a href="#17-2-4-程序：显示一个月的提示列表（改进版）" class="headerlink" title="17.2.4    程序：显示一个月的提示列表（改进版）"></a>17.2.4    程序：显示一个月的提示列表（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> *reminders[MAX_REMIND];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			reminders[j], reminders[j<span class="number">-1</span>];</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line">		reminders[i] = <span class="built_in">malloc</span>(<span class="number">2</span> + strlen(msg_str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (reminders[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-动态分配数组"><a href="#17-3-动态分配数组" class="headerlink" title="17.3    动态分配数组"></a>17.3    动态分配数组</h2><blockquote>
<p><strong>原理：</strong>在程序执行期间为数组分配空间，然后通过指向数组第一个元素的指针访问数组。由于c语言中数组和指针的紧密关系，指向动态分配的内存块的指针可以当作数组的名字使用。<br><strong>注意：</strong>计算数组所需的空间要使用sizeof运算符，如果分配空间不足，稍后网数组中存储时程序会出现异常。</p>
</blockquote>
<h3 id="17-3-1-使用malloc函数为数组分配存储空间"><a href="#17-3-1-使用malloc函数为数组分配存储空间" class="headerlink" title="17.3.1    使用malloc函数为数组分配存储空间"></a>17.3.1    使用malloc函数为数组分配存储空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个含n个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">a = <span class="built_in">malloc</span>(n * sizeof(int)); <span class="comment">// 计算数组所需的空间要使用sizeof运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作数组使用</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-3-2-calloc函数"><a href="#17-3-2-calloc函数" class="headerlink" title="17.3.2    calloc函数"></a>17.3.2    calloc函数</h3><blockquote>
<p><strong>函数原型（<code>stdlib.h</code>）：</strong>如果要求的空间无效，那么此函数返回空指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 分配内存空间并初始化</span><br><span class="line">* @param &#123;size_t&#125; numeb 数组的长度</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 数组第一个元素的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmeb, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当第一个参数为1时，可以为任何类型的数据项（不仅仅是数组）分配空间</li>
<li>calloc函数会清除分配的空间中的数据</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为n的int型数组，并将所有项初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(n, sizeof(int));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向结构体的指针</span></span><br><span class="line"><span class="keyword">struct</span> point &#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125; *p;</span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1</span>, sizeof(struct point)); <span class="comment">//p将指向新创建的结构体，且结构体的成员x、y都为0</span></span><br></pre></td></tr></table></figure>
<h3 id="17-3-3-realloc函数"><a href="#17-3-3-realloc函数" class="headerlink" title="17.3.3    realloc函数"></a>17.3.3    realloc函数</h3><blockquote>
<p><strong>原型(<code>stdlib.h</code>)：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 调整分配的内存的大小</span><br><span class="line">* @param &#123;void *&#125; ptr 指向内存块（通常是数组）的指针</span><br><span class="line">* @param &#123;size_t&#125; size 内存块的新尺寸</span><br><span class="line">* @return &#123;void *&#125; 新的内存块的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用途：</strong>一旦为数组分配完内存，稍后可能会返现数组过大或过小。relloc函数可以调整数组的大小以使它更适合需要。<br><strong>局限：</strong>要确定传递给<code>realloc函数</code>的指针来自于先前<code>malloc函数</code>、<code>calloc函数</code>或<code>realloc函数</code>的调用获得的。否则程序会出现异常。<br><strong>规则：</strong></p>
<ul>
<li>如果无法扩大内存（后边内存被占用），会在别处分配新的内存，然后把旧块中的内容复制过去</li>
<li>当扩展内存块时，    <code>realloc函数</code>不会对添加进内存块的字节进行初始化</li>
<li>如果<code>realloc函数</code>不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。</li>
<li>如果<code>realloc函数</code>调用时以空指针作为第一个实际参数，那么它的行为就将像<code>malloc函数</code>一样</li>
<li>如果<code>realloc函数</code>调用时以0作为第二个实际参数，那么它会释放掉内存块    </li>
</ul>
<p><strong>注意：</strong>一旦<code>realloc函数</code>返回，一定要对指向内存块的所有指针进行更新（将新的地址赋值给指针），因为可能realloc函数移动到了其地方的内存块。</p>
</blockquote>
<h2 id="17-4-释放存储"><a href="#17-4-释放存储" class="headerlink" title="17.4    释放存储"></a>17.4    释放存储</h2><blockquote>
<p><strong>堆（heap）：</strong><code>malloc函数</code>和其他内存分配函数所获得的内存块都来自一个称为堆的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也会耗尽堆，这会导致函数返回空指针。<br><strong>垃圾（garbage）：</strong>对程序而言不再访问到的内存块被称为垃圾。<br><strong>内存泄漏（memroy leak）：</strong>运行中留有垃圾被称为内存泄漏。<br><strong>垃圾收集器（garbage collector）：</strong>用于垃圾的自动定位和回收，但c语言不提供。相反，每个c程序负责回收各自的垃圾（调用<code>free函数</code>）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟内存泄漏*/</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...)</span><br><span class="line">q = <span class="built_in">malloc</span>(...)</span><br><span class="line">p = q; <span class="comment">// p原本指向的内存块变成垃圾</span></span><br></pre></td></tr></table></figure>
<h3 id="17-4-1-free函数"><a href="#17-4-1-free函数" class="headerlink" title="17.4.1    free函数"></a>17.4.1    free函数</h3><blockquote>
<p><strong>用途：</strong>调用<code>free函数</code>将内存块释放返回堆。<br><strong>原型：</strong><code>stdlib.h</code><br><strong>限制：</strong><code>free函数</code>的世纪参数必须是指针，而且一定是先前<code>内存分配函数</code>返回的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 释放内存</span><br><span class="line">* @param &#123;void *&#125; ptr 指向需要释放的内存块的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-4-2-“悬空指针”问题"><a href="#17-4-2-“悬空指针”问题" class="headerlink" title="17.4.2    “悬空指针”问题"></a>17.4.2    “悬空指针”问题</h3><blockquote>
<p><strong>悬空指针（dangling pointer）：</strong>指向被<code>free</code>掉的内存块的指针。<br><strong>注意：</strong>悬空指针很难被发现，而且试图通过“悬空指针”修改被释放掉的内存块会导致程序异常。</p>
</blockquote>
<h2 id="17-5-链表"><a href="#17-5-链表" class="headerlink" title="17.5    链表"></a>17.5    链表</h2><blockquote>
<p><strong>链表（linked list）：</strong>时由一连串的结构（节点）组成的，其中每个节点都包含指向下一个链中节点的指针。<br><strong>优点：</strong>更灵活，方便扩大和缩小（插入和删除）。<br><strong>缺点：</strong>没有“随机访问”的能力</p>
</blockquote>
<h3 id="17-5-1-声明节点类型"><a href="#17-5-1-声明节点类型" class="headerlink" title="17.5.1    声明节点类型"></a>17.5.1    声明节点类型</h3><blockquote>
<p><strong>注意：</strong>结点类型只能使用标记而不能使用<code>typedef</code>定义结构，因为后者无法在节点内声明指向另一个结点的成员。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的单个节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node *first = <span class="literal">NULL</span>; <span class="comment">//链表初始为空</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-2-创建节点"><a href="#17-5-2-创建节点" class="headerlink" title="17.5.2    创建节点"></a>17.5.2    创建节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点分配内存</span></span><br><span class="line">new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点初始化值</span></span><br><span class="line">(*new_node).value = <span class="number">0</span>; <span class="comment">// .的优先级高于间接寻址运算符*，所以使用()提升后者优先级</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-3-gt-运算符"><a href="#17-5-3-gt-运算符" class="headerlink" title="17.5.3    -&gt;运算符"></a>17.5.3    -&gt;运算符</h3><blockquote>
<p><strong>右箭头选择（right arrow selection）：</strong>通过指针访问结构中的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;value); <span class="comment">//scanf("%d", &amp;(*new_node).value)</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-4-在链表的开始处插入节点"><a href="#17-5-4-在链表的开始处插入节点" class="headerlink" title="17.5.4    在链表的开始处插入节点"></a>17.5.4    在链表的开始处插入节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>为节点分配内存单元</li>
<li>把数据存储在节点中</li>
<li>把节点插入到链表中</li>
</ol>
<p><strong>伏笔：</strong>在17.6节中对<code>add_to_list</code>有进一步优化。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FALURE 0</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 节点</span><br><span class="line"> * @struct</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加节点到链表头部</span><br><span class="line"> * 需要注意的是，该函数执行后还需要将头部指向该函数返回的新的节点才能完成插入到链表头部的工作</span><br><span class="line"> * @param  list 要插入的链表（指向头部节点的指针）</span><br><span class="line"> * @param  n    要插入的节点存储的值</span><br><span class="line"> * @return      新的链表（指向新的头节点的指针）</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明新节点</span></span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配内存</span></span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_ro list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FALURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	new_node-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	return new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行完成链表的创建</span><br><span class="line"> * @return  链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">read_numbers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *first = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a series of intergers (0 to terminate):\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			return first;</span><br><span class="line">		&#125;</span><br><span class="line">		first = add_to_list(first, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个含有用户录入的数字的链表</span></span><br><span class="line">	<span class="keyword">struct</span> node *num_list;</span><br><span class="line">	num_list = read_numbers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-5-搜索链表"><a href="#17-5-5-搜索链表" class="headerlink" title="17.5.5    搜索链表"></a>17.5.5    搜索链表</h3><blockquote>
<p><strong>惯用法：</strong><code>for (p = first; p != NULL; p = p-&gt;next)</code><br><em>形式一：惯用法</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;value == n) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式二：省略中间变量</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span>; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;value == n) &#123;</span><br><span class="line">			return <span class="built_in">list</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式三：链表到末尾和找到目标判定合并</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式四：使用while</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	wile (<span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-6-从链表中删除节点"><a href="#17-5-6-从链表中删除节点" class="headerlink" title="17.5.6    从链表中删除节点"></a>17.5.6    从链表中删除节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定位要删除的节点</li>
<li>改变前一个节点，从而使它“绕过”删除节点</li>
<li>调用<code>free函数</code>从而收回删除节点占用的内存空间</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据节点的值找到节点并删除之</span><br><span class="line">* @param &#123;struct node*&#125; list 所在的链表</span><br><span class="line">* @param &#123;int&#125; n 要删除的节点存储的值</span><br><span class="line">* @return &#123;struct node*&#125; 链表的头节点</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">delete_from_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *cur, *prev;</span><br><span class="line">	<span class="comment">// 定位要删除的节点</span></span><br><span class="line">	<span class="keyword">for</span> (cur = <span class="built_in">list</span>, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;value != n; prev = cur, cur = cur-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	<span class="comment">// 没有找到要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了，要删除的节点是第一个节点</span></span><br><span class="line">	<span class="keyword">if</span> (prev == NUL) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了， 要删除的节点不是第一个几点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		prev-&gt;next = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cur);</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-8-程序：维护零件数据库（改进版）"><a href="#17-5-8-程序：维护零件数据库（改进版）" class="headerlink" title="17.5.8    程序：维护零件数据库（改进版）"></a>17.5.8    程序：维护零件数据库（改进版）</h3><blockquote>
<p><strong>说明：</strong>使用链表代替数组有两个主要的好处</p>
<ol>
<li>不需要事先限制数据库的大小，数据库可以扩大到没有更多内存空间存储零件为止</li>
<li>可以很容易保持用零件编号排序的数据库，当往数据库中添加新零件时，只是简单把它插入链表中的适当位置就可以了</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ tree -L 2</span><br><span class="line"> .</span><br><span class="line"> ├── invent2</span><br><span class="line"> ├── invent2.c</span><br><span class="line"> ├── invent2.o</span><br><span class="line"> ├── makefile</span><br><span class="line"> ├── readline.c</span><br><span class="line"> ├── readline.h</span><br><span class="line"> └── readline.o   └── readline.o</span><br></pre></td></tr></table></figure>
<h4 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invent2-c"><a href="#invent2-c" class="headerlink" title="invent2.c"></a>invent2.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (linked list version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * 定义零件</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number; <span class="comment">// 编号</span></span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>]; <span class="comment">// 名字长度</span></span><br><span class="line"> 	<span class="keyword">int</span> on_hand; <span class="comment">// 当前库存</span></span><br><span class="line"> 	<span class="keyword">struct</span> part *next; <span class="comment">// 指向下一个零件</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表（头节点）</span></span><br><span class="line"> <span class="keyword">struct</span> part *inventory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"> 		<span class="comment">// 跳过换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>: insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>: search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>: update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>: print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>: return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索零件</span><br><span class="line"> * @param  number 零件包含的值</span><br><span class="line"> * @return        对应零件节点的地址（没找到返回NULL）</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span> &amp;&amp; number &gt; p-&gt;number; p = p -&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; number == p-&gt;number) &#123;</span><br><span class="line"> 		return p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入一种零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *cur, *prev, *new_node;</span><br><span class="line"> 	<span class="comment">// 为新节点分配空间</span></span><br><span class="line"> 	new_node = <span class="built_in">malloc</span>(sizeof(struct part));</span><br><span class="line"> 	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Database is full; can't add more parts.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 零件编号</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;number);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 根据编号寻找插入位置(按从小到大的顺序排列)</span></span><br><span class="line"> 	<span class="keyword">for</span> (cur = inventory, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number &gt; cur-&gt;number; prev = cur, cur = cur-&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 发现编号相同的节点</span></span><br><span class="line"> 	<span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number == cur-&gt;number) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exits.\n"</span>);</span><br><span class="line"> 		<span class="built_in">free</span>(new_node);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name:"</span>);</span><br><span class="line"> 	read_line(new_node-&gt;name, NAME_LEN);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件数量</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;on_hand);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 插入进去</span></span><br><span class="line"> 	new_node-&gt;next = cur;</span><br><span class="line"> 	<span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		inventory = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		prev-&gt;next = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 以交互的方式根据编号搜索并显示目标零件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">struct</span> part *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">	p = find_part(number);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p-&gt;name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, p-&gt;on_hand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 修改零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> number, change;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	p = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		p-&gt;on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印所有零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part number    Part Name   Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d      %-25s%11d\n"</span>, p-&gt;number, p-&gt;name, p-&gt;on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-6-指向指针的指针"><a href="#17-6-指向指针的指针" class="headerlink" title="17.6    指向指针的指针"></a>17.6    指向指针的指针</h2><blockquote>
<p><strong>说明：</strong>对17.5.4中的<code>add_to_list</code>进行优化，优化后插入链表的功能将完全由该函数提供。<br><strong>原理：</strong>通过指针的指针的副本，达到修改指针指向的目的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 向链表中插入节点</span><br><span class="line">* @param &#123;struct node **&#125; node 指向链表的头节点的指针的指针</span><br><span class="line">* @param &#123;int&#125; n 节点存储的值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node **<span class="built_in">list</span>,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_to_list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURES);</span><br><span class="line">	&#125;</span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	<span class="comment">// 新节点的下一个节点指向链表头节点</span></span><br><span class="line">	new_node-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原本指向头节点的指针指向新节点</span></span><br><span class="line">	<span class="comment">// 详解：list的值是first这个指针本身的地址，通过*list便可以访问到first这个指针</span></span><br><span class="line">	*<span class="built_in">list</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">add_to_list(&amp;first, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="17-7-指向函数的指针"><a href="#17-7-指向函数的指针" class="headerlink" title="17.7    指向函数的指针"></a>17.7    指向函数的指针</h2><blockquote>
<p><strong>说明：</strong>毕竟函数占用内存单元，所以每个函数都有地址，就像每个变量都有地址一样。</p>
</blockquote>
<h3 id="17-7-1-函数指针作为实际参数"><a href="#17-7-1-函数指针作为实际参数" class="headerlink" title="17.7.1    函数指针作为实际参数"></a>17.7.1    函数指针作为实际参数</h3><blockquote>
<p><strong>声明：</strong>声明为指向函数的指针有两种方式，从编译器的角度看是完全一样的。</p>
<blockquote>
<p>方式一：<strong>返回值 函数名(<code>返回值 (*函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double (*f)(double), double a, double b)  &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x); // 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式二：<strong>返回值 函数名(<code>返回值 (函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double f(double), double a, double b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x);// 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-7-2-qsort函数"><a href="#17-7-2-qsort函数" class="headerlink" title="17.7.2    qsort函数"></a>17.7.2    qsort函数</h3><blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 为数组排序</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;int (*)&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size,  int (*compar) (const void *, const void *));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较函数（提供给qsort函数排序规则）</span><br><span class="line"> * @param &#123;void *&#125; p 第一个零件</span><br><span class="line"> * @param &#123;void *&#125; q 第二个零件</span><br><span class="line"> * @return   正数（1）：*p &gt; *q;负数（-1）：*p &lt; *q;零（0）：*p = *q</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_parts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">const</span> <span class="keyword">void</span> *q)</span> </span>&#123;</span><br><span class="line">	return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比较函数进行排序</span></span><br><span class="line">qsort(inventory, num_parts, <span class="keyword">sizeof</span>(struct part), compare_parts);</span><br></pre></td></tr></table></figure>
<h3 id="17-7-3-函数指针的其他用途"><a href="#17-7-3-函数指针的其他用途" class="headerlink" title="17.7.3    函数指针的其他用途"></a>17.7.3    函数指针的其他用途</h3><blockquote>
<p><strong>说明：</strong>c语言对待指向函数的指针就像对待指向数据的指针一样。我们可以把函数存储在变量中，或者用做数组的元素，再或者用做结构或联合的成员，甚至可以编写返回函数指针的函数，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*存储函数的变量*/</span></span><br><span class="line"><span class="keyword">void</span> (*pf) (<span class="keyword">int</span>); <span class="comment">//声明一个可以存储指向函数的指针的变量（pf可以指向任何带有int型实际参数，且返回值为void的函数）</span></span><br><span class="line"></span><br><span class="line">pf = f; <span class="comment">// 指向函数f</span></span><br><span class="line"></span><br><span class="line">(*pf)(i); <span class="comment">// pf(i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储函数的数组*/</span></span><br><span class="line"><span class="keyword">void</span> (*file_cmd[])(<span class="keyword">void</span>) = &#123;</span><br><span class="line">	new_cmd,</span><br><span class="line">	open_cmd,</span><br><span class="line">	close_cmd,</span><br><span class="line">	close_all_cmd,</span><br><span class="line">	save_cmd,</span><br><span class="line">	ext_cmd</span><br><span class="line">&#125;;</span><br><span class="line">(*file_cmd[n])(); <span class="comment">// 或者file_cmd[n]();</span></span><br></pre></td></tr></table></figure>
<h3 id="17-7-4-程序：列三角函数表"><a href="#17-7-4-程序：列三角函数表" class="headerlink" title="17.7.4    程序：列三角函数表"></a>17.7.4    程序：列三角函数表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tabulates values of trigonometric functions</span><br><span class="line"> */</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)double, double first, double last, double incr);</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">	double final, increament, initial;</span><br><span class="line">	printf("Enter initial value: ");</span><br><span class="line">	scanf("%lf", &amp;initial);</span><br><span class="line"></span><br><span class="line">	printf("Enter final value:");</span><br><span class="line">	scanf("%lf", &amp;final);</span><br><span class="line"></span><br><span class="line">	printf("Enter increament:");</span><br><span class="line">	scanf("%lf", &amp;increament);</span><br><span class="line"></span><br><span class="line">	printf("\n     x     cos(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(cos, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     sin(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(sin, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     tan(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(tan, initial, final, increament);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)(double), double first, double last, double incr) &#123;</span><br><span class="line">	double x;</span><br><span class="line">	int i, num_intervals;</span><br><span class="line">	num_intervals = cell((last - first) / incr);</span><br><span class="line">	for (i = 0; i &lt;= num_intervals; i++) &#123;</span><br><span class="line">		x = first + i * incr;</span><br><span class="line">		printf("%10.5f %10.5f\n", x, (*f)[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/16 结构、联合和枚举/" itemprop="url">
                  16 结构、联合和枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:49:46+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/16 结构、联合和枚举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/16 结构、联合和枚举/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="16-1-结构变量"><a href="#16-1-结构变量" class="headerlink" title="16.1    结构变量"></a>16.1    结构变量</h2><blockquote>
<p><strong>结构：</strong>结构的特性与数组很不相同。</p>
<ul>
<li>结构的元素（成员）可能具有不同的类型</li>
<li>每个结构成员都有名字</li>
<li>为了选择特殊的结构成员需要知名结构成员的名字而不是它的位置</li>
</ul>
<p><strong>扩展：</strong>大多数语言都提供类似的特性，所以结构可能听起来很舒需。再其它语言中，经常把结构称为纪录（record），把结构的成员称为字段（field）。</p>
</blockquote>
<h3 id="16-1-1-结构变量的声明"><a href="#16-1-1-结构变量的声明" class="headerlink" title="16.1.1    结构变量的声明"></a>16.1.1    结构变量的声明</h3><p><strong>语法：</strong>只声明不初始化（会非配内存但成员不会初始化）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span>, 实例变量<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong>结构实例化的变量具备以下特点</p>
<ul>
<li>成员在内存中是按照顺序存储的</li>
<li>内部成员拥有单独的名字空间（name space）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//零件</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//零件编号</span></span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//零件名称</span></span><br><span class="line">	<span class="keyword">int</span> on_hand;<span class="comment">//零件现有数量</span></span><br><span class="line">&#125;part1, part2;<span class="comment">//同时用这种结构实例化了两个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//工号</span></span><br><span class="line">	<span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line">&#125;employee1, employee2;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-2-结构变量的初始化"><a href="#16-1-2-结构变量的初始化" class="headerlink" title="16.1.2    结构变量的初始化"></a>16.1.2    结构变量的初始化</h3><blockquote>
<p><strong>语法：</strong>声明的同时初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">    成员<span class="number">2</span>类型 成员<span class="number">2</span>名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;,   </span><br><span class="line">  实例变量<span class="number">2</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;, </span><br><span class="line">  ...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则：</strong>类似数组</p>
<ol>
<li>用于结构初始化式的表达式必须是常量</li>
<li>初始化式可以短于它所初始化的结构，任何剩余的成员都用0作为它的初始值</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> on, hand;</span><br><span class="line">&#125;part1 = &#123;<span class="number">528</span>, <span class="string">"Disk drive"</span>, <span class="number">10</span>&#125;,</span><br><span class="line"> part2 = &#123;<span class="number">914</span>, <span class="string">"Printer cable"</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-3-对结构的操作"><a href="#16-1-3-对结构的操作" class="headerlink" title="16.1.3    对结构的操作"></a>16.1.3    对结构的操作</h3><blockquote>
<p><strong>限制：</strong>不能用<code>==</code>或<code>!=</code>判定两个结构是否相等或不等。</p>
</blockquote>
<h4 id="16-1-3-1-访问成员"><a href="#16-1-3-1-访问成员" class="headerlink" title="16.1.3.1    访问成员"></a>16.1.3.1    访问成员</h4><blockquote>
<p><strong>左值：</strong>结构成员的值是左值</p>
<ul>
<li>可以出现在赋值运算的左侧</li>
<li>作为自增或自减表达式的操作数</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Part number %d:"</span>, part1.number);</span><br><span class="line">part1.number = <span class="number">228</span>;<span class="comment">//可以出现在赋值运算的左侧</span></span><br><span class="line">part1.on_hand++;<span class="comment">//作为自增或自减表达式的操作数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>逗号运算符：</strong><code>结构变量.成员名</code></p>
<ul>
<li>优先级和后缀++和后缀–相同（几乎高于所有其他运算符）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part1.on_hand);<span class="comment">//.运算符优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-2-赋值运算"><a href="#16-1-3-2-赋值运算" class="headerlink" title="16.1.3.2    赋值运算"></a>16.1.3.2    赋值运算</h4><blockquote>
<p><strong>说明：</strong>数组不能用=运算符实现变量间数组内容的复制，但结构变量可以。<br><strong>注意：</strong>只能用于同一个结构类型声明的的变量之间。<br><strong>技巧：</strong>把需要复制的数组嵌在结构体内（作为成员）进行复制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;a1, a2;</span><br><span class="line"></span><br><span class="line">a1 = a2;<span class="comment">//a1的存储空间中数据和a2相同，实现了复制</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-结构类型"><a href="#16-2-结构类型" class="headerlink" title="16.2    结构类型"></a>16.2    结构类型</h2><blockquote>
<p><strong>说明：</strong>上一小结重点放在结构变量而不是结构类型本身上，这一节将重点观察结构类型。<br><strong>命名结构类型：</strong>如果需要在程序的不同位置声明结构变量，上一节的“匿名结构”就行不通了。c语言提供了两种命名结构的方法</p>
<ol>
<li>声明“结构标记”(结构用语链表时，只能声明“结构标记”)</li>
<li>使用<code>typedef</code>定义类型名</li>
</ol>
</blockquote>
<h3 id="16-2-1-结构标记的声明"><a href="#16-2-1-结构标记的声明" class="headerlink" title="16.2.1    结构标记的声明"></a>16.2.1    结构标记的声明</h3><blockquote>
<p><strong>结构标记(structure tag)：</strong>结构标记用于标记某种特定结构类型的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  结构类型名&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125;[结构变量<span class="number">1</span>, ...];<span class="comment">//分号表示声明的结束，不能省略</span></span><br><span class="line"><span class="keyword">struct</span> 结构类型名 结构变量<span class="number">2</span>, ...;<span class="comment">//struct关键字不能省略，因为结构类型名不是有效的c语言类型名(原生的和typedef定义的才是)。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不仅声明了标记part，而且声明了变量</span></span><br><span class="line"><span class="keyword">struct</span> part&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> part  part1 = &#123;<span class="number">528</span>, <span class="string">"disk drive"</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> part part2;</span><br><span class="line">part2 = part1;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-2-结构类型的定义"><a href="#16-2-2-结构类型的定义" class="headerlink" title="16.2.2    结构类型的定义"></a>16.2.2    结构类型的定义</h3><blockquote>
<p><strong>说明：</strong>用typedef来定义真正的类型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125; 结构类型名;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; Part;<span class="comment">//类型名的名字必须出现在定义的末尾，而不是在单词struct的后边</span></span><br><span class="line">Part part1, part2;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-3-结构类型的实际参数和返回值"><a href="#16-2-3-结构类型的实际参数和返回值" class="headerlink" title="16.2.3    结构类型的实际参数和返回值"></a>16.2.3    结构类型的实际参数和返回值</h3><blockquote>
<p><strong>缺点：</strong>带来一定系统开销，尤其是结构题很大的时候</p>
<blockquote>
<p>给函数传递结构和从函数返回结构都要求使用结构中所有成员的副本。</p>
</blockquote>
<p><strong>技巧：</strong>有时用指向结构的指针来代替传递给函数（或函数返回）的结构本身是很明智的做法。</p>
</blockquote>
<h4 id="16-2-3-1-用作参数"><a href="#16-2-3-1-用作参数" class="headerlink" title="16.2.3.1    用作参数"></a>16.2.3.1    用作参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_part</span> <span class="params">(<span class="keyword">struct</span> part p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"part number: %d\n"</span>, p.number);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Quality on hand: %d \n"</span>, p.on_hand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line">print_part(part1);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-2-用作返回值"><a href="#16-2-3-2-用作返回值" class="headerlink" title="16.2.3.2    用作返回值"></a>16.2.3.2    用作返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> part <span class="title">build_part</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> on_hand)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> part p;</span><br><span class="line">	p.number = number;</span><br><span class="line">	<span class="built_in">strcpy</span>(p.name, name);</span><br><span class="line">	p.on_hand = on_hand;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-3-数组和结构的嵌套"><a href="#16-3-数组和结构的嵌套" class="headerlink" title="16.3    数组和结构的嵌套"></a>16.3    数组和结构的嵌套</h2><h3 id="16-3-1-嵌套的结构"><a href="#16-3-1-嵌套的结构" class="headerlink" title="16.3.1    嵌套的结构"></a>16.3.1    嵌套的结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义姓名</span></span><br><span class="line"><span class="keyword">struct</span> person_name &#123;</span><br><span class="line">	<span class="keyword">char</span> first[FIRST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> middle_initial;</span><br><span class="line">	<span class="keyword">char</span> last[LAST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">struct</span> student &#123;</span><br><span class="line">	<span class="keyword">struct</span> person_name name; <span class="comment">// 结构的成员可以是另一种结构体</span></span><br><span class="line">	int_id, age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; student1, student2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">"Fred"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-结构数组"><a href="#16-3-2-结构数组" class="headerlink" title="16.3.2    结构数组"></a>16.3.2    结构数组</h3><blockquote>
<p><strong>说明：</strong>结构可以作为数组的元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="comment">// 声明结构数组</span></span><br><span class="line"><span class="keyword">struct</span> part inventory[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问*/</span></span><br><span class="line"><span class="comment">// 访问结构数组中的结构</span></span><br><span class="line">print_part(inventory[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*操作*/</span></span><br><span class="line"><span class="comment">// 为数组中的结构的成员赋值</span></span><br><span class="line">inventory[i].number = <span class="number">883</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组中的结构的成员（字符串）置空</span></span><br><span class="line"> inventory[i].name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-3-结构数组的初始化"><a href="#16-3-3-结构数组的初始化" class="headerlink" title="16.3.3    结构数组的初始化"></a>16.3.3    结构数组的初始化</h3><blockquote>
<p><strong>语法：</strong>类似二维数组的初始化，每个结构都拥有自己的大括号。<br><strong>注意：</strong>每个结构值的内层大括号是可选项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构：国家代码</span></span><br><span class="line"><span class="keyword">struct</span> dialog_code &#123;</span><br><span class="line">	<span class="keyword">char</span> *country;</span><br><span class="line">	<span class="keyword">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> dialog_code country_codes[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Argentina"</span>, <span class="number">54</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Bangladesh"</span>, <span class="number">66</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-4-程序：维护零件数据库"><a href="#16-3-4-程序：维护零件数据库" class="headerlink" title="16.3.4    程序：维护零件数据库"></a>16.3.4    程序：维护零件数据库</h3><h4 id="16-3-4-1-编写"><a href="#16-3-4-1-编写" class="headerlink" title="16.3.4.1    编写"></a>16.3.4.1    编写</h4><h5 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invent-c"><a href="#invent-c" class="headerlink" title="invent.c"></a>invent.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (array version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line"> 	<span class="keyword">int</span> on_hand;</span><br><span class="line"> &#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> num_parts = <span class="number">0</span>; <span class="comment">// 当前零件的数量</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待用户操作</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 跳过所有的换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line"> 				insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line"> 				search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line"> 				update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line"> 				print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line"> 				return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 				<span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 按照零件的编号查找零件在清单数组中的下标</span><br><span class="line"> * @param  number 零件的编号</span><br><span class="line"> * @return        零件在清单中的下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (inventory[i].number == number) &#123;</span><br><span class="line"> 			return i;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行插入零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 输入零件号</span></span><br><span class="line"> 	<span class="keyword">int</span> part_number;</span><br><span class="line"> 	<span class="keyword">if</span> (num_parts == MAX_PARTS) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Datebase is full, can't add more parts .\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter partnumber: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part_number);</span><br><span class="line"> 	<span class="keyword">if</span> (find_part(part_number) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exists.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	inventory[num_parts].number = part_number;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 输入零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name: "</span>);</span><br><span class="line"> 	read_line(inventory[num_parts].name, NAME_LEN);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inventory[num_parts].on_hand);</span><br><span class="line"> 	num_parts++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 在命令行根据零件编号搜索零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, inventory[i].name);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新清单中某种零件的数量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number, change;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number : "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand: "</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		inventory[i].on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印当前零件清单中所有种类零件的信息</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part Number   Part Name             "</span></span><br><span class="line"> 		   <span class="string">"Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d     %-25s%11d\n"</span>, inventory[i].number, inventory[i].name, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-3-4-2-编译"><a href="#16-3-4-2-编译" class="headerlink" title="16.3.4.2    编译"></a>16.3.4.2    编译</h4><p>$ vim makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invent:invent.o readline.o</span><br><span class="line">	gcc -o invent invent.o readline.o</span><br><span class="line">invent.o:invent.c readline.h</span><br><span class="line">	gcc -c invent.c</span><br><span class="line">readline.o:readline.c readline.h</span><br><span class="line">	gcc -c readline.c</span><br></pre></td></tr></table></figure>
<p>$ make</p>
<h4 id="16-3-4-3-运行"><a href="#16-3-4-3-运行" class="headerlink" title="16.3.4.3    运行"></a>16.3.4.3    运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./invent </span><br><span class="line"> Enter operation code:i</span><br><span class="line"> Enter partnumber: 01</span><br><span class="line"> Enter part name: screen</span><br><span class="line"> Enter quantity on hand: 1 </span><br><span class="line"></span><br><span class="line"> Enter operation code:p</span><br><span class="line"> Part Number   Part Name             Quantity on hand</span><br><span class="line">       1     screen</span><br></pre></td></tr></table></figure>
<h2 id="16-4-联合"><a href="#16-4-联合" class="headerlink" title="16.4    联合"></a>16.4    联合</h2><h3 id="特点（和结构相比）"><a href="#特点（和结构相比）" class="headerlink" title="特点（和结构相比）"></a>特点（和结构相比）</h3><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>包含一个或多个成员</li>
<li>成员可以是不同的类型</li>
<li>声明标记和类型的方式</li>
<li>访问成员的方式</li>
<li>可以使用<code>=</code>进行复制操作</li>
<li>可以在函数间传递或作为函数的返回值</li>
<li>初始化方式</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>联合的实例所有成员共享相同的存储空间</li>
<li>联合的实例大小由最大的成员的类型决定</li>
<li>联合初始化实例时初始化的是按照第一个成员的类型来初始化值的</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; u = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0会按照i的类型初始化存储空间</span></span><br><span class="line"></span><br><span class="line">u.f = <span class="number">78.4</span>; <span class="comment">// 为联合赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="16-4-1-使用联合来节省空间"><a href="#16-4-1-使用联合来节省空间" class="headerlink" title="16.4.1    使用联合来节省空间"></a>16.4.1    使用联合来节省空间</h3><blockquote>
<p><strong>原理：</strong>在<code>struct</code>中使用<code>union</code>作为成员，后者使用<code>struct</code>作为成员。这种混合的结构可以实现一种数据结构应用于多种情境的效果。<br><strong>扩展：</strong>在<code>c++</code>中，<code>struct</code>中的<code>union</code>可以匿名，在<code>c</code>中则不得不指定<code>union</code>的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_LEN 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTHOR_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESIGN_LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 礼品册上的商品</span><br><span class="line"> * 可以存储3种类型的商品：书籍、杯子、衬衫</span><br><span class="line"> *</span><br><span class="line"> * @type &#123;struct&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> catalog_item &#123;</span><br><span class="line">	<span class="keyword">int</span> stock_number; <span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">int</span> item_type; <span class="comment">// 分类</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 可能是书</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> title[TITLE_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">char</span> author[AUTHOR_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> num_pages;</span><br><span class="line">		&#125; book;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是杯子</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">		&#125; mug;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是衬衫</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> colors;</span><br><span class="line">			<span class="keyword">int</span> sizes;</span><br><span class="line">	 	&#125; shirt;</span><br><span class="line">	&#125; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构体实例</span></span><br><span class="line">	<span class="keyword">struct</span> catalog_item bookItem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为结构体中的联合的成员赋值</span></span><br><span class="line">	<span class="built_in">strcpy</span>(bookItem.item.book.title, <span class="string">"three body"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问结构题中的联合的成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, bookItem.item.book.title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-2-使用联合来构造混合的数据结构"><a href="#16-4-2-使用联合来构造混合的数据结构" class="headerlink" title="16.4.2    使用联合来构造混合的数据结构"></a>16.4.2    使用联合来构造混合的数据结构</h3><blockquote>
<p><strong>说明：</strong>创建含有不同数据类型的混合数据结构（比如数组）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 混合数据类型，包含整型和浮点型</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;union&#125; Number</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明混合型数组</span></span><br><span class="line">	Number number_array[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	number_array[<span class="number">0</span>].i = <span class="number">5</span>; <span class="comment">// 第一个值为整型</span></span><br><span class="line">	number_array[<span class="number">1</span>].f = <span class="number">3.14</span>; <span class="comment">// 第二个值为浮点型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number_array[<span class="number">0</span>].i); <span class="comment">// 5</span></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-3-为联合添加“标记字段”"><a href="#16-4-3-为联合添加“标记字段”" class="headerlink" title="16.4.3    为联合添加“标记字段”"></a>16.4.3    为联合添加“标记字段”</h3><blockquote>
<p><strong>用途：</strong>为联合提供额外的当前类型信息，防止获取到无意义的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_KIND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_KIND 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;struct&#125; </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> kind; <span class="comment">// 标记字段</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据数据结构的类型以不同的方式打印值</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;struct&#125; n 要打印的数据结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构实例</span></span><br><span class="line">	Number n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记字段</span></span><br><span class="line">	n.kind = INT_KIND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	n.u.i = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印出来</span></span><br><span class="line">	print_number(n); <span class="comment">// 82</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n.u.i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%g\n"</span>, n.u.f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-5-枚举"><a href="#16-5-枚举" class="headerlink" title="16.5    枚举"></a>16.5    枚举</h2><blockquote>
<p><strong>说明：</strong><code>enum</code>是一种由程序员列出值的类型，而且程序员必须为每种值（枚举常量）命名。<br><strong>特点：</strong></p>
<ul>
<li>遵循到c语言的作用域规则（如果枚举声明在函数体内，那么它的常量对外部函数是不可见的）</li>
<li>声明的方式类似结构和联合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的声明方式：定义枚举类型的同时声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-1-枚举标记和枚举类型"><a href="#16-5-1-枚举标记和枚举类型" class="headerlink" title="16.5.1    枚举标记和枚举类型"></a>16.5.1    枚举标记和枚举类型</h3><blockquote>
<p><strong>说明：</strong>类似结构和联合的标记，有两种方式。</p>
</blockquote>
<h5 id="方式1：enum-标记名-可能值"><a href="#方式1：enum-标记名-可能值" class="headerlink" title="方式1：enum 标记名 {可能值}"></a>方式1：<code>enum 标记名 {可能值}</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> suit s1, s2;</span><br></pre></td></tr></table></figure>
<h5 id="方式2：typedef-enum-可能值-类型名"><a href="#方式2：typedef-enum-可能值-类型名" class="headerlink" title="方式2：typedef enum {可能值} 类型名"></a>方式2：<code>typedef enum {可能值} 类型名</code></h5><blockquote>
<p><strong>技巧：</strong>利用<code>typedef</code>来创建布尔类型是非常好的一种方法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; Suit;</span><br><span class="line">Suit s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-2-枚举作为整数"><a href="#16-5-2-枚举作为整数" class="headerlink" title="16.5.2    枚举作为整数"></a>16.5.2    枚举作为整数</h3><blockquote>
<p><strong>说明：</strong>在系统内部，c语言会把枚举变量和常量作为整数处理。</p>
<ul>
<li>当没有为枚举常量指定值时，它的值时一个大于前一个常量的值（默认第一个枚举常量的值为0）</li>
<li>可以为枚举常量自由选择不同的值</li>
<li>当为枚举常量指定值时，对大小顺序没有要求</li>
<li>两个或多个枚举常量具有相同的值也是合法的</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS = <span class="number">20</span>, DIAMONDS = <span class="number">10</span>, HEARTS, SPADES&#125;; <span class="comment">// 20, 10, 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>把整数用作枚举的值是非常危险的，<code>c++</code>不允许整数用作枚举的值来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s;</span><br><span class="line">i = DIAMONDS;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">s++;</span><br><span class="line">i = s + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-3-用枚举声明“标记字段”"><a href="#16-5-3-用枚举声明“标记字段”" class="headerlink" title="16.5.3    用枚举声明“标记字段”"></a>16.5.3    用枚举声明“标记字段”</h3><blockquote>
<p><strong>说明：</strong><code>enum</code>和<code>union</code>配合实现<code>union</code>的“标记字段”。<br><strong>优点：</strong></p>
<ul>
<li>不需要额外定义宏</li>
<li>明确类型的可能值范围</li>
<li>含义更明确</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedeg <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">enum</span> &#123;INT_KIND, FLOAT_KIND&#125; kind;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/15 编写大规模程序/" itemprop="url">
                  15 编写大规模程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:39:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/15 编写大规模程序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/15 编写大规模程序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="15-1-源文件"><a href="#15-1-源文件" class="headerlink" title="15.1    源文件"></a>15.1    源文件</h2><blockquote>
<p><strong>说明：</strong>可以把程序分割成一定数量的源文件(.c文件和.h文件)。</p>
<ul>
<li>原文件的扩展名为.c，每个原文件包含程序的部分内容，主要是函数的定义和变量</li>
<li>一个原文件必须包含名为main的函数，次函数作为程序的起始点</li>
</ul>
<p><strong>优点：</strong>把程序分裂成多个源文件有许多显著的优点。</p>
<ul>
<li>（易读）把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构</li>
<li>（易维护）可以单独对每一个文件进行编译。</li>
<li>（易复用）当把函数集合在单独的源文件中时，会更容易在其他程序中重新使用这些函数。</li>
</ul>
</blockquote>
<h3 id="案例－计算器："><a href="#案例－计算器：" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h3><blockquote>
<p><strong>逆波兰符号（Reverse Polish Notation, RPN）：</strong>指运算符都跟在操作数的后边。例如：<code>30 5 - 7 *</code>。<br><strong>思路：</strong>程序逐个读入操作数和运算符，那么利用栈跟踪中间结果这样的方式计算逆波兰表达式是很容易的。</p>
<ol>
<li>读取“记号”（数或运算符）</li>
<li>如果程序读取数，就将此数压入栈</li>
<li>如果程序读取运算符，那么将从栈顶弹出两个数进行相应的计算。</li>
</ol>
</blockquote>
<h2 id="15-2-头文件"><a href="#15-2-头文件" class="headerlink" title="15.2    头文件"></a>15.2    头文件</h2><blockquote>
<p><strong>说明：</strong>如果打算几个源文件可以访问相同的信息，那么将把此信息放在文件中，扩展名为<code>.h</code>，然后利用<code>#include</code>指令把文件的内容带进每个源文件中。这样的<code>.h</code>文件就是头文件（或包含文件）。</p>
</blockquote>
<h3 id="15-2-1-include指令"><a href="#15-2-1-include指令" class="headerlink" title="15.2.1    #include指令"></a>15.2.1    #include指令</h3><p><strong>语法：</strong>有两种格式，其中的<code>文件名</code>可以包含路径或驱动器号。而且预处理器不会讲<code>&quot;文件名&quot;</code>当作字符串处理了，不然DOS路径中的某些字符有可能被当作转义字符。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>搜索目标</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>#include &lt;文件名&gt;</td>
<td>系统头文件所在的目录</td>
<td>有可能是多个，通常是/usr/include</td>
</tr>
<tr>
<td>#include “文件名”</td>
<td>搜索当前目录，然后搜索系统头文件所在的目录</td>
<td>可以通过诸如-I选项修改搜索目录</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"c:\cprogs\utils.h"</span>/*DOS path*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"/cprogs/utils.h"</span>/*UNIX path*/</span></span><br></pre></td></tr></table></figure>
<p><strong>可移植性技巧：</strong>不要在<code>#include</code>指令中包含路径或驱动器信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys\stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;..\include\utils.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-共享宏定义和类型定义"><a href="#15-2-2-共享宏定义和类型定义" class="headerlink" title="15.2.2    共享宏定义和类型定义"></a>15.2.2    共享宏定义和类型定义</h3><blockquote>
<p><strong>说明：</strong>将通用的宏定义和类型定义放在头文件中有许多明显的好处。</p>
<ul>
<li>不用频繁复制代码</li>
<li>易于修改和维护</li>
<li>避免犹豫原文件包含相同宏或类型的不同定义而导致的矛盾</li>
</ul>
</blockquote>
<p><em>boolean.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-共享函数原型"><a href="#15-2-3-共享函数原型" class="headerlink" title="15.2.3    共享函数原型"></a>15.2.3    共享函数原型</h3><blockquote>
<p><strong>说明：</strong>为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。<br><strong>技巧：</strong>为了保证函数原型声明一致，声明部分单独放在一个头文件中。然后在定义和调用的源文件中都引入该头文件。<br><strong>注意：</strong>在调用在其他文件中的函数时，要始终确保编译器在调用之前看到函数的原型。</p>
</blockquote>
<h4 id="案例－计算器：-1"><a href="#案例－计算器：-1" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h4><p><em>1. 头文件：<code>stack.h</code></em></p>
<blockquote>
<p><strong>说明：</strong>包含共享的函数的原型声明。<br><strong>注意：</strong>只在<code>calc.c</code>中使用的的函数不应该定义在该头文件中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>2. 函数定义：<code>stack.c</code></em></p>
<blockquote>
<p><strong>说明：</strong>实现stack.c中声明的所有函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>3. 入口文件：<code>calc.c</code></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//编译器会通过stack.h中make_empty的原型找到对应的定义，从而正确调用</span></span><br><span class="line">	make_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>编译运行</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o calc calc.c stack.c</span><br><span class="line">$ ./calc </span><br><span class="line"> what</span><br></pre></td></tr></table></figure>
<h3 id="15-2-4-共享变量声明"><a href="#15-2-4-共享变量声明" class="headerlink" title="15.2.4    共享变量声明"></a>15.2.4    共享变量声明</h3><blockquote>
<p><strong>说明：</strong>为了共享变量<code>i</code>，首先把变量i的定义（和初始化）放置在一个文件中，而在其他文件中包含变量<code>i</code>的声明（使用关键字<code>extern</code>）。<br><strong>变量声明：</strong><code>extern</code></p>
<ul>
<li>类似函数的声明，仅声明变量名和类型（内存不会为其分配空间）</li>
<li>通常情况下我们不使用<code>extern</code>，这种情况下变量声明和定义同时完成</li>
<li>可以用于所有类型的变量</li>
<li>在数组的声明中使用<code>extern</code>时可以忽略数组的长度<code>extern int a[];</code></li>
<li>编译器无法检查<code>变量声明</code>是否和<code>变量定义</code>严格匹配，因此有可能出现和声明类型不一致的定义，这会导致程序的异常行为</li>
</ul>
<p><strong>技巧：</strong>通常把共享的变量的声明放置在头文件中，需要访问该共享变量的源文件中引入该头文件。同时如果变量的定义在其它源文件（而不是入口文件中），则也需要引入该头文件。<br><strong>扩展：</strong>虽然在文件中共享变量是<code>c</code>语言界的长期惯例，但是它有重大缺陷。<code>19.2</code>节有如何设计不需要共享变量的程序的知识。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern提示编译器变量i是在程序的其它位置定义的（同一文件或不同文件）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-5-嵌套包含"><a href="#15-2-5-嵌套包含" class="headerlink" title="15.2.5    嵌套包含"></a>15.2.5    嵌套包含</h3><blockquote>
<p><strong>说明：</strong>头文件自身可以包含<code>#include</code>指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"boolean.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-6-保护头文件"><a href="#15-2-6-保护头文件" class="headerlink" title="15.2.6    保护头文件"></a>15.2.6    保护头文件</h3><blockquote>
<p><strong>为什么保护：</strong>如果源文件包含同一个文件两次（直接或间接），那么可能（如果包含类型定义）会产生编译错误。</p>
<ul>
<li>避免由重复的类型定义导致的编译错误</li>
<li>节约编译时间</li>
</ul>
<p><strong>如何保护：</strong>为了防止头文件多次包含导致的多次编译，将用<code>#ifndef</code>和<code>#endif</code>两个指令把文件闭合起来。在预编译阶段去重复掉引入的头文件的代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BOOLEAN_H是按照所在头文件名(BOOLEAN.h)进行命名的，目的是避免和其它头文件中的宏冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-7-头文件中的-error指令"><a href="#15-2-7-头文件中的-error指令" class="headerlink" title="15.2.7    头文件中的#error指令"></a>15.2.7    头文件中的#error指令</h3><blockquote>
<p><strong>用途：</strong>放在头文件中用来检查不应该包含头文件的条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在DOS程序中才能正常使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOS</span></span><br><span class="line">	<span class="comment">//如果非DOS程序试图包含此头文件，那么编译将在#error指令处停止</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">error</span> Grapphics supported only under DOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="15-3-把程序划分成多个文件（程序：文本格式化）"><a href="#15-3-把程序划分成多个文件（程序：文本格式化）" class="headerlink" title="15.3    把程序划分成多个文件（程序：文本格式化）"></a>15.3    把程序划分成多个文件（程序：文本格式化）</h2><blockquote>
<p><strong>功能分析：</strong>能够将输入的文本格式化的命令行工具。</p>
<ul>
<li>“删除空行、制表符”</li>
<li>“填充”：添加单词直到再多一个单词就会导致溢出时才停止</li>
<li>“调整”：除最后一行外，在单词间添加额外的空格以便每行有精确的相同长度（60个字符）</li>
</ul>
</blockquote>
<h2 id="15-4-构建多文件程序"><a href="#15-4-构建多文件程序" class="headerlink" title="15.4    构建多文件程序"></a>15.4    构建多文件程序</h2><blockquote>
<p><strong>原理：</strong>大多数编译器允许一步完成编译和链接的过程。</p>
<ol>
<li><strong>编译：</strong>对每个源文件（不包括头文件）分别进行编译</li>
<li><strong>链接：</strong>把上一步产生的目标文件和库函数的代码结合在一起生成可执行的程序。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-o告诉编译器最终的可执行文件的名字</span></span><br><span class="line">$ gcc -o fmt fmt.c line.c word.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-1-makefile"><a href="#15-4-1-makefile" class="headerlink" title="15.4.1    makefile"></a>15.4.1    makefile</h3><p><strong>命令行编译的缺点：</strong></p>
<ul>
<li>枯燥乏味（敲没有营养的编译命令）</li>
<li>浪费时间，所有源文件每次都会被重新编译</li>
<li>构建大规模程序费时费力易出错</li>
</ul>
<p><strong>说明：</strong>Unix系统发明了makefile的概念，这个文件包含构建程序的必要信息。</p>
<ol>
<li>列出了作为程序部分的文件</li>
<li>描述了文件之间的依赖性</li>
</ol>
<p><strong>基本语法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件名:依赖的文件</span><br><span class="line">[tab]命令</span><br></pre></td></tr></table></figure>
<p><strong>扩展：</strong>不是每个人都使用makefile，其它程序维护工具正变得流行，包括一些集成开发环境支持的“工程文件”。</p>
<h4 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt:fmt.o word.o line.o</span><br><span class="line">	gcc -o fmt fmt.o word.o line.o</span><br><span class="line">fmt.o:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.o:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.o:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h4 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.exe:fmt.obj word.obj line.obj</span><br><span class="line">	gcc -o fmt fmt.obj word.obj line.obj</span><br><span class="line">fmt.obj:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.obj:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.obj:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-2-链接期间的错误"><a href="#15-4-2-链接期间的错误" class="headerlink" title="15.4.2    链接期间的错误"></a>15.4.2    链接期间的错误</h3><blockquote>
<p><strong>常见错误：</strong></p>
<ol>
<li>Undefined symbol</li>
<li>Unresollved external reference</li>
</ol>
<p><strong>起因：</strong>程序中丢失了函数定义或变量定义，那么链接器将无法解决外部引用。</p>
<ol>
<li>拼写错误</li>
<li>丢失文件</li>
<li>丢失库</li>
</ol>
</blockquote>
<h3 id="15-4-3-重新构建程序"><a href="#15-4-3-重新构建程序" class="headerlink" title="15.4.3    重新构建程序"></a>15.4.3    重新构建程序</h3><blockquote>
<p><strong>两种情况：</strong>无论哪个文件发生变化，重新编译后都需要重新链接整个程序。</p>
<ol>
<li>变化影响单独一个源文件：只对此文件进行重新编译</li>
<li>变化影响头文件：重新编译所有包含此头文件的源文件</li>
</ol>
<p><strong>使用makefile重新构建：</strong>通过检查每个文件的日期，makex可以确定从程序最后一次构建后哪些文件发生了变化。然后根据依赖关系判断如何重新编译。</p>
</blockquote>
<h3 id="15-4-4-在程序外定义宏"><a href="#15-4-4-在程序外定义宏" class="headerlink" title="15.4.4    在程序外定义宏"></a>15.4.4    在程序外定义宏</h3><blockquote>
<p><strong>意义：</strong>不需要编辑任何程序文件就对宏的值进行改变。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D</td>
<td>在命令行指定宏的值</td>
<td>大多数UNIX编译器和某些非UNIX编译器</td>
</tr>
<tr>
<td>-U</td>
<td>取消指定宏的定义</td>
<td>一些编译器</td>
</tr>
</tbody>
</table>
<p><em>foo.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br></pre></td></tr></table></figure>
<p><em>命令行</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DDEBUG=1 foo.c</span><br><span class="line"># gcc -UDEBUG foo.c</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/14 预处理器/" itemprop="url">
                  14 预处理器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:28:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/14 预处理器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/14 预处理器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>预处理器是一个小软件，它可以在编译前编辑c程序<br><strong>弊端：</strong></p>
<ul>
<li>造成那一发现的错误的根源</li>
<li>经常被错误地用来编写一些几乎不可能读懂的程序</li>
</ul>
<p><strong>技巧：</strong>适度使用预处理功能，减少对于处理器的依赖。<br><strong>扩展：</strong>c++中可以进一步限制预处理器的使用。</p>
</blockquote>
<h2 id="14-1-预处理器的工作方式"><a href="#14-1-预处理器的工作方式" class="headerlink" title="14.1    预处理器的工作方式"></a>14.1    预处理器的工作方式</h2><blockquote>
<p><strong>说明：</strong>预处理器的输入是一个c语言程序，程序中可能会包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8B%E5%8D%884.28.36.png" alt="Alt text"></p>
<blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>不检查错误</li>
<li>不删除包含指令的行，而是简单地将它们替换为空</li>
<li>将每一处注视替换为空格字符（有些与编译器会进一步删除不必要的空白字符，并在每一行开始使用缩进的空格符和制表符）</li>
</ul>
<p><strong>注意：</strong>预处理器仅知道少量的c语言规则，因此，它在执行指令时非常有可能产生非法的程序。</p>
</blockquote>
<h2 id="14-2-预处理指令"><a href="#14-2-预处理指令" class="headerlink" title="14.2    预处理指令"></a>14.2    预处理指令</h2><p><strong>分类：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>包括</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义</td>
<td><code>#define</code> <code>#undef</code></td>
</tr>
<tr>
<td>文件包含</td>
<td><code>#include</code></td>
</tr>
<tr>
<td>条件编译</td>
<td><code>#if</code> <code>ifdef</code> <code>ifindef</code> <code>elif</code> <code>#else</code> <code>#endif</code></td>
</tr>
<tr>
<td>其他</td>
<td><code>#error</code> <code>#line</code> <code>#pragma</code></td>
</tr>
</tbody>
</table>
<p><strong>语法：</strong></p>
<ul>
<li>指令都以<code>#</code>开始：<code>空白符 #指令名 指令所需要的其他信息</code></li>
<li>在指令的符号之间可以插入任意树龄的空格或横向制表符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#		<span class="meta-keyword">define</span>		N 		100<span class="comment">// 这样写也是合法的</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>指令总是在第一个换行符处结束，除非明确地指明要继续（通过在行末尾使用<code>\</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISK_CAPACITY (SIDES *  \</span><br><span class="line">                        TRACK_PER_SIDE * \)</span></span><br><span class="line">				    	  SECTORS_PER_TRACK * \</span><br><span class="line">						  BYTES_PER_SECTOR)</span><br></pre></td></tr></table></figure>
<ul>
<li>指令可以出现在程序种任何地方（<code>#define</code>和<code>#include</code>通常放在文件开始）</li>
<li>注释可以和指令放在同一行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREEZING_PT 32.0	<span class="comment">/* Freezing point of water */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-3-宏定义"><a href="#14-3-宏定义" class="headerlink" title="14.3    宏定义"></a>14.3    宏定义</h2><blockquote>
<p><strong>说明：</strong>除了简单的宏，与编译器也支持带参数的宏。</p>
</blockquote>
<h3 id="14-3-1-简单的宏"><a href="#14-3-1-简单的宏" class="headerlink" title="14.3.1    简单的宏"></a>14.3.1    简单的宏</h3><p><strong>语法：</strong><code>#define 表示符 替换列表</code><br><strong>替换列表：</strong>一系列c语言记号，包括表示符、关键字、数、字符常量、字符串字面量、运算符和标点符号。<br><strong>原理：</strong>当预处理器遇到一个宏定义时，会做一个<code>标识符</code>代表<code>替换列表</code>的记录。再文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。<br><strong>注意（常见错误）：</strong></p>
<ol>
<li>不要在宏定义中放置任何额外的符号</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N = 1000<span class="comment">//不能使用=</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会成为int a[= 100]，导致错误</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不能在宏定义的末尾添加分号</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;<span class="comment">//这里添加的分号会被作为替换列表的一部分</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会变成int a[100;]</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>简单的宏主要用来定义那些被<code>Kernighan</code>和<code>Ritchie</code>称为明示常量（<code>manifest constant</code>）的东西。优点如下</p>
<ol>
<li>程序更易读</li>
<li>易于修改</li>
<li>帮助避免前后不一致或键盘输入错误</li>
<li>可以对c语法做小的修改</li>
<li>对类型重命名</li>
<li>控制条件编译</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE_LEN 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR <span class="string">'R'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOS <span class="string">'\0'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-带参数的宏"><a href="#14-3-2-带参数的宏" class="headerlink" title="14.3.2    带参数的宏"></a>14.3.2    带参数的宏</h3><blockquote>
<p><strong>语法：</strong><code>#define 标识符(x1, x2, ..., xn) 替换列表</code></p>
<ul>
<li>宏的<code>(</code>和<code>标识符</code>之间必须没有空格（否则会被当作简单宏处理）</li>
</ul>
<p><strong>原理：</strong>当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，宏调用<code>标识符(y1,y2,...,yn)</code>会被<code>替换列表</code>替换，且参数也会依据<code>宏定义</code>对应到替换列表中。<br><strong>用途：</strong></p>
<ul>
<li>经常被用来作为一些简单的函数使用（模拟函数调用）</li>
<li>经常被作为模版，替换经常重复书写的代码段（替换语句）<br><strong>优点：</strong>相比实际的函数</li>
<li>程序可能会稍快些（没有存储上下文、复制参数等的开销）</li>
<li>宏会更“通用”（没有对参数类型的限制）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>编译后的代码通常会变大</li>
<li>宏参数没有类型检查</li>
<li>无法用一个指针指向一个宏</li>
<li>宏可能会不止一次地计算它的参数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果宏使用带有副作用的参数，多次进行宏调用带来的副作用可能导致不易察觉的错误。</li>
</ul>
<p><strong>技巧：</strong>避免使用带有副作用的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y)	((x) &gt; (y) ? (x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EVEN(n) ((n)%2 == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTINT_INT(x) printf(<span class="string">"%d\n"</span>, x)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">i = MAX(j+k, m-n);<span class="comment">//会被修改为i = ((j+k) &gt; (m-n) ? (j+k):(m-n));</span></span><br><span class="line"><span class="keyword">if</span>(IS_EVEN(i)) i++;<span class="comment">//if(((i)%2 == 0)) i++;</span></span><br><span class="line"></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("%d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-运算符"><a href="#14-3-3-运算符" class="headerlink" title="14.3.3    #运算符"></a>14.3.3    <code>#</code>运算符</h3><blockquote>
<p><strong>说明：</strong>将带参数的宏的参数转换为字符串字面量<br><strong>语法：</strong><code>#define 标识符(x1...) 替换列表</code></p>
<ul>
<li><code>#参数</code>仅允许出现在带参数的宏的替换列表中</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(x) printf(#x <span class="string">" = %%d"</span>, x)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//c语言中相邻的字符串字面量会被合并</span></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("i/j = %d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-4-运算符"><a href="#14-3-4-运算符" class="headerlink" title="14.3.4    ##运算符"></a>14.3.4    <code>##</code>运算符</h3><blockquote>
<p><strong>说明：</strong>可以将两个记号（例如标识符）“粘”在一起，成为一个记号。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define MK_ID(n) i##n</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">//int i1, i2, i3;</span><br><span class="line">int MK_ID(1), MK_ID(2), MK_ID(3);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>求最大值的函数模版（针对不同类型）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERIC_MAX(type)		\</span><br><span class="line">type type##_max(type x, type y)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return x &gt; y ? x : y;		\</span><br><span class="line">&#125;	</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* float float_max(float x, float y)&#123;</span><br><span class="line">*	return x &gt; y ? x : y;</span><br><span class="line">* &#125;</span><br><span class="line">*/</span></span><br><span class="line">GENERIC_MAX(<span class="keyword">float</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-5-宏的通用属性"><a href="#14-3-5-宏的通用属性" class="headerlink" title="14.3.5    宏的通用属性"></a>14.3.5    宏的通用属性</h3><ul>
<li>宏的替换列表可以包含对另一个宏的调用</li>
<li>预处理器智慧替换完整的记号，而不会替换记号的片段</li>
<li>一个宏定义的作用范围通常到出现这个宏的文件末尾</li>
<li>宏不可以被定义两遍，除非新的定义和旧的定义是一样的</li>
<li>宏可以使用<code>#undef</code>指令取消定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N<span class="comment">//取消对N的定义以便给出新的定义</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-6-宏定义中的圆括号"><a href="#14-3-6-宏定义中的圆括号" class="headerlink" title="14.3.6    宏定义中的圆括号"></a>14.3.6    宏定义中的圆括号</h3><blockquote>
<p><strong>说明：</strong>在宏定义中缺少圆括号会导致c语言最让人讨厌的错误（比如优先级问题）。<br><strong>哪里要添加圆括号：</strong></p>
<ol>
<li>如果宏的替换列表中又运算符，那么始终要讲替换列表放在括号中</li>
<li>当宏有参数时，仅给替换列表添加圆括号是不够的，参数的每一次出现都要添加圆括号</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE(x) (x*10)<span class="comment">//需要给x添加括号</span></span></span><br><span class="line">...</span><br><span class="line">j = SCALE(i+<span class="number">1</span>);<span class="comment">//j = ((i+1)*10);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-7-创建较长的宏"><a href="#14-3-7-创建较长的宏" class="headerlink" title="14.3.7    创建较长的宏"></a>14.3.7    创建较长的宏</h3><h4 id="14-3-7-1-逗号运算符"><a href="#14-3-7-1-逗号运算符" class="headerlink" title="14.3.7.1    逗号运算符"></a>14.3.7.1    逗号运算符</h4><blockquote>
<p><strong>说明：</strong>创建较长的宏的一个办法是使用<code>逗号运算符</code>，特别是可以使用逗号运算符来使替换列表包含一系列表达式。<br><strong>限制：</strong><code>逗号运算符</code>只能连接<code>表达式</code>，不能连接<code>语句</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-2-复合语句"><a href="#14-4-7-2-复合语句" class="headerlink" title="14.4.7.2        复合语句"></a>14.4.7.2        复合语句</h4><blockquote>
<p><strong>说明：</strong>除了使用逗号表达式，还可以将<code>语句</code>或<code>表达式</code>放在<code>{}</code>内形成复合语句。<br><strong>缺点：</strong>不能在<code>替换列表</code>为复合语句的宏调用的末尾使用分号结尾，因为在<code>if</code>语句中会调用会导致错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-3-在只循环一次的do-while中包含语句和表达式"><a href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式" class="headerlink" title="14.4.7.3    在只循环一次的do-while中包含语句和表达式"></a>14.4.7.3    在只循环一次的do-while中包含语句和表达式</h4><blockquote>
<p><strong>说明：</strong>加入一个宏需要包含一系列的语句，而不仅仅是一些列的表达式，可以将语句放在<code>do</code>循环中，并将条件设置为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s)		\</span><br><span class="line">	do&#123;				\</span><br><span class="line">		gets(s); 	\</span><br><span class="line">		puts(s);	\</span><br><span class="line">	&#125;while(0)		</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//do&#123;gets(s); puts(s);&#125;while(0)</span></span><br><span class="line">ECHO(str);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-8-预定义宏"><a href="#14-3-8-预定义宏" class="headerlink" title="14.3.8    预定义宏"></a>14.3.8    预定义宏</h3><blockquote>
<p><strong>说明：</strong>在c语言中预定义了一些有用的宏，这些宏主要是提供当前编译的信息。<br><strong>扩展：</strong>c语言提供了一个通用的、用于错误检测的宏—assert宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>LINE</em></td>
<td>被编译的文件的行数</td>
</tr>
<tr>
<td><em>FILE</em></td>
<td>被编译的文件的名字</td>
</tr>
<tr>
<td><em>DATE</em></td>
<td>编译的日期（格式”Mmm dd yyyy”）</td>
</tr>
<tr>
<td><em>TIME</em></td>
<td>编译的时间（格式”hh:mm:ss”）</td>
</tr>
<tr>
<td><em>STDC</em></td>
<td>如果编译器接受标准c，那么值为1</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测被零除的错误</span></span><br><span class="line"><span class="comment">//该宏应该在除法之前被调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ZERO(divisor)	\</span><br><span class="line">	<span class="meta-keyword">if</span>(divisor == 0)&#123;		\</span><br><span class="line">		printf(<span class="string">"**** Attempt to divide by zero on line %d "</span> \</span><br><span class="line">				<span class="string">"of file $s ***\n"</span>, _LINE_, _FILE_);		\\</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">CHECK_ZERO(j);</span><br><span class="line">k = i / j;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="14-4-条件编译"><a href="#14-4-条件编译" class="headerlink" title="14.4    条件编译"></a>14.4    条件编译</h2><blockquote>
<p><strong>说明：</strong>条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段。</p>
</blockquote>
<h3 id="14-4-1-if指令和-endif指令"><a href="#14-4-1-if指令和-endif指令" class="headerlink" title="14.4.1    #if指令和#endif指令"></a>14.4.1    #if指令和#endif指令</h3><blockquote>
<p><strong>语法：</strong>当预处理器遇到<code>if</code>指令时，会计算常量表达式。如果表达式的值为0，那么<code>#if</code>与<code>#endif</code>之间的行将在预处理过程中删除。<br><strong>注意：</strong>对于没有定义过的标识符，<code>#if</code>指令会把它当作是值为0的宏对待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">&gt;	语句</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of i: %d\n"</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of j: %d\n"</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-defined运算符"><a href="#14-4-2-defined运算符" class="headerlink" title="14.4.2    defined运算符"></a>14.4.2    defined运算符</h3><blockquote>
<p><strong>说明：</strong>如果标识符是一个定义过的宏返回1，否则返回0。<br><strong>用途：</strong>判断宏某个标识符是否被定义的宏，通常和<code>#if</code>指令结合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-3-ifdef指令和-ifndef指令"><a href="#14-4-3-ifdef指令和-ifndef指令" class="headerlink" title="14.4.3    #ifdef指令和#ifndef指令"></a>14.4.3    #ifdef指令和#ifndef指令</h3><blockquote>
<p><strong>说明：</strong>严格说来，这里要介绍的两种指令都不是必须的，因为都可以用其他指令模拟。</p>
</blockquote>
<h4 id="14-4-3-1-ifdef指令"><a href="#14-4-3-1-ifdef指令" class="headerlink" title="14.4.3.1    #ifdef指令"></a>14.4.3.1    #ifdef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>if defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="14-4-3-2-ifndef指令"><a href="#14-4-3-2-ifndef指令" class="headerlink" title="14.4.3.2    #ifndef指令"></a>14.4.3.2    #ifndef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>#if !defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="14-4-4-elif指令和-else指令"><a href="#14-4-4-elif指令和-else指令" class="headerlink" title="14.4.4    #elif指令和#else指令"></a>14.4.4    #elif指令和#else指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 表达式1</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 表达式2</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<h3 id="14-4-5-使用条件编译"><a href="#14-4-5-使用条件编译" class="headerlink" title="14.4.5    使用条件编译"></a>14.4.5    使用条件编译</h3><p><strong>常见应用：</strong></p>
<ul>
<li>编写在多台机器或多种操作系统之间可移植的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WINDOWS)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(DOS)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS2)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写可以使用不同的编译器进行编译的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC__</span></span><br><span class="line">标准c函数原型</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">经典c函数声明</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>为宏提供默认定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUFFER_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时屏蔽包含注释的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">包含注释的代码行</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-5-其他指令"><a href="#14-5-其他指令" class="headerlink" title="14.5    其他指令"></a>14.5    其他指令</h2><h3 id="14-5-1-error指令"><a href="#14-5-1-error指令" class="headerlink" title="14.5.1    #error指令"></a>14.5.1    #error指令</h3><blockquote>
<p><strong>语法：</strong><code>#error 消息</code><br><strong>说明：</strong>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，这个消息一定会包含<code>消息</code>，然后大多数编译器会立即终止编译而不去找出其他错误。<br><strong>用途：</strong>通常与条件编译指令一起用于检测正常编译过程中不应出现的情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if INT_MAX &lt; 1000000</span><br><span class="line">#error int type is too small//Error directive:int type is too small</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="14-5-2-line指令"><a href="#14-5-2-line指令" class="headerlink" title="14.5.2    #line指令"></a>14.5.2    #line指令</h3><blockquote>
<p><strong>说明：</strong>用来改变程序行编号的方式以及使编译器认为所在文件是另一个文件。<br><strong>语法：</strong><code>#line 行号 [文件名]</code></p>
<ul>
<li><code>行号</code>是大小介于1-32767之间的整数</li>
<li><code>行号</code>会影响<code>__LINE__</code>宏的值，<code>文件名</code>影响<code>__FILE__</code>的值</li>
</ul>
<p><strong>用途：</strong>主要用于那些产生c代码作为输入的程序，因为出错信息都指向程序员编写的文件，而不是（更复杂）由一些工具生成的文件。</p>
</blockquote>
<h3 id="14-5-3-pragma指令"><a href="#14-5-3-pragma指令" class="headerlink" title="14.5.3    #pragma指令"></a>14.5.3    #pragma指令</h3><blockquote>
<p><strong>语法：</strong><code>#pragma 记号</code></p>
<ul>
<li>＃pragma指令通常只跟着一个记号，这个记号表示了一条编译器需要服从的命令</li>
<li>一些编译器允许#pragma指令所包含的不仅是简单的命令（特别是有些编译器允许#pragma指令带参数）</li>
<li>如果#pragma指令包含了无法识别的命令，编译器必须忽略这些#pragma指令，不允许产生出错信息</li>
</ul>
<p><strong>注意：</strong>#pragma指令中出现的命令集在不同的编译器上是不一样的，需要查阅相关编译器的文档。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/13 字符串/" itemprop="url">
                  13 字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:11:36+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/13 字符串/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/13 字符串/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="13-1-字符串字面量"><a href="#13-1-字符串字面量" class="headerlink" title="13.1    字符串字面量"></a>13.1    字符串字面量</h2><blockquote>
<p><strong>说明：</strong>用一对双括号括起来的字符序列。</p>
<h3 id="13-1-1-字符串字面量中的转义序列"><a href="#13-1-1-字符串字面量中的转义序列" class="headerlink" title="13.1.1    字符串字面量中的转义序列"></a>13.1.1    字符串字面量中的转义序列</h3><p><strong>说明：</strong><code>char</code>型字面量中能够使用的转义字符字符串字面量中都可以使用。<br><strong>注意：</strong>数字转义字符并不常用，但使用时会需要注意一些<code>char</code>中不会遇到的问题</p>
</blockquote>
<table>
<thead>
<tr>
<th>数字转义字符</th>
<th>格式</th>
<th>字符串字面量额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制转义字符</td>
<td><code>\最多含有3位数字的八进制数字</code></td>
<td>在3个数字之后结束，或者在第一个非八进制数字符处结束。</td>
</tr>
<tr>
<td>十六进制转义字符</td>
<td><code>\x十六进制数</code></td>
<td>没有字数限制，直到第一个非十六机制数字符截止（通常还限制十六进制数大小为<code>\x0~\x7f</code>或<code>\x0~\xff</code>）</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串字面量中使用8进制转义字符</span></span><br><span class="line"><span class="string">"\1234"</span><span class="comment">//2个字符（\123和4）</span></span><br><span class="line"><span class="string">"\189"</span><span class="comment">//3个字符（\1，8，9）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字面量中使用16进制转义字符</span></span><br><span class="line"><span class="string">"Z\x81rich"</span><span class="comment">//6个字符（Z, \81, r, i, c, h）</span></span><br><span class="line"><span class="string">"\x81ber"</span><span class="comment">//2个字符（\x81be和r）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-延续字符串字面量"><a href="#13-1-2-延续字符串字面量" class="headerlink" title="13.1.2    延续字符串字面量"></a>13.1.2    延续字符串字面量</h3><h4 id="方式一：用字符-结尾"><a href="#方式一：用字符-结尾" class="headerlink" title="方式一：用字符\结尾"></a>方式一：用字符<code>\</code>结尾</h4><blockquote>
<p><strong>说明：</strong>只要在一行用字符<code>\</code>结尾，那么c语言就允许在下一行延续字符串字面量。<br><strong>注意：</strong>除了（看不见）的末尾的换行符，在同一行不可以有其他字符跟在<code>\</code>后面。<br><strong>扩展：</strong>不只字符串，字符<code>\</code>还可以用来分隔任何长的符号。<br><strong>缺点：</strong>字符字面量必须从下一行的起始位置继续，破坏了程序的缩紧结构。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A,then \</span><br><span class="line">press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="方式二：字面量自动合并（c标准）"><a href="#方式二：字面量自动合并（c标准）" class="headerlink" title="方式二：字面量自动合并（c标准）"></a>方式二：字面量自动合并（c标准）</h4><blockquote>
<p><strong>说明：</strong>当两条或更多条字符串字面量相连时（仅用空白字符分割），编译器必须把他们合并成单独一条字符串。<br><strong>优点：</strong>不必破坏缩紧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A, then"</span></span><br><span class="line">	   <span class="string">"press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-如何存储字符串字面量"><a href="#13-1-3-如何存储字符串字面量" class="headerlink" title="13.1.3    如何存储字符串字面量"></a>13.1.3    如何存储字符串字面量</h3><blockquote>
<p><strong>存储形式：</strong>c语言把字符串字面量作为字符数组来处理，相当于<code>char *</code>。<br><strong>空字符（<code>\0</code>）：</strong><code>ASCII</code>字符集中的第一个字符。<br><strong>内存分配：</strong>当c语言编译器在程序中遇到长度为<code>n</code>的字符串字面量时，它会为字符串字面量分配长度为<code>n+1</code>的内存空间，用来存储字符串子民啊量中的字符，以及额外的一个字符——<code>空字符</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc"</span>);<span class="comment">//当调用printf时，会传递"abc"的地址（即指向字母`a`存储单元的指针）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-4-字符串字面量的操作"><a href="#13-1-4-字符串字面量的操作" class="headerlink" title="13.1.4    字符串字面量的操作"></a>13.1.4    字符串字面量的操作</h3><blockquote>
<p><strong>说明：</strong>可以将字符串字面量赋值给<code>char *</code>指针。<br><strong>特点：</strong></p>
<ul>
<li><p>c语言允许指针添加下标，因此可以给字符串字面量添加下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = <span class="string">"abc"</span>[<span class="number">1</span>];<span class="comment">//b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>允许改变字符串字面量的字符（不推荐）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//一些编译器可能会出现异常</span></span><br><span class="line">&gt;<span class="keyword">char</span> *p = <span class="string">"abc"</span>;</span><br><span class="line">&gt;*p = <span class="string">'b'</span>;<span class="comment">//字符串字面量被修改为"bbc"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = <span class="string">"abc"</span>;<span class="comment">//这个赋值操作不是复制"abc"中的字符，而仅仅是使用p指向字符串的第一个字符。</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-5-字符串字面量与字符常量"><a href="#13-1-5-字符串字面量与字符常量" class="headerlink" title="13.1.5    字符串字面量与字符常量"></a>13.1.5    字符串字面量与字符常量</h3><blockquote>
<p><strong>说明：</strong>只包含一个字符的字符串字面量不同于字符常量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>例子</th>
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;a&quot;</code></td>
<td>字符串字面量</td>
<td>用指针来表示</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>字符常量</td>
<td>用整数（字符的ASCII码）来表示</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//合法，相当于传递`char *`指针作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">'\n'</span>);<span class="comment">//会报错，传递的不是指针而是整数</span></span><br></pre></td></tr></table></figure>
<h2 id="13-2-字符串变量"><a href="#13-2-字符串变量" class="headerlink" title="13.2    字符串变量"></a>13.2    字符串变量</h2><blockquote>
<p><strong>存储方式：</strong><code>char str[STR_LEN+1]</code></p>
<ul>
<li>载体为一维的字符数组</li>
<li>以空字符串结尾（数组的长度比字符串的长度多一个字符）</li>
</ul>
<p><strong>注意：</strong>如果没有给空字符预留位置，可能导致程序运行时出现不可预知的结果，因为c函数库中的函数假设字符串都以空字符串结束。<br><strong>技巧：</strong>字符串的长度取决于空字符的位置，而不是取决于存放字符串的字符数组的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="keyword">char</span> str[STR_LEN+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="13-2-1-初始化字符串变量"><a href="#13-2-1-初始化字符串变量" class="headerlink" title="13.2.1    初始化字符串变量"></a>13.2.1    初始化字符串变量</h3><blockquote>
<p><strong>两种字面量：</strong><code>字符串字面量</code>和<code>数组字初始化式</code></p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p><strong>底层：</strong>c编译器会把它看成是数组初始化式的缩写形式。<br><strong>规则：</strong></p>
<ul>
<li>如果初始化式太短以至于不能填满字符串变量时，c编译器会讲多出的部分都赋值为<code>\0</code></li>
<li>如果没有空间给空字符串，将使数组无法作为字符串使用</li>
</ul>
<p><strong>注意：</strong>一定要确保数组的长度要长于初始化式的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器将把字符床"June 14"中的字符复制到数组date1中，然后追加一个空字符串从而使date1可以作为字符串使用</span></span><br><span class="line"><span class="keyword">char</span> date[<span class="number">8</span>] = <span class="string">"June 14"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>J</th>
<th>u</th>
<th>n</th>
<th>e</th>
<th></th>
<th>1</th>
<th>4</th>
<th>\0</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p><strong>规则：</strong>如果初始化式比本身短，会把余下的字符数组元素初始化为<code>\0</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组长度可以省略由编译器自己计算，手工计算很容易出错</span></span><br><span class="line"><span class="keyword">char</span> date1[<span class="number">8</span>] = &#123;<span class="string">'J'</span>, <span class="string">'u'</span>, <span class="string">'n'</span>, <span class="string">'e'</span>, <span class="string">' '</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-2-字符数组和字符指针"><a href="#13-2-2-字符数组和字符指针" class="headerlink" title="13.2.2    字符数组和字符指针"></a>13.2.2    字符数组和字符指针</h3><blockquote>
<p><strong>说明：</strong>数组变量有两种</p>
</blockquote>
<table>
<thead>
<tr>
<th>＊</th>
<th>字符数组</th>
<th>字符指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>声明</strong></td>
<td><code>char varStr[]</code></td>
<td><code>char *varStr</code></td>
</tr>
<tr>
<td><strong>元素是否可修改</strong></td>
<td>是</td>
<td>否（因为指针指向的是不可修改的字符串）</td>
</tr>
<tr>
<td><strong>变量本身是否可改变指向</strong></td>
<td>否（数组名和数组绑定在一起且无法改变指向）</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>声明字符指针必需指向字符数组后才能使用，无论是字面量（两种形式的字面量）还是已经声明好的字符数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[STR_LEN+<span class="number">1</span>];</span><br><span class="line">p = srt;<span class="comment">//p指向了str的第一个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="13-3-字符串的读／写"><a href="#13-3-字符串的读／写" class="headerlink" title="13.3    字符串的读／写"></a>13.3    字符串的读／写</h2><h3 id="13-3-1-用printf函数和puts函数写字符串"><a href="#13-3-1-用printf函数和puts函数写字符串" class="headerlink" title="13.3.1    用printf函数和puts函数写字符串"></a>13.3.1    用printf函数和puts函数写字符串</h3><h4 id="13-3-1-1-printf函数"><a href="#13-3-1-1-printf函数" class="headerlink" title="13.3.1.1    printf函数"></a>13.3.1.1    <code>printf</code>函数</h4><blockquote>
<p><strong>说明：</strong>转换说明为<code>%[m][.p]s</code>，下面分3中情景讨论。</p>
</blockquote>
<hr>
<p><em>情景1:<code>%s</code>（不限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>情景</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>末尾提供了<code>空字符</code></td>
<td>逐个写字符<code>直到遇到空字符</code></td>
</tr>
<tr>
<td>末尾没有<code>空字符</code></td>
<td>会越过字符串的末尾继续写，直到最终在<code>内存的某个地方找到空字符</code>为止</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景2:<code>%ms</code>（限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>m大小</th>
<th>表现</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>>字符串长度</td>
<td>多出部分显示空格，字符串右对齐</td>
<td>在<code>m</code>前使用<code>-</code>强制左对齐</td>
</tr>
<tr>
<td>&lt;字符串长度</td>
<td>忽略设置的m，显示整个字符串</td>
<td>不会截断</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景3:<code>%m.ps</code>（限制宽度，截断）</em><br>会使字符串的前p个字符在大小为m的区域内显示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Are we having fun yet?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value of str:%s\n"</span>, str);<span class="comment">//Are we having fun yet?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(str);<span class="comment">////Are we having fun yet?(\n)</span></span><br></pre></td></tr></table></figure>
<h4 id="13-3-1-2-put函数"><a href="#13-3-1-2-put函数" class="headerlink" title="13.3.1.2    put函数"></a>13.3.1.2    put函数</h4><blockquote>
<p><strong>参数：</strong>需要显示的字符串<br><strong>说明：</strong></p>
<ul>
<li>不使用转换说明和格式串</li>
<li>在写完字符串后，puts函数总会添加一个额外的换行符</li>
</ul>
</blockquote>
<h3 id="13-3-2-用scanf函数和gets函数读字符串"><a href="#13-3-2-用scanf函数和gets函数读字符串" class="headerlink" title="13.3.2    用scanf函数和gets函数读字符串"></a>13.3.2    用scanf函数和gets函数读字符串</h3><h4 id="13-3-2-1-scanf函数"><a href="#13-3-2-1-scanf函数" class="headerlink" title="13.3.2.1    scanf函数"></a>13.3.2.1    scanf函数</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>不需要在str前添加运算符<code>&amp;</code>，因为str是数组名，编译器会自动把它当作指针来处理</li>
<li>空白符（换行符、空格符、制表符）会使scanf函数停止读入，因此用scanf输入的字符串永远不会包含空白符</li>
<li>scanf函数始终会在字符串末尾存储一个<code>空字符</code>（否则无法当作正常字符串使用）</li>
</ul>
<p><strong>注意：</strong>scanf不会检测何时填满数组，可能会越过数组边界，导致异常。<br><strong>技巧：</strong>使用<code>%ns</code>代替<code>%s</code>可以使scanf函数更安全（<code>n</code> 指可以存储的最大字符的数量）</p>
<p><strong>限制：</strong>通常不用于读入一整行输入。</p>
</blockquote>
<h4 id="13-3-2-2-gets函数"><a href="#13-3-2-2-gets函数" class="headerlink" title="13.3.2.2    gets函数"></a>13.3.2.2    gets函数</h4><blockquote>
<p><strong>说明：</strong>类似scanf函数，把读入的字符放在数组中，然后存储一个<code>空字符</code>。</p>
<ul>
<li>不会在开始读字符串之前跳过空白字符（scanf函数会跳过）</li>
<li>会持续读入直到找到换行符（不是任意空白符）</li>
</ul>
<p><strong>扩展：</strong>gets函数天生就是不安全的，fgets函数是更加安全的选择。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sentence[STR_LEN+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a sentence:\n"</span>);<span class="comment">//To , or not to c</span></span><br><span class="line">gets(sentence);<span class="comment">//sentence的值为"To , or not to c"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-3-3-逐个字符读字符串"><a href="#13-3-3-逐个字符读字符串" class="headerlink" title="13.3.3    逐个字符读字符串"></a>13.3.3    逐个字符读字符串</h3><p><strong>说明：</strong>利用<code>getchar</code>自定义更加灵活的输入函数<br><strong>编程思路：</strong></p>
<ol>
<li>在开始存储字符串之前，函数应该跳过空白字符吗？</li>
<li>什么字符会导致函数停止读取：换行符、任意空白字符、还是其他一些字符？需要存储这类字符还是忽略掉？</li>
<li>如果输入的字符串太长以致无法存储，那么程序应该做些什么：胡咧额外的字符，还是把它们留给下一次的操作输入？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 不会跳过空白符，在第一个换行符处（不把换行符存储到字符串中）停止读取，</span><br><span class="line">* 并且忽略额外的字符。</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-访问字符串中的字符"><a href="#13-4-访问字符串中的字符" class="headerlink" title="13.4    访问字符串中的字符"></a>13.4    访问字符串中的字符</h2><p><strong>说明：</strong>访问字符串中的字符存在两种方式</p>
<ol>
<li>数组下标</li>
<li>指针</li>
</ol>
<h3 id="13-4-1-用数组下标"><a href="#13-4-1-用数组下标" class="headerlink" title="13.4.1    用数组下标"></a>13.4.1    用数组下标</h3><p><strong>说明：</strong>既然字符串是以数组的方式存储的，那么可以使用下标来访问字符串中的字符。<br><strong><code>const</code>：</strong>形式参数使用<code>const</code>修饰可以防止数组被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用数组下标遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-2-用指针"><a href="#13-4-2-用指针" class="headerlink" title="13.4.2    用指针"></a>13.4.2    用指针</h3><blockquote>
<p><strong>说明：</strong>使用指针代替数组下标访问字符串中的字符会更加便捷。<br><code>const</code>：用<code>const</code>修饰字符串指针可以避免传进来的实参的指向被改变，即便如此，因为传进来的指针的副本，所以可以可以自增。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用指针遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; s != <span class="string">'\0'</span>; s++)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-使用c语言的字符串库"><a href="#13-5-使用c语言的字符串库" class="headerlink" title="13.5    使用c语言的字符串库"></a>13.5    使用c语言的字符串库</h2><blockquote>
<p><strong>说明：</strong>c语言的函数库为字符串的操作提供了丰富的函数集，包含在<code>string.h</code>中。<br><strong>参数：</strong></p>
<ul>
<li>每个函数至少需要一个字符串作为实际参数</li>
<li>字符串形式参数类型可以是<code>char *</code></li>
<li>合法的实际参数类型：字符数组、<code>char *</code>类型变量、字符串字面量</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>形式参数没有声明为const的函数会在调用函数时修改形式参数，因此对应的实际参数不能为字符串字面量（字符串字面量的特点在于不可修改）。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-1-strcpy函数"><a href="#13-5-1-strcpy函数" class="headerlink" title="13.5.1    strcpy函数"></a>13.5.1    strcpy函数</h3><p><strong>背景：</strong>不能使用赋值运算符将字符串字面量赋值给字符数组（但字符串指针可以）。因为数组名在c语言中是不能作为左值使用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<p><strong>原型：</strong><code>char *strcpy(char *s1, const char *s2)</code><br><strong>用途：</strong>将<code>s2</code>指向的字符串复制到<code>s1</code>指向的数组中。<br><strong>返回值：</strong>被赋值的字符串的首地址，可以被用来实现多重赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcpy</span>(s2, <span class="string">"abc"</span>));<span class="comment">//将abc复制给s1和s2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>函数会将<code>s2</code>指向的字符串逐个复制过去直到遇到一个空字符为止，因此假设<code>s2</code>长度为<code>n</code>，如果<code>s1</code>长度小于<code>n</code>包含（<code>\0</code>），<code>s1</code>后面的内存也会被覆盖</li>
<li>因为不会修改<code>s2</code>指向的字符串，因此s2被声明为<code>const</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<h3 id="13-5-2-strcat函数"><a href="#13-5-2-strcat函数" class="headerlink" title="13.5.2    strcat函数"></a>13.5.2    strcat函数</h3><p><strong>原型：</strong><code>char *strcats(char *s1, const char *s2)</code><br><strong>说明：</strong>将<code>s2</code>指向的字符串追加到<code>s1</code>指向的字符串的后面<br><strong>返回值：</strong><code>s1</code>指向的字符串（指针）<br><strong>注意：</strong>如果<code>s1</code>指向的数组的大小不足以容纳所有的字符，将会多余的字符复制到数组后面的内存，到处错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2, <span class="string">"def"</span>);<span class="comment">//"abcdefhgi"</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcat</span>(s2, <span class="string">"ghi"</span>));<span class="comment">//"defhgi"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-3-strcmp函数"><a href="#13-5-3-strcmp函数" class="headerlink" title="13.5.3    strcmp函数"></a>13.5.3    strcmp函数</h3><p><strong>原型：</strong><code>int strcmp(const char *s1, const chat *s2)</code><br><strong>说明：</strong>比较两个字符串的大小</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于0</td>
<td>s1 &lt; s2</td>
</tr>
<tr>
<td>0</td>
<td>s1 == s2</td>
</tr>
<tr>
<td>大于0</td>
<td>s1 &gt; s2</td>
</tr>
</tbody>
</table>
<p><strong>底层：</strong>依据对应ASCII字符集的大小</p>
<ul>
<li>字典顺序</li>
<li>前<code>i</code>个字符相同，第<code>i+1</code>个字符大的大（若其中一个没有第<code>i+1</code>个字符，则字符数多的大）</li>
<li>所有大写字母（65～90）都小于所有小写字符（97～122 ）</li>
<li>数字（48～57）小于字母</li>
<li>空格符（32）小于所有打印字符</li>
</ul>
<h3 id="13-5-4-strlen函数"><a href="#13-5-4-strlen函数" class="headerlink" title="13.5.4    strlen函数"></a>13.5.4    strlen函数</h3><p><strong>原型：</strong><code>size_t strlen(const char *s)</code><br><strong>说明：</strong>求字符串的长度，即字符串中第一个空字符串前的字符的个数（不包括空字符）。</p>
<blockquote>
<p><strong>size_ t</strong>：无符号整数类型（unsigned int 或 unsigned long int ），在c函数库定义的。</p>
</blockquote>
<p><strong>注意：</strong>当用数组作为函数的实际参数时，strlen函数不会测量数组本身的长度，而是返回存储在数组中的字符串的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">fen = <span class="built_in">strlen</span>(<span class="string">"abc"</span>);<span class="comment">//3</span></span><br><span class="line">len = <span class="built_in">strlen</span>(<span class="string">" "</span>);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, <span class="string">"abc"</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(str1);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-5-程序：显示一个月的提示列表"><a href="#13-5-5-程序：显示一个月的提示列表" class="headerlink" title="13.5.5    程序：显示一个月的提示列表"></a>13.5.5    程序：显示一个月的提示列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$./remind</span><br><span class="line"> Enter day and reminder:1 dd</span><br><span class="line"> Enter day and reminder:2 ff</span><br><span class="line"> Enter day and reminder:3 ff</span><br><span class="line"> Enter day and reminder:0</span><br><span class="line"></span><br><span class="line"> Day Reminder</span><br><span class="line">  1 dd</span><br><span class="line">  2 ff</span><br><span class="line">  3 ff</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合(记录备忘列表)，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> reminders[MAX_REMIND][MSG_LEN + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(reminders[j], reminders[j<span class="number">-1</span>]);</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-6-字符串惯用法"><a href="#13-6-字符串惯用法" class="headerlink" title="13.6    字符串惯用法"></a>13.6    字符串惯用法</h2><h3 id="13-6-1-搜索字符串的结尾"><a href="#13-6-1-搜索字符串的结尾" class="headerlink" title="13.6.1    搜索字符串的结尾"></a>13.6.1    搜索字符串的结尾</h3><p><strong>相关惯用法：</strong></p>
<ol>
<li><code>while(*s){s++;}</code></li>
<li><code>while(*s++){...}
 ;</code></li>
</ol>
<h4 id="13-6-1-1-原始版本"><a href="#13-6-1-1-原始版本" class="headerlink" title="13.6.1.1    原始版本"></a>13.6.1.1    原始版本</h4><blockquote>
<p><strong>思路：</strong>从左到右扫描字符串，n自增。当s最终指向一个空字符串时，n的长度就是字符串的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">for</span>(n = <span class="number">0</span>; *s != <span class="string">'\0'</span>; s++)&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-1-2-优化版本"><a href="#13-6-1-2-优化版本" class="headerlink" title="13.6.1.2    优化版本"></a>13.6.1.2    优化版本</h4><blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>空字符的ASCII码值为0，而0在c语言中可以代表“假”</li>
<li>字符串是被当作字符数组来处理的，而数组不同元素的存储地址之差和下标之差相同，因此可以通过地址之差计算数组长度，避免了频繁的自增操作，从而提高速度</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> chat *s)&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">	<span class="keyword">while</span>(*s)&#123;</span><br><span class="line">		*s++;</span><br><span class="line">	&#125;</span><br><span class="line">	return s - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-6-2-复制字符串"><a href="#13-6-2-复制字符串" class="headerlink" title="13.6.2    复制字符串"></a>13.6.2    复制字符串</h3><blockquote>
<p><strong>惯用法：</strong>字符串复制惯用法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span>(*p++ = *s2++)</span><br><span class="line">&gt; ;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="13-6-2-1-原版"><a href="#13-6-2-1-原版" class="headerlink" title="13.6.2.1    原版"></a>13.6.2.1    原版</h4><blockquote>
<p><strong>说明：</strong>自定义实现<code>strcat</code>函数<br><strong>思路：</strong></p>
<ol>
<li>查找字符串s1末尾空字符串的位置，并使指针p指向它</li>
<li>把字符串s2中的字符逐个复制到p所指向的位置</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> chat *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*s2 != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		*p = *s2;</span><br><span class="line">		p++;</span><br><span class="line">		s2++;</span><br><span class="line">	&#125;</span><br><span class="line">	*p = <span class="string">'\0'</span>;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-2-2-优化版"><a href="#13-6-2-2-优化版" class="headerlink" title="13.6.2.2    优化版"></a>13.6.2.2    优化版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*p++ = s2++)</span><br><span class="line">		;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-7-字符串数组"><a href="#13-7-字符串数组" class="headerlink" title="13.7    字符串数组"></a>13.7    字符串数组</h2><blockquote>
<p><strong>两种方式：</strong><code>二维字符数组</code>和<code>一维指针数组</code><br><strong>技巧：</strong>得益于指针和数组之间的紧密联系，访问一维指针数组中的元素的方式和访问而为字符数组中元素的方式相同。</p>
</blockquote>
<h4 id="二维字符数组"><a href="#二维字符数组" class="headerlink" title="二维字符数组"></a>二维字符数组</h4><blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>需要知道所有字符串的长度，以最长的字符串的长度来确定二位数组每一行的长度。</li>
<li>不能填满数组的一整行的字符会用空字符填补，浪费空间。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> planets[][<span class="number">8</span>] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Earth"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>, <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Neptune"</span>, <span class="string">"Pluto"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.16.44.png" alt="Alt text"></p>
<h4 id="一维字符指针数组"><a href="#一维字符指针数组" class="headerlink" title="一维字符指针数组"></a>一维字符指针数组</h4><blockquote>
<p><strong>说明：</strong>大部分字符串集都是长短字符串的混合，c语言本身不提供“参次不齐的数组”，但可以通过字符数组指针的数组模拟。<br><strong>参次不齐的数组(ragged array)：</strong>数组的每一行有不同的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">m</span><br><span class="line"></span><br><span class="line"><span class="title">for</span><span class="params">(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(planets[i][<span class="number">0</span>] == <span class="string">'M'</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s begins with M\n"</span>, planets[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.23.02.png" alt="Alt text"></p>
<h3 id="13-7-1-命令行参数"><a href="#13-7-1-命令行参数" class="headerlink" title="13.7.1    命令行参数"></a>13.7.1    命令行参数</h3><p><strong>程序参数（command-line atgument）：</strong>不仅是操作系统命令，所有程序都有命令行信息。<code>Q&amp;A</code>为了能够访问这些命令行参数，必须为<code>main</code>函数定义为含有两个参数的函数，这两个参数通常命名为<code>argc</code>和<code>argv</code>。<br><strong>空指针：</strong>是一种不指向任何内容的特殊指针。宏<code>NULL</code>代表空指针。<br><strong>参数向量（argv）和参数计数（argc）：</strong></p>
<ul>
<li>argv[0]：指向程序名的字符串</li>
<li>argv[1]~argv[argc-1]：余下的命令行参数</li>
<li>argv[argc]：指向空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*argc：参数计数，命令行参数的数量（包括程序名本身）</span><br><span class="line">*argv: 参数向量，指向命令行参数的指针数组（以字符串的行书存储）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.56.34.png" alt="Alt text"></p>
<p><em>命令行输入参数案例</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l remind.c</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用数组）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;argc; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用指针）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **p;<span class="comment">//p用来指向argv中的字符串，因为argv本身作为数组就是指针，而其中的字符串（字符数组）也是指针，所以声明p为指针的指针</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;argv[<span class="number">1</span>]; *p != <span class="literal">NULL</span>; p++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-7-2-程序：核对行星的名字"><a href="#13-7-2-程序：核对行星的名字" class="headerlink" title="13.7.2    程序：核对行星的名字"></a>13.7.2    程序：核对行星的名字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_PLANETS 9<span class="comment">//行星的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//9大行星</span></span><br><span class="line">	<span class="keyword">char</span> *planets[] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Eath"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>,  <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Nepture"</span>, <span class="string">"Pluto"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以此访问每个参数，并遍历9大行星寻找匹配的目标</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NUM_PLANETS; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[i], planets[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is planets %d\n"</span>, argv[i], j+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j == NUM_PLANETS)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is not a planet\n"</span>, argv[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./planet Pluto  </span><br><span class="line"> Pluto is planets 9</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/12 指针和数组/" itemprop="url">
                  12 指针和数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:24:07+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/12 指针和数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/12 指针和数组/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="12-1-指针的算术运算"><a href="#12-1-指针的算术运算" class="headerlink" title="12.1    指针的算术运算"></a>12.1    指针的算术运算</h2><blockquote>
<p><strong>说明：</strong>指针不仅可以指向普通变量，还可以指向数组元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">//a[0]值变为5</span></span><br></pre></td></tr></table></figure>
<p><strong>3种格式：</strong></p>
<ol>
<li>指针加上整数</li>
<li>指针减去整数</li>
<li>两个指针相减</li>
</ol>
<h3 id="12-1-1-指针加上整数"><a href="#12-1-1-指针加上整数" class="headerlink" title="12.1.1    指针加上整数"></a>12.1.1    指针加上整数</h3><blockquote>
<p><strong>说明：</strong>指针<code>p</code>加上整数<code>j</code>产生指向<code>p</code>元素后<code>j</code>个位置的指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line">q = p + <span class="number">3</span>;<span class="comment">//p指向了数组下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-2-指针减去整数"><a href="#12-1-2-指针减去整数" class="headerlink" title="12.1.2    指针减去整数"></a>12.1.2    指针减去整数</h3><blockquote>
<p><strong>说明：</strong>如果<code>p</code>指向数组元素<code>a[i]</code>，那么<code>p-j</code>指向<code>a[i-j]</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">8</span>];</span><br><span class="line">q = p<span class="number">-3</span>;<span class="comment">//指向数组a下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-指针相减"><a href="#12-1-3-指针相减" class="headerlink" title="12.1.3    指针相减"></a>12.1.3    指针相减</h3><blockquote>
<p><strong>说明：</strong>当两个指针相减时，结果为指针之间的距离。<br><strong>用途：</strong>用来计算数组种元素的个数。如果<code>p</code>指向<code>a[i]</code>且<code>q</code>指向<code>a[j]</code>，那么<code>p-q</code>就等于<code>i-j</code>。<br><strong>限制：</strong></p>
<ul>
<li>只有在<code>p</code>指向数组元素时，指针<code>p</code>上的算数运算才会获得意义的结果</li>
<li>只有在两个指针指向同一个数组时，指针相减才有意义</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">i = p - q;<span class="comment">//4</span></span><br><span class="line">i = q - p;<span class="comment">//-4</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-指针比较"><a href="#12-1-4-指针比较" class="headerlink" title="12.1.4    指针比较"></a>12.1.4    指针比较</h3><blockquote>
<p><strong>说明：</strong>可以用关系运算符（<code>&lt;</code> <code>&lt;=</code>  <code>&lt;</code>  <code>&gt;=</code>）和判等运算符（<code>==</code>和<code>!=</code>）。<br><strong>限制：</strong>只有在两个指针指向同一个数组时，用关系运算符进行的指针比较才有意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p &lt;= q;<span class="comment">//0</span></span><br><span class="line">q &gt; p;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h2 id="12-2-指针用于数组处理"><a href="#12-2-指针用于数组处理" class="headerlink" title="12.2    指针用于数组处理"></a>12.2    指针用于数组处理</h2><blockquote>
<p><strong>说明：</strong>指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。<br><strong>注意：</strong>数组<code>a</code>的下标是<code>0到N-1</code>,但<code>&amp;a[N]</code>是合法的，只要不尝试对该地址存储空间进行读取活写入，就是安全的。<br><strong>性能：</strong>一些编译器依赖下标而不是指针产生的循环代码性会更好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N], sum, *p;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符和-运算符的组合"><a href="#运算符和-运算符的组合" class="headerlink" title="*运算符和++运算符的组合"></a><code>*</code>运算符和<code>++</code>运算符的组合</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*p++</code>或<code>*(p++)</code></td>
<td>表达式的值是<code>*p</code>，然后<code>p</code>自增1</td>
</tr>
<tr>
<td><code>(*p)++</code></td>
<td>表达式的值为<code>*p</code>，然后<code>*p</code>自增1</td>
</tr>
<tr>
<td><code>*++p</code></td>
<td>先自增<code>p</code>，在自增后的指针对应的值</td>
</tr>
<tr>
<td><code>++*p</code>或<code>++(*p)</code></td>
<td>表达式的值是<code>*p</code>自增后的值</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(p &lt; &amp;a[N])&#123;</span><br><span class="line">	sum += *p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程序-栈"><a href="#程序-栈" class="headerlink" title="程序:栈"></a>程序:栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> *top = contents[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = &amp;contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[STACK_SIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		*top++ = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return *--top;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-用数组名作为指针"><a href="#12-3-用数组名作为指针" class="headerlink" title="12.3    用数组名作为指针"></a>12.3    用数组名作为指针</h2><blockquote>
<p><strong>说明：</strong>可以用数组的名字作为指向数组第一个元素的指针。<br><strong>意义：</strong>简化了指针的算术运算，而且使得数组和指针都更加通用。<br><strong>局限：</strong>虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其它地方是错误的。所以当需要的时候，可以先将数组指针复制给其它变量，然后改变该指针变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">*a = <span class="number">7</span>;<span class="comment">//a[0]=7</span></span><br><span class="line">*(a+<span class="number">1</span>); = <span class="number">12</span>;<span class="comment">//a[1]=12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-1-程序：数列反向（改进版）"><a href="#12-3-1-程序：数列反向（改进版）" class="headerlink" title="12.3.1    程序：数列反向（改进版）"></a>12.3.1    程序：数列反向（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reverses a series of numbers (pointer version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//输入N个数组存储到数组中</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers\n"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//逆向打印所有数组元素</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In reverse order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a + N <span class="number">-1</span>; p &gt;= a; p--)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">" %d"</span>, *p);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./reverse2                             </span><br><span class="line"> Enter 10 numbers</span><br><span class="line"> 1 2 3 4 5 6 7 8 9 0</span><br><span class="line"> In reverse order: 0 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<h3 id="12-3-2-数组型实际参数（改进版）"><a href="#12-3-2-数组型实际参数（改进版）" class="headerlink" title="12.3.2    数组型实际参数（改进版）"></a>12.3.2    数组型实际参数（改进版）</h3><blockquote>
<p><strong>说明：</strong>数组作为实参传递给函数是是作为指针传递的（传引用），而不会复制数组。</p>
</blockquote>
<ul>
<li><p>因为没有对数组进行复制，所以数组作为实际参数不会防止原数组被修改<br><strong>防改变：</strong>为了指明数组形式参数不会改变，可以在它的声明中包含单词<code>const</code></p>
</li>
<li><p>给函数传递数组所需的时间不依赖于数组的大小</p>
</li>
<li>声明形参时，数组型式和指针形式等价，编译器处理这两类声明就好像它们是完全一样的<br><strong>局限：</strong>不适用于普通变量的声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];<span class="comment">//会导致编译器为10个证书预留空间</span></span><br><span class="line"><span class="keyword">int</span> *a;<span class="comment">//会导致编译器为指针变量分配空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以给形式参数为数组的函数传递数组的“片段”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, max;</span><br><span class="line">	max = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; max)&#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">4</span>, b = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> larget = find_largest(b, N);<span class="comment">//会把数组b的第一个元素的地址赋给a，数组本身并没有复制</span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-3-用指针作为数组名"><a href="#12-3-3-用指针作为数组名" class="headerlink" title="12.3.3    用指针作为数组名"></a>12.3.3    用指针作为数组名</h3><blockquote>
<p><strong>说明：</strong>指向数组的指针除了可以通过指针的方式操作数组外，还可以将该指针当作数组来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> a[N], i, sum = <span class="number">0</span>, *p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	sum += p[i];<span class="comment">//*(p+i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-4-指针和多维数组"><a href="#12-4-指针和多维数组" class="headerlink" title="12.4    指针和多维数组"></a>12.4    指针和多维数组</h2><h3 id="12-4-1-处理多维数组的元素"><a href="#12-4-1-处理多维数组的元素" class="headerlink" title="12.4.1    处理多维数组的元素"></a>12.4.1    处理多维数组的元素</h3><blockquote>
<p><strong>说明：</strong>可以通过指针递增的方式访问到多维数组的每一个元素，因为c语言始终按照顺序存储多维数组的元素。</p>
</blockquote>
<p><em>数组遍历（数组下标的方式）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="comment">//将数组元素初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">0</span>; row &lt; NUM_ROWS; row++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(col = <span class="number">0</span>; col &lt; NUM_COLS; col++)&#123;</span><br><span class="line">		a[row][col] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>数组遍历（指针的方式）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>][<span class="number">0</span>]; p &lt;= &amp;a[NUMROWS<span class="number">-1</span>][NUM_COLS<span class="number">-1</span>]; P++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-2-处理多维数组的行"><a href="#12-4-2-处理多维数组的行" class="headerlink" title="12.4.2    处理多维数组的行"></a>12.4.2    处理多维数组的行</h3><blockquote>
<p><strong>说明：</strong>二维数组第<code>i</code>(从0开始)行第一个元素的地址<br><code>a[i]</code> == <code>*(a + i)</code> ==<code>&amp;a[i][0]</code> == <code>&amp;(*(a[i] + 0))</code> == <code>&amp;*a[i]</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[NUM_ROWS][NUM_COLS], *p, i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//初始化a的第i行元素为0</span></span><br><span class="line"><span class="keyword">for</span>(p = a[i]; p &lt; a[i] + NUM_COLS; p++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-3-用多维数组名作为指针"><a href="#12-4-3-用多维数组名作为指针" class="headerlink" title="12.4.3    用多维数组名作为指针"></a>12.4.3    用多维数组名作为指针</h3><p><strong>指针的指针：</strong><code>int a[10], b[10][10];</code></p>
<blockquote>
<p><code>a</code>可以看作是<code>int *</code>型的指针，而<code>b</code>用作指针时则是<code>int **</code>型的（指针某个整数的指针的指针）。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/11 指针/" itemprop="url">
                  11 指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:05:35+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/11 指针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/11 指针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>字节(byte)：</strong>大多数现代计算机用字节来分割内存，每个字节可以存储8位信息。每个字节都有唯一的地址，用来和内存中的其他字节进行区别。<br><strong>变量在内存中的地址：</strong>程序中的每个变量占有一个或多个内存字节，把第一个字节的地址称为变量的地址。<br><strong>指针变量：（pointer variable）</strong>虽然可以用整数表示地址，但是其取值单位可能不同于整数的范围，所以一定不能用普通整型变量存储地址。但是，可以用热熟的指针变量存储地址。<br><strong>指针：</strong>在用指针变量p存储变量i的地址时，我们说成是p“指向”i。换句话说，指针就是地址，而且指针变量是只存储地址的变量。</p>
<h2 id="11-1声明指针变量"><a href="#11-1声明指针变量" class="headerlink" title="11.1声明指针变量"></a>11.1声明指针变量</h2><p><strong>语法：</strong><code>int *p</code></p>
<ul>
<li>必须在指针变量名字前放置<code>*</code></li>
<li>可以和其他变量一起出现在声明中</li>
<li>每个指针变量唯一指向特定类型（引用类型）的对象</li>
<li>对指针可以指向的引用类型没有限制，甚至可以指向另一个指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, i, a[<span class="number">10</span>], *p;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-取地址运算符和间接寻址运算符"><a href="#11-2-取地址运算符和间接寻址运算符" class="headerlink" title="11.2    取地址运算符和间接寻址运算符"></a>11.2    取地址运算符和间接寻址运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;变量</code></td>
<td>取地址运算符</td>
<td>找到变量的地址</td>
</tr>
<tr>
<td><code>*指针变量</code></td>
<td>间接寻址运算符</td>
<td>找到指针指向的对象</td>
</tr>
</tbody>
</table>
<h3 id="11-2-1-取地址运算符"><a href="#11-2-1-取地址运算符" class="headerlink" title="11.2.1    取地址运算符"></a>11.2.1    取地址运算符</h3><p><strong>先声明后赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p;</span><br><span class="line">p = &amp;i;</span><br></pre></td></tr></table></figure>
<p><strong>声明的同时赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-间接寻址运算符"><a href="#11-2-2-间接寻址运算符" class="headerlink" title="11.2.2    间接寻址运算符"></a>11.2.2    间接寻址运算符</h3><blockquote>
<p><strong>说明：</strong>一旦指针变量指向指向了对象，就可以使用<code>*</code>运算符访问存储在对象中的内容。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);<span class="comment">//*p等价于i</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>不要把间接寻址运算符用于未初始化的指针变量。否则一旦改变未知的内存单元可能会导致不规律的行为或操作系统的崩溃。</p>
<h2 id="11-3-指针赋值"><a href="#11-3-指针赋值" class="headerlink" title="11.3    指针赋值"></a>11.3    指针赋值</h2><blockquote>
<p><strong>前提：</strong>两个指针具有相同的类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, *p, *q;</span><br><span class="line">p = &amp;i;</span><br><span class="line">q = p;<span class="comment">//把i的地址右赋值给了p，此时右两个指针同时指向i</span></span><br></pre></td></tr></table></figure>
<h2 id="11-4-指针作为实际参数"><a href="#11-4-指针作为实际参数" class="headerlink" title="11.4    指针作为实际参数"></a>11.4    指针作为实际参数</h2><blockquote>
<p><strong>背景：</strong>c语言的参数传递机制为“值传递”，参数传递进来的是变量的副本。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_part;</span><br><span class="line"><span class="keyword">float</span> frace_part;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *frac_part)</span></span>;</span><br><span class="line"><span class="comment">//或void decompose(float x, int *, float *);</span></span><br><span class="line">decompose(<span class="number">3.1415926</span>, &amp;i, &amp;f);</span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义*/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 取出一个浮点数的整数部分和小数部并分别赋值给两个外部变量</span><br><span class="line">* @param x 目标浮点数</span><br><span class="line">* @param *int_part 存储整数部分的地址</span><br><span class="line">* @param *fract_part 存储小数部分的变量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *fract_part)</span></span>&#123;</span><br><span class="line">	*int_part = (int) x;</span><br><span class="line">	*fract_part = x - *int_part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-1-程序：找出数组中的最大元素和最小元素"><a href="#11-4-1-程序：找出数组中的最大元素和最小元素" class="headerlink" title="11.4.1    程序：找出数组中的最大元素和最小元素"></a>11.4.1    程序：找出数组中的最大元素和最小元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Finds the largest and smallest elements in an array</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> b[N], i, big, small;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers:"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	max_min(b, N, &amp;big, &amp;small);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Largest: %d\n"</span>, big);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"smallest: %d\n"</span>, small);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 找出最大值和最小值并将结果赋给响应指针对应的变量</span><br><span class="line"> * @param a   数组</span><br><span class="line"> * @param n   数组大小</span><br><span class="line"> * @param max 存储最大值的变量</span><br><span class="line"> * @param min 存储最小值的变量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	*max = *min = a[<span class="number">0</span>];</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line"> 			*max = a[i];</span><br><span class="line"> 		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line"> 			*min = a[i];</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./maxmin </span><br><span class="line"> Enter 10 numbers:1 2 3 4 5 6 7 8 9 10</span><br><span class="line"> Largest: 10</span><br><span class="line"> smallest: 1</span><br></pre></td></tr></table></figure>
<h3 id="11-4-2-用const保护实际参数"><a href="#11-4-2-用const保护实际参数" class="headerlink" title="11.4.2    用const保护实际参数"></a>11.4.2    用const保护实际参数</h3><p><strong>使用指针替代变量副本：</strong>如果需要大量的存储空间，那么传递变量的值可能浪费时间和空间。<br><strong>const：</strong>放在形式参数的类型说明之前，证明函数不会改变传递给函数的指针所指向的对象。试图改变用<code>const</code>修饰的形参对应的实参会引发编译器发出特定消息。</p>
<h2 id="11-5-指针作为返回值"><a href="#11-5-指针作为返回值" class="headerlink" title="11.5    指针作为返回值"></a>11.5    指针作为返回值</h2><p><strong>用途：</strong>函数返回结果的内存位置而不是返回值。<br><strong>场景：</strong></p>
<ol>
<li>返回指向外部变量的指针</li>
<li>返回声明为<code>static</code>的局部变量的指针</li>
<li><strong>限制：</strong>永远不会返回指向自动局部变量的指针，因为函数返回后局部变量的存储空间就不存在了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">max</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*a &gt; *b)&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p, x, y;</span><br><span class="line">p = max(*x, &amp;y);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/10 程序结构/" itemprop="url">
                  10 程序结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T22:53:52+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/10 程序结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/10 程序结构/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="10-1-局部变量"><a href="#10-1-局部变量" class="headerlink" title="10.1    局部变量"></a>10.1    局部变量</h2><p><strong>局部：</strong>在函数体内声明的变量称为相对于函数的局部。<br><strong>存储期限（storage duration）：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。<br><strong>特点：</strong></p>
<ul>
<li><strong>自动存储期限：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。在闭合函数返回时收回分配。</li>
<li><strong>程序快作用域：</strong>变量的作用域是可以参考变量的程序文本的部分。从变量声明的点开始一直到闭合函数的末尾。局部变量拥有程序块作用域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">log</span> = <span class="number">0</span>;<span class="comment">/*局部变量*/</span></span><br><span class="line">   <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">     n /= <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">log</span>++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-1-静态存储期限：static"><a href="#10-1-1-静态存储期限：static" class="headerlink" title="10.1.1 静态存储期限：static"></a>10.1.1 静态存储期限：<code>static</code></h3><p><strong>特点：</strong>具有静态存储期限的变量拥有永久的存储单元，所以会在整个程序执行期间会保留变量的值。</p>
<ol>
<li>静态局部变量始终有程序块作用域，它对其他函数而言是不可见的</li>
<li>静态变量是隐藏来自其他函数的数据的地方，但是它会为将来同一个函数的调用保留这些数据。</li>
</ol>
<p><strong>声明方式：</strong>在局部变量声明中放置单词<code>static</code>可以使用变量从自动存储期限变为静态存储期限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*因为局部变量i已经声明为static，所以在程序执行期间它占有同样的存储单元。在f返回时，变量i不会丢失自身的值。*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-形式参数"><a href="#10-1-2-形式参数" class="headerlink" title="10.1.2 形式参数"></a>10.1.2 形式参数</h3><p><strong>和局部变量比较</strong></p>
<ul>
<li><strong>相同点：</strong>自动存储期限、块级作用域</li>
<li><strong>不同点：</strong>在每次函数调用时对形式参数自动进行初始化（调用中通过赋值获得实际参数的值）</li>
</ul>
<h2 id="10-2-外部变量"><a href="#10-2-外部变量" class="headerlink" title="10.2    外部变量"></a>10.2    外部变量</h2><blockquote>
<p><strong>又名：</strong>全局变量<br><strong>声明位置：</strong>外部变量是声明在任何函数体外的。<br><strong>性质：</strong></p>
<ul>
<li>静态存储期限：同声明的static的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。</li>
<li>文件作用域：从变量声明的点开始一直到闭合文件的末尾。跟随在外部变量声明后的所有函数都可以访问它。</li>
</ul>
</blockquote>
<h3 id="10-2-1-程序：用外部变量实现栈"><a href="#10-2-1-程序：用外部变量实现栈" class="headerlink" title="10.2.1    程序：用外部变量实现栈"></a>10.2.1    程序：用外部变量实现栈</h3><blockquote>
<p><strong>栈（stack）：</strong>像数组一样，栈可以存储具有相同数据类型的多个数据项。<br><strong>操作方式：</strong>LIFO(后进先出)，占中数据项的操作是十分受限制的，可以忘栈中压入数据，或者从栈中弹出数据项。禁止测试或修改不在栈顶的数据项。<br><strong>c语言实现：</strong>把元素存储在数组中，称为<code>constents</code>,命名为top的一个整型变量用来标记栈栈顶的位置。栈为空时，top值为0。为了往栈中压入数据项，可以把数据项简单存储在contents中标记为top的位置上，然后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>中标记为top的位置上，谈后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>的索引取回弹出的数据项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		contents[top++] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return contents[--top];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-外部变量的利与弊"><a href="#10-2-2-外部变量的利与弊" class="headerlink" title="10.2.2 外部变量的利与弊"></a>10.2.2 外部变量的利与弊</h3><blockquote>
<p><strong>利：</strong>有利于多个函数必须共享一个变量或者上述几个函数共享大量变量。<br><strong>蔽：</strong></p>
<ol>
<li>可维护性差：如果改变外部变量，那么需要检查同一个文件中的每个函数，确认该改变对函数的影响。</li>
<li>可读性差：如果外部变量出现问题，难以确定导致这个值发生错误的函数。</li>
<li>可复用性差：很难再其他城程序中复用依赖于外部变量的函数。因为以来外部变量的函数不是“独立的”。</li>
</ol>
<p><strong>技巧：</strong>为了提高可阅读性和可能的错误，使用外部变量时，确保它们都拥有有意义的名字。</p>
</blockquote>
<h3 id="10-2-3-程序：猜数（略）"><a href="#10-2-3-程序：猜数（略）" class="headerlink" title="10.2.3 程序：猜数（略）"></a>10.2.3 程序：猜数（略）</h3><h2 id="10-3-程序块"><a href="#10-3-程序块" class="headerlink" title="10.3    程序块"></a>10.3    程序块</h2><blockquote>
<p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    多条声明</span><br><span class="line">    多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>作用域：</strong>程序块中的变量具有进入程序块时为存储变量分配单元，而在退出程序块时解除分配。<br><strong>函数体（也是程序块）放置临时变量的优点：</strong></p>
<ol>
<li>避免函数体起始位置的声明与只是临时使用的变量相混淆</li>
<li>减少了名字冲突</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = i;</span><br><span class="line">	i = j;</span><br><span class="line">	j = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-作用域"><a href="#10-4-作用域" class="headerlink" title="10.4    作用域"></a>10.4    作用域</h2><blockquote>
<p><strong>规则：</strong></p>
<ol>
<li>标识符拥有文件作用域，即在所声明的闭合程序块内有效</li>
<li>新的声明临时会“隐藏”旧的声明</li>
<li>在程序块结束后后面，被“隐藏”的标识符重新获得旧的含义</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第1个*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第2个*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*第3个*/</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/*第4个*/</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		i = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-5-构建c-程序"><a href="#10-5-构建c-程序" class="headerlink" title="10.5    构建c 程序"></a>10.5    构建c 程序</h2><p><strong>程序构成要素：</strong></p>
<ul>
<li>预处理指令：诸如<code>#include</code>和<code>#define</code></li>
<li>类型定义</li>
<li>函数声明和外部变量声明</li>
<li>函数定义</li>
</ul>
<p><strong>建议编排顺序：</strong></p>
<ol>
<li>#include指令</li>
<li>define指令</li>
<li>类型定义（typedef）</li>
<li>外部变量声明</li>
<li>除main函数之外的函数原型</li>
<li>main函数的定义</li>
<li>其他函数的定义</li>
</ol>
<p><strong>建议函数注释：</strong>盒形注释</p>
<ul>
<li>函数名</li>
<li>描述函数的目的</li>
<li>讨论每个参数的含义</li>
<li>描述返回值</li>
<li>罗列任何的副作用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/9 函数/" itemprop="url">
                  9 函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T19:06:38+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/9 函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/9 函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="9-1-函数的定义和调用"><a href="#9-1-函数的定义和调用" class="headerlink" title="9.1    函数的定义和调用"></a>9.1    函数的定义和调用</h2><blockquote>
<p><strong>语法</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>简析</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回类型（return type）</td>
<td>每次调用函数返回数据的类型，当不需要返回值时使用<code>void</code></td>
</tr>
<tr>
<td>形式参数（parameter）</td>
<td>每一个参数都必须有类型，没有行参使用<code>void</code></td>
</tr>
<tr>
<td>函数体（body）</td>
<td>用<code>{}</code>括起来的执行部分</td>
</tr>
<tr>
<td>实际参数（argument）</td>
<td>为了激活（即调用（call））函数，需要写出函数名及跟随其后的实际参数列表</td>
</tr>
</tbody>
</table>
<h3 id="9-1-1-程序：计算平均值"><a href="#9-1-1-程序：计算平均值" class="headerlink" title="9.1.1    程序：计算平均值"></a>9.1.1    程序：计算平均值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes pairwise averages of three numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>&#123;</span><br><span class="line"> 	return (a+b) / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter three numbers:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f%f%f"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, y, average(x,y));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, y, z, average(y,z));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, z, average(x,z));</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./average</span><br><span class="line"> Enter three numbers:1 2 3</span><br><span class="line"> Average of 1 and 2: 1.5</span><br><span class="line"> Average of 2 and 3: 2.5</span><br><span class="line"> Average of 1 and 3: 2</span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-程序：显示倒数计时"><a href="#9-1-2-程序：显示倒数计时" class="headerlink" title="9.1.2    程序：显示倒数计时"></a>9.1.2    程序：显示倒数计时</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a countdown</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, n);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">10</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line"> 		print_count(i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./countdwn </span><br><span class="line">T minus 10 and counting</span><br><span class="line">T minus 9 and counting</span><br><span class="line">T minus 8 and counting</span><br><span class="line">T minus 7 and counting</span><br><span class="line">T minus 6 and counting</span><br><span class="line">T minus 5 and counting</span><br><span class="line">T minus 4 and counting</span><br><span class="line">T minus 3 and counting</span><br><span class="line">T minus 2 and counting</span><br><span class="line">T minus 1 and counting</span><br></pre></td></tr></table></figure>
<h3 id="9-1-3-程序：显示双关语"><a href="#9-1-3-程序：显示双关语" class="headerlink" title="9.1.3    程序：显示双关语"></a>9.1.3    程序：显示双关语</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a bad pun</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	print_pun();</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./pun2</span><br><span class="line"> To c, or not to c:that is the question.</span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-函数定义"><a href="#9-1-4-函数定义" class="headerlink" title="9.1.4    函数定义"></a>9.1.4    函数定义</h3><blockquote>
<p><strong>函数定义：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  声明</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数无法返回数组，但是没有其它关于返回类型的限制</li>
<li>如果忽略返回类型，那么会假定函数返回值的类型时<code>int</code>型</li>
<li>制定返回类型是<code>void</code>型说明函数没有返回值</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>为每个函数指定一个明显的返回类型是一个很好的方法（<code>void</code>也可以省略，毕竟经典c没有<code>void</code>概念，但不推荐这样）</li>
<li>如果返回值很冗长，比如<code>unsigned long int</code>，那么把返回类型单独放一行是非常有用的</li>
</ul>
</blockquote>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>需要在每个形式参数的前面说明其类型</li>
<li>形式参数间用逗号进行分隔</li>
<li>如果函数没有形式参数，那么在圆口哈没应该出现<code>void</code></li>
<li>即使有些行参具有相同数据类型，也必须对每个形式参数分别进行类型说明</li>
</ul>
</blockquote>
<h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数体内声明的变量专属于此函数，其它函数不能对这些变量进行检查或修改</li>
<li>函数体可以为空，以后可以回来编写它的函数体</li>
</ul>
</blockquote>
<h3 id="9-1-5-函数调用"><a href="#9-1-5-函数调用" class="headerlink" title="9.1.5    函数调用"></a>9.1.5    函数调用</h3><blockquote>
<p><strong>语法：</strong><code>[强制转换返回类型] 函数名(实参1, 实参2 ...);</code><br><strong>有无返回值的函数调用的区别：</strong>void型的函数调用是语句，所以调用后边始终跟着分号；非void型的函数调用是表达式。<br><strong>注意：</strong>丢掉圆括号仍然是合法的表达式，但不起任何作用，有些编译器会给出警告。</p>
</blockquote>
<h4 id="强制转换返回类型"><a href="#强制转换返回类型" class="headerlink" title="[强制转换返回类型]"></a>[强制转换返回类型]</h4><blockquote>
<p><strong>说明：</strong>很少用到，可以省略<br><strong>技巧：</strong>可以将返回值强制类型转换成<code>void</code>，使别人清楚编写者使故意扔掉返回值的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"Hi, Mom!\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-程序：判定素数"><a href="#9-1-6-程序：判定素数" class="headerlink" title="9.1.6    程序：判定素数"></a>9.1.6    程序：判定素数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests whether a number is prime</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"> <span class="function">Bool <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> divisor;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"> 		return FALSE;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">for</span>(divisor = <span class="number">2</span>; divisor * divisor &lt;= n; divisor++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(n % divisor == <span class="number">0</span>)&#123;</span><br><span class="line"> 			return FALSE;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return TRUE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> 	<span class="keyword">if</span>(is_prime(n))&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"'Prime'\n"</span>);</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Not prime\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./prime </span><br><span class="line"> Enter a number:34</span><br><span class="line"> Not prime</span><br></pre></td></tr></table></figure>
<h2 id="9-2-函数声明"><a href="#9-2-函数声明" class="headerlink" title="9.2    函数声明"></a>9.2    函数声明</h2><blockquote>
<p><strong>背景：</strong>c语言没有要求函数的定义必须放置在<code>main</code>函数的定义之后。如果函数的定义在调用之后，那么编译器会为被调用的函数的函数做一些假设。如果假设错误，则程序无法正常工作。<br><strong>说明：</strong>在调用前声明（declare）每个函数，函数声明是的编译器对函数进行概要浏览，而函数的完整定义稍后再出现。</p>
<blockquote>
<p><strong>函数原型（function prototype）：</strong><code>Q&amp;A</code>中将这种函数声明称为函数原型。原型为如何调用函数提供了一个完整的描述：提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型。<br><strong>行参规则：</strong>可以不写形式参数的名字，只要显示类型就可以，<code>float average(float float)</code>，但不建议，为了代码的可阅读性和可维护性。</p>
</blockquote>
<p><strong>语法：</strong><code>返回类型 函数名（形式参数）;</code><br><strong>注意：</strong>函数的声明必须和函数的定义一致。</p>
</blockquote>
<h2 id="9-3-实际参数"><a href="#9-3-实际参数" class="headerlink" title="9.3    实际参数"></a>9.3    实际参数</h2><blockquote>
<p><strong>实参和形参：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式参数(parameter)</td>
<td>出现在函数定义中，它们以假名字来表示函数调用时提供的值</td>
</tr>
<tr>
<td>实际参数(argument)</td>
<td>出现在函数调用中的表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>通过值传递：</strong>调用函数时，计算出每个实际参数的值并且把它赋值给相应的形式参数。</p>
<blockquote>
<p><strong>特点：</strong>在函数的执行过程中，对形式参数的改变不会影响实际参数的值。</p>
</blockquote>
</blockquote>
<h3 id="9-3-1-实际参数的转换"><a href="#9-3-1-实际参数的转换" class="headerlink" title="9.3.1    实际参数的转换"></a>9.3.1    实际参数的转换</h3><blockquote>
<p><strong>说明：</strong>c语言允许在实际参数的类型和形式参数的类型不匹配的情况下进行函数调用。<br><strong>实参转换规则：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>编译器在调用前是否遇到原型</th>
<th>转换方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>实参的值被隐式转换成相应形式参数的类型。</td>
</tr>
<tr>
<td>否</td>
<td>编译器执行默认的实际参数提升</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>默认的实际参数提升</strong></p>
<ol>
<li>把<code>float</code>型的实际参数转换成<code>double</code>类型</li>
<li>执行整数的提升（即把<code>char</code>型和<code>short</code>型的实际参数转换成<code>int</code>型）<br><strong>注意：</strong>默认的实际参数提升不总会获得期望的效果<br><strong>技巧：</strong>始终在调用函数前声明函数非常必要。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter number to be squard:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">	<span class="comment">//把变量i强制转换为正确的类型的方法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The answer if %g\n"</span>, square((double)i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-数组型实际参数"><a href="#9-3-2-数组型实际参数" class="headerlink" title="9.3.2    数组型实际参数"></a>9.3.2    数组型实际参数</h3><p><strong>语法：</strong><code>数组类型 数组实参名[数组长度]</code><br><strong>特点：</strong></p>
<ul>
<li>其中<code>数组长度</code>通常省略不写。即便写了在函数中仍然无法判断数组的长度。</li>
<li>多维数组形式参数只能忽略第一位的长度</li>
</ul>
<p><strong>获取实参数组长度：</strong>c语言没有提供任何简便的方法来确定传递给它的数组的长度。但是如果函数需要，必须把长度作为额外的实际参数提供给函数。<br><strong>注意：</strong>在函数内部通过<code>sizeof(a) / sizeof(a[0])</code>的方式并不能正确计算出传递进来的数组的长度。<br><strong>技巧：</strong>通过传递比数组实际长度小的整数参数，来部分操作数组。<br><strong>延伸：</strong>不能传递令人困扰的具有任意列数的多维数组。幸运的是，我们经常可以通过使用指针数组的方式处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数原型*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//如果愿意可以省略形式参数的名字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b[LEN], total;</span><br><span class="line">	total = sun_array(b, LEN);<span class="comment">//在数组名传递给函数时，不要在数组名的后边放置方括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* params&#123;int Array&#125; a 数组</span><br><span class="line">* params&#123;int&#125; n 数组长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, sun = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		sun += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-return语句"><a href="#9-4-return语句" class="headerlink" title="9.4    return语句"></a>9.4    return语句</h2><blockquote>
<p><strong>return语句：</strong><code>return 表达式;</code><br><strong>隐式转换：</strong>如果<code>return</code>语句中表达式的类型和函数的返回类型不匹配，那么系统将会把表达式的类型隐式转换为返回类型<br><strong>立即返回：</strong>在返回类型为<code>void</code>的函数中可以使用<code>return;</code>，会导致函数立即返回，后面不能包含表达式</p>
</blockquote>
<p><strong><code>void</code>和非<code>void</code></strong></p>
<table>
<thead>
<tr>
<th>返回值类型是否为<code>void</code></th>
<th>是否必须<code>return</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td>是</td>
<td>必须使用<code>return 表达式</code>返回值，否则某些编译器会报错</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td><code>return</code>并不是必须的，因为在执行最后一条语句后函数将会自动跳转。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to C :that is the qyestion.\n"</span>)</span><br><span class="line">	return;<span class="comment">/*可以省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-5-程序终止"><a href="#9-5-程序终止" class="headerlink" title="9.5    程序终止"></a>9.5    程序终止</h2><blockquote>
<p><strong>状态码：</strong>即<code>main</code>函数的返回值，默认为<code>int</code>类型；或者<code>exit</code>函数的实参。</p>
<blockquote>
<p><strong>用途：</strong>在某些操作系统中程序终止时可以检测到状态码。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常终止</td>
<td>0</td>
</tr>
<tr>
<td>异常终止</td>
<td>非0</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>即使不打算用状态码，确信每个c程序都返回状态码也是一个很好的实践，因为某些运行程序的人可能稍后再决定测试状态码。</p>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><p><strong>功能：</strong>终止程序，相当于在<code>main</code>函数中使用<code>return</code>。<br><strong>实参：</strong>传递给<code>exit</code>函数的实际参数和<code>main</code>函数的返回值具有相同的含义，两者都说明程序终止时的状态。<br><strong>所在库：</strong><code>&lt;stdlib.h&gt;</code><br><strong>相关宏定义：</strong><code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>,值由实现定义，典型的值是0和1<br><strong>区别于<code>return</code>：</strong><code>return</code>和<code>exit</code>都可以在任何函数中调用，但<code>return</code>只有在<code>main</code>函数中调用才会终止程序；<code>exit</code>在任何函数中调用都会终止程序。<br><strong>技巧：</strong>一些程序员专门使用<code>exit</code>函数以便于模式匹配程序可以很容易地定位程序中全部的退出点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<h2 id="9-6-递归函数"><a href="#9-6-递归函数" class="headerlink" title="9.6    递归函数"></a>9.6    递归函数</h2><blockquote>
<p><strong>说明：</strong>如果函数调用它本身，那么此函数就是递归的（recursice）。<br><strong>技巧：</strong>为了防止无限递归，所有递归函数都需要某些类型的终止条件。<br><strong>注意：</strong>c语言允许递归，但大多数c程序员并不经常使用递归。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 计算n的阶乘</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">face</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return n * fact(n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 计算x^n</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	return n == <span class="number">0</span> ? <span class="number">1</span> : x * power(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-1-快速排序算法"><a href="#9-6-1-快速排序算法" class="headerlink" title="9.6.1    快速排序算法"></a>9.6.1    快速排序算法</h3><blockquote>
<p><strong>分治法(divide-and-conquer)：</strong>把一个大问题划分成多个较小的问题，然后采用相同的算法分别解决这些小问题。比如排序算法。<br><strong>算法操作：</strong></p>
<ol>
<li>选择数组元素e（作为“分割元素”），然后重新排列数组使得元素从1一直到i-1都是小雨或等于元素e的，元素i包含e，而元素从i-1一直到n都是大于或等于e的。</li>
<li>通过递归地采用快速排序算法，对从1到i-1的元素进行排序。</li>
<li>通过递归地采用快速排序方法，对从i+1到n的元素进行排序。</li>
</ol>
</blockquote>
<h4 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of integers using Quicksort algorthm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 12</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>&#125;;</span><br><span class="line"> 			  </span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line"> 	printArr(a, <span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印数组</span><br><span class="line"> * @param &#123;int&#125; a 需要打印的数组</span><br><span class="line"> * @param &#123;int&#125; flag 表示打印时排序处在的状态</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 自己实现的快排程序：快速排序</span><br><span class="line"> * @param &#123;int&#125; a[] 被排序的数组</span><br><span class="line"> * @param &#123;int&#125; low 起点</span><br><span class="line"> * @param &#123;int&#125; high 终点</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">myquicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"%d****%d\n"</span>, low, high);</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return ;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> middleValue = a[low];</span><br><span class="line"> 		<span class="keyword">int</span> emptyPoint = low;</span><br><span class="line"> 		<span class="keyword">int</span> newLow = low, </span><br><span class="line"> 			newHigh = high;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">/**</span><br><span class="line"> 		 * 只要low指针和high指针没有最后相遇，就交替往中间靠拢。并在在这个过程中完成位置的交换。</span><br><span class="line"> 		 * 原理是：有点像拆东墙补西墙，把中间数字两边的数字看作东墙和西墙的话，</span><br><span class="line"> 		 * 其实就是在东墙上找西墙上的砖补到西墙上，东墙被拿走砖的位置且只能是这个位置需要西墙去补。一来二去就完成了砖的交换过程。</span><br><span class="line"> 		 */</span></span><br><span class="line"> 		<span class="keyword">while</span>(newLow &lt; newHigh)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(newLow == emptyPoint)&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为低位：高位指针向左移动寻找比中间值小的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newHigh] &gt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newHigh--;	</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newHigh];</span><br><span class="line"> 				emptyPoint = newHigh;</span><br><span class="line"> 			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为高位：低位指针向右移动寻找比中间值大的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newLow] &lt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newLow++;</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newLow];</span><br><span class="line"> 				emptyPoint = newLow;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			printArr(a, <span class="number">1</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//标记</span></span><br><span class="line"> 		done:</span><br><span class="line"> 		a[emptyPoint] = middleValue;</span><br><span class="line"> 		printArr(a, <span class="number">0</span>);</span><br><span class="line"> 		<span class="keyword">if</span>(newLow &gt; low)&#123;</span><br><span class="line"> 			quicksort(a, low, newLow - <span class="number">1</span>);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span>(newHigh &lt; high)&#123;</span><br><span class="line"> 			quicksort(a, newHigh + <span class="number">1</span>, high);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-2-程序：快速排序"><a href="#9-6-2-程序：快速排序" class="headerlink" title="9.6.2 程序：快速排序"></a>9.6.2 程序：快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of intergers using Quicksort algorithm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="comment">/*声明函数*/</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], i;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*输入需要排队的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers to be sorted :"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*调用排序函数进行排序*/</span></span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*打印排序好的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In sorted order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 快排程序</span><br><span class="line"> * @param &#123;Array&#125; a 数组</span><br><span class="line"> * @param &#123;int&#125; low 开始下标 </span><br><span class="line"> * @param &#123;int&#125; high 结束下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> middle;</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//获得分段的中间位置</span></span><br><span class="line"> 	middle = split(a, low, high);</span><br><span class="line"> 	quicksort(a, low, middle <span class="number">-1</span>);</span><br><span class="line"> 	quicksort(a, middle + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> part_element = a[low];</span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">/*high指针向左移动寻找比part_element小的数，直到找到或low和high指针重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; part_element &lt;= a[high])&#123;</span><br><span class="line"> 			high--;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果重合了，说明没有找到</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果找到了，将找到的比中间值小的数放到当前low指针指向的位置，并将指针向右移动</span></span><br><span class="line"> 		a[low++] = a[high];</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">/*low指针向右移动，寻找比part_element大的数，直到找到一个或low和high重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= part_element)&#123;</span><br><span class="line"> 			low++;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//重合了就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果没重合，就讲找到的数移动到high指针指向的位置，并将high的指针向左移动一下</span></span><br><span class="line"> 		a[high--] = a[low];</span><br><span class="line"> 		return high;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-3-改进"><a href="#9-6-3-改进" class="headerlink" title="9.6.3    改进"></a>9.6.3    改进</h3><ol>
<li><p>改进分割算法</p>
<blockquote>
<p>上面介绍的方法不是最有效的。我们不再选择数组中的第一个元素作为分割元素，较好的方法是取第一个元素、中间元素和最后一个元素的中间值。分个过程本身也可以加速。特别是，在两个while循环中避免测试low&lt;high是可能的。</p>
</blockquote>
</li>
<li><p>采用不同的方法进行小数组排序</p>
</li>
<li><p>使得快速排序非递归</p>
<blockquote>
<p>虽然快速排序本质上是使用递归算法，并且递归格式的快速排序是最容易理解的，但是实际上若去掉递归会更有效率。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/8 数组/" itemprop="url">
                  8 数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:48:30+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/8 数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/8 数组/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>变量：</strong>变量分为两种</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>标量（scalar）</td>
<td>标亮具有保存单一数据项的能力</td>
</tr>
<tr>
<td>聚合（aggregate）</td>
<td>存储数值的集合（数组(array)和结构(structure)）</td>
</tr>
</tbody>
</table>
<h2 id="8-1-一维数组"><a href="#8-1-一维数组" class="headerlink" title="8.1    一维数组"></a>8.1    一维数组</h2><blockquote>
<p><strong>说明：</strong>数组是含有多个数据值的数据结构，并且每个数据之具有相同的数据类型。这些数据类型的值被称为元素（element）。<br><strong>声明数组：</strong>需要说明数组元素的<code>类型</code>(任何类型)和<code>数量</code>（任何整数常量表达式）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>因为程序后面变化时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br></pre></td></tr></table></figure>
<h3 id="8-1-1-数组下标"><a href="#8-1-1-数组下标" class="headerlink" title="8.1.1    数组下标"></a>8.1.1    数组下标</h3><blockquote>
<p><strong>说明：</strong>为了存取特定的数组元素，可以在写数组名的同时在后迷呐加上一个用方括号围绕的整数值（称这是对数组进行下标（subsvripting）或索引（indexing））。<br><strong>注意：</strong></p>
<ul>
<li><code>a[i]</code>的表达式格式是左值，所以数组元素可以和普通变量一样使用</li>
<li>在调用scanf函数读取数组元素时，就像对待普通变量一样，必须使用取地址符号<code>&amp;</code>。</li>
<li>c语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="comment">//对某些编译器来说，这个表面上正确的for语句却产生了一个无限循环</span></span><br><span class="line"><span class="comment">//如果i在内存中的位置在a[9]后面，那么修改a[10]其实是修改了i，使i变为0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		a[i] = <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>避免数组下标的副作用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不确定的做法</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; N)&#123;</span><br><span class="line">	a[i] = b[i++];<span class="comment">//i有可能会在复制发生之前就进行自增，导致两个数组错位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安全的做法</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	a[i] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">5</span>]);</span><br><span class="line">++a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空数组</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数组元素</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	sun += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-程序：数列反向"><a href="#8-1-2-程序：数列反向" class="headerlink" title="8.1.2    程序：数列反向"></a>8.1.2    程序：数列反向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reverse a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], i;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers:"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In reverse order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">" %d"</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./reverse</span><br><span class="line"> Enter 10 numbers:10</span><br><span class="line"> 9</span><br><span class="line"> 8</span><br><span class="line"> 7</span><br><span class="line"> 6</span><br><span class="line"> 5</span><br><span class="line"> 4</span><br><span class="line"> 3</span><br><span class="line"> 2</span><br><span class="line"> 1</span><br><span class="line"> In reverse order: 1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>
<h3 id="8-1-3-数组初始化"><a href="#8-1-3-数组初始化" class="headerlink" title="8.1.3    数组初始化"></a>8.1.3    数组初始化</h3><blockquote>
<p><strong>常量表达式列表规则：</strong></p>
<ul>
<li>列表用<code>{}</code>括起来，内部数值用<code>,</code>分隔</li>
<li>初始化式完全为空或比数组长度长是非法的，但可以比数组短，此时数组中生育的元素赋值为0</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整的格式</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略数组的长度，此时编译器会利用初始化式的长度确定数组的大小</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化式比数组长度短</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//&#123;1,2,3,4,5,6,0,0,0,0&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部数组元素初始化为0</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//&#123;0,0,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-1-4-程序：检查数中重复出现的数字"><a href="#8-1-4-程序：检查数中重复出现的数字" class="headerlink" title="8.1.4    程序：检查数中重复出现的数字"></a>8.1.4    程序：检查数中重复出现的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks numbers for repeated digits</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	Bool digit_seen[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> 	<span class="keyword">int</span> digit;</span><br><span class="line"> 	<span class="keyword">long</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> 		<span class="comment">//取个位数</span></span><br><span class="line"> 		digit  = n % <span class="number">10</span>;</span><br><span class="line"> 		<span class="comment">//检查个位数是不是已经有过一个了，是的话终止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(digit_seen[digit])&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//以当前个位数作为索引将对应数字元素的值改为TRUE</span></span><br><span class="line"> 		digit_seen[digit] = TRUE;</span><br><span class="line"> 		n /= <span class="number">10</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 		<span class="comment">//n&gt;0说明至少有一个数字发生了重复</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Repeated digit\n\n"</span>);</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"No repeated digit\n\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./repdigit </span><br><span class="line">Enter a number:12345677</span><br><span class="line">Repeated digit</span><br></pre></td></tr></table></figure>
<h3 id="8-1-5-对数组使用sizeof运算符"><a href="#8-1-5-对数组使用sizeof运算符" class="headerlink" title="8.1.5    对数组使用sizeof运算符"></a>8.1.5    对数组使用sizeof运算符</h3><blockquote>
<p><strong>用途：</strong></p>
<ul>
<li>计算数组的字节数</li>
<li>计算数组中每个元素的字节数</li>
<li>利用上面的结果计算数组的长度</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">10</span>]); i++)&#123;</span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>利用宏：</strong>简化用sizeof计算数组长度。更加有效的方式是使用带参数的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE (sizeof(a) / sizeof(a[0]))</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-6-程序：计算利息"><a href="#8-1-6-程序：计算利息" class="headerlink" title="8.1.6    程序：计算利息"></a>8.1.6    程序：计算利息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of compound interest</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NUM_RATES (sizeof(value) / sizeof(value[0]))</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> INITIAL_BALANCE 100.00</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, low_rate, num_years, year;</span><br><span class="line"> 	<span class="keyword">float</span> value[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter interest rate:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;low_rate);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of years:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num_years);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//表格标题行</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nYears"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM_RATES; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%6d%%"</span>, low_rate + i);<span class="comment">//两个%%代表要显示%字符串</span></span><br><span class="line"> 		value[i] = INITIAL_BALANCE;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	<span class="comment">//各个利率下逐年100美金的价值</span></span><br><span class="line"> 	<span class="keyword">for</span>(year = <span class="number">1</span>; year &lt;= num_years; year++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%3d    "</span>, year);</span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM_RATES; i++)&#123;</span><br><span class="line"> 			value[i] += (low_rate+i) / <span class="number">100.0</span> * value[i];</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"%7.2f"</span>, value[i]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);	</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./interest                            </span><br><span class="line"> Enter interest rate:5</span><br><span class="line"> Enter number of years:6</span><br><span class="line"></span><br><span class="line"> Years     5%     6%     7%     8%     9%</span><br><span class="line">  1     105.00 106.00 107.00 108.00 109.00</span><br><span class="line">  2     110.25 112.36 114.49 116.64 118.81</span><br><span class="line">  3     115.76 119.10 122.50 125.97 129.50</span><br><span class="line">  4     121.55 126.25 131.08 136.05 141.16</span><br><span class="line">  5     127.63 133.82 140.26 146.93 153.86</span><br><span class="line">  6     134.01 141.85 150.07 158.69 167.71</span><br></pre></td></tr></table></figure>
<h2 id="8-2-多维数组"><a href="#8-2-多维数组" class="headerlink" title="8.2    多维数组"></a>8.2    多维数组</h2><blockquote>
<p><strong>语法：</strong><code>m[i][j]</code><br><strong>注意：</strong>不能把<code>m[i][j]</code>写为<code>m[i, j]</code>。c语言把逗号看成是逗号运算符，所以<code>m[i,j]</code>等同于<code>m[j]</code>。<br><strong>地位：</strong>和其它编程语言中的多位数组相比， c语言中的多位数组扮演的角色相对较弱，这主要是因为c语言为存储多维数组提供了更加灵活的方法：指针数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">float</span> ident[N][N];</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">0</span>; row &lt; N; row++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(col = <span class="number">0</span>; col &lt; N; col++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(row == col)&#123;</span><br><span class="line">			ident[row][col] = <span class="number">1.0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ident[row][col] = <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-1-多为数组的初始化"><a href="#8-2-1-多为数组的初始化" class="headerlink" title="8.2.1    多为数组的初始化"></a>8.2.1    多为数组的初始化</h3><blockquote>
<p><strong>说明：</strong>通过嵌套一维初始化式的方式可以产生二维数组的初始化式。<br><strong>规则：</strong>c 语言提供了多种方法来缩写初始化式。</p>
<ul>
<li>如果初始化式不大到足以填满整个多位数组，那么数组中剩余的元素会被赋值为0。</li>
<li>如果内层的列表不大到足以填满数组的一行，那么慈航的剩余元素会被初始化为0。</li>
<li>可以忽略掉内层的大括号<br><strong>注意：</strong>在多维数组中忽略掉内层的大括号可能很危险，此外省略括号会引起某些编译器产生警告信息。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//行数不足</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//列数不足</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//忽略内层的大括号</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-2-常量数组"><a href="#8-2-2-常量数组" class="headerlink" title="8.2.2    常量数组"></a>8.2.2    常量数组</h3><blockquote>
<p><strong>语法：</strong><code>const 类型 数组名[]</code><br><strong>说明：</strong>程序不应对声明为<code>const</code>的数组进行修改。</p>
<ul>
<li>表明程序不会修改数组</li>
<li>告知不打算修改数组对编译器发现错误是很有帮助的</li>
</ul>
</blockquote>
<h3 id="8-2-3-发牌"><a href="#8-2-3-发牌" class="headerlink" title="8.2.3    发牌"></a>8.2.3    发牌</h3><blockquote>
<p><strong>相关函数：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>所属库</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>time</td>
<td>time.h</td>
<td>返回当前的时间，且这个时间是被编码成单独的数。</td>
</tr>
<tr>
<td>srand</td>
<td>stdlib.h</td>
<td>初始化c语言的随机数生成器</td>
</tr>
<tr>
<td>rand</td>
<td>stdlib.h</td>
<td>在每次调用时会产生一个显然随机的数</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Deals a random hand of cards</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SUITS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_RANKS 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Bool in_hand[NUM_SUITS][NUM_RANKS] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> num_cards, rank, suit;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> rank_code[] = &#123;<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'t'</span>,<span class="string">'j'</span>,<span class="string">'q'</span>,<span class="string">'k'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> suit_code[] = &#123;<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'s'</span>, <span class="string">'h'</span>&#125;;</span><br><span class="line">	srand((unsigned)time(NULL));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter number of cards in hand:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num_cards);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your hand:"</span>);</span><br><span class="line">	<span class="keyword">while</span>(num_cards &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		suit = rand() % NUM_SUITS;<span class="comment">//检出随机的花面</span></span><br><span class="line">		rank = rand() % NUM_RANKS;<span class="comment">//检出随机的纸牌等级</span></span><br><span class="line">		<span class="comment">//如果某张牌已经发出去过，则不能再发同样的牌，应当重新发</span></span><br><span class="line">		<span class="keyword">if</span>(!in_hand[suit][rank] == TRUE)&#123;</span><br><span class="line">			in_hand[suit][rank] = TRUE;</span><br><span class="line">			num_cards--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %c%c"</span>, rank_code[rank], suit_code[suit]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./deal                        </span><br><span class="line"> Enter number of cards <span class="keyword">in</span> hand:10</span><br><span class="line"> Your hand: 5s 6d th 9c 6s qs 7c 9d kh 2d</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/7 基本类型/" itemprop="url">
                  7 基本类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:39:48+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/7 基本类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/7 基本类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="7-1-整型"><a href="#7-1-整型" class="headerlink" title="7.1    整型"></a>7.1    整型</h2><blockquote>
<p><strong>可移植性技巧：</strong>对不超过32767的整数采用int或shaort int，其它情况下使用long int。<br><strong>注意：</strong>不要部分差别地使用长整型，因为长整型操作比较耗时。</p>
</blockquote>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>说明</th>
<th>bit（16位机器）</th>
<th>bit(32位机器)</th>
<th>数值范围(16位机器)</th>
<th>数值范围(32位机器)</th>
<th>有无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short [signed] int</code></td>
<td>短整型</td>
<td>16</td>
<td>16</td>
<td>-2^15~2^15-1</td>
<td>-2^15~2^15-1</td>
<td>有</td>
</tr>
<tr>
<td><code>short usigned int</code></td>
<td>无符号短整型</td>
<td>16</td>
<td>16</td>
<td>0~2^16-1</td>
<td>0~2^16-1</td>
<td>无</td>
</tr>
<tr>
<td><code>int [signed]</code></td>
<td>整型</td>
<td>16</td>
<td>32</td>
<td>-2^15~2^15-1</td>
<td>-2^31~2^31-1</td>
<td>有</td>
</tr>
<tr>
<td><code>int unsigned</code></td>
<td>无符号整型</td>
<td>16</td>
<td>32</td>
<td>0~2^16-1</td>
<td>0~2^32-1</td>
<td>无</td>
</tr>
<tr>
<td><code>long [signed]</code></td>
<td>长整型</td>
<td>32</td>
<td>32</td>
<td>-2^31~2^31-1</td>
<td>-2^31~2^31-1</td>
<td>有</td>
</tr>
<tr>
<td><code>long unsigned int</code></td>
<td>无符号长整型</td>
<td>32</td>
<td>32</td>
<td>0~2^32-1</td>
<td>0~2^32-1</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="7-1-1-整型常量"><a href="#7-1-1-整型常量" class="headerlink" title="7.1.1    整型常量"></a>7.1.1    整型常量</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>整数都是以二进制形式存储的，不会考虑实际的书写方式</li>
<li>任何时候都可以从一种书写方式切换到另一种，甚至可以混合使用</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>包含数字</th>
<th>写法</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>0~9</td>
<td>不能以0开头</td>
<td>15 255</td>
<td></td>
</tr>
<tr>
<td>八进制</td>
<td>0~7</td>
<td>必须以0开头</td>
<td>017 0377</td>
<td></td>
</tr>
<tr>
<td>十六进制</td>
<td>0~9和字母a~f</td>
<td>字母部分大小写均可</td>
<td>0xf</td>
</tr>
</tbody>
</table>
<h4 id="长整型和无符号整型"><a href="#长整型和无符号整型" class="headerlink" title="长整型和无符号整型"></a>长整型和无符号整型</h4><blockquote>
<p><strong>注意：</strong>默认情况下编译器对处于int类型取值范围内的整数使用int类型，否则使用long int。</p>
</blockquote>
<table>
<thead>
<tr>
<th>后缀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>U(u)</td>
<td>指定常量为无符号整型</td>
</tr>
<tr>
<td>L(l)</td>
<td>指定常量为长整型</td>
</tr>
</tbody>
</table>
<h3 id="7-1-2-读／写整数"><a href="#7-1-2-读／写整数" class="headerlink" title="7.1.2    读／写整数"></a>7.1.2    读／写整数</h3><blockquote>
<p><strong>溢出：</strong>当程序付给变量的值太大以至于无法存储在int类型中时，这时值会被处理为不符合预期的值。</p>
</blockquote>
<h4 id="printf函数和scanf函数"><a href="#printf函数和scanf函数" class="headerlink" title="printf函数和scanf函数"></a><code>printf</code>函数和<code>scanf</code>函数</h4><p><strong>有符号整数</strong></p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>类型</th>
<th>进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>int</td>
<td>十进制</td>
</tr>
<tr>
<td>%hd</td>
<td>short signed int</td>
<td>十进制</td>
</tr>
<tr>
<td>%ld</td>
<td>long signed int</td>
<td>十进制</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%hd"</span>, &amp;s);<span class="comment">//写：短整型</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;l);<span class="comment">//写：长整型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%hd"</span>, s);<span class="comment">//读：短整型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld"</span>, l);<span class="comment">//读：长整型</span></span><br></pre></td></tr></table></figure>
<p><strong>无符号整数</strong></p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>类型</th>
<th>进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>十进制数字</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>八进制</td>
</tr>
<tr>
<td>%x</td>
<td>unsigned int</td>
<td>十六进制</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>, %u);<span class="comment">//写：无符号十进制</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>, u);<span class="comment">//读：无符号十进制</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-程序：数列求和（改进版）"><a href="#7-1-3-程序：数列求和（改进版）" class="headerlink" title="7.1.3    程序：数列求和（改进版）"></a>7.1.3    程序：数列求和（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sums a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program sums a series of intergers.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter intergers (0 to terminate:)"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		sum += n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The sun is:%d\n"</span>, sum);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-浮点数"><a href="#7-2-浮点数" class="headerlink" title="7.2    浮点数"></a>7.2    浮点数</h2><blockquote>
<p><strong>IEEE浮点标准：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>bit</th>
<th>最小正数</th>
<th>最大值</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32</td>
<td>1.17x10^-38</td>
<td>3.40x10^38</td>
<td>6个数字</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>2.22x0^-308</td>
<td>1.79x10^308</td>
<td>15个数字</td>
</tr>
<tr>
<td>long float</td>
<td>>=43</td>
<td>未说明</td>
<td>未说明</td>
<td>未说明</td>
</tr>
<tr>
<td>long double</td>
<td>>=79</td>
<td>未说明</td>
<td>未说明</td>
<td>未说明</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>c语言浮点数：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>浮点数</th>
<th>说明</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>当精度要求不严格时，float类型是很适合的类型</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>提供更高的精度，适合绝大多数</td>
</tr>
<tr>
<td>long double</td>
<td>扩展双精度浮点数</td>
<td>支持极高精度的要求，很少会用到</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>long double类型没有出现在IEEE标准中，其长度随机器的不同而变化，最常通用的尺寸是80位和128位</li>
</ol>
</blockquote>
<h3 id="7-2-1-浮点常量"><a href="#7-2-1-浮点常量" class="headerlink" title="7.2.1    浮点常量"></a>7.2.1    浮点常量</h3><blockquote>
<p><strong>语法：</strong>必须包含小数点或指数<br><strong>举个栗子：</strong>57.0的多种写法</p>
</blockquote>
<p><code>57.0</code> <code>57.</code> <code>57.0e0</code> <code>57E0</code> <code>5.7e1</code> <code>5.7e+1</code> <code>.57e2</code> <code>570.e-1</code></p>
<blockquote>
<p><strong>存储方式：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>情景</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认情况</td>
<td><code>double</code></td>
</tr>
<tr>
<td><code>浮点常量F(f)</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>浮点常量L(l)</code></td>
<td><code>long double</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>double</code>类型的值在使用时，如果需要会自动转换为<code>float</code>类型的值。</p>
</blockquote>
<h3 id="7-2-2-读-些浮点数"><a href="#7-2-2-读-些浮点数" class="headerlink" title="7.2.2    读/些浮点数"></a>7.2.2    读/些浮点数</h3><table>
<thead>
<tr>
<th>浮点类型</th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
</tr>
<tr>
<td>double</td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
<td><code>%le</code> <code>%lf</code> <code>%lg</code></td>
</tr>
<tr>
<td>long double</td>
<td><code>%Le</code> <code>%Lf</code> <code>%Lg</code></td>
<td><code>%Le</code> <code>%Lf</code> <code>%Lg</code></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%Lf"</span>, &amp;ld);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%Lf"</span>, ld);</span><br></pre></td></tr></table></figure>
<h2 id="7-3-字符型"><a href="#7-3-字符型" class="headerlink" title="7.3    字符型"></a>7.3    字符型</h2><blockquote>
<p><strong>char：</strong><code>Q&amp;A</code> <code>char</code>类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。<br><strong>ASCII字符集：</strong>用7位代码表示128个字符，一些计算机把ASCII码扩展为8位代码以便可以表示256个字符。<br><strong>字符常量：</strong>字符常量需要用单引号括起来，而不是双引号。<br><strong>将<code>char</code>当作整数：</strong>c语言会按小整数的方式处理字符，毕竟所有字符都是以二进制的形式进行编码的。在ASCII码中，字符的取值范围是0000000(0)~1111111(127)。</p>
<blockquote>
<p><strong>优点：</strong>利用字符和数相同的属性灵活处理字符，例如<code>for(ch = &#39;A&#39;; ch &lt;= &#39;Z&#39;; ch++) ...</code><br><strong>缺点：</strong></p>
<ol>
<li>导致编译器无法检查出的多种编程错误</li>
<li>编写出诸如<code>&#39;a&#39; * &#39;b&#39; / &#39;c&#39;</code>这类无意义的表达式</li>
<li>妨碍程序的可移植性（因为程序可能会基于一些对字符集的假设）</li>
</ol>
</blockquote>
<p><strong>有符号和无符号</strong></p>
<blockquote>
<p><strong>编译器行为：</strong>一些编译器按照有符号数据(-128~127)处理<code>char</code>，另一些则为无符号(0~255)<code>char</code>。设置有些编译器允许程序员通过编译器选项选择<code>char</code>时有符号型还是无符号型<br><strong>可移植性技巧：</strong>用<code>signed char</code>或<code>unsigned char</code>代替<code>char</code>。</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="string">'a'</span>;<span class="comment">//i is now 97</span></span><br><span class="line">ch = <span class="number">65</span>;<span class="comment">//ch is now 'A'</span></span><br><span class="line">ch = ch + <span class="number">1</span>;<span class="comment">//ch is now 'B'</span></span><br><span class="line">ch++;<span class="comment">//ch is now 'C'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果ch时小写字母，转为大写字母</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">	ch = ch - <span class="string">'a'</span> + <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-1-转义序列"><a href="#7-3-1-转义序列" class="headerlink" title="7.3.1    转义序列"></a>7.3.1    转义序列</h3><blockquote>
<p><strong>用途：</strong>c语言为了处理字符集中的每一个字符，提供了<code>转义字符</code>用来表示一些不可见或无法从键盘输入的字符。<br><strong>字符转义字符：</strong>没有包含所有无法打印的ASCII字符，只包含了最常用的字符。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>转移序列</th>
</tr>
</thead>
<tbody>
<tr>
<td>警报（响铃）符</td>
<td>\a</td>
</tr>
<tr>
<td>回退符</td>
<td><code>\b</code></td>
</tr>
<tr>
<td>换页符</td>
<td><code>\f</code></td>
</tr>
<tr>
<td>换行符</td>
<td><code>\n</code></td>
</tr>
<tr>
<td>回车符</td>
<td><code>\r</code></td>
</tr>
<tr>
<td>横向制表符</td>
<td><code>\t</code></td>
</tr>
<tr>
<td>纵向制表符</td>
<td><code>\v</code></td>
</tr>
<tr>
<td>反斜杠</td>
<td><code>\\</code></td>
</tr>
<tr>
<td>问号</td>
<td><code>\?</code></td>
</tr>
<tr>
<td>单引号</td>
<td><code>\&#39;</code></td>
</tr>
<tr>
<td>双引号</td>
<td><code>\&quot;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>数字转义字符：</strong>可以表示任何字符，突破<code>字符转义字符</code>的限制。<br><strong>转义字符常量：</strong>有8进制和16进制两种书写方式，需要用一对单引号括起来。</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>书写方式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制转义序列</td>
<td><code>\最多含有三位数字的八进制数</code></td>
<td>必须表示为无符号字符型</td>
</tr>
<tr>
<td>十六进制转义序列</td>
<td><code>\x十六进制数</code></td>
<td>标准c对于数字个数没有限制，<code>x</code>必须为小写，十六进制数无限制</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define ESC '\33'	//用宏的方式定义数字转义字符常量</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>补充：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>其它序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>三字符序列（trigraph sequence）</td>
<td>一些特殊的ASCII字符的代码</td>
</tr>
<tr>
<td>多字节字符（multibyte character）</td>
<td></td>
</tr>
<tr>
<td>宽字符（nultibyte character）</td>
</tr>
</tbody>
</table>
<h3 id="7-3-2-字符处理函数"><a href="#7-3-2-字符处理函数" class="headerlink" title="7.3.2    字符处理函数"></a>7.3.2    字符处理函数</h3><blockquote>
<p><strong>toupper：</strong>c语言的toupper库函数，用来检测自身的参数是否是小写字母，如果是则将其转换成相应的大写字母。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">toupper</span>(ch)) == <span class="string">'A'</span>) ...</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-读-写字符"><a href="#7-3-3-读-写字符" class="headerlink" title="7.3.3    读/写字符"></a>7.3.3    读/写字符</h3><blockquote>
<p><strong>两种方式：</strong><code>printf</code>/<code>scanf</code>和<code>getChar</code>/<code>putchar</code></p>
</blockquote>
<h4 id="7-3-3-1-printf-和-scanf"><a href="#7-3-3-1-printf-和-scanf" class="headerlink" title="7.3.3.1    printf 和 scanf"></a>7.3.3.1    printf 和 scanf</h4><blockquote>
<p><strong>转换说明：</strong><code>%c</code><br><strong>技巧：</strong></p>
<ul>
<li>在格式串转换说明<code>%c</code>前面加一个空格，强制<code>scanf</code>函数在读入字符前跳过空白字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;ch);<span class="comment">//会跳过零个或多个空白字符</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通常情况下scanf函数不会跳过空白，所以很容易检查到输入行的结尾</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">&#125;<span class="keyword">while</span>(ch != <span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;hc);<span class="comment">//reads a single character</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);<span class="comment">//writes a single character</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-3-2-getchar-和-putchar"><a href="#7-3-3-2-getchar-和-putchar" class="headerlink" title="7.3.3.2    getchar 和 putchar"></a>7.3.3.2    getchar 和 putchar</h4><blockquote>
<p><strong>说明：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>库方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>getchar</td>
<td>读入一个字符并返回这个字符</td>
<td>不会跳过空白字符</td>
</tr>
<tr>
<td>putchar</td>
<td>用来单独写一个字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>执行速度快：</strong>比 scanf 和 printf 节约时间。</p>
<ol>
<li>这两个函数比scanf和prinf简单，因为scanf和prinf是设计用来读/写多种不同格式类型数据的</li>
<li>为了额外的速度提升，通常getchar函数和puchar函数是作为宏来实现的</li>
</ol>
<p><strong>可以应用多种不同的c语言惯用法：</strong>包括用循环搜索字符或跳过所有出现的统一字符。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环搜索字符</span></span><br><span class="line"><span class="keyword">while</span>(getchar != <span class="string">'\n'</span>)</span><br><span class="line">;</span><br><span class="line"><span class="comment">//跳过所有出现的统一字符</span></span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) == <span class="string">' '</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>避免混合使用<code>scanf</code>和<code>getchar</code>：</strong>scanf函数有一种留下后边字符的趋势，也就是说对于输入后面的字符只是看了一下，并没有读入。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter an interger:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//读入i的同时，scanf函数调用将会留下后面没有消耗掉的人一字符，包括换行符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a command:"</span>);</span><br><span class="line">command = getchar();<span class="comment">//getchar会取回第一个声誉字符</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-4-程序：确定消息的长度"><a href="#7-3-4-程序：确定消息的长度" class="headerlink" title="7.3.4    程序：确定消息的长度"></a>7.3.4    程序：确定消息的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determines the length a message</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a message:"</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		len ++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Your message was %d character(s) long.\n"</span>, len);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./length2 </span><br><span class="line"> Enter a message:1234567</span><br><span class="line"> Your message was 7 character(s) long.</span><br></pre></td></tr></table></figure>
<h2 id="7-4-sizeof运算符"><a href="#7-4-sizeof运算符" class="headerlink" title="7.4    sizeof运算符"></a>7.4    sizeof运算符</h2><blockquote>
<p><strong>说明：</strong>编译器本身就可以计算sizeof表达式的值，所以sizeof 是一种特殊的运算符（一元运算符）<br><strong>用途：</strong>用来计算制定类型值所需空间的大小。<br><strong>sizeof表达式：</strong><code>sizeof(类型名)</code><br><strong>参数：</strong>常量、变量或表达式<br><strong>优先级：</strong>高于二元运算符（比如+）<br><strong>返回值：</strong>字节数，类型由实现定义，通常是无符号整数<br><strong>圆括号：</strong>当应用于表示式时不需要圆括号，比如<code>sizeof i</code>，但是由于运算符优先级的问题，建议始终在sizeof表达式中采用圆括号。<br><strong>以<code>int</code>为例：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>处理器架构</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2(通常)</td>
</tr>
<tr>
<td>32</td>
<td>4(通常)</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把sizeof表达式转换成`unsigned long`(最大的无符号类型)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Size of int:%lu\n"</span>, (unsigned long)<span class="keyword">sizeof</span>(int));</span><br></pre></td></tr></table></figure>
<h2 id="7-5-类型转换"><a href="#7-5-类型转换" class="headerlink" title="7.5    类型转换"></a>7.5    类型转换</h2><blockquote>
<p><strong>计算机执行算术运算的限制：</strong>要求操作数大小相同，存储方式也相同。</p>
</blockquote>
<h2 id="7-5-1-隐式转换（implicit-conversion"><a href="#7-5-1-隐式转换（implicit-conversion" class="headerlink" title="7.5.1    隐式转换（implicit conversion)"></a>7.5.1    隐式转换（implicit conversion)</h2><blockquote>
<p><strong>说明：</strong>c语言允许在表达式中混合使用基本数据类型（整数、浮点数甚至是字符）。此时c语言编译器需要生成一些指令将某些操作数转换成不同类型，是的硬件可以对表达式进行计算。<br><strong>隐式转换情景：</strong></p>
<ul>
<li>当算术表达式或逻辑表达式中操作数的类型不相同时（常用算数转换）</li>
<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时</li>
<li>当函数调用中使用的参数类型与其对应的参数的类型不匹配时</li>
<li>当 return语句中表达式的类型和函数返回值的类型不匹配时</li>
</ul>
</blockquote>
<h3 id="7-5-1-常用算数转换"><a href="#7-5-1-常用算数转换" class="headerlink" title="7.5.1    常用算数转换"></a>7.5.1    常用算数转换</h3><blockquote>
<p><strong>原理：</strong>为了统一操作数的类型，通常可以将相对狭小的操作数转换成另一个操作数的类型来实现（即提升）。<br><strong>整型提升（integral promition）：</strong>把<code>char</code>或<code>short int</code>转换成<code>int</code>（或<code>unsigned int</code>）。</p>
<p><strong>两种情况：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>情况</th>
<th>提升方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>任一操作数的类型时浮点型的情况</td>
<td><code>long double&lt;-double&lt;-float</code></td>
</tr>
<tr>
<td>两个操作数都不是浮点型的情况</td>
<td><code>unsigned long int&lt;-long int&lt;-usigned int&lt;-int</code></td>
</tr>
<tr>
<td><code>long int</code>和<code>unsigned int</code></td>
<td>两个操作数都会转换成<code>usigned long int</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>尽量避免使用<code>unsigned int</code>，特别不要把它和有符号整数混合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ,u;</span><br><span class="line">i = <span class="number">-10</span>;</span><br><span class="line">u = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int转换为usigned int时最高位的符号位不再是符号位</span></span><br><span class="line">i &lt; u;<span class="comment">//0，因为会进行隐式转换导致讲-10当作unsigned int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> ul;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line">i = i + c;<span class="comment">//c被转为int</span></span><br><span class="line">i = i + s;<span class="comment">//s被转为int</span></span><br><span class="line">u = u + i;<span class="comment">//i被转为unsigned int</span></span><br><span class="line">l = l + u;<span class="comment">//l被转为long int</span></span><br><span class="line">ul = ul + <span class="number">1</span>;<span class="comment">//l被转为unsigned long int</span></span><br><span class="line">f = f + ul;<span class="comment">//f被转为double</span></span><br><span class="line">d = d + f;<span class="comment">//f被转为double</span></span><br><span class="line">ld = ld + d;<span class="comment">//d被转为long double</span></span><br></pre></td></tr></table></figure>
<h3 id="7-5-2-赋值中的转换"><a href="#7-5-2-赋值中的转换" class="headerlink" title="7.5.2    赋值中的转换"></a>7.5.2    赋值中的转换</h3><blockquote>
<p><strong>转化规则：</strong>把赋值运算右边的表达式转换成左边变量的类型。</p>
</blockquote>
<h4 id="7-5-2-1-两边类型一样“宽”"><a href="#7-5-2-1-两边类型一样“宽”" class="headerlink" title="7.5.2.1    两边类型一样“宽”"></a>7.5.2.1    两边类型一样“宽”</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">i = c;<span class="comment">//c被转为int</span></span><br><span class="line">f = i;<span class="comment">//i被转为float</span></span><br><span class="line">d = f;<span class="comment">//f被转为double</span></span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-2-浮点数赋值给整型"><a href="#7-5-2-2-浮点数赋值给整型" class="headerlink" title="7.5.2.2    浮点数赋值给整型"></a>7.5.2.2    浮点数赋值给整型</h4><blockquote>
<p><strong>规则：</strong>去掉小数部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="number">842.97</span>;<span class="comment">//i为842</span></span><br><span class="line">i = <span class="number">-842.87</span>;<span class="comment">//i为-842</span></span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-3-溢出"><a href="#7-5-2-3-溢出" class="headerlink" title="7.5.2.3    溢出"></a>7.5.2.3    溢出</h4><blockquote>
<p><strong>说明：</strong><code>Q&amp;A</code>如果取值在变量类型范围之外，那么把值赋给一个狭小类型的变量将会得到无意义的结果（设置更糟）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">10000</span>;</span><br><span class="line">i = <span class="number">1.0e20</span>;</span><br><span class="line">f = <span class="number">1.0e100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-3-强制类型转换"><a href="#7-5-3-强制类型转换" class="headerlink" title="7.5.3    强制类型转换"></a>7.5.3    强制类型转换</h3><blockquote>
<p><strong>强制转换表达式：</strong><code>（类型名）表达式</code><br><strong>优先级：</strong>被当作一元运算符，因此高于二元运算符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f, frac_part;</span><br><span class="line">frac_part = f - (int)f;<span class="comment">//获得浮点数f的小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> quotient;</span><br><span class="line"><span class="keyword">int</span> divided, divisor;</span><br><span class="line">quotient = (float)dividend / divisor;<span class="comment">//divisor会被迫使编译器把divisor也转换成为float类型。</span></span><br></pre></td></tr></table></figure>
<h2 id="7-6-类型定义"><a href="#7-6-类型定义" class="headerlink" title="7.6    类型定义"></a>7.6    类型定义</h2><blockquote>
<p><strong>语法：</strong><code>typedef 原本类型名 类型别名;</code><br><strong>说明：</strong>采用typedef定义类型别名会导致编译器将其加入到类型列表中。<br><strong>用途：</strong></p>
<ol>
<li>如果程序员使用有意义的类型名，会使程序更加易于理解</li>
<li>使程序更加易于维护</li>
<li>是编写可移植程序的一种重要工具</li>
</ol>
<p><strong>可移植性技巧：</strong>为了更大的可移植性，可以考虑使用<code>typedef</code>定义新的整型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在16位机器上</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line">Quantity q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在32位机器上</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line">Quantity q;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>编译器库中（可能）自带的类型定义：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> Dollars;</span><br><span class="line">Dollars cash_in, cash_out;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/6 循环/" itemprop="url">
                  6 循环
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:09:39+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/6 循环/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/6 循环/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="6-1-while语句"><a href="#6-1-while语句" class="headerlink" title="6.1    while语句"></a>6.1    while语句</h2><blockquote>
<p><strong>语法：</strong><code>while(表达式)语句</code></p>
<ul>
<li>圆括号强制要求，循环体外面的大括号不强制要求使用（多个语句除外）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-无限循环"><a href="#6-1-1-无限循环" class="headerlink" title="6.1.1    无限循环"></a>6.1.1    无限循环</h3><blockquote>
<p><strong>说明：</strong>如果控制表达式的值始终是非零值的话，while语句将无法终止。<br><strong>技巧：</strong>c语言程序员有时故意用非零常量作为控制表达式来构造无限循环。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) ...</span><br></pre></td></tr></table></figure>
<h3 id="6-1-2-程序：显示平方值的表格"><a href="#6-1-2-程序：显示平方值的表格" class="headerlink" title="6.1.2    程序：显示平方值的表格"></a>6.1.2    程序：显示平方值的表格</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of squares using a while statement</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"This program prints a table of ssquares.\n"</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of entries in table :"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> 	i = <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%10d%10d\n"</span>, i, i*i);</span><br><span class="line"> 		i++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./square                          </span><br><span class="line"> This program prints a table of ssquares.</span><br><span class="line"> Enter number of entries <span class="keyword">in</span> table :5</span><br><span class="line">         1         1</span><br><span class="line">         2         4</span><br><span class="line">         3         9</span><br><span class="line">         4        16</span><br><span class="line">         5        25</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-程序：数列求和"><a href="#6-1-3-程序：数列求和" class="headerlink" title="6.1.3    程序：数列求和"></a>6.1.3    程序：数列求和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sums a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program sums a series of intergers.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter intergers (0 to terminate:)"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		sum += n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The sun is:%d\n"</span>, sum);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./sum </span><br><span class="line"> This program sums a series of intergers.</span><br><span class="line"> Enter intergers (0 to terminate:)1 2 3 4 0</span><br><span class="line"> The sun is:10</span><br></pre></td></tr></table></figure>
<h2 id="6-2-do语句"><a href="#6-2-do语句" class="headerlink" title="6.2    do语句"></a>6.2    do语句</h2><blockquote>
<p><strong>语法：</strong><code>do 语句 while(表达式);</code><br><strong>语句说明：</strong>do语句的本质就是while语句，只不过do语句是在每次执行循环体之后对控制表达式进行判定的。<br><strong>适用场景：</strong>至少要执行一次的循环体<br><strong>注意：</strong>最好所有的do语句都适用大括号，因为没有大括号的do语句很容易被误认为while语句。</p>
</blockquote>
<h3 id="程序：计算整数中数字的位数"><a href="#程序：计算整数中数字的位数" class="headerlink" title="程序：计算整数中数字的位数"></a>程序：计算整数中数字的位数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Calculates the number od digits in an interger</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> digits = <span class="number">0</span>, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a nonnegative interger:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"> 	<span class="comment">//如果使用while循环，输入0将导致判断错误（认为0为0位数字）</span></span><br><span class="line"> 	<span class="keyword">do</span>&#123;</span><br><span class="line"> 		n /= <span class="number">10</span>;</span><br><span class="line"> 		digits++;</span><br><span class="line"> 	&#125;<span class="keyword">while</span>(n &gt; <span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"The number has %d digit(s).\n"</span>, digits);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./numdigit </span><br><span class="line"> Enter a nonnegative interger:20150621</span><br><span class="line"> The number has 8 digit(s).</span><br></pre></td></tr></table></figure>
<h2 id="6-3-for语句"><a href="#6-3-for语句" class="headerlink" title="6.3    for语句"></a>6.3    for语句</h2><blockquote>
<p><strong>语法：</strong><code>for (表达式1;表达式2;表达式3) 语句</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">10</span>;  i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>while模拟for：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span>；</span><br><span class="line"><span class="keyword">while</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句</span><br><span class="line">    表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-1-for语句的惯用法"><a href="#6-3-1-for语句的惯用法" class="headerlink" title="6.3.1    for语句的惯用法"></a>6.3.1    for语句的惯用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从0向上加到n-1</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="comment">//从1向上加到n</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; n++)</span><br><span class="line"><span class="comment">//从n-1减到0</span></span><br><span class="line"><span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="comment">//从n减到1</span></span><br><span class="line"><span class="keyword">for</span>(i = n; i &gt; <span class="number">0</span>; i--)</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-在-for语句中省略表达式"><a href="#6-3-2-在-for语句中省略表达式" class="headerlink" title="6.3.2 在 for语句中省略表达式"></a>6.3.2 在 for语句中省略表达式</h3><table>
<thead>
<tr>
<th>省略</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>表达式1</td>
<td><code>for(; 表达式2; 表达式3)</code></td>
<td>执行循环前没有初始化的操作</td>
</tr>
<tr>
<td>表达式2</td>
<td><code>for(表达式1; ; 表达式3)</code></td>
<td>表达式2默认为真值，无限循环</td>
</tr>
<tr>
<td>表达式3</td>
<td><code>for(表达式1; 表达式2;)</code></td>
<td>循环体有责任确认第二个表达式的值最终回变为假</td>
</tr>
<tr>
<td>表达式1、3</td>
<td><code>for(;表达式2;)</code></td>
<td>同<code>while</code></td>
</tr>
<tr>
<td>表达式1、2、3</td>
<td><code>for(;;)</code></td>
<td>简单的无限循环</td>
</tr>
</tbody>
</table>
<h3 id="6-3-3-逗号运算符"><a href="#6-3-3-逗号运算符" class="headerlink" title="6.3.3    逗号运算符"></a>6.3.3    逗号运算符</h3><blockquote>
<p><strong>语法：</strong><code>表达式1,表达式2</code><br><strong>用途：</strong>为了在c语言要求单独一个表达式的情况下使用两个或多个表达式。<br><strong>使用场景：</strong>宏、<code>for</code>循环<br><strong>优先级：</strong>低于所有其它运算符。<br><strong>计算过程：</strong></p>
<ol>
<li>计算表达式1并且仍低哦计算出的值</li>
<li>计算表达式2，把这个值作为整个表达式的值</li>
</ol>
<p><strong>注意：</strong>计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。</p>
</blockquote>
<h3 id="6-2-4-程序：显示平方值的表格（改进版）"><a href="#6-2-4-程序：显示平方值的表格（改进版）" class="headerlink" title="6.2.4    程序：显示平方值的表格（改进版）"></a>6.2.4    程序：显示平方值的表格（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of squares using a for statement</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"This program prints a table of squares."</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of entries in table:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%10d%10d\n"</span>, i, i * i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-退出循环"><a href="#6-4-退出循环" class="headerlink" title="6.4    退出循环"></a>6.4    退出循环</h2><h3 id="6-4-1-break语句"><a href="#6-4-1-break语句" class="headerlink" title="6.4.1    break语句"></a>6.4.1    break语句</h3><blockquote>
<p><strong>作用：</strong>把程序从<code>switch</code>语句中转移出来；跳出<code>while</code>、<code>do</code>、<code>for</code>循环。<br><strong>注意：</strong>break只能跳出一层循环</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a number (enter 0 to stop):"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d cubed is %d\n"</span>, n, n*n*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-2-continue-语句"><a href="#6-4-2-continue-语句" class="headerlink" title="6.4.2    continue 语句"></a>6.4.2    continue 语句</h3><blockquote>
<p><strong>作用：</strong>把程序控制正号转移到循环结束之前的一点；只能用于循环。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">	sun += i;</span><br><span class="line">	n ++;</span><br><span class="line">	<span class="comment">/*continue jumps to here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-goto语句"><a href="#6-4-3-goto语句" class="headerlink" title="6.4.3    goto语句"></a>6.4.3    goto语句</h3><blockquote>
<p><strong>语法：</strong></p>
<ul>
<li>标号语句：<code>标识符 : 语句</code></li>
<li>goto语句：<code>goto 标识符</code></li>
</ul>
<p><strong>注意：</strong><code>break</code> <code>continue</code> <code>return</code>本质上都是受限制的goto语句，它们和<code>exit</code>函数配合可以应对大多数需要goto语句的情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(d = <span class="number">2</span>; d &lt; n; d++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n % d == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//goto语句</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标号语句</span></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span>(d &lt; n)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d is divisible by %d\n"</span>, n, d);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d is prime\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-4-程序：账目簿结算"><a href="#6-4-4-程序：账目簿结算" class="headerlink" title="6.4.4    程序：账目簿结算"></a>6.4.4    程序：账目簿结算</h3><h2 id="6-5-空语句"><a href="#6-5-空语句" class="headerlink" title="6.5    空语句"></a>6.5    空语句</h2><blockquote>
<p><strong>语法：</strong><code>;</code><br><strong>用途：</strong></p>
<ul>
<li>编写空循环体（在某些情况下帮助省略循环体）</li>
<li><code>goto</code>语句的标号不能独立存在，后面必须有语句，可以使用空语句</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(d =<span class="number">2</span>; d &lt; n &amp;&amp; n % d != <span class="number">0</span>; d++)</span><br><span class="line">;<span class="comment">/*empty body*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>建议将空语句单独放在一行，便于代码阅读。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/5 选择语句/" itemprop="url">
                  5 选择语句
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T17:51:28+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/5 选择语句/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/5 选择语句/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>c语言语句：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>语句</th>
</tr>
</thead>
<tbody>
<tr>
<td>return语句</td>
<td><code>return</code></td>
</tr>
<tr>
<td>表达式语句</td>
<td><code>表达式;</code></td>
</tr>
<tr>
<td>选择语句</td>
<td><code>if</code> <code>switch</code></td>
</tr>
<tr>
<td>循环语句</td>
<td><code>while</code> <code>do</code> <code>for</code></td>
</tr>
<tr>
<td>跳转语句</td>
<td><code>break</code> <code>continue</code> <code>goto</code></td>
</tr>
<tr>
<td>复合语句</td>
<td>几条语句组合成一个</td>
</tr>
<tr>
<td>空语句</td>
<td>不执行任何操作</td>
</tr>
</tbody>
</table>
<h2 id="5-1-逻辑表达式"><a href="#5-1-逻辑表达式" class="headerlink" title="5.1    逻辑表达式"></a>5.1    逻辑表达式</h2><blockquote>
<p><strong>注意：</strong>c语言没有<code>Boolean</code>类型，表达式的<code>真假</code>依赖于其结果是<code>0</code>或<code>非0</code>。</p>
</blockquote>
<h3 id="5-1-1-关系运算符"><a href="#5-1-1-关系运算符" class="headerlink" title="5.1.1    关系运算符"></a>5.1.1    关系运算符</h3><p><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code></p>
<blockquote>
<p><strong>操作数类型：</strong>可以用关系运算符比较整数和浮点数，以及混合类型的操作数。<br><strong>返回值：</strong>c语言的表达式中产生的结果是<code>0或1</code><br><strong>优先级于结合性：</strong>关系运算符的优先级低于算术运算符。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &lt; k;<span class="comment">//(i &lt; j) &lt; k</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-判等运算符"><a href="#5-1-2-判等运算符" class="headerlink" title="5.1.2    判等运算符"></a>5.1.2    判等运算符</h3><p><code>==</code> <code>!=</code></p>
<blockquote>
<p><strong>操作数类型：</strong>同关系运算符<br><strong>返回值：</strong>同关系运算符<br><strong>优先级于结合性：</strong>优先级低于关系运算符，左结合<br><strong>技巧：</strong>利用关系运算符和判等运算符返回整数值这一事实</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &gt;= j) + (i == j);<span class="comment">//0(大于),1(等于),2(小于)</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-逻辑运算符"><a href="#5-1-3-逻辑运算符" class="headerlink" title="5.1.3    逻辑运算符"></a>5.1.3    逻辑运算符</h3><p><code>&amp;&amp;</code> <code>\|\|</code> <code>!</code></p>
<blockquote>
<p><strong>操作数类型：</strong>真（任何非零值操作数），假（零值）。<br><strong>返回值：</strong>0（假）或1（真）。<br><strong>优先级于结合性：</strong><code>&amp;&amp;</code>和<code>||</code>优先级低于关系运算符和判等运算符，左结合；<code>!</code>优先级同<code>+(正)、-(负)</code>。<br><strong>注意：</strong><code>&amp;&amp;</code>和<code>||</code>都对运算符进行<code>短路</code>计算，也就是说，计算机先计算左侧的值，如果通过左侧的值推导出表达式的值就不需要运行计算右侧的值（操作数的副作用也不会发生）。</p>
</blockquote>
<h2 id="5-2-if语句"><a href="#5-2-if语句" class="headerlink" title="5.2    if语句"></a>5.2    if语句</h2><blockquote>
<p><strong>语法：</strong><code>if (表达式) 语句（单独一条）</code><br><strong>注意：</strong>为语句增加大括号或表达式使用圆括号有时并不是必需的，但会使程序更易读，使编译器更容易理解。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lent_num == MAX_LINES)&#123;</span><br><span class="line">	line_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-1-复合语句"><a href="#5-2-1-复合语句" class="headerlink" title="5.2.1    复合语句"></a>5.2.1    复合语句</h3><blockquote>
<p><strong>语法：</strong><code>if(表达式){语句1;语句2;...}</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lent_num == MAX_LINES)&#123;</span><br><span class="line">	line_num = <span class="number">0</span>;</span><br><span class="line">	page_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-else语句"><a href="#5-2-2-else语句" class="headerlink" title="5.2.2 else语句"></a>5.2.2 else语句</h3><blockquote>
<p><strong>语法：</strong><code>if(表达式) 语句 else 语句</code></p>
<h3 id="5-2-3-级联if语句"><a href="#5-2-3-级联if语句" class="headerlink" title="5.2.3    级联if语句"></a>5.2.3    级联if语句</h3><p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n is less than 0\n"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"n is equal to 0\n"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"n is greter than 0\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-程序：计算股票经纪人的佣金"><a href="#5-2-4-程序：计算股票经纪人的佣金" class="headerlink" title="5.2.4    程序：计算股票经纪人的佣金"></a>5.2.4    程序：计算股票经纪人的佣金</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Calculate a broker's commission</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> commission, value;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter value of trade:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;value);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span> (value &lt; <span class="number">2500.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">30.00</span> + <span class="number">.017</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">6250.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">56.00</span> + <span class="number">.0066</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">20000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">76.00</span> + <span class="number">.0034</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">50000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">100.00</span> + <span class="number">.0022</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">500000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">155.00</span> + <span class="number">.0011</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		commission = <span class="number">255.00</span> + <span class="number">.0009</span> * value;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(commission &lt; <span class="number">39.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">39.00</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"commission:$%.2f\n\n"</span>, commission);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./broker </span><br><span class="line"> Enter value of trade:6000</span><br><span class="line"> commission:<span class="variable">$95</span>.60</span><br></pre></td></tr></table></figure>
<h3 id="5-2-5-“悬空else”的问题"><a href="#5-2-5-“悬空else”的问题" class="headerlink" title="5.2.5    “悬空else”的问题"></a>5.2.5    “悬空else”的问题</h3><blockquote>
<p><strong>规则：</strong>c语言遵循的规则是else字句应该属于离它最近的且还未和其他else匹配的if语句。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(y != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">		result = x / y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error:y is equal to 0\n"</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5-2-6-条件表达式"><a href="#5-2-6-条件表达式" class="headerlink" title="5.2.6    条件表达式"></a>5.2.6    条件表达式</h3><blockquote>
<p><strong>又名：</strong>三元运算符<br><strong>语法：</strong><code>表达式1 ? 表达式2 : 表达式3</code><br><strong>优先级：</strong>低于所有其它运算符<br><strong>使用场景：</strong>return语句、printf函数中、某些类型的宏定义<br><strong>注意：</strong>条件表达式使程序更加短小也更难以阅读，所以最好避免使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">k = i &gt; (j ? i : j) + j;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5-2-7-模拟布尔值"><a href="#5-2-7-模拟布尔值" class="headerlink" title="5.2.7    模拟布尔值"></a>5.2.7    模拟布尔值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL int</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(flag == TRUE) ...</span><br><span class="line"><span class="keyword">if</span>(flag == FALSE) ...</span><br><span class="line"><span class="keyword">if</span>(!flag) ...</span><br></pre></td></tr></table></figure>
<h2 id="5-3-switch语句"><a href="#5-3-switch语句" class="headerlink" title="5.3    switch语句"></a>5.3    switch语句</h2><blockquote>
<p><strong>语法：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式 : 多条语句</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> 常量表达式 : 多条语句</span><br><span class="line">	<span class="keyword">default</span> : 多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>特点：</strong></p>
<ol>
<li>不允许由重复的情况标号</li>
<li>对情况的顺序没有要求（default）不一定要放置在最后</li>
<li>不要求一定要有default，如果不匹配任何情况又没有default，则什么也不做</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制表达式</td>
<td>switch <code>控制表达式</code></td>
<td>整数或字符（也会被当作整数）</td>
</tr>
<tr>
<td>情况标号</td>
<td><code>case 常量表达式</code></td>
<td>常量表达式中只能存在常量（包括宏）</td>
</tr>
<tr>
<td>语句</td>
<td>每个情况标号后边任意数量的语句</td>
<td>c语言中少数几个不需要大括号的地方之一</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Passing"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"Failing"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal grade"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-1-break语句的作用"><a href="#5-3-1-break语句的作用" class="headerlink" title="5.3.1    break语句的作用"></a>5.3.1    break语句的作用</h3><blockquote>
<p><strong>说明：</strong>switch语句实际上是一种基于计算的跳转，如果没有break或其它跳转语句，程序控制将会从一种情况继续到下面一种情况。<br><strong>注意：</strong>break的故意省略需要明确指出以防某些人尝试修正“错误”。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		num_passing++;</span><br><span class="line">		<span class="comment">/*FALL THROUGH*/</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: total grades++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-程序：显示法定格式的日期"><a href="#5-3-2-程序：显示法定格式的日期" class="headerlink" title="5.3.2    程序：显示法定格式的日期"></a>5.3.2    程序：显示法定格式的日期</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a date in legal form</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> month, day, year;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter date (mm/dd/yy):"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d /%d /%d"</span>, &amp;month, &amp;day, &amp;year);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Dated this %d"</span>, day);</span><br><span class="line"> 	<span class="keyword">switch</span>(day)&#123;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">case</span> <span class="number">21</span>:<span class="keyword">case</span> <span class="number">31</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"st"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"nd"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"th"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">" day of "</span>);</span><br><span class="line"> 	<span class="keyword">switch</span>(month)&#123;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"January"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"February"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"Marth"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"April"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"May"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">"June"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">"July"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">"August"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">"September"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">10</span>: <span class="built_in">printf</span>(<span class="string">"October"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">11</span>: <span class="built_in">printf</span>(<span class="string">"November"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">12</span>: <span class="built_in">printf</span>(<span class="string">"December"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">",20%.2d\n"</span>, year);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./date                        </span><br><span class="line"> Enter date (mm/dd/yy):6/21/15          </span><br><span class="line"> Dated this 21st day of June,2015</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/4 表达式/" itemprop="url">
                  4	表达式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T16:41:12+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/09/4 表达式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/09/4 表达式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1    算数运算符"></a>4.1    算数运算符</h2><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号运算符</td>
<td>在<code>经典c</code>中不存在这种运算符，它主要用于强调某数值常量是正数</td>
</tr>
<tr>
<td>-</td>
<td>一元负号号运算符</td>
</tr>
</tbody>
</table>
<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>除<code>%</code>外，二元运算符允许操作数既可以是整数也可以是浮点数，或者是两者混合</li>
<li><code>int</code>类型的操作数和<code>float</code>型操作数混合在一起时，运算结果为<code>float</code>型</li>
<li>当<code>/</code>和<code>%</code>用于负操作数时，其结果与具体实现有关</li>
</ol>
<p><strong>由实现定义(implementtion-defined)：</strong>软件在特定的平台上编译、链接和执行，行为可能会稍有差异。这是c语言为了和硬件平台匹配追求高效率的结果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法运算符</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减法运算符</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>乘法运算符</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td>除法运算符</td>
<td>当两个操作数都是整数时，运算结果会向下取整</td>
</tr>
<tr>
<td>%</td>
<td>取余运算符</td>
<td>操作数要求都是整数，否则无法编译通过</td>
</tr>
</tbody>
</table>
<h3 id="4-1-1-运算符的优先级与结合性"><a href="#4-1-1-运算符的优先级与结合性" class="headerlink" title="4.1.1    运算符的优先级与结合性"></a>4.1.1    运算符的优先级与结合性</h3><blockquote>
<p><strong>注意：</strong>很少有程序员会费心记住优先级和结合性规则，而是在需要时参考运算符表或添加足够多的<code>()</code>。<br><strong>运算符优先级：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>最高优先级</td>
<td><code>+(负)</code> <code>-（正）</code>  <code>*</code> <code>/</code> <code>%</code></td>
</tr>
<tr>
<td>最低优先级</td>
<td><code>+(加)</code> <code>-(减)</code></td>
</tr>
</tbody>
</table>
<p><strong>结合性：</strong></p>
<ul>
<li>一元运算符都是右结合<code>(right assoiative)</code>的,即从右向左结合</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-+i;<span class="comment">//-(+i)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>二元运算符都是左结合<code>(left assoiative)</code>的，即从左向右结合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i-j-k;<span class="comment">//(i-j)-k</span></span><br><span class="line">+i+jk/;<span class="comment">//(+i)+(j/k)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-程序：计算通用产品代码的校验位"><a href="#4-1-2-程序：计算通用产品代码的校验位" class="headerlink" title="4.1.2    程序：计算通用产品代码的校验位"></a>4.1.2    程序：计算通用产品代码的校验位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Compaer a Universal Prouct Code check digit</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, first_sum, second_sum, total;</span><br><span class="line"> 	<span class="comment">/*输入左边第一位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter the first (single) digit:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line"> 	<span class="comment">/*输入2-6位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter first groun of value digits:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%1d%1d%1d%1d%1d"</span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;i5);</span><br><span class="line"> 	<span class="comment">/*输入7-11位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter second group of five digits:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%1d%1d%1d%1d%1d"</span>, &amp;j1, &amp;j2, &amp;j3, &amp;j4, &amp;j5);</span><br><span class="line"> 	first_sum = d + i2 + i4 + j1 + j3 + j5;</span><br><span class="line"> 	second_sum = i1 + i3 + i5 + j2 + j4;</span><br><span class="line"> 	total = <span class="number">3</span> * first_sum + second_sum;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Check digit:%d\n"</span>, <span class="number">9</span> - ((total - <span class="number">1</span>) % <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./upc </span><br><span class="line"> Enter the first (single) digit:2</span><br><span class="line"> Enter first groun of value digits:23456</span><br><span class="line"> Enter second group of five digits:78954</span><br><span class="line"> Check digit:5</span><br></pre></td></tr></table></figure>
<h2 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2    赋值运算符"></a>4.2    赋值运算符</h2><blockquote>
<p><strong>注意：</strong>c语言的<code>=</code>不是<code>语句</code>，而是<code>运算符</code>。赋值表达式<code>v=e</code>的结果是v的值。</p>
</blockquote>
<h3 id="4-2-1-简单赋值"><a href="#4-2-1-简单赋值" class="headerlink" title="4.2.1    简单赋值"></a>4.2.1    简单赋值</h3><blockquote>
<p><strong>语法：</strong><code>v=e</code>，<code>e</code>可以是常量、变量或表达式。<br><strong>副作用：</strong>简单赋值运算符是已知的第一个有副作用的运算符，因为它会改变操作数的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = j = k = <span class="number">0</span>;<span class="comment">//i = (j = k = 0)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="4-2-2-左值"><a href="#4-2-2-左值" class="headerlink" title="4.2.2    左值"></a>4.2.2    左值</h3><blockquote>
<p><strong>定义：</strong><code>Q&amp;A</code>左值表示存储在计算机内存中的对象，而不是常量和计算结果。例如变量。<br><strong>注意：</strong>赋值运算符要求左边的操作数必须是左值。</p>
</blockquote>
<h3 id="4-2-3-复合赋值"><a href="#4-2-3-复合赋值" class="headerlink" title="4.2.3    复合赋值"></a>4.2.3    复合赋值</h3><blockquote>
<p><strong>用途：</strong>简化利用变量原有值计算出新值，并重新赋值给这个变量的操作。<br><strong>列举：</strong>共10种</p>
</blockquote>
<table>
<thead>
<tr>
<th>+=</th>
<th>-=</th>
<th>*=</th>
<th>/=</th>
<th>%=</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><code>v += e</code>并不完全等同于<code>v = v + e</code>(优先级问题)</li>
</ol>
</blockquote>
<h2 id="4-3-自增运算符和自减运算符"><a href="#4-3-自增运算符和自减运算符" class="headerlink" title="4.3    自增运算符和自减运算符"></a>4.3    自增运算符和自减运算符</h2><blockquote>
<p><strong>和<code>i+=1</code>或<code>i-=1</code>的区别</strong>：</p>
<ol>
<li><code>++</code>和<code>--</code>既可以是前缀运算符，也可以是后缀运算符</li>
<li>和赋值运算符一样，<code>++</code>和<code>--</code>也有副作用：它会改变操作数的值</li>
</ol>
</blockquote>
<p><strong>前缀使用和后缀使用的区别：</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>语法</th>
<th>执行时机</th>
<th>优先级</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀方式</td>
<td><code>++i</code>或<code>--i</code></td>
<td>立即执行</td>
<td>和<code>一元正负号</code>优先级相同，右结合方式</td>
</tr>
<tr>
<td>后缀方式</td>
<td><code>i++</code>或<code>++i</code></td>
<td>稍后再执行</td>
<td>高于<code>一元正负号</code>，左结合方式</td>
<td><code>Q&amp;A</code>没有给出明确的时间，当会是下一条语句执行之前</td>
</tr>
</tbody>
</table>
<h2 id="4-4-表达式求值"><a href="#4-4-表达式求值" class="headerlink" title="4.4    表达式求值"></a>4.4    表达式求值</h2><h3 id="4-4-1-部分c语言运算符表"><a href="#4-4-1-部分c语言运算符表" class="headerlink" title="4.4.1    部分c语言运算符表"></a>4.4.1    部分c语言运算符表</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-06-19%20%E4%B8%8B%E5%8D%888.44.42.png" alt="Alt text"></p>
<h3 id="4-4-2-为表达式添加圆括号"><a href="#4-4-2-为表达式添加圆括号" class="headerlink" title="4.4.2    为表达式添加圆括号"></a>4.4.2    为表达式添加圆括号</h3><blockquote>
<p><strong>过程：</strong>检查表达式，找到最高优先级地运算符后，用圆括号把运算符合相应的操作数括起来，圆括号的内容将被看成一个单独的操作数。然后重复此类操作指导表达式被完全加上圆括号。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=&gt;start: start</span><br><span class="line">e=&gt;end: end</span><br><span class="line">op1=&gt;operation: a = b += c++ - d + --e / -f</span><br><span class="line">op2=&gt;operation: a = b += (c++) - d + (--e) / (-f)</span><br><span class="line">op3=&gt;operation: a = b += (c++) - d + ((--e) / (-f))</span><br><span class="line">op4=&gt;operation: a = b += ((c++) - d + (((--e) / (-f))))</span><br><span class="line">op5=&gt;operation: (a = b += ((c++) - d + (((--e) / (-f)))))</span><br><span class="line"></span><br><span class="line">s-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="4-4-3-子表达式的求值顺序"><a href="#4-4-3-子表达式的求值顺序" class="headerlink" title="4.4.3    子表达式的求值顺序"></a>4.4.3    子表达式的求值顺序</h3><blockquote>
<p><strong>注意：</strong>c语言并没有定义子表达式的求值顺序（<code>&amp;&amp;</code> <code>||</code> <code>条件运算符</code> <code>逗号运算符</code>除外）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>;</span><br><span class="line">c = (b = a + <span class="number">2</span>) - (a = <span class="number">1</span>)<span class="comment">//c可能是6也可能是2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>建议：</strong>不在表达式种使用赋值运算符，而是采用一串分离的赋值表达式。</p>
</blockquote>
<h2 id="4-5-表达式语句"><a href="#4-5-表达式语句" class="headerlink" title="4.5    表达式语句"></a>4.5    表达式语句</h2><blockquote>
<p><strong>表达式转换为语句：</strong>任何表达式都可以通过添加分号转换为语句。<br><strong>注意：</strong>除非表达式有副作用，否则将表达式用作语句并没有任何意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i --;<span class="comment">//因为副作用的关系起到了作用</span></span><br><span class="line"></span><br><span class="line">i * j - <span class="number">1</span>;<span class="comment">//因为没有副作用，将该表达式作为语句使用没有任何意义</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/3 格式化输入／输出/" itemprop="url">
                  3 格式化输入／输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T22:48:34+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/08/3 格式化输入／输出/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/08/3 格式化输入／输出/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-1-printf函数"><a href="#3-1-printf函数" class="headerlink" title="3.1    printf函数"></a>3.1    printf函数</h2><blockquote>
<p><strong>语法：</strong><code>printf(格式串,表达式1,表达式2,...)</code><br><strong>转换说明（conversion specification）：</strong>以字符<code>%</code>开头，用来表示打印过程中填充了值的占位符。<code>%</code>后面的信息指定了把数值从内部（二进制）形式转换成打印（字符）形式的方法。<br><strong>注意：</strong></p>
<ol>
<li>单独调用一次prinf函数时可以打印的值的个数没有限制</li>
<li>c语言编译器不会检测格式串中转换说明的数据是否和输出项的数量相匹配</li>
<li>也不检测转换说明是否适合要显示项的数据类型</li>
</ol>
</blockquote>
<h3 id="3-1-1-转换说明"><a href="#3-1-1-转换说明" class="headerlink" title="3.1.1    转换说明"></a>3.1.1    转换说明</h3><blockquote>
<p><strong>格式：</strong><code>%m.pX</code>或<code>%-m.pX</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">含义</th>
<th style="text-align:left">必选</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">左对齐</td>
<td style="text-align:left">否</td>
<td>左对齐（默认右对齐）</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">minimum field width</td>
<td style="text-align:left">否</td>
<td>最小字段宽度</td>
<td>当<code>打印字符数&lt;m</code>时会根据对齐方式在前或后放置额外的空格；<code>打印字符数&gt;m</code>时字段宽度会自动扩展为需要的尺寸。</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">分隔</td>
<td style="text-align:left">否</td>
<td>分隔m和p，p存在时才存在</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">precision</td>
<td style="text-align:left">否</td>
<td>含义依赖于<code>X</code>的选择</td>
<td><code>d</code>(数字的最少个数，不够用0补够，默认1)；<code>e</code>(小数点后数字个数，默认6) ;<code>f</code>(同e); <code>g</code>(有效数字的最大数量)</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">conversion specifier</td>
<td style="text-align:left">是</td>
<td>在显示数值前对其进行那种转换</td>
<td><code>d</code>(十进制)；<code>e</code>(指数)；<code>f</code>(浮点数)<code>g</code>(根据数的大小决定指数形式还是浮点数形式)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>以上只就部分转换说明符进行了说明。</p>
</blockquote>
<h3 id="3-1-2-程序：用printf函数格式化数"><a href="#3-1-2-程序：用printf函数格式化数" class="headerlink" title="3.1.2    程序：用printf函数格式化数"></a>3.1.2    程序：用printf函数格式化数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints int and float values in various formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">float</span> x;</span><br><span class="line"></span><br><span class="line"> 	i = <span class="number">40</span>;</span><br><span class="line"> 	x = <span class="number">839.21</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"|%d|%5d|%-5d|%5.3d|\n"</span>, i, i, i, i);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"|%10.3f|%10.3e|%-10g|\n"</span>, x, x, x);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./tprintf </span><br><span class="line"> |40|   40|40   |  040|</span><br><span class="line"> |   839.210| 8.392e+02|839.21    |</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-转义序列"><a href="#3-1-3-转义序列" class="headerlink" title="3.1.3    转义序列"></a>3.1.3    转义序列</h3><blockquote>
<p><strong>简介：</strong>通过使用<code>\</code>组合其它字符实现对字符的转义，转义字符使字符串包含一些特殊字符而又不会使编译器引发问题，包括非打印的控制字符和对编译器有特殊含义的字符（比如<code>&quot;</code>）。</p>
</blockquote>
<p><code>只提供部分</code></p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报（响铃）</td>
</tr>
<tr>
<td>\b</td>
<td>回退符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Item\tUnit\tPurpose\n\tPrice\tDate\n"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-2-scanf函数"><a href="#3-2-scanf函数" class="headerlink" title="3.2    scanf函数"></a>3.2    scanf函数</h2><blockquote>
<p><strong>语法：</strong><code>scanf(格式串, 表达式1, 表达式2, ...)</code><br><strong>注意：</strong></p>
<ul>
<li>编译器不会检查转换说明的数量与输入变量是否相匹配</li>
<li>编译器不会检查转换说明和对应输入变量格式是否合适</li>
<li>忘记在变量前放置符号<code>&amp;</code>将会产生不可预知的结果（比如变量没有初始化）</li>
</ul>
</blockquote>
<h3 id="3-2-1-scanf函数的工作方法"><a href="#3-2-1-scanf函数的工作方法" class="headerlink" title="3.2.1    scanf函数的工作方法"></a>3.2.1    scanf函数的工作方法</h3><blockquote>
<p><strong>简述：</strong>scanf函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成功。<br><strong>空白字符(white-space)：</strong>空格、横向（纵向）制表符、换页符、换行符。<br><strong>匹配规则：</strong></p>
<ol>
<li>从左边开始处理输入的字符串的信息</li>
<li>对格式串中的每一个转换说明，scanf函数努力从输入的数据中定位适当类型的项，并且跳过必要的空白符</li>
<li>遇到不可能属于当前转换说明的字符时结束对当前转换字符的匹配，并将已经匹配的字符赋值给对应变量</li>
<li>如果用户输入的字符都和当前转换说明不匹配，则不再查看格式串的剩余部分</li>
</ol>
</blockquote>
<h3 id="3-2-2-格式串中的普通字符"><a href="#3-2-2-格式串中的普通字符" class="headerlink" title="3.2.2    格式串中的普通字符"></a>3.2.2    格式串中的普通字符</h3><blockquote>
<p><strong>空白字符</strong>：当再格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符。<br><strong>其他字符：</strong>当格式串中国年遇到一个非空白字符时，scanf会把它与下一个输入字符进行比较。如果匹配则丢掉匹配的部分，并针对后面的输入及对应的格式串进行处理；否则异常退出。</p>
</blockquote>
<h3 id="3-2-3-混淆printf函数和scanf函数"><a href="#3-2-3-混淆printf函数和scanf函数" class="headerlink" title="3.2.3    混淆printf函数和scanf函数"></a>3.2.3    混淆printf函数和scanf函数</h3><p><strong>常见问题</strong></p>
<ul>
<li>在printf函数调用时在变量前面放置<code>&amp;</code></li>
<li>scanf中格式串中出现不必要的<code>\n</code>，导致交互程序会一直匹配用户输入的空白符</li>
</ul>
<h3 id="3-2-4-程序：计算持有的股票的价值"><a href="#3-2-4-程序：计算持有的股票的价值" class="headerlink" title="3.2.4    程序：计算持有的股票的价值"></a>3.2.4    程序：计算持有的股票的价值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes the value of stock holdings</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> price, shares;</span><br><span class="line"> 	<span class="keyword">float</span> num, denom, value;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter share price (must inclide a fraction):\n"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d%f/%f"</span>, &amp;price, &amp;num, &amp;denom);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of shares:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;shares);</span><br><span class="line"></span><br><span class="line"> 	value = (price + num / denom) * shares;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Value of holdings:$%.2f\n"</span>, value);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./stocks </span><br><span class="line"> Enter share price (must inclide a fraction):</span><br><span class="line"> 64 18/40</span><br><span class="line"> Enter number of shares:100</span><br><span class="line"> Value of holdings:<span class="variable">$6445</span>.00</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/2 c语言基本概念/" itemprop="url">
                  2 c语言基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T22:24:08+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/08/2 c语言基本概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/08/2 c语言基本概念/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2    c语言基本概念</p>
<h2 id="2-1-编写一个简单地c程序"><a href="#2-1-编写一个简单地c程序" class="headerlink" title="2.1    编写一个简单地c程序"></a>2.1    编写一个简单地c程序</h2><h3 id="2-1-1-程序：显示双关语"><a href="#2-1-1-程序：显示双关语" class="headerlink" title="2.1.1    程序：显示双关语"></a>2.1.1    程序：显示双关语</h3><blockquote>
<p><strong>注意：</strong>编译器往往要求文件的扩展名为<code>.c</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-编译和链接"><a href="#2-1-2-编译和链接" class="headerlink" title="2.1.2    编译和链接"></a>2.1.2    编译和链接</h3><blockquote>
<p><strong>预处理器（processor）：</strong>优点类似编辑器，它可以给程序添加内容，也可以对程序进行修改。<br><strong>指令（directive）：</strong>以<code>#</code>开头的命令，由预处理器执行为程序文件添加内容。<br><strong>目标代码（object code）：</strong>编译生成的机器指令（需要链接才能运行）<br><strong>编译器（complier）：</strong>在编译阶段将程序翻译成目标代码。比如UNIX下的<code>cc</code><br><strong>连接器（linker）：</strong>把编译产生的目标代码和任何其它附加代码整合在一起，生成可执行文件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 编写程序</span><br><span class="line">e=&gt;end: 执行</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 预处理：执行指令，引入相关代码</span><br><span class="line">op2=&gt;operation: 编译：将预处理后的代码翻译为目标代码</span><br><span class="line">op3=&gt;operation: 链接：整合目标代码和附加代码（包括库函数），生成完全可执行的程序</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure>
<h4 id="cc"><a href="#cc" class="headerlink" title="cc"></a>cc</h4><table>
<thead>
<tr>
<th>-o</th>
<th>允许为含有可执行程序的文件命名</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>使用技巧</strong></p>
<ul>
<li><strong>自动链接：</strong>使用<code>cc</code>进行编译时，系统会自动进行链接操作，不需要单独的链接命令</li>
<li><strong>可执行文件命名：</strong>默认为<code>文件名.out</code></li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o pun pun.c<span class="comment"># 可执行文件名为pun</span></span><br></pre></td></tr></table></figure>
<h4 id="gcc-GNU-C-Complier）"><a href="#gcc-GNU-C-Complier）" class="headerlink" title="gcc(GNU C Complier）"></a>gcc(GNU C Complier）</h4><table>
<thead>
<tr>
<th>-Wall</th>
<th>使gcc比平常更彻底地检查程序并警告可能发生的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>简介：</strong>UNIX系统中最常用的编译器之一。<br><strong>自由软件基金会（Free Software Foundation, FSF）：</strong>由<code>Richard M.Stallman</code>创建，旨在对抗UNIX正版软件的使用限制和高额费用。重写了大量UNIX软件并免费发布。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -o pun pun.c</span><br></pre></td></tr></table></figure>
<h2 id="2-2-简单程序的通用形式"><a href="#2-2-简单程序的通用形式" class="headerlink" title="2.2    简单程序的通用形式"></a>2.2    简单程序的通用形式</h2><blockquote>
<p><strong>一般形式：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指令</span><br><span class="line">main()&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3个关键语言特性：</strong><code>指令</code> <code>函数</code> <code>语句</code></p>
</blockquote>
<h3 id="2-2-1-指令"><a href="#2-2-1-指令" class="headerlink" title="2.2.1    指令"></a>2.2.1    指令</h3><blockquote>
<p><strong>头文件：</strong>都包含一些标准库的内容<br><strong>语法：</strong></p>
<ol>
<li>所有的指令都以<code>#</code>开始，用以和c程序的其它代码进行区分</li>
<li>默认情况下指令是一行</li>
<li>在每条指令的结尾既没有分号也没有其它特殊标记</li>
</ol>
</blockquote>
<h3 id="2-2-2-函数"><a href="#2-2-2-函数" class="headerlink" title="2.2.2    函数"></a>2.2.2    函数</h3><blockquote>
<p><strong>定义：</strong>一系列组合在一起并且赋予了名字的语句<br><strong>分2类：</strong></p>
<ul>
<li>程序员编写的函数</li>
<li>编译器提供的库函数(<code>library function</code>)</li>
</ul>
</blockquote>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h4><blockquote>
<p><strong>简介：</strong>c程序可以包含多个函数，但前置规定必须有一个<code>main</code>函数<br><strong>特点：</strong></p>
<ul>
<li>在执行程序时系统会自动调用main函数</li>
<li>名字<code>main</code>是至关重要的，不能改写为<code>begin</code> <code>start</code>，甚至<code>MAIN</code></li>
</ul>
<p><strong>注意：</strong>建议在<code>main</code>函数末尾用一条<code>return</code>结束语句，<code>Q&amp;A</code>如果不这样做，某些编译器可能会产生一条警告信息。</p>
</blockquote>
<h3 id="2-2-3-语句"><a href="#2-2-3-语句" class="headerlink" title="2.2.3    语句"></a>2.2.3    语句</h3><blockquote>
<p><strong>定义：</strong>程序运行时执行的命令<br><strong>语法：</strong></p>
<ul>
<li>除复合语句和指令除外，每条语句都要用<code>;</code>结尾</li>
</ul>
</blockquote>
<h3 id="2-2-4-显示字符串"><a href="#2-2-4-显示字符串" class="headerlink" title="2.2.4    显示字符串"></a>2.2.4    显示字符串</h3><blockquote>
<p><strong>字符串字面量：</strong>用一对双引号保卫的一系列字符<br><code>printf</code>：不会自动跳转到下一行（除非在末尾添加<code>\n</code>）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"To, or not to c:"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"that is the question.\n:"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3    注释"></a>2.3    注释</h2><blockquote>
<p><strong>语法：</strong><code>/**/</code>，可以出现在程序的任何位置，单独占行或和其它程序放在同一行。</p>
</blockquote>
<h3 id="2-3-1-文档说明"><a href="#2-3-1-文档说明" class="headerlink" title="2.3.1    文档说明"></a>2.3.1    文档说明</h3><h4 id="2-3-1-1-举个栗子"><a href="#2-3-1-1-举个栗子" class="headerlink" title="2.3.1.1    举个栗子"></a>2.3.1.1    举个栗子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Name:	pun.c 			 */</span></span><br><span class="line"><span class="comment">/* Purpose:	Prints a bad pun */</span></span><br><span class="line"><span class="comment">/* Author:	K. N. King		 */</span></span><br><span class="line"><span class="comment">/* Date written:	5/21/95	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-2-其它形式"><a href="#2-3-1-2-其它形式" class="headerlink" title="2.3.1.2    其它形式"></a>2.3.1.2    其它形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************</span><br><span class="line"> * Name:	pun.c 			  *</span><br><span class="line"> * Purpose:	Prints a bad pun  *</span><br><span class="line"> * Author:	K. N. King		  *</span><br><span class="line"> * Date written:	5/21/95	  *</span><br><span class="line"> * ****************************/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* Name:	pun.c 	</span><br><span class="line">* Purpose:	Prints a bad pun </span><br><span class="line">* Author:	K. N. King	</span><br><span class="line">* Date written:	5/21/95	 </span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-翼型注释"><a href="#2-3-2-翼型注释" class="headerlink" title="2.3.2    翼型注释"></a>2.3.2    翼型注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main()<span class="comment">/* Beginning of main program */</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-变量和赋值"><a href="#2-4-变量和赋值" class="headerlink" title="2.4    变量和赋值"></a>2.4    变量和赋值</h2><h3 id="2-4-1-类型"><a href="#2-4-1-类型" class="headerlink" title="2.4.1    类型"></a>2.4.1    类型</h3><blockquote>
<p><strong>简介：</strong>类型用来寿命变量所存储的数据的种类。类型会影响变量的存储方式，所以选择合适的类型非常关键。</p>
<h4 id="int和float"><a href="#int和float" class="headerlink" title="int和float"></a><code>int</code>和<code>float</code></h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>速度</th>
<th>存储</th>
<th>取值特点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>整数</td>
<td>较快</td>
<td>占用少</td>
<td>取值范围小</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>浮点数</td>
<td>较慢</td>
<td>占用多</td>
<td>取值范围大</td>
<td>存储的数值往往只是数值的近似值，存在摄入误差</td>
</tr>
</tbody>
</table>
<h3 id="2-4-2-声明"><a href="#2-4-2-声明" class="headerlink" title="2.4.2    声明"></a>2.4.2    声明</h3><p><strong>语法：</strong></p>
<ul>
<li>每条声明都要以<code>;</code>结尾</li>
<li>声明多个相同类型的变量时，中间用<code>,</code>隔开</li>
</ul>
<p><strong>建议：</strong>在声明和语句之间留出空白。<br><strong>注意：</strong><code>main</code> 函数包含声明时，必须把声明放置在语句之前。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  声明</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-4-3-赋值"><a href="#2-4-3-赋值" class="headerlink" title="2.4.3    赋值"></a>2.4.3    赋值</h3><blockquote>
<p><strong>语法：</strong><code>变量 = 表达式</code><br><strong>表达式：</strong>赋值运算的右侧的包含常量、变量和运算符的公式。</p>
</blockquote>
<h3 id="2-4-4-显示变量的值"><a href="#2-4-4-显示变量的值" class="headerlink" title="2.4.4    显示变量的值"></a>2.4.4    显示变量的值</h3><blockquote>
<p><strong>方式：</strong>通过<code>printf</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Height: %d Length: %d\n"</span>, height, length);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-程序：计算箱子的空间重量"><a href="#2-4-5-程序：计算箱子的空间重量" class="headerlink" title="2.4.5    程序：计算箱子的空间重量"></a>2.4.5    程序：计算箱子的空间重量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Name:	pun.c 			 */</span></span><br><span class="line"><span class="comment">/* Purpose:	Prints a bad pun */</span></span><br><span class="line"><span class="comment">/* Author:	K. N. King		 */</span></span><br><span class="line"><span class="comment">/* Date written:	5/21/95	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height, length, width, volume, weight;</span><br><span class="line">	</span><br><span class="line">	height = <span class="number">8</span>;</span><br><span class="line">	length = <span class="number">12</span>;</span><br><span class="line">	width = <span class="number">10</span>;</span><br><span class="line">	volume = height * length * width;</span><br><span class="line">	weight = (volume + <span class="number">165</span>) / <span class="number">166</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensions: %dx%dx%d\n"</span>, length, width, height);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"volume(cubic inches):%d\n"</span>, volume);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensional weight (pounds):%d\n"</span>, weight);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -o pun pun.c</span><br><span class="line">$ ./pun</span><br><span class="line"> Dimensions: 12x10x8</span><br><span class="line"> volume(cubic inches):960</span><br><span class="line"> Dimensional weight (pounds):6</span><br></pre></td></tr></table></figure>
<h3 id="2-4-6-初始化"><a href="#2-4-6-初始化" class="headerlink" title="2.4.6    初始化"></a>2.4.6    初始化</h3><blockquote>
<p><strong>初始化式（initializer）：</strong>在变量声明中加入初始值。<br><strong>注意：</strong>程序开始执行时，默契热情况下某些变量会自动设置为零，而大多数变量则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> height, length = <span class="number">12</span>, width = <span class="number">12</span>;<span class="comment">/*其中第一个个变量的值未知*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-7-显示表达式的值"><a href="#2-4-7-显示表达式的值" class="headerlink" title="2.4.7    显示表达式的值"></a>2.4.7    显示表达式的值</h3><p><code>在任何需要数值的地方，都可以使用具有相同类型的表达式。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prinf(<span class="string">"%d\n"</span>, height * length * width);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-读入输入"><a href="#2-5-读入输入" class="headerlink" title="2.5    读入输入"></a>2.5    读入输入</h2><blockquote>
<p><code>scanf</code>:和<code>printf</code>相对应的c库函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">/*读入一个整数给i*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;x);<span class="comment">/*读入一个float数值给x*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="程序：计算箱子的空间重量（改进版）"><a href="#程序：计算箱子的空间重量（改进版）" class="headerlink" title="程序：计算箱子的空间重量（改进版）"></a>程序：计算箱子的空间重量（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Computes the dimensioal weight of a box</span><br><span class="line"> * from input provided by the user</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height, length, width, volume, weight;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter height of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;height);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter length of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter width of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;width);</span><br><span class="line"></span><br><span class="line">	volume = height * length * width;</span><br><span class="line">	weight = (volume + <span class="number">165</span>) / <span class="number">166</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"volume(cubic inches):%d\n"</span>, volume);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensional weight (pounds):%d\n"</span>, weight);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./dweight2 </span><br><span class="line"> Enter height of box:2</span><br><span class="line"> Enter length of box:3</span><br><span class="line"> Enter width of box:4</span><br><span class="line"> volume(cubic inches):24</span><br><span class="line"> Dimensional weight (pounds):1</span><br></pre></td></tr></table></figure>
<h2 id="2-6-定义常量"><a href="#2-6-定义常量" class="headerlink" title="2.6    定义常量"></a>2.6    定义常量</h2><blockquote>
<p><strong>宏定义（macro definition）：</strong>对程序进行预处理时，预处理器会把每一个宏用其表示的值替换回来。<br><strong>语法：</strong><code># define 宏变量名 字面量或表达式</code><br><strong>注意：</strong></p>
<ul>
<li>常量的名字使用大写字母（沿用了10几年的规范）</li>
<li>当宏包含运算符时，必须使用括号把表达式括起来</li>
</ul>
</blockquote>
<h3 id="程序：华氏温度转换为摄氏温度"><a href="#程序：华氏温度转换为摄氏温度" class="headerlink" title="程序：华氏温度转换为摄氏温度"></a>程序：华氏温度转换为摄氏温度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span><br><span class="line"> * Converts a Fahrenheit temperature to Celsius *</span><br><span class="line"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">define</span> FREEZING_PT  32.0</span></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">define</span> SCALE_FACTOR (5.0 / 9.0)<span class="comment">/*如果是(5/9)结果为0*/</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> fahrenheit, celsius;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter Fahrenheit temperature:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;fahrenheit);</span><br><span class="line"></span><br><span class="line"> 	celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;<span class="comment">/*温度转换*/</span></span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Celsius equivalent:%.1f\n"</span>, celsius);<span class="comment">/*保留小数点后一位*/</span></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./celsius </span><br><span class="line"> Enter Fahrenheit temperature:32</span><br><span class="line"> Celsius equivalent:0.0</span><br></pre></td></tr></table></figure>
<h2 id="2-7-标识符"><a href="#2-7-标识符" class="headerlink" title="2.7    标识符"></a>2.7    标识符</h2><blockquote>
<p><strong>定义：</strong>变量、函数］宏和其他尸体的名字成为标识符(identifier)。<br><strong>规则：</strong></p>
<ol>
<li>可以包含字母、数字和下划线</li>
<li>必须以字母或者下划线开头</li>
<li>区分大小写</li>
<li><code>Q&amp;A</code>标准C对标识符的最大长度没有限制</li>
<li>不能使用<code>关键字</code>作为标识符<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-06-16%20%E4%B8%8B%E5%8D%882.54.55.png" alt="Alt text"></li>
</ol>
</blockquote>
<h2 id="2-8-c语言程序的布局"><a href="#2-8-c语言程序的布局" class="headerlink" title="2.8    c语言程序的布局"></a>2.8    c语言程序的布局</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>语句可以划分在任意多行内</li>
<li>记号间的空格应该便于肉眼区别记号。因此通常在每个运算符的前后都放上一个空格。</li>
<li>缩进有助于轻松识别程序嵌套</li>
<li>空行可以把程序划分成逻辑单元，从而使读者更容易辨别程序的结构。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/1 c语言概述/" itemprop="url">
                  1 c语言概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T21:47:27+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/08/1 c语言概述/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/08/1 c语言概述/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-c语言的历史"><a href="#1-1-c语言的历史" class="headerlink" title="1.1    c语言的历史"></a>1.1    c语言的历史</h2><h3 id="1-1-1-起源"><a href="#1-1-1-起源" class="headerlink" title="1.1.1    起源"></a>1.1.1    起源</h3><blockquote>
<p><strong>简介：</strong>c语言是在贝尔实验室由<code>Ken Thompson</code> <code>Dennis Ritchie</code>及其同事在开发UNIX操作系统的过程中的副产品。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 1969</span><br><span class="line">e=&gt;end: 1973</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: Thompson独自动手使用汇编语言编写了UNIX操作系统的最初版本</span><br><span class="line">op2=&gt;operation: Thompson在BCPL语言（基于ALGOL 60）的基础上开发B语言</span><br><span class="line">op3=&gt;operation: 1970年，B语言经过改进运行在PDP-11上</span><br><span class="line">op4=&gt;operation: 1971年，B语言暴露出不适合PDP-11的问题</span><br><span class="line">op5=&gt;operation: Ritchie开始开发B语言的升级版，NB</span><br><span class="line">op6=&gt;operation: NB越来越脱离B,改名C语言</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-标准化"><a href="#1-1-2-标准化" class="headerlink" title="1.1.2    标准化"></a>1.1.2    标准化</h3><blockquote>
<p><strong>注意：</strong>c语言目前最新标准是1999年修订的<code>C99</code>(ISO 9899:1999)，但目前没有得到广发应用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 1978</span><br><span class="line">e=&gt;end: 1990</span><br><span class="line">op1=&gt;operation: 1978年，《The C Programming Language》第一版出版，成为事实标准，即经典C(K&amp;R C)</span><br><span class="line">op2=&gt;operation: 1983年，ANSI开始编制C语言标准</span><br><span class="line">op3=&gt;operation: 1988年，经过多次修订，C语言标准完成</span><br><span class="line">op4=&gt;operation: 1989年12月通过，成为ANSI标准X3.159-1989</span><br><span class="line">op5=&gt;operation: 1990年，ISO通过此项标准，成为ISO/IEC 9899-1990国际标准，即标准C(ANSI C或ANSI/ISO C)</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-C-语言"><a href="#1-1-3-C-语言" class="headerlink" title="1.1.3    C++语言"></a>1.1.3    C++语言</h3><blockquote>
<p><strong>相关：</strong><code>Concurrent C</code> <code>Object C</code> <code>C++</code><br><strong>C++简介：</strong>贝尔实验室的<code>Bjarne Stroustrup</code>设计，在许多方面对C语言进行扩展，支持面向对象。<br><strong>为什么不直接学习c++：</strong></p>
<ul>
<li>+c++语言比c语言更加难学，最好先精通c</li>
<li>存在大量c语言代码需要维护</li>
<li>并不是所有场景都适合c++</li>
</ul>
</blockquote>
<h2 id="1-2-C语言的优缺点"><a href="#1-2-C语言的优缺点" class="headerlink" title="1.2    C语言的优缺点"></a>1.2    C语言的优缺点</h2><blockquote>
<ul>
<li>c语言是一种低级语言</li>
<li>c语言是一种小型语言</li>
<li>c语言是一种包容性语言</li>
</ul>
</blockquote>
<h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1    优点"></a>1.2.1    优点</h3><ul>
<li>高效性</li>
<li>可移植</li>
<li>功能强大</li>
<li>灵活性</li>
<li>标准库</li>
<li>与UNIX系统的集成</li>
</ul>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ul>
<li>c语言可能会漏洞百出</li>
<li>c程序可能会难以理解</li>
<li>c程序可能会难以修改</li>
</ul>
<h3 id="1-2-3-高效地使用c语言"><a href="#1-2-3-高效地使用c语言" class="headerlink" title="1.2.3    高效地使用c语言"></a>1.2.3    高效地使用c语言</h3><ul>
<li>学习如何规避c语言地缺陷</li>
<li>使用软件工具使程序更加可靠</li>
<li>利用现有地代码库</li>
<li>采用一套切合实际地编码规范</li>
<li>避免“投机取巧”和极度复杂地代码</li>
<li>避免不可移植性</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">100</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
