<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/2/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/2/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_08  枚举类型/" itemprop="url">
                  8 枚举类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:44:27+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_08  枚举类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_08  枚举类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>枚举为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。<br><strong>更加灵活：</strong></p>
<ul>
<li><strong>原始值不是必需的：</strong>不必给每一个枚举成员提供一个值（原始值）</li>
<li><strong>原始值类型：</strong>原始值的类型可以是<code>字符串</code>、<code>字符</code>、<code>整型值</code>或<code>浮点数</code></li>
<li><strong>关联值：</strong>枚举成员可以指定任意类型的关联值存储到枚举成员中</li>
</ul>
<p><strong>一等类型：</strong>采用了很多在传统上只被类（class）所支持的特性</p>
<ul>
<li><strong>计算型属性：</strong>用于提供枚举值的附加信息</li>
<li><strong>实例方法：</strong>用于提供和枚举值相关联的功能</li>
<li><strong>构造函数：</strong>来提供一个初始值</li>
<li><strong>动态扩展：</strong>可以在原始实现的基础上扩展它们的功能</li>
<li><strong>实现协议：</strong>还可以遵守协议（protocols）来提供标准的功能</li>
</ul>
</blockquote>
<h2 id="8-1-枚举语法"><a href="#8-1-枚举语法" class="headerlink" title="8.1    枚举语法"></a>8.1    枚举语法</h2><blockquote>
<p><strong>语法：</strong>使用<code>enum</code>关键词来创建枚举并且把它们的整个定义放在一对<code>{}</code>内，使用<code>case</code>关键字来定义一个新的枚举成员值。</p>
<ul>
<li><strong>没有默认原始值：</strong>枚举成员在被创建时<code>不会被赋予</code>一个<code>默认的整型值</code>(与 C 和 Objective-C 不同)</li>
<li><strong><code>case</code>后多个成员值：</strong>多个成员值可以出现在同一行上，用<code>,</code>隔开</li>
<li><strong>枚举类型名：</strong>每个枚举定义了一个全新的类型，它们的名字应该<code>以一个大写字母开头</code>（像 Swift 中其他类型一样）</li>
<li><strong>省略类型名：</strong>当变量或常量的类型已知是某种枚举类型时时，再次为其赋值可以省略相应枚举类型名。</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> 成员<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 成员<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case后一个成员值的情况</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case后多个成员值的情况</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举值的声明和赋值</span></span><br><span class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line">directionToHead = .<span class="type">East</span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-使用switch语句匹配枚举值"><a href="#8-2-使用switch语句匹配枚举值" class="headerlink" title="8.2    使用switch语句匹配枚举值"></a>8.2    使用switch语句匹配枚举值</h2><blockquote>
<p><strong>注意：</strong>必须穷举所有枚举值的情况（<code>switch</code>的完备性）</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">directionToHead = .<span class="type">South</span></span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"watch out for penguins"</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Where the sun rises"</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Where the skies are blue"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-关联值"><a href="#8-3-关联值" class="headerlink" title="8.3    关联值"></a>8.3    关联值</h2><blockquote>
<p><strong>说明：</strong>连同成员值一起存储额外的自定义信息。</p>
<ul>
<li>每次在代码中使用该枚举成员时，还可以用不同的关联值</li>
<li>可以定义 Swift 枚举来存储任意类型的关联值</li>
</ul>
<p><strong>语法：</strong><code>case 成员名(关联值1类型, 关联值1类型, ...)</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条形码</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 二维码</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条形码</span></span><br><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维码</span></span><br><span class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="提取关联值"><a href="#提取关联值" class="headerlink" title="提取关联值"></a>提取关联值</h3><blockquote>
<p><strong>说明：</strong>可以在<code>switch</code>语句中提取一个枚举值的关联值。<br><strong>语法：</strong>需要声明提取关联值到常量（<code>let</code>）还是变量（<code>var</code>）</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 枚举值 &#123;</span><br><span class="line">    <span class="keyword">case</span> .枚举成员<span class="number">1</span>(<span class="keyword">let</span> 关联值<span class="number">1</span>, ...)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>当一个<code>enum</code>值关联的所有关联值都想提取为<code>let</code>或<code>var</code>时，为了简洁，可以只在成员名称前标注一个<code>let</code>或者<code>var</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过switch提取关联值</span></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"UPC-A:\(numberSystem), \(manufacturer), \(product), \(check)"</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">QRCode</span>(<span class="keyword">let</span> productCode):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"QR code:\(productCode)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写（仅用于所有关联值都要提取为为常量或变量时）:在成员名前标注一个let或var</span></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">UPCA</span>(numberSystem, manufacturer, product, check):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"UPC-A: \(numberSystem), \(manufacturer), \(product), \(check)."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(productCode):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"QR code: \(productCode)."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-原始值"><a href="#8-4-原始值" class="headerlink" title="8.4    原始值"></a>8.4    原始值</h2><blockquote>
<p><strong>说明：</strong>枚举成员都可以有一个默认值，也叫原始值</p>
<ul>
<li>原始值的类型必须相同</li>
<li>原始值可以是<code>字符串</code>，<code>字符</code>，或者<code>任意整型值</code>或<code>浮点型值</code></li>
</ul>
<p><strong>注意：</strong><code>原始值</code>和<code>关联值</code>不要混淆</p>
</blockquote>
<table>
<thead>
<tr>
<th>区分对象</th>
<th>设置的时间</th>
<th>是否可以改变</th>
</tr>
</thead>
<tbody>
<tr>
<td>关联值</td>
<td>创建一个基于枚举成员的常量或变量时</td>
<td>是</td>
</tr>
<tr>
<td>原始值</td>
<td>定义枚举类型时</td>
<td>否</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-1-原始值的隐式赋值"><a href="#8-4-1-原始值的隐式赋值" class="headerlink" title="8.4.1    原始值的隐式赋值"></a>8.4.1    原始值的隐式赋值</h3><blockquote>
<p><strong>说明：</strong>在使用原始值为<code>整数</code>或者<code>字符串类型</code>的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p>
</blockquote>
<h4 id="原始值为整数"><a href="#原始值为整数" class="headerlink" title="原始值为整数"></a>原始值为整数</h4><blockquote>
<ul>
<li>隐式赋值的值依次递增1</li>
<li>如果第一个枚举成员没有设置原始值，其原始值将为0</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始值的隐式赋值</span></span><br><span class="line"><span class="comment">// 星球（带有Int型原始值）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问原始值</span></span><br><span class="line"><span class="keyword">let</span> earthsOrder = <span class="type">Planet</span>.<span class="type">Earth</span>.rawValue</span><br></pre></td></tr></table></figure>
<h4 id="原始值为字符串"><a href="#原始值为字符串" class="headerlink" title="原始值为字符串"></a>原始值为字符串</h4><blockquote>
<p><strong>说明：</strong>每个枚举成员的隐式原始值为该枚举成员的名称</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指南针（带有String类型）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sunsetDirection = <span class="type">CompassPoint</span>.<span class="type">West</span>.rawValue</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-使用原始值初始化枚举实例"><a href="#8-4-2-使用原始值初始化枚举实例" class="headerlink" title="8.4.2    使用原始值初始化枚举实例"></a>8.4.2    使用原始值初始化枚举实例</h3><blockquote>
<p><strong>说明：</strong>在定义枚举类型的时候使用了<code>原始值</code>，那么将会自动获得一个初始化方法<br><strong>调用初始化方法：</strong><code>枚举类型名(rawValue: 原始值)</code></p>
<ul>
<li><strong>参数：</strong>接收一个叫做<code>rawValue</code>的参数，参数类型即为原始值类型</li>
<li><strong>返回值（可选型）：</strong><code>枚举成员</code>或<code>nil</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星球（带有Int型原始值）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原始值初始化枚举实例</span></span><br><span class="line"><span class="keyword">let</span> passiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举的可失败构造器</span></span><br><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There isn't a planet at position \(positionToFind)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-5-递归枚举"><a href="#8-5-递归枚举" class="headerlink" title="8.5    递归枚举"></a>8.5    递归枚举</h2><blockquote>
<p><strong>说明：</strong>是一种特殊的枚举类型</p>
<ul>
<li>有一个或多个枚举成员<code>使用该枚举类型的实例作为关联值</code></li>
<li>使用递归枚举时，编译器会插入一个间接层</li>
<li>可以在枚举成员前加上<code>indirect</code>来表示该成员可递归</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 纯数字</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 两个表达式的和</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="comment">// 两个表达式的积</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对表达式进行处理的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">            <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">            <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum, <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_07  闭包/" itemprop="url">
                  7 闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:40:46+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_07  闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_07  闭包/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>描述：</strong>可以捕获和存储其所在上下文中任意常量或变量的引用的字包含的函数代码块。<br><strong>说明：</strong>由<code>3</code>种类型的闭包。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>是否有名字</th>
<th>捕获内容</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局函数</td>
<td>是</td>
<td>无</td>
<td>严格说来不是闭包</td>
</tr>
<tr>
<td>嵌套函数</td>
<td>是</td>
<td>其封闭函数域内的变量或常量的引用</td>
<td>在较复杂函数中，需要命名和定义自包含代码模块的场景</td>
</tr>
<tr>
<td>闭合表达式</td>
<td>否</td>
<td>其上下文中的变量或常量的引用</td>
<td>处理一些函数并需要将另外一些函数作为该函数的参数时</td>
</tr>
</tbody>
</table>
<h2 id="7-1-闭包表达式"><a href="#7-1-闭包表达式" class="headerlink" title="7.1    闭包表达式"></a>7.1    闭包表达式</h2><blockquote>
<p><strong>描述：</strong>闭包表达式是一种利用简洁语法构建内联闭包的方式<br><strong>说明：</strong>和<code>全局函数</code>或<code>嵌套函数</code>相比有如下特点</p>
<ul>
<li><strong>类型推断：</strong>利用上下文推断<code>参数</code>和<code>返回值</code>类型</li>
<li><strong>隐式返回：</strong>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>语句。</li>
<li><strong>参数名称缩写</strong></li>
<li><strong>尾随闭包语法</strong></li>
</ul>
<p><strong>语法：</strong>一般形式</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>可以使用<code>常量</code>、<code>变量</code>和<code>inout</code>类型作为参数</li>
<li>参数不支持设置<code>默认值</code></li>
<li>可以在参数列表的最后使用<code>可变参数</code></li>
<li><code>元组</code>也可以作为参数和返回值</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Charis"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个比较函数（按照字典顺序逆序排序）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backwards</span><span class="params">(s1: String, s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">var</span> reversed = names.<span class="built_in">sort</span>(backwards)<span class="comment">// ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包表达式</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>(&#123;(s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 闭包表达式：推断类型</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>(&#123;s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭合表达式：推断类型、隐式返回</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>(&#123;s1, s2 <span class="keyword">in</span> s1 &gt; s2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭合表达式：推断类型、隐式返回、参数名缩写</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>(&#123;$<span class="number">0</span> &gt; $<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭合表达式：&gt;(一个字符串函数)</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>(&gt;)</span><br></pre></td></tr></table></figure>
<h2 id="7-2-尾随闭包"><a href="#7-2-尾随闭包" class="headerlink" title="7.2    尾随闭包"></a>7.2    尾随闭包</h2><blockquote>
<p><strong>条件：</strong>当将闭包作为最后一个参数传递给函数时<br><strong>用途：</strong>增强函数的<code>可读性</code>（其实就是一种特殊条件下的简写）<br><strong>语法：</strong>书写在函数<code>()</code>之后，用<code>{}</code>括起来。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 案例1：基本案例 */</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 用于展示尾随闭包的函数</span><br><span class="line">* @param &#123;() -&gt; Void&#125; closure 函数类型参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：不使用尾随闭包</span></span><br><span class="line">someFunctionThatTakesAClosure(&#123;</span><br><span class="line">    <span class="comment">// 闭包主体</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：使用尾随闭包</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 案例2：sort */</span></span><br><span class="line"><span class="comment">// sort使用尾随闭包</span></span><br><span class="line">reversed = names.<span class="built_in">sort</span>() &#123;$<span class="number">0</span> &gt; $<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort使用尾随闭包：省略()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 案例3：map */</span></span><br><span class="line"><span class="keyword">let</span> digitNames = [</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Zero"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"One"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"Two"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"Three"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"Four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"Five"</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">"Six"</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">"Seven"</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">"Eight"</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">"Nine"</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尾随闭包：["OneSix", "FiveEight", "FiveOneZero"]</span></span><br><span class="line"><span class="keyword">let</span> strings = numbers.<span class="built_in">map</span>&#123;</span><br><span class="line">    (<span class="keyword">var</span> number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">        output = digitNames[number % <span class="number">10</span>]! + output</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-捕获值"><a href="#7-3-捕获值" class="headerlink" title="7.3    捕获值"></a>7.3    捕获值</h2><blockquote>
<p><strong>说明：</strong>能够捕获值的闭包有<code>2</code>种</p>
<ul>
<li><strong>嵌套函数：</strong>捕获其外部函数所有的参数以及定义的常量和变量</li>
<li><strong>闭包表达式：</strong>闭包可以在其被定义的上下文中捕获常量或变量</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>如果一个值是不可变的，Swift 可能会改为捕获并保存一份对值的拷贝</li>
<li>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 捕获值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(froIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span><span class="comment">// 被捕获</span></span><br><span class="line">    <span class="comment">// 嵌套函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得闭包1</span></span><br><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(froIncrement: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用闭包</span></span><br><span class="line">incrementByTen()<span class="comment">// 10</span></span><br><span class="line">incrementByTen()<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得闭包2</span></span><br><span class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementor(froIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()<span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h2 id="7-4-闭包是引用类型"><a href="#7-4-闭包是引用类型" class="headerlink" title="7.4    闭包是引用类型"></a>7.4    闭包是引用类型</h2><blockquote>
<p><strong>说明：</strong>这意味着不同的变量或常量可以引用同一个闭包。</p>
</blockquote>
<h2 id="7-5-逃逸闭包和非逃逸闭包"><a href="#7-5-逃逸闭包和非逃逸闭包" class="headerlink" title="7.5    逃逸闭包和非逃逸闭包"></a>7.5    逃逸闭包和非逃逸闭包</h2><blockquote>
<p><strong>逃逸：</strong>当一个闭包作为参数传到一个函数中，但是这个闭包在函数执行过程中没有执行，函数返回之后才被执行或者从来没有执行过，我们称该闭包从函数中逃逸。<br><strong>说明：</strong>通过标注传入闭包的闭包为<code>@noescape</code>，让编译器对<code>非逃逸闭包</code>进行优化。</p>
</blockquote>
<h3 id="noescape"><a href="#noescape" class="headerlink" title="@noescape"></a>@noescape</h3><blockquote>
<p><strong>说明：</strong>告诉编译器，闭包必须在被传入到的函数体中执行。</p>
<ul>
<li>将闭包标注为<code>@noescape</code>使你能在闭包中隐式地引用<code>self</code>（因为<code>@noescape</code>保障了成员方法）</li>
</ul>
<p><strong>用途：</strong>使编译器能够进行一些更加激进的优化。<br><strong>注意：</strong>如果被标注了<code>@noescape</code>的闭包没有在函数体中执行，编译器讲报错。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 参数带有@noescape标注（闭包不可以逃逸）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNoescapeClosure</span><span class="params">(@noescape closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数不带@noescape标注（闭包可以逃逸）</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 掩饰@noescape标注的闭包中隐式使用self</span><br><span class="line">* 成员函数doSomething会调用上面两个函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 传入闭包：必须使用self</span></span><br><span class="line">        someFunctionWithEscapingClosure &#123;<span class="keyword">self</span>.x = <span class="number">100</span>&#125;</span><br><span class="line">        <span class="comment">// 传入闭包：self可以省略</span></span><br><span class="line">        someFunctionWithNoescapeClosure &#123;x = <span class="number">200</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)<span class="comment">// 200(说明@noescape的闭包不使用self也成功调用了x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用前面通过someFunctionWithEscapingClosure逃逸的闭包</span></span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x)<span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h2 id="7-6-自动闭包"><a href="#7-6-自动闭包" class="headerlink" title="7.6    自动闭包"></a>7.6    自动闭包</h2><blockquote>
<p><strong>描述：</strong><code>自动闭包</code>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。<br><strong>限制：</strong><br><strong>用途：</strong>这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的<code>{}</code>。<br><strong>说明：</strong>有<code>2</code>种方式</p>
<ul>
<li>显式创建：<code>{语句}</code></li>
<li></li>
</ul>
<p><strong>技巧：</strong>自动闭包让你能够<code>延迟求值</code>，因为代码段不会被执行直到你调用这个闭包。延迟求值对于那些有<code>副作用</code>和<code>代价昂贵</code>的代码来说是很有益处的，因为你能控制代码什么时候执行。</p>
</blockquote>
<h3 id="7-6-1-通过普通闭包实现延迟执行"><a href="#7-6-1-通过普通闭包实现延迟执行" class="headerlink" title="7.6.1    通过普通闭包实现延迟执行"></a>7.6.1    通过普通闭包实现延迟执行</h3><p><em>案例1：先创建闭包然后调用 </em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Aelx"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// 创建自动闭包</span></span><br><span class="line"><span class="keyword">let</span> customerProvider = &#123;customersInLine.removeAtIndex(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="comment">// 执行闭包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Now serving\(customerProvider())!"</span>)</span><br></pre></td></tr></table></figure>
<p><em>案例2：将闭包作为参数传递</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer( &#123; customersInLine.removeAtIndex(<span class="number">0</span>) &#125; )</span><br></pre></td></tr></table></figure>
<h3 id="7-6-2-自动闭包实现延迟执行"><a href="#7-6-2-自动闭包实现延迟执行" class="headerlink" title="7.6.2    自动闭包实现延迟执行"></a>7.6.2    自动闭包实现延迟执行</h3><h4 id="autoclosure和-autoclosure-escaping"><a href="#autoclosure和-autoclosure-escaping" class="headerlink" title="@autoclosure和@autoclosure(escaping)"></a>@autoclosure和@autoclosure(escaping)</h4><blockquote>
<p><strong>说明：</strong>通过将参数标记为<code>@autoclosure</code>来接收一个自动闭包。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>是否允许闭包逃逸</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@autoclosure</td>
<td>不</td>
<td>暗含了<code>@noescape</code>特性</td>
</tr>
<tr>
<td>@autoclosure(escaping)</td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过autoclosure标记，自动将传入的参数（语句）转换为闭包 */</span></span><br><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 包装（延迟执行）对顾客的服务</span><br><span class="line">* @param &#123;() -&gt; String&#125; @autoclosure customerProvider 将输参数（语句）自动转换为一个() -&gt; String的闭包</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(@autoclosure customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// customerProvider是一个被自动封装好的闭包</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：customersInLine.removeAtIndex(0)在serveCustomer中被调用（通过自动闭包）时才会执行</span></span><br><span class="line"></span><br><span class="line">serveCustomer(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h5 id="autoclosure-escaping"><a href="#autoclosure-escaping" class="headerlink" title="@autoclosure(escaping)"></a>@autoclosure(escaping)</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="comment">// 存储() -&gt; String类型闭包的数组</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 将闭包存入集合的工具函数</span><br><span class="line">* @param &#123;() -&gt; String&#125; @autoclosure(escaping) customerProvider 为语句自动创建() -&gt; String类型的封包</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProvider</span><span class="params">(@autoclosure<span class="params">(escaping)</span></span></span> customerProvider: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用工具函数</span></span><br><span class="line">collectCustomerProvider(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line">collectCustomerProvider(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Collected \(customersInLine.count)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行集合中的闭包</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProviders)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_06  函数/" itemprop="url">
                  6 函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:40:24+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_06  函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_06  函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>用来完成特定任务的独立的代码。</p>
<ul>
<li><strong>从简单到复杂：</strong>既可以定义最简单的没有参数名字的 C 风格函数，也可以定义复杂的带局部和外部参数名的 Objective-C 风格函数</li>
<li><strong>默认参数值：</strong>参数可以提供默认值，以简化函数调用</li>
<li><strong>In-out参数：</strong>参数前加 <code>&amp;</code> 符,表示这个值可以被函数修改（只能针对变量参数，类似传引用）</li>
<li><strong>当作普通变量：</strong>可以把函数类型当做任何其他普通变量类型一样处理</li>
<li><strong>嵌套：</strong>函数的定义可以写在在其他函数定义中</li>
</ul>
</blockquote>
<h2 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1    定义"></a>6.1    定义</h2><blockquote>
<p><strong>定义：</strong>使用<code>func</code>关键字</p>
<ul>
<li><strong>函数名：</strong>描述函数执行的任务</li>
<li><strong>参数：</strong>可以定义一个或多个有名字和类型的值，作为函数的输入</li>
<li><strong>返回值：</strong>可以定义某种类型的值作为函数执行结束的输出</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloAgain</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloAgain(<span class="string">"Anna"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-参数"><a href="#6-1-1-参数" class="headerlink" title="6.1.1    参数"></a>6.1.1    参数</h3><blockquote>
<p><strong>说明：</strong>特点总结</p>
<ul>
<li><strong>参数数量：</strong>参数可以没有、1个或多个（用<code>,</code>分隔）</li>
<li><strong>参数名：</strong>包括外部参数名（为了调用时的可读性）和内部参数名（内部调用）</li>
<li><strong>默认参数值：</strong>当默认值被定义后,调用这个函数时可以忽略这个 参数</li>
<li><strong>定义可变参数：</strong>可以用可变参数来传入不确定数 量的输入参数</li>
<li><strong>常量参数：</strong>函数参数默认是常量，在函数体中不能修改</li>
<li><strong>变量参数：</strong>可以在函数中把它当做新的可修改副本来使<br>用</li>
</ul>
</blockquote>
<h4 id="6-1-1-1-参数数量和类型"><a href="#6-1-1-1-参数数量和类型" class="headerlink" title="6.1.1.1    参数数量和类型"></a>6.1.1.1    参数数量和类型</h4><blockquote>
<p><strong>说明：</strong>参数具有以下特点</p>
<ul>
<li><strong>数量：</strong>可以有0个或多个输入参数</li>
<li><strong>类型：</strong>可以有多种类型的输入参数</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数数量</th>
<th>参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>无参函数</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>多参量函数</td>
<td>大于1</td>
<td>多种类型</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloAgain</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参量函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHelloAgain(personName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(personName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">true</span>))</span><br></pre></td></tr></table></figure>
<h4 id="6-1-1-2-参数名"><a href="#6-1-1-2-参数名" class="headerlink" title="6.1.1.2    参数名"></a>6.1.1.2    参数名</h4><blockquote>
<p><strong>说明：</strong>包括<code>内部参数名</code>和<code>外部参数名</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部参数名</td>
<td>在函数被调用时，函数内部用来访问参数相应副本</td>
<td>所有参数都必须有</td>
</tr>
<tr>
<td>外部参数名</td>
<td>往函数的调用语句中传递参数时使用</td>
<td>第一个参数可以指定，其它参数要么指定一个外部参数名，要么就默认和内部参数名相同（除非使用<code>_</code>声明不指定外部参数名）</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定外部参数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to person: String, and anotherPerson: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello \(person) and \(anotherPerson)!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(to: <span class="string">"Bill"</span>, and: <span class="string">"Ted"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用_忽略外部参数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, <span class="number">_</span> secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="6-1-1-2-默认参数值"><a href="#6-1-1-2-默认参数值" class="headerlink" title="6.1.1.2    默认参数值"></a>6.1.1.2    默认参数值</h4><blockquote>
<p><strong>语法：</strong><code>部参数名: 参数类型 = 默认值</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>将带有默认值的参数放在函数参数列表的最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同的函数在不同情况下调用时显得更为清晰。</p>
</blockquote>
<h4 id="6-1-1-3-可变参数"><a href="#6-1-1-3-可变参数" class="headerlink" title="6.1.1.3    可变参数"></a>6.1.1.3    可变参数</h4><blockquote>
<p><strong>说明：</strong>可以用可变参数来指定函数参数可以被传入不确定数量的输入值。</p>
<ul>
<li>可变参数的传入值在函数体中变为此类型的一个数组</li>
<li>一个函数<code>最多只能有一个</code>可变参数</li>
<li>如果函数有一个或多个带默认值的参数，而且还有一个可变参数，那么把可变参数放在参数表的最后</li>
</ul>
<p><strong>语法：</strong><code>部参数名: 参数类型 ...</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br></pre></td></tr></table></figure>
<h4 id="6-1-1-4-常量参数和变量参数"><a href="#6-1-1-4-常量参数和变量参数" class="headerlink" title="6.1.1.4    常量参数和变量参数"></a>6.1.1.4    常量参数和变量参数</h4><blockquote>
<p><strong>说明：</strong>对于<code>值类型</code>(<code>class</code>之外的所有类型)，无论<code>常量参数</code>还是<code>变量参数</code>，函数使用的都是副本。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>副本是否可以修改</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量参数</td>
<td>否</td>
<td>默认</td>
<td></td>
</tr>
<tr>
<td>变量参数</td>
<td>是</td>
<td><code>var 参数名: 参数类型</code></td>
<td>仅存在于函数调用的声明周期中，调用结速后修改便消失了</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;String|var&#125; string 字符串</span><br><span class="line">* @param &#123;Int&#125; totalLength 输出总长度</span><br><span class="line">* @param &#123;Character&#125; pad 填充使用的字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alignRight</span> <span class="params">(<span class="keyword">var</span> string: String, totalLength: Int, pad: Character)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// 要在前面填充的字符总数</span></span><br><span class="line">    <span class="keyword">let</span> amountToPad = totalLength - string.characters.<span class="built_in">count</span>;</span><br><span class="line">    <span class="keyword">if</span> amountToPad &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> padString = <span class="type">String</span>(pad)</span><br><span class="line">    <span class="comment">// 补上填充字符</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...amountToPad &#123;</span><br><span class="line">        string = padString + string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回填充后的字符串</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-5-输入输出参数"><a href="#6-1-2-5-输入输出参数" class="headerlink" title="6.1.2.5    输入输出参数"></a>6.1.2.5    输入输出参数</h4><blockquote>
<p><strong>关键字：</strong><code>inout</code>(声明函数时使用)<br><strong>操作符：</strong><code>&amp;</code>（调用函数时使用）<br><strong>说明：</strong>相当于将原本针对值类型默认的<code>传值</code>转变为<code>传引用</code>。</p>
<ul>
<li>只能传递<code>变量</code>给<code>输入输出参数</code>（不能传入<code>常量</code>或者<code>字面量</code>）</li>
<li>不能用于<code>带默认值的参数</code>和<code>可变参数</code></li>
<li>参数被<code>inout</code>标记后就不能再被<code>let</code>或<code>var</code>标记</li>
</ul>
<p><strong>扩展：</strong>函数对函数体外进行影响的两个方式</p>
<ul>
<li>返回值</li>
<li>输入输出参数</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 对调两个整数的值</span><br><span class="line">* @param &#123;Int|input&#125; a 第一个整数</span><br><span class="line">* @param &#123;Int|input&#125; b 第二个整数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line"><span class="comment">// &amp;</span></span><br><span class="line"><span class="built_in">swap</span>(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now \(someInt), and anotherInt is now \(anotherInt)"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-1-2-返回值"><a href="#6-1-2-返回值" class="headerlink" title="6.1.2    返回值"></a>6.1.2    返回值</h3><blockquote>
<p><strong>声明返回值语法：</strong><code>func 函数名 () -&gt; 返回值类型 {...}</code><br><strong>说明：</strong>分为3种情况</p>
</blockquote>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>严格说来函数依然返回了值<code>Void</code>（空元组）</td>
<td></td>
</tr>
<tr>
<td>一个返回值</td>
<td>任意类型</td>
<td></td>
</tr>
<tr>
<td>多个返回值</td>
<td>用元组让多个值作为一个符合值返回</td>
<td>也可以是可选型元组</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>函数一旦设置了返回值，则必须通过<code>return</code>返回相应类型的返回值。</p>
</blockquote>
<h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><blockquote>
<p><strong>说明：</strong>声明方式有3种</p>
<ul>
<li>省略<code>-&gt; 返回值类型</code></li>
<li><code>-&gt; Void</code></li>
<li><code>-&gt; ()</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="comment">// 1. 不使用 -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayGoodbye</span><span class="params">(personName: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Bye, \(personName)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. -&gt; Void</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayGoodbye2</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Bye, \(personName)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. -&gt; ()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayGoodsbye3</span><span class="params">(personName: String)</span></span> -&gt; () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Bye, \(personName)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回元组"><a href="#返回元组" class="headerlink" title="返回元组"></a>返回元组</h4><blockquote>
<p><strong>技巧：</strong>声明返回的元组时，为每一项设置名字，以便通过名字访问每一项。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 返回数组种的最大值和最小值</span><br><span class="line">* @param &#123;Array&lt;Int&gt;&#125; array 数组</span><br><span class="line">* @return &#123;(min: Int, max: Int)&#125; 元组</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMin)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min is \(bounds.min) and max is \(bounds.max)"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="返回可选型元组"><a href="#返回可选型元组" class="headerlink" title="返回可选型元组"></a>返回可选型元组</h4><blockquote>
<p><strong>语法：</strong><code>-&gt; (...)?</code><br><strong>应用：</strong>当返回的元组可能是一个<code>nil</code>值时必须将返回的元组定义为可选型</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 返回数组种的最大值和最小值</span><br><span class="line">* @param &#123;Array&lt;Int&gt;&#125; array 数组</span><br><span class="line">* @return &#123;(min: Int, max: Int)?&#125; 元组</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="comment">// 如果数组为空，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMin)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"min is \(bounds.min) and max is \(bounds.max)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-函数类型"><a href="#6-2-函数类型" class="headerlink" title="6.2    函数类型"></a>6.2    函数类型</h2><blockquote>
<p><strong>说明：</strong>函数的类型由函数的<code>参数类型</code>和<code>返回值类型</code>决定。项其它类型一样：</p>
<ul>
<li><strong>常量或变量：</strong>可以定义一个类型为函数的常量或变量，并将函数赋值给它</li>
<li><strong>赋值：</strong>如果变量或常量是某种函数类型，那么只有匹配的函数才能进行赋值</li>
<li><strong>类型推断：</strong>当赋值一个函数给常量或变量时，Swift可以推断其函数类型</li>
<li><strong>作为参数</strong></li>
<li><strong>作为返回值类型</strong></li>
</ul>
</blockquote>
<h3 id="6-2-1-基本使用"><a href="#6-2-1-基本使用" class="headerlink" title="6.2.1    基本使用"></a>6.2.1    基本使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数类型：(Int, Int) -&gt; Int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型：() -&gt; Void</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数类型变量</span></span><br><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(2, 3))"</span>)<span class="comment">// 声明并赋值</span></span><br><span class="line"></span><br><span class="line">mathFunction = multiplyTwoInts<span class="comment">// 重新赋值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(2, 3))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherMathFunction = addTwoInts<span class="comment">// 自动类型推断</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-作为参数"><a href="#6-2-2-作为参数" class="headerlink" title="6.2.2    作为参数"></a>6.2.2    作为参数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(a, b))"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-作为返回值"><a href="#6-2-3-作为返回值" class="headerlink" title="6.2.3    作为返回值"></a>6.2.3    作为返回值</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 选择相应步骤的函数</span><br><span class="line">* @param &#123;Bool&#125; backwards 返回哪个函数的依据</span><br><span class="line">* @return &#123;(Int) -&gt; Int&#125; 函数类型返回值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepBackward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(currentValue &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-3-嵌套函数"><a href="#6-3-嵌套函数" class="headerlink" title="6.3    嵌套函数"></a>6.3    嵌套函数</h2><blockquote>
<p><strong>说明：</strong>定义在其他函数中的函数。</p>
<ul>
<li>对外界不可见</li>
<li>可以通过被函数返回使其对外界可见</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_05  控制流/" itemprop="url">
                  5 控制流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:38:49+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_05  控制流/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_05  控制流/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="5-1-for循环"><a href="#5-1-for循环" class="headerlink" title="5.1    for循环"></a>5.1    for循环</h2><blockquote>
<p><strong>说明：</strong>有两种形式</p>
<ul>
<li><code>for-in</code></li>
<li><code>for initialization; condition; increment</code>（c语言形式）</li>
</ul>
</blockquote>
<h3 id="5-1-1-for-in"><a href="#5-1-1-for-in" class="headerlink" title="5.1.1    for-in"></a>5.1.1    for-in</h3><blockquote>
<p><strong>说明：</strong>可以遍历的集合包括<code>区间</code>、<code>Array</code>、<code>Set</code>、<code>String中的字符</code>。</p>
<ul>
<li>其中每次循环都会被赋值的常量不需要声明</li>
<li>可以使用<code>_</code>忽略每个数据项中具体的值</li>
<li>字典内部是无序的，不经处理不能保证遍历顺序</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index) times 5 is \(index * 5)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, <span class="number">_</span>) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(animalName)s"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-C语言形式"><a href="#5-1-2-C语言形式" class="headerlink" title="5.1.2    C语言形式"></a>5.1.2    C语言形式</h3><blockquote>
<p><strong>语法：</strong>标准C样式。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> initialization; condition; increment &#123;</span><br><span class="line">&gt;    statements</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; ++index &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is \(index)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-while循环"><a href="#5-2-while循环" class="headerlink" title="5.2    while循环"></a>5.2    while循环</h2><blockquote>
<p><strong>说明：</strong>分两类</p>
<ul>
<li><code>while</code></li>
<li><code>repeat-while</code></li>
</ul>
</blockquote>
<h3 id="5-2-1-while"><a href="#5-2-1-while" class="headerlink" title="5.2.1    while"></a>5.2.1    while</h3><blockquote>
<p><strong>说明：</strong>每次在循环开始时计算条件是否符合。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;  </span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-repeat-while"><a href="#5-2-2-repeat-while" class="headerlink" title="5.2.2    repeat-while"></a>5.2.2    repeat-while</h3><blockquote>
<p><strong>说明：</strong>和<code>while</code>的区别是在判断循环条件之前，先执行一次循环的代码块，然后重复循环直到条件为<code>false</code>。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">repeat</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3    条件语句"></a>5.3    条件语句</h2><blockquote>
<p><strong>说明：</strong><code>if</code>、<code>switch</code></p>
<ul>
<li><code>if</code>：当条件较为简单且可能的情况很少时使用</li>
<li><code>switch</code>：当条件较复杂、可能情况较多且需要模式匹配的情景使用</li>
</ul>
</blockquote>
<h3 id="5-3-1-if"><a href="#5-3-1-if" class="headerlink" title="5.3.1    if"></a>5.3.1    if</h3><blockquote>
<p><strong>语法：</strong><code>if-[else]</code>、<code>if-else if-...-[else]</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// 处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// 处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temperatureInFahrenheit = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit &gt;= <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's really warm. Don't forget to wear sunscreen."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-switch"><a href="#5-3-2-switch" class="headerlink" title="5.3.2    switch"></a>5.3.2    switch</h3><blockquote>
<p><strong>语法：</strong>类似C语言</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line">	<span class="keyword">case</span> value <span class="number">1</span>:</span><br><span class="line">	    respond to value <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> value <span class="number">2</span>, value <span class="number">3</span>:</span><br><span class="line">	    respond to value <span class="number">2</span> or <span class="number">3</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>和C语言的<code>switch</code>相比更加强悍。<br><strong>更安全：</strong></p>
<ol>
<li>每个<code>case</code>分支都必须包含至少一条语句</li>
<li><code>case</code>和<code>default</code>必须包含所有可能的情况，否则报错</li>
<li>当匹配的<code>case</code>分支中的代码执行完毕，<code>switch</code>终止（不需要手动<code>break</code>）</li>
</ol>
<p><strong>更强大：</strong></p>
<ol>
<li><code>case</code>可以包含多个模式，用<code>,</code>分隔</li>
<li><code>case</code>分支的模式可以是：<code>区间</code>、<code>元组</code></li>
<li>允许多个<code>case</code>匹配到一个值，但执行时只有最前面的被匹配到的分支会执行</li>
<li>值绑定</li>
<li><code>where</code></li>
</ol>
</blockquote>
<h4 id="case多个模式"><a href="#case多个模式" class="headerlink" title="case多个模式"></a><code>case</code>多个模式</h4><blockquote>
<p><strong>用途：</strong>多个值匹配到一种<code>case</code>中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line">    <span class="comment">// 原音字符</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(someCharacter) is a vowel"</span>)</span><br><span class="line">    <span class="comment">// 辅音字符</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</span><br><span class="line"><span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(someCharacter) is a consonant"</span>)</span><br><span class="line">    <span class="comment">// 不匹配24个英文字符</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(someCharacter) is not a vowel or a consonant"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount = <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings = <span class="string">"moons orbiting saturn"</span></span><br><span class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        naturalCount = <span class="string">"no"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</span><br><span class="line">        naturalCount = <span class="string">"a few"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">12</span>:</span><br><span class="line">        naturalCount = <span class="string">"several"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>..&lt;<span class="number">100</span>:</span><br><span class="line">        naturalCount = <span class="string">"dozens of"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>..&lt;<span class="number">1000</span>:</span><br><span class="line">        naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        naturalCount = <span class="string">"many"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are \(naturalCount) \(countedThings)."</span>)</span><br></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><blockquote>
<p><strong>说明：</strong>在<code>case</code> 分支的模式将匹配的值绑定到一个临时的常量或变量，然后就可以在分之内使用这些常量或变量。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line">	<span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"on the x-axis with an x value of \(x)"</span>)</span><br><span class="line">	<span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"on the y-axis with a y value of \(y)"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"somewhere else at (\(x), \(y))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="where表达式"><a href="#where表达式" class="headerlink" title="where表达式"></a><code>where</code>表达式</h4><blockquote>
<p><strong>说明：</strong><code>case</code> 分支的模式可以使用where语句来判断额外的条件。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-控制转移语句"><a href="#5-4-控制转移语句" class="headerlink" title="5.4    控制转移语句"></a>5.4    控制转移语句</h2><blockquote>
<p><strong>说明：</strong>Swift 有<code>5</code>种控制转移语句</p>
<ul>
<li><code>continue</code></li>
<li><code>break</code></li>
<li><code>fallthrough</code></li>
<li><code>return</code></li>
<li><code>throw</code></li>
</ul>
</blockquote>
<h3 id="5-4-1-continue"><a href="#5-4-1-continue" class="headerlink" title="5.4.1    continue"></a>5.4.1    continue</h3><blockquote>
<p><strong>说明：</strong>告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> puzzleInput = <span class="string">"great minds think alike"</span></span><br><span class="line"><span class="keyword">var</span> puzzleOutput = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput.characters &#123;</span><br><span class="line">    <span class="keyword">switch</span> character &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>, <span class="string">" "</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        puzzleOutput.append(character)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(puzzleOutput)</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-break"><a href="#5-4-2-break" class="headerlink" title="5.4.2    break"></a>5.4.2    break</h3><blockquote>
<p><strong>说明：</strong>立刻结束整个控制流的执行。</p>
</blockquote>
<h4 id="switch语句中的break"><a href="#switch语句中的break" class="headerlink" title="switch语句中的break"></a>switch语句中的break</h4><blockquote>
<p><strong>背景：</strong><code>switch</code>的完备性使所有值的情况都要求有对应的分支（但是有的分支內并不需要执行任何代码）<br><strong>说明：</strong>立即结束<code>switch</code>代码块<br><strong>用途：</strong>用来匹配或者忽略一个或多个分支</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberSymbol: <span class="type">Character</span> = <span class="string">"三"</span>  <span class="comment">// 简体中文里的数字 3</span></span><br><span class="line"><span class="keyword">var</span> possibleIntegerValue: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">switch</span> numberSymbol &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"1"</span>, <span class="string">"١"</span>, <span class="string">"一"</span>, <span class="string">"๑"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"2"</span>, <span class="string">"٢"</span>, <span class="string">"二"</span>, <span class="string">"๒"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"3"</span>, <span class="string">"٣"</span>, <span class="string">"三"</span>, <span class="string">"๓"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"4"</span>, <span class="string">"٤"</span>, <span class="string">"四"</span>, <span class="string">"๔"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">4</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = possibleIntegerValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The integer value of \(numberSymbol) is \(integerValue)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An integer value could not be found for \(numberSymbol)."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-fallthrough"><a href="#5-4-3-fallthrough" class="headerlink" title="5.4.3    fallthrough"></a>5.4.3    fallthrough</h3><blockquote>
<p><strong>说明：</strong>使代码执行继续到下一个 <code>case</code> 中的执行代码</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description = <span class="string">"The number \(integerToDescribe) is"</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description += <span class="string">" a prime number, and also"</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description += <span class="string">" an integer."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-4-标签"><a href="#5-4-4-标签" class="headerlink" title="5.4.4    标签"></a>5.4.4    标签</h3><blockquote>
<p><strong>说明：</strong>配合<code>continue</code>或 <code>break</code>实现跳转。适用的语句包括</p>
<ul>
<li><code>while</code>、<code>repeat-while</code></li>
<li><code>for</code></li>
<li><code>switch</code></li>
</ul>
<p><strong>语法：</strong>以<code>while</code>为例子</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找二维数组中的特殊值</span></span><br><span class="line"><span class="keyword">var</span> board = <span class="type">Array</span>&lt;<span class="type">Array</span>&lt;<span class="type">Int</span>&gt;&gt;()<span class="comment">//声明二维数组</span></span><br><span class="line"><span class="comment">//初始化二维数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span>&#123;</span><br><span class="line">    board.append(<span class="type">Array</span>(<span class="built_in">count</span>:<span class="number">10</span>,repeatedValue:<span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机给二维数组中某个元素赋值1</span></span><br><span class="line"><span class="keyword">let</span> randx = <span class="type">Int</span>(arc4random()%<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> randy = <span class="type">Int</span>(arc4random()%<span class="number">10</span>)</span><br><span class="line">board[randx][randy] = <span class="number">1</span></span><br><span class="line"><span class="comment">//找到这个值为1的元素的位置</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span> , j = <span class="number">0</span></span><br><span class="line">mainloop:<span class="keyword">for</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> mainloop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"board[\(i)][\(j)] = 1"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-5-提前退出"><a href="#5-5-提前退出" class="headerlink" title="5.5    提前退出"></a>5.5    提前退出</h2><blockquote>
<p><strong>说明：</strong>条件为真时，执行<code>guard</code>语句后的代码；不为真则执行<code>else</code>分句中的代码。</p>
<ul>
<li>一个<code>guard</code>语句总是有一个<code>else</code>分句</li>
<li><code>else</code>分支必须通过<code>return</code>、<code>break</code>、<code>continue</code>、<code>throw</code>，或者调用一个不返回的方法或函数（比如<code>fatalError</code>函数）来退出<code>guard</code>所在的代码段。</li>
</ul>
<p><strong>用途：</strong>相比于可以实现同样功能的if语句，按需使用<code>guard</code>语句会提升我们代码的可靠性和可读性。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: [String: String])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = person[<span class="string">"name"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello \(name)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location = person[<span class="string">"location"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I hope the weather is nice near you."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I hope the weather is nice in \(location)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"John"</span>])</span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"Jane"</span>, <span class="string">"location"</span>: <span class="string">"Cupertino"</span>])</span><br></pre></td></tr></table></figure>
<h2 id="5-6-检测API是否可用"><a href="#5-6-检测API是否可用" class="headerlink" title="5.6    检测API是否可用"></a>5.6    检测API是否可用</h2><blockquote>
<p><strong>用途：</strong>确保我们不会不小心地使用对于当前部署目标不可用的 API。<br><strong>语法：</strong>最后一个参数<code>*</code>是必须写的，用于处理未来潜在的平台。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(platform name version, ..., *) &#123;</span><br><span class="line">    <span class="comment">// 验证的API可用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>平台名字可以是<code>iOS</code>，<code>OSX</code>或<code>watchOS</code>，除了特定的主板本号像 <code>iOS 8</code>，我们可以指定较小的版本号像 <code>iOS 8.3</code> 以及 <code>OS X v10.10.3</code>。</p>
<ol>
<li>编译器使用从可用性条件语句中获取的信息去验证在代码块中调用的 <code>API</code> 是否都可用</li>
<li>根据步骤<code>1</code>，在一个<code>if</code>或<code>guard</code>语句中去有条件的执行一段代码</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">9</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 9 的 API, 在 OS X 使用 OS X v10.10 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 OS X 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_04  集合类型/" itemprop="url">
                  4 集合类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:33:00+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_04  集合类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_04  集合类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Array、Sets、Dictionary</code>(Swift将这3中类型使纤维范型集合)</p>
</blockquote>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组（Array）</td>
<td>有序数据集合</td>
</tr>
<tr>
<td>集合（Sets）</td>
<td>无序无重复数据的集</td>
</tr>
<tr>
<td>字典（Dictionaries）</td>
<td>无序的键值对的值</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-25%20%E4%B8%8B%E5%8D%8811.16.16.png" alt="Alt text"></p>
<h2 id="4-1-集合的可变性"><a href="#4-1-集合的可变性" class="headerlink" title="4.1    集合的可变性"></a>4.1    集合的可变性</h2><blockquote>
<p><strong>说明：</strong>集合的可变性依赖于声明为常量或变量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>声明</th>
<th>可变性</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量（<code>let</code>）</td>
<td>大小不可改变</td>
</tr>
<tr>
<td>变量（<code>var</code>）</td>
<td>可以添加或移除集合中的项</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>不可变的集合性能更好。</p>
</blockquote>
<h2 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h2><blockquote>
<p><strong>扩展：</strong>Swift中的<code>Array</code>可以桥接到Foundation中的<code>NSArray</code>。</p>
</blockquote>
<h3 id="4-2-1-创建数组"><a href="#4-2-1-创建数组" class="headerlink" title="4.2.1 创建数组"></a>4.2.1 创建数组</h3><blockquote>
<p><strong>说明：</strong>有3种声明数组的形式</p>
</blockquote>
<table>
<thead>
<tr>
<th>形式</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Array&lt;ElementType&gt;(count: Int, repeatedValue)</code></td>
<td>调用数组的<code>构造器</code></td>
<td>如果不提供参数，则会调用另一个构造器（创建空数组）</td>
</tr>
</tbody>
</table>
<p>|<code>[ElementType]（count: Int, repeatedValue）</code>|调用<code>构造器</code>的方式|另一种调用构造器的方式，和上面等价，更常用|<br>|<code>[Element, ...]</code>|数组字面量|<code>[]</code>表示空数组|</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明数组：形式一（构造器，不常用）</span></span><br><span class="line"><span class="keyword">var</span> anotherInts = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;(<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> anotherInts2 = <span class="type">Array</span>(<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInts is of type [Int] with \(someInts.count) items."</span>)</span><br><span class="line"><span class="comment">// 声明数组：形式二（构造器）</span></span><br><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()</span><br><span class="line"><span class="comment">// 声明数组：形式三（数组字面量）</span></span><br><span class="line"><span class="keyword">var</span> shoppingList1: [<span class="type">String</span>] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]<span class="comment">// 指定类型</span></span><br><span class="line"><span class="keyword">var</span> shoppingList2 = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]<span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-空数组"><a href="#4-2-2-空数组" class="headerlink" title="4.2.2 空数组"></a>4.2.2 空数组</h3><blockquote>
<p><strong>说明：</strong>3种方式（对应数组声明的3种方式）</p>
<ol>
<li><code>Array[ElementType]（）</code></li>
<li><code>[ElementType] ()</code></li>
<li><code>[]</code>(空数组字面量无法推断类型，声明常量或变量时需指定类型)</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> emptyArray1 = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> emptyArray2 = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> emptyArray3: [<span class="type">Int</span>] = []</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-数组相加"><a href="#4-2-3-数组相加" class="headerlink" title="4.2.3 数组相加"></a>4.2.3 数组相加</h3><blockquote>
<p><strong>说明：</strong><code>+</code>、<code>+=</code>在数组之间起到拼接的作用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> threeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>:<span class="number">3</span>, repeatedValue: <span class="number">0</span>)<span class="comment">// [0.0, 0.0, 0.0]</span></span><br><span class="line"><span class="keyword">let</span> anotherThreeDoubles = <span class="type">Array</span>(<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)<span class="comment">// [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +</span></span><br><span class="line"><span class="keyword">var</span> sixDouble = threeDoubles + anotherThreeDoubles</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=</span></span><br><span class="line">sixDouble += [<span class="number">3</span>, <span class="number">3</span>]<span class="comment">// [0, 0, 0, 2.5, 2.5, 2.5, 3, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-数组字面量"><a href="#4-2-4-数组字面量" class="headerlink" title="4.2.4 数组字面量"></a>4.2.4 数组字面量</h3><blockquote>
<p><strong>语法：</strong>一系列由<code>,</code>分割并由<code>[]</code>包含的数值。</p>
<ul>
<li>只能拥有相同类型值</li>
<li>当数组不为<code>[]</code>的时候，不必把数组的类型定义清楚</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4-2-5-属性和方法（访问和修改数组）"><a href="#4-2-5-属性和方法（访问和修改数组）" class="headerlink" title="4.2.5 属性和方法（访问和修改数组）"></a>4.2.5 属性和方法（访问和修改数组）</h3><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><blockquote>
<p><strong>说明：</strong><code>arr[下标或下标区间]</code></p>
<ul>
<li>可以通过<code>下标</code>(<code>下标区间</code>)改变某个(些)已有索引值对应的数据项（<code>下标</code>或<code>下标区间</code>不能超过数组的下标范围）</li>
<li><code>下标区间</code>中<code>下标</code>的数量可以和用来替换其对应的数据项的新数据项数量不同</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>, <span class="string">"Maple Syrup"</span>, <span class="string">"Flour"</span>]<span class="comment">// 0...3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前3项（0, 1, 2）替换为 ["Bananas", "Apples"]</span></span><br><span class="line">shoppingList[<span class="number">0</span>...<span class="number">2</span>] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]<span class="comment">// ["Bananas", "Apples", "Flour"]</span></span><br></pre></td></tr></table></figure>
<h4 id="count属性"><a href="#count属性" class="headerlink" title="count属性"></a>count属性</h4><blockquote>
<p><strong>类型：</strong><code>Int</code><br><strong>说明：</strong>只读属性，用来获取数组中的数据项数量。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The shopping list contains \(shoppingList.count) items."</span>)</span><br></pre></td></tr></table></figure>
<h4 id="isEmpty属性"><a href="#isEmpty属性" class="headerlink" title="isEmpty属性"></a>isEmpty属性</h4><blockquote>
<p><strong>类型：</strong><code>Bool</code><br><strong>说明：</strong>用来判断数组是否为空。<br><strong>技巧：</strong>可以作为检查<code>count</code>属性的值是否为0的捷径。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h4><blockquote>
<p><strong>说明：</strong>在数组后面添加新的数据项。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;ElementType&#125; newElement 要被添加的数据项</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(newElement: ElementType)</span></span> -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line">shoppingList.append(<span class="string">"Flour"</span>)<span class="comment">// ["Eggs", "Milk", "Flour"]</span></span><br></pre></td></tr></table></figure>
<h4 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h4><blockquote>
<p><strong>说明：</strong>在某个具体索引项之前添加数据项。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;ElementType&#125; newElement 要插入的数据项</span><br><span class="line">&gt;* @param &#123;Int&#125; atIndex 下标（插入的位置）</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(newElement: String, atIndex: Int)</span></span> -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">"Flour"</span>, atIndex: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="removeAtIndex方法"><a href="#removeAtIndex方法" class="headerlink" title="removeAtIndex方法"></a>removeAtIndex方法</h4><blockquote>
<p><strong>说明：</strong>移除数组中的某一项。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Int&#125; index 要删除的数据项的下标</span><br><span class="line">&gt;* @return &#123;ElementType&#125; 要删除的数据项的类型</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(index: Int)</span></span> -&gt;<span class="type">ElementType</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>, <span class="string">"Maple Syrup"</span>]</span><br><span class="line"><span class="comment">// 删除第一项</span></span><br><span class="line">shoppingList.removeAtIndex(<span class="number">0</span>)<span class="comment">// "flour"</span></span><br></pre></td></tr></table></figure>
<h4 id="removeFirst函数"><a href="#removeFirst函数" class="headerlink" title="removeFirst函数"></a>removeFirst函数</h4><blockquote>
<p><strong>说明：</strong>删除第一项<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return &#123;ElementType&#125; 删除的数组项</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeFirst</span><span class="params">()</span></span> -&gt; <span class="type">ElementType</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>, <span class="string">"Maple Syrup"</span>]</span><br><span class="line"><span class="comment">// 删除第一项</span></span><br><span class="line">shoppingList.removeFirst()<span class="comment">// "Eggs"</span></span><br></pre></td></tr></table></figure>
<h4 id="removeLast函数"><a href="#removeLast函数" class="headerlink" title="removeLast函数"></a>removeLast函数</h4><blockquote>
<p><strong>说明：</strong>删除最后一项<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return &#123;ElementType&#125; 删除的数组项</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> -&gt; <span class="type">ElementType</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>, <span class="string">"Maple Syrup"</span>]</span><br><span class="line"><span class="comment">// 删除第一项</span></span><br><span class="line">shoppingList.removeLast()<span class="comment">// "Maple Syrup"</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-6-数组遍历"><a href="#4-2-6-数组遍历" class="headerlink" title="4.2.6 数组遍历"></a>4.2.6 数组遍历</h3><blockquote>
<p><strong>说明：</strong>有两种方式</p>
<ul>
<li><code>for-in</code>：只在遍历时获得元素项</li>
<li><code>for-in</code>配合<code>enumerate</code>：遍历时获得元素项和对应下标</li>
</ul>
</blockquote>
<h4 id="enumerate方法"><a href="#enumerate方法" class="headerlink" title="enumerate方法"></a>enumerate方法</h4><blockquote>
<p><strong>说明：</strong>配合<code>for-in</code>使用，返回一个由每一个数据项索引和数据值组成的元组。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-in</span></span><br><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>, <span class="string">"Maple Syrup"</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enumerate属性</span></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item \(String(index + 1)): \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-集合"><a href="#4-3-集合" class="headerlink" title="4.3    集合"></a>4.3    集合</h2><blockquote>
<p><strong>关键字：</strong><code>Set</code></p>
<ul>
<li>元素类型相同</li>
<li>没有确定顺序</li>
<li>每个元素只出现一次</li>
</ul>
<p><strong>扩展：</strong>Swift中的<code>Set</code>类型被桥接到<code>Foundation</code>中的<code>NSSet</code>类。</p>
</blockquote>
<h3 id="4-3-1-集合类型的哈希值"><a href="#4-3-1-集合类型的哈希值" class="headerlink" title="4.3.1    集合类型的哈希值"></a>4.3.1    集合类型的哈希值</h3><blockquote>
<p><strong>说明：</strong>存储在<code>Set</code>中的类型必须是可<code>哈希化</code>的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>值类型（可哈细化）</th>
<th>条件</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String</code>、<code>Int</code>、<code>Double</code>、<code>Bool</code></td>
<td>无</td>
<td>所有基本类型（既可以作为值，也可以作为键）</td>
</tr>
<tr>
<td><code>enum</code>类型值</td>
<td>没有关联值</td>
</tr>
<tr>
<td>自定义类型</td>
<td>实现<code>Hashable</code>协议（符合<code>Equatable</code>协议）</td>
<td><code>1.</code>需要提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>；<code>2.</code>提供一个是否相等运算符<code>==</code>的实现</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>Hashable协议的<code>==</code>实现必须满足三种情况</p>
<ul>
<li>自反性：<code>a == a</code></li>
<li>对称性：<code>a == b</code>意味着<code>b == a</code></li>
<li>传递性：<code>a == b</code> &amp;&amp; <code>b == c</code>意味着<code>a == c</code></li>
</ul>
</blockquote>
<h3 id="4-3-2-声明集合类型"><a href="#4-3-2-声明集合类型" class="headerlink" title="4.3.2    声明集合类型"></a>4.3.2    声明集合类型</h3><blockquote>
<p><strong>说明：</strong>有2种类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>形式</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Set&lt;ElementType&gt;()</code></td>
<td>调用构造器</td>
<td>没有类似<code>[ElementType] ()</code>的简化形式</td>
</tr>
<tr>
<td><code>Set()</code></td>
<td>调用构造器</td>
<td>必要条件是声明的变量或常量不仅制定了<code>Set</code>，而且明确了<code>&lt;ElementType&gt;</code></td>
</tr>
<tr>
<td><code>[Element, ...]</code></td>
<td>字面量</td>
<td>需要明确指定<code>标记名:Set&lt;ElementType&gt;</code>，其中<code>&lt;ElementType&gt;</code>在集合字面量不是<code>[]</code>的情况下可以省略（类型推断）</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空Set（形式1）</span></span><br><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with \(letters.count) items."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量（形式2）</span></span><br><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-创建和构造一个空的集合"><a href="#4-3-3-创建和构造一个空的集合" class="headerlink" title="4.3.3    创建和构造一个空的集合"></a>4.3.3    创建和构造一个空的集合</h3><blockquote>
<p><strong>说明：</strong>2种形式（对应两种声明方式）</p>
<ul>
<li><code>Set&lt;ElementType&gt;()</code></li>
<li><code>Set()</code></li>
<li><code>[]</code>(无法进行类型推断，需要指定<code>ElementType</code>)</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="keyword">var</span> emptySet1: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = []</span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">var</span> emptySet2: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()</span><br><span class="line"><span class="comment">// 形式3</span></span><br><span class="line"><span class="keyword">var</span> emptySet3: <span class="type">Set</span> = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure>
<h3 id="4-3-4-用数组字面量创建集合"><a href="#4-3-4-用数组字面量创建集合" class="headerlink" title="4.3.4    用数组字面量创建集合"></a>4.3.4    用数组字面量创建集合</h3><blockquote>
<p><strong>注意：</strong>对应的常量或变量必须指定了<code>Set</code>类型，否则会被默认为<code>Array</code>。</p>
</blockquote>
<h3 id="4-3-5-属性和方法（访问和修改一个集合）"><a href="#4-3-5-属性和方法（访问和修改一个集合）" class="headerlink" title="4.3.5    属性和方法（访问和修改一个集合）"></a>4.3.5    属性和方法（访问和修改一个集合）</h3><h4 id="count属性-1"><a href="#count属性-1" class="headerlink" title="count属性"></a>count属性</h4><blockquote>
<p><strong>类型：</strong><code>Int</code><br><strong>说明：</strong>只读属性，用来获取<code>Set</code>中的数据项数量。</p>
</blockquote>
<h4 id="isEmpty属性-1"><a href="#isEmpty属性-1" class="headerlink" title="isEmpty属性"></a>isEmpty属性</h4><blockquote>
<p><strong>类型：</strong><code>Bool</code><br><strong>说明：</strong>用来判断数组是否为空。<br><strong>技巧：</strong>可以作为检查<code>count</code>属性的值是否为0的捷径。</p>
</blockquote>
<h4 id="insert方法-1"><a href="#insert方法-1" class="headerlink" title="insert方法"></a>insert方法</h4><blockquote>
<p><strong>说明：</strong>在<code>Set</code>中插入一个元素。<br><strong>原型：</strong><code>Set类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Hashable&#125; member 新数据项</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(member: Hashable)</span></span> -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><blockquote>
<p><strong>说明：</strong>移除一个数据项<br><strong>原型：</strong><code>Set类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Hashable&#125; member 要移除的数据项的键</span><br><span class="line">&gt;* @return &#123;Hashable?&#125; 移除的数据项</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(member: Hashable)</span></span> -&gt; <span class="type">Hashable</span>?</span><br></pre></td></tr></table></figure>
<h4 id="contain方法"><a href="#contain方法" class="headerlink" title="contain方法"></a>contain方法</h4><blockquote>
<p><strong>说明：</strong>检查<code>Set</code>中是否包含一个特定的值。<br><strong>原型：</strong><code>Set类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Hashable&#125; member 数据项值</span><br><span class="line">&gt;* @return &#123;Bool&#125; 是否包含 </span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(member: Hashable)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空Set（形式1）</span></span><br><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with \(letters.count) items."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空Set</span></span><br><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="keyword">var</span> emptySet1: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = []</span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">var</span> emptySet2: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()</span><br><span class="line"><span class="comment">// 形式3</span></span><br><span class="line"><span class="keyword">var</span> emptySet3: <span class="type">Set</span> = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="comment">// 清空Set</span></span><br><span class="line">letters = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量（形式2）</span></span><br><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I have \(favoriteGenres.count) favorite music genres."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// isEmpty</span></span><br><span class="line"><span class="keyword">if</span> favoriteGenres.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"As far as music goes, I'm not picky."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have particular music preferences."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert</span></span><br><span class="line">favoriteGenres.insert(<span class="string">"Jazz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre = favoriteGenres.remove(<span class="string">"Rock"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(removedGenre) ? I'm over it."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I never much cared for thar."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// contains</span></span><br><span class="line"><span class="keyword">if</span> favoriteGenres.<span class="built_in">contains</span>(<span class="string">"Funk"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I get up on the good foot."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's too funky here."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-6-遍历一个集合"><a href="#4-3-6-遍历一个集合" class="headerlink" title="4.3.6    遍历一个集合"></a>4.3.6    遍历一个集合</h3><blockquote>
<p><strong>说明：</strong>如果不做任何处理，使用<code>for-in</code>遍历时<code>Set</code>时并没有确定的顺序。</p>
</blockquote>
<h4 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h4><blockquote>
<p><strong>说明：</strong>根据提供的序列返回一个有序<code>Set</code>。<br><strong>原型：</strong><code>Set类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return &#123;Set&#125; 带顺序的Set</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> -&gt; <span class="type">Set</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(genre)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(genre)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-7-完成集合操作"><a href="#4-3-7-完成集合操作" class="headerlink" title="4.3.7    完成集合操作"></a>4.3.7    完成集合操作</h3><h4 id="4-3-7-1-基本集合操作"><a href="#4-3-7-1-基本集合操作" class="headerlink" title="4.3.7.1    基本集合操作"></a>4.3.7.1    基本集合操作</h4><blockquote>
<p><strong>说明：</strong>交、差、并、补</p>
</blockquote>
<table>
<thead>
<tr>
<th>集合操作</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>交</td>
<td>intersect</td>
</tr>
<tr>
<td>差</td>
<td>exclusive</td>
</tr>
<tr>
<td>并</td>
<td>union</td>
</tr>
<tr>
<td>补</td>
<td>subtract</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-29%20%E4%B8%8B%E5%8D%884.04.29.png" alt="Alt text"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 奇数</span></span><br><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">// 偶数</span></span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span> ,<span class="number">2</span> ,<span class="number">4</span> ,<span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// 素数</span></span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并</span></span><br><span class="line">oddDigits.union(evenDigits).<span class="built_in">sort</span>()<span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交</span></span><br><span class="line">oddDigits.intersect(evenDigits).<span class="built_in">sort</span>()<span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差</span></span><br><span class="line">oddDigits.subtract(singleDigitPrimeNumbers)<span class="comment">// [9, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补</span></span><br><span class="line">oddDigits.exclusiveOr(singleDigitPrimeNumbers).<span class="built_in">sort</span>()<span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-7-2-集合成员关系和相等"><a href="#4-3-7-2-集合成员关系和相等" class="headerlink" title="4.3.7.2    集合成员关系和相等"></a>4.3.7.2    集合成员关系和相等</h4><blockquote>
<p><strong>说明：</strong>集合之间的关系可以分为6中情况</p>
</blockquote>
<table>
<thead>
<tr>
<th>关系</th>
<th>判定方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>相等</td>
<td><code>==</code></td>
<td>判断两个集合是否包含全部相同的值</td>
</tr>
<tr>
<td>被包含</td>
<td><code>isSubsetOf</code></td>
<td>判断一个集合中的值是否也被包含在另外一个集合中</td>
</tr>
<tr>
<td>包含</td>
<td><code>isSupersetOf</code></td>
<td>判断一个集合中包含另一个集合的所有值</td>
</tr>
<tr>
<td>被包含且不想等</td>
<td><code>isStrucxtSubsetOf</code></td>
<td>判定一个集合是另外一个集合的真子集</td>
</tr>
<tr>
<td>包含且不想等</td>
<td><code>isStructSupersetOf</code></td>
<td>判定一个集合是另外一个集合的父集且不想等</td>
</tr>
<tr>
<td>不相交</td>
<td><code>isDisjoinWith</code></td>
<td>判断两个集合不包含相同的值</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"dog"</span>, <span class="string">"cat"</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"pig"</span>, <span class="string">"chicken"</span>, <span class="string">"sheep"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimal: <span class="type">Set</span> = [<span class="string">"Dove"</span>, <span class="string">"Mouse"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被包含</span></span><br><span class="line">houseAnimals.isSubsetOf(farmAnimals)<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 包含</span></span><br><span class="line">farmAnimals.isSupersetOf(houseAnimals)<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 不相交</span></span><br><span class="line">farmAnimals.isDisjointWith(cityAnimal)<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4-字典"><a href="#4-4-字典" class="headerlink" title="4.4    字典"></a>4.4    字典</h2><blockquote>
<p><strong>类型关键字：</strong><code>Dictionary</code><br><strong>说明：</strong>其实就是键值对容器。</p>
<ul>
<li>每个<code>value</code>都关联唯一的<code>key</code></li>
<li><code>key</code>作为字典中的这个值数据的标示符</li>
<li>没有具体顺序</li>
</ul>
<p><strong>限制：</strong>对<code>key</code>和<code>value</code>的类型要求有所不同</p>
<ul>
<li><code>key</code>：其类型必须遵循<code>Hashable</code>协议</li>
<li><code>value</code>：所有数据类型</li>
</ul>
<p><strong>扩展：</strong>Swift中的<code>Dictionary</code></p>
</blockquote>
<h3 id="4-4-1-创建字典"><a href="#4-4-1-创建字典" class="headerlink" title="4.4.1    创建字典"></a>4.4.1    创建字典</h3><blockquote>
<p><strong>说明：</strong>可划分为<code>3</code>种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>创建形式</th>
<th>说明</th>
<th>是否只能创建空字典</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[keyType: valueType] ()</code></td>
<td>调用构造器的简化形式</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td><code>[key1: value1, ...]</code></td>
<td>字面量</td>
<td>否，空字典字面量为<code>[:]</code></td>
<td></td>
</tr>
<tr>
<td><code>Dictionary&lt;Int, String&gt;()</code></td>
<td>调用构造器</td>
<td>是</td>
<td><code>&lt;Int, String&gt;</code>可省略（当变量或常量的键值对类型已指定过时）</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：构造器的简化方式</span></span><br><span class="line"><span class="comment">// 指定键值对类型</span></span><br><span class="line"><span class="keyword">var</span> dictionary1 = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// 方式2:字面量形式</span></span><br><span class="line"><span class="keyword">var</span> dictionary2: [<span class="type">Int</span>: <span class="type">String</span>] = [<span class="string">"YYZ"</span>: <span class="string">"Toronto"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：构造器</span></span><br><span class="line"><span class="comment">// 指定键值对类型</span></span><br><span class="line"><span class="keyword">var</span> dictionary3 = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;()</span><br><span class="line"><span class="comment">// 键值对类型已确定</span></span><br><span class="line"><span class="keyword">var</span> dictionary4: [<span class="type">Int</span>: <span class="type">String</span>] = <span class="type">Dictionary</span>()</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-访问和修改字典"><a href="#4-4-2-访问和修改字典" class="headerlink" title="4.4.2    访问和修改字典"></a>4.4.2    访问和修改字典</h3><h4 id="下标-1"><a href="#下标-1" class="headerlink" title="下标"></a>下标</h4><blockquote>
<p><strong>说明：</strong>通过下标可以实现字典中<code>key-value</code>的增删改查。<br><strong>注意：</strong>当通过下标使用<code>key</code>访问字典中的<code>value</code>时，返回的是相应的可选型。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"YYZ"</span>: <span class="string">"Toronto"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br><span class="line"><span class="comment">// 添加新key-value</span></span><br><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London"</span></span><br><span class="line"><span class="comment">// 修改value</span></span><br><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London Heathrow"</span></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName = airports[<span class="string">"DUB"</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name of the airport is \(airportName)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airport is not in the aitpoorts dictionary."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">airports[<span class="string">"LHR"</span>] = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h4 id="count属性-2"><a href="#count属性-2" class="headerlink" title="count属性"></a>count属性</h4><blockquote>
<p><strong>类型说明：</strong><code>Int</code><br><strong>说明：</strong>记录着字典中着键值对的数量的只读属性。</p>
</blockquote>
<h4 id="isEmpty属性-2"><a href="#isEmpty属性-2" class="headerlink" title="isEmpty属性"></a>isEmpty属性</h4><blockquote>
<p><strong>类型说明：</strong><code>Bool</code><br><strong>说明：</strong>判断字典是否为空字典。</p>
</blockquote>
<h4 id="keys属性"><a href="#keys属性" class="headerlink" title="keys属性"></a>keys属性</h4><blockquote>
<p><strong>类型：</strong><code>[key1, key2, ...]</code><br><strong>说明：</strong>字典中所有数据项的<code>key</code>构成的数组。</p>
</blockquote>
<h4 id="values属性"><a href="#values属性" class="headerlink" title="values属性"></a>values属性</h4><blockquote>
<p><strong>类型：</strong><code>[value1, value2, ...]</code><br><strong>说明：</strong>字典中所有数据项的<code>value</code>构成的数组。</p>
</blockquote>
<h4 id="removeValueForKey方法"><a href="#removeValueForKey方法" class="headerlink" title="removeValueForKey方法"></a>removeValueForKey方法</h4><blockquote>
<p><strong>说明：</strong>通过<code>key</code>移除键值对。<br><strong>原型：</strong><code>Dictionary类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Hashable&#125; key 要删除的键值对的键</span><br><span class="line">&gt;* @return &#123;ValueType?&#125; 对应value的可选型</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeValueForKey</span><span class="params">(key: Hashable)</span></span> -&gt; <span class="type">ValueType</span>?</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The dictionary if airports contains \(airports.count) items."</span>)</span><br><span class="line"><span class="comment">// isEmpty</span></span><br><span class="line"><span class="keyword">if</span> airports.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Tge airports dictionary is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// removeValueForKey</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = airports.removeValueForKey(<span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value for DUB."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value fot DUB."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-3-字典遍历"><a href="#4-4-3-字典遍历" class="headerlink" title="4.4.3    字典遍历"></a>4.4.3    字典遍历</h3><blockquote>
<p><strong>说明：</strong>通过<code>for-in</code>便利字典时，每一个数据项都以<code>(key, value)</code>元组形式返回。<br><strong>技巧：</strong></p>
<ul>
<li>可以通过临时常量或变量分解<code>(key, value)</code></li>
<li>可以使用<code>keys</code>或<code>values</code>属性获取相应的数组单独进行遍历</li>
<li>字典是无序的，可以通过对<code>keys</code>或<code>values</code>属性使用<code>sort方法</code>获得特定顺序</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(airportCode): \(airportName)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历字典的key</span></span><br><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport code: \(airportCode)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历字典的value</span></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport name: \(airportName)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提取key或value构成的数组</span></span><br><span class="line"><span class="keyword">let</span> airportCodes = [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="keyword">let</span> airportNames = [<span class="type">String</span>](airports.values)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_03  字符串和字符/" itemprop="url">
                  3 字符串和字符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:32:42+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_03  字符串和字符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_03  字符串和字符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>有序的<code>Character</code>类型的值的集合，通过<code>String类</code>来表示。</p>
<ul>
<li>每一个字符串都是由编码无关的<code>Unicide</code>字符组成</li>
<li>可以通过內插的方式将字符串插入到常量、变量、字面量表达式中</li>
</ul>
<p><strong>扩展：</strong>和Cocoa中的Foundation框架中的<code>NSString类</code>进行了无缝对接</p>
<ul>
<li>可以将创建的任何字符串的值转换成<code>NSString</code></li>
<li>可以调用任意的<code>NSString</code>API</li>
<li>可以在任意要求传入<code>NSString</code>实例作为参数的API中用<code>String类</code>的值代替</li>
</ul>
</blockquote>
<p>##3.1    字符串字面量</p>
<blockquote>
<p><strong>格式：</strong><code>&quot;固定顺序的文本字符集&quot;</code><br><strong>应用：</strong>为常量或变量提供初始值</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span></span><br></pre></td></tr></table></figure>
<p>##3.2    初始化空字符串</p>
<blockquote>
<p><strong>说明：</strong>2种形式</p>
<ol>
<li>将空的字符串字面量赋值给变量</li>
<li>初始化一个新的<code>String</code>实例</li>
</ol>
<p><strong>判空：</strong>可以通过字符串实例的<code>isEmpty</code>属性(Boolean)来判断字符串是否为空。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3.3    字符串可变性</p>
<blockquote>
<p><strong>说明：</strong>和Swift中其它值类型一样，可变性取决于定义为常量还是变量</p>
<ul>
<li>常量：不可改变</li>
<li>变量：可以改变</li>
</ul>
<p><strong>扩展：</strong>在O-C和Cocoa中，字符串的可变性取决于使用<code>NSString类</code>还是<code>NSMutableString类</code>。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义为变量</span></span><br><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Hourse"</span></span><br><span class="line"><span class="comment">// 所以可以修改</span></span><br><span class="line">variableString += <span class="string">" add carriage"</span></span><br></pre></td></tr></table></figure>
<p>##3.4    字符串是值类型</p>
<blockquote>
<p><strong>说明：</strong>意味着在以下操作中通过拷贝来传递值</p>
<ul>
<li>常量、变量赋值操作</li>
<li>在函数、方法中传参</li>
</ul>
<p><strong>意义：</strong>确保传递的字符串不会被意外修改。<br><strong>扩展：</strong>为了保证性能，Swift编译器只会在绝对必要的情况下才进行复制。</p>
<p>##3.5    使用字符<br><strong>说明：</strong><code>Character</code></p>
<ul>
<li>字符类型的常量和字符串相似，不同点在于自能包含一个字符。</li>
<li>用字符常量初始化字符类型必须指定常量或变量为<code>Character</code>，否则默认为字符串类型。</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamatuinMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<p>###3.5.1    字符串的Chracters属性</p>
<blockquote>
<p><strong>说明：</strong>可以通过该属性遍历字符串对应的字符数组。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串中的字符</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog"</span>.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###3.5.2    字符数组转换为字符串</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明字符数组</span></span><br><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>]</span><br><span class="line"><span class="comment">// 将字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)<span class="comment">// "Cat"</span></span><br></pre></td></tr></table></figure>
<p>##3.6    连接字符串和字符</p>
<blockquote>
<p><strong>说明：</strong>两种方式</p>
<ul>
<li><code>+</code>、<code>+=</code>：字符串拼接</li>
<li><code>append方法</code><br>###append方法<br><strong>说明：</strong>将一个字符附加到字符串变量的尾部<br><strong>原型：</strong><code>String类实例方法</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Character&#125; c 字符</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;void append(<span class="built_in">c</span>: <span class="type">Character</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>参数只能是<code>Character</code>常量或变量，不能是字面量(因为存在歧义)</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">" there"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+</span></span><br><span class="line"><span class="keyword">var</span> welcome = str1 + str2<span class="comment">// hello there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+=</span></span><br><span class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></span><br><span class="line">instruction += str2<span class="comment">// look over there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//append</span></span><br><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br><span class="line">instruction.append(exclamationMark)</span><br></pre></td></tr></table></figure>
<p>##3.7    字符串插值</p>
<blockquote>
<p><strong>用途：</strong>构建新的字符串。<br><strong>语法：</strong><code>\(表达式)</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="comment">// 通过插值构建新的字符串</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"</span></span><br></pre></td></tr></table></figure>
<p>##3.8    Unicode</p>
<p>###3.8.1    Unicode标量</p>
<blockquote>
<p><strong>Unicode码位：</strong>格式为<code>U+[1到8位16进制数字]</code></p>
<ul>
<li><strong>Unicode标量码位：</strong>是对应字符或者修饰符的唯一的21位数字，每个<code>Unicode标量</code>都对应着一个<code>Unicode码位</code>，但反过来不成立。</li>
<li><strong>Unicode代理项码位：</strong>Unicode码位中不属于Unicode标量的部分。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>U+0000~U+D7FF</th>
<th>U+D800~U+DFFF</th>
<th>U+E000~U+10FFF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unicode标量</td>
<td>unicode代理项</td>
<td>Unicode标量</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>应用：</strong>Swift的<code>String</code>类型是基于Unicode标量建立的。</p>
</blockquote>
<p>###3.8.2    字符串字面量的特殊字符</p>
<blockquote>
<p><strong>说明：</strong>分两类</p>
<ul>
<li>转义字符</li>
<li>Unicode标量</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\0</code></td>
<td>空字符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\u{1到8位16进制数}</code></td>
<td>Unicode标量</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \"</span></span><br><span class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more importent than knowledge\" - Einstein"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unocode标量</span></span><br><span class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span></span><br></pre></td></tr></table></figure>
<p>###3.8.3    可扩展的字形群集</p>
<blockquote>
<p><strong>说明：</strong>有些字符由多个部分组成，每个部分都可以用一个Unicode标量表示。组合起来就形成了一个新字符。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span><span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span><span class="comment">// é</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;D55C&#125;"</span><span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;"</span><span class="comment">// 한</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// é⃝</span></span><br><span class="line"><span class="keyword">let</span> encosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span><span class="comment">// é⃝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 🇺🇸</span></span><br><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;"</span><span class="comment">// 🇺🇸</span></span><br></pre></td></tr></table></figure>
<p>##3.9    计算字符数量</p>
<p>###characters.count属性</p>
<blockquote>
<p><strong>说明：</strong><code>String</code>类实例成员<code>characters</code>提供的记录字符总数的属性。<br><strong>性能问题：</strong>字符串中可能包含可扩展字符群，只有遍历<code>Unicode</code>标量确定字符群表示的字符后才能确定字符串的长度<br><strong>扩展：</strong><code>NSString</code>的<code>length</code>属性不同于swift的<code>String</code>的<code>count</code>属性。前者利用<code>UTF-16</code>表示的16位代码单元数字。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala, Snail, Penguin, Dromedary"</span></span><br><span class="line"><span class="comment">// 获得字符串中字符的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has \(unusualMenagerie.characters.count)"</span>)<span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可扩展的群组作为Character拼接到字符串时，字符串的字符数量并不一定会改变</span></span><br><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in \(word) is \(word.characters.count)"</span>)<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span><span class="comment">// café</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in \(word) is \(word.characters.count)"</span>)<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>##3.10    访问和修改字符串</p>
<blockquote>
<p><strong>说明：</strong>两种方式</p>
<ul>
<li>字符串的属性和方法</li>
<li>下标语法<br>###3.10.1    字符串索引<br>####相关属性(2个)</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>字符串实例属性</th>
<th>说明</th>
<th>空字符串相应属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td>startIndex</td>
<td>第一个<code>Character</code>的下标</td>
<td>0</td>
</tr>
<tr>
<td>endIndex</td>
<td>最后一个<code>Character</code>的下标 + 1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>####predecessor方法</p>
<blockquote>
<p><strong>说明：</strong>通过当前下标获得前一个下标<br><strong>原型：</strong><code>Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return  &#123;String.CharacterView.Index&#125; 下标索引</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">predecessor</span> -&gt; <span class="title">String</span>.<span class="title">CharacterView</span>.<span class="title">Index</span></span></span><br></pre></td></tr></table></figure>
<p>####successor方法</p>
<blockquote>
<p><strong>说明：</strong>通过当前索引获得后面一个索引。<br><strong>原型：</strong><code>Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return  &#123;String.CharacterView.Index&#125; 下标索引</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">successor</span> -&gt; <span class="title">String</span>.<span class="title">CharacterView</span>.<span class="title">Index</span></span></span><br></pre></td></tr></table></figure>
<p>####indices属性</p>
<blockquote>
<p><strong>说明：</strong>包含全部索引的<code>Range</code><br><strong>类型：</strong><code>Range &lt;Index&gt;</code><br><strong>原型：</strong><code>String&gt;characters的成员属性</code></p>
</blockquote>
<p>####advancedBy方法</p>
<blockquote>
<p><strong>说明：</strong>以当前位置为参照，获得相隔指定数量个下标的位置处的下标。<br><strong>原型：</strong><code>String.CharacterView.Index类型的成员方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Int&#125; n 距离（正数代表向右移动，负数代表向左移动）</span><br><span class="line">&gt;* @return &#123;Index&#125; 下标</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">advancedBy</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Gunten Tag!"</span></span><br><span class="line"><span class="comment">// 访问第一个字符</span></span><br><span class="line">greeting[greeting.startIndex]<span class="comment">// G</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问最后一个字符</span></span><br><span class="line">greeting[greeting.endIndex.predecessor()]<span class="comment">// !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第二个字符</span></span><br><span class="line">greeting[greeting.startIndex.successor()]<span class="comment">// u</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问最后一个字符</span></span><br><span class="line">greeting[greeting.endIndex.advancedBy(-<span class="number">1</span>)] <span class="comment">// !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indices属性</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(greeting[index])"</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###3.10.2    插入和删除</p>
<p>####insert函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引插入一个字符串。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Character&#125; newElement 要插入的字符</span><br><span class="line">&gt;* @param &#123;Index&#125; atIndex 插入的位置</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(newElement: Character, atIndex: Index)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<p>####insertContentsOf函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引插入一个字符串。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;CollectionType&#125; newElements 插入的集合</span><br><span class="line">&gt;* @param &#123;Index&#125; at 插入位置</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">insertContentsOf</span><span class="params">(newElements: CollectionType, at: Index)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<p>####removeAtIndex函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串中的指定索引删除一个字符<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param  &#123;Index&#125; i 要删除的字符对应的索引</span><br><span class="line">&gt;* @return &#123;Character&#125; 删除的字符</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(i: Index)</span></span> -&gt; <span class="type">Character</span></span><br></pre></td></tr></table></figure>
<p>####removeRange函数</p>
<blockquote>
<p><strong>说明：</strong>在一个字符串的指定索引删除一个字串<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">removeRange</span><span class="params">(subRange: Range&lt;Index&gt;)</span></span> -&gt; void</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串尾部插入一个字符</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, atIndex: welcome.endIndex)<span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串倒数第二个位置插入另一个字符串</span></span><br><span class="line">welcome.insertContentsOf(<span class="string">" there"</span>.characters, at: welcome.endIndex.predecessor())<span class="comment">// hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定索引处的字符</span></span><br><span class="line">welcome.removeAtIndex(welcome.endIndex.predecessor())<span class="comment">// hello there!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除子串</span></span><br><span class="line"><span class="keyword">let</span> range = welcome.endIndex.advancedBy(-<span class="number">6</span>)..&lt;welcome.endIndex<span class="comment">// 5..&lt;11</span></span><br><span class="line">welcome.removeRange(range)<span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>##3.11    比较字符串</p>
<p>###3.11.1    字符串/字符相等</p>
<blockquote>
<p><strong>说明：</strong>使用<code>!=</code>和<code>==</code></p>
<ul>
<li>如果两个字符串（或字符）的可扩展字形群集是标准相等（Unicode标量不同，语言外观相同）的，那就认为它们是相等的</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较普通两个字符串</span></span><br><span class="line"><span class="keyword">let</span> quotation = <span class="string">"we're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"we're a lot alike, you and I."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个Unicode标量不同但外观相同的字符串</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;E9&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion = <span class="string">"Voulez-vous uncaf\u&#123;65&#125;\u&#123;301&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These twostrings are considered equal"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###33.11.2        前缀/后缀相等</p>
<p>####hasPrefix函数</p>
<blockquote>
<p><strong>说明：</strong>判断字符串是否包含某种前缀。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;String&#125; prefix 前缀</span><br><span class="line">&gt;* @return &#123;Boolean&#125; true : 包含前缀；false : 不包含前缀</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">hasPrefix</span><span class="params">(<span class="keyword">prefix</span>: String)</span></span> -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<p>####hasSuffix函数</p>
<blockquote>
<p><strong>说明：</strong>判断字符串是否包含某种后缀。<br><strong>原型：</strong><code>String类型的实例方法</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;String&#125; suffix 前缀</span><br><span class="line">&gt;* @return &#123;Boolean&#125; true : 包含后缀；false : 不包含后缀</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">hasSuffix</span><span class="params">(<span class="keyword">prefix</span>: String)</span></span> -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景位置</span></span><br><span class="line"><span class="keyword">let</span> romeoAndJuliet = [</span><br><span class="line">    <span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 3: A room in Capulet's room"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 3: Ouside Friar Lawrence's cell"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span><span class="comment">// 场景一数量</span></span><br><span class="line"><span class="comment">// 根据前缀删选数据项</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1 "</span>) &#123;</span><br><span class="line">        ++act1SceneCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are \(act1SceneCount) scenes in Act 1"</span>)</span><br></pre></td></tr></table></figure>
<p>##3.12    字符串的Unicode表示形式</p>
<blockquote>
<p><strong>编码方式和字符集：</strong>事实上，计算机存储任何数据（包括文本文件）都是以<code>二进制方式</code>存储的，但字符如何对应到二进制数据，或者说二进制数据如何解读成字符是由<code>编码方式</code>和<code>字符集</code>决定的。每种<code>字符集</code>都对应一种或多种<code>编码方式</code>。<br><strong>说明：</strong>当字符串被保存到文本文件时，会按照某种编码方式存储。而Unicode标量对应的编码方式包括以下三种。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Unicode字符集对应的编码方式</th>
<th>代码单元大小（bit）</th>
<th>对应的String的成员属性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UTF-8</strong></td>
<td>8</td>
<td>utf8</td>
</tr>
<tr>
<td><strong>UTF-16</strong></td>
<td>16</td>
<td>utf16</td>
</tr>
<tr>
<td><strong>UTF-32(Unicode标量集合)</strong></td>
<td>32</td>
<td>unicodeScalars</td>
</tr>
</tbody>
</table>
<p>###举个例子：<code>Dog‼🐶</code></p>
<table>
<thead>
<tr>
<th>code unit(十进制)</th>
<th>D</th>
<th>o</th>
<th>g</th>
<th>!!</th>
<th>🐶</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UTF-8编码</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>226 128 188</td>
<td>240 159 144 182</td>
</tr>
<tr>
<td><strong>UTF-16编码</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>8252</td>
<td>55357 56374</td>
</tr>
<tr>
<td><strong>UTF-32(Unicode标量)</strong></td>
<td>68</td>
<td>111</td>
<td>103</td>
<td>8252</td>
<td>128054</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_02  基本运算符/" itemprop="url">
                  2 基本运算符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:32:24+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_02  基本运算符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_02  基本运算符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>基本运算</th>
<th>正负</th>
<th>自加/减</th>
<th>自返运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>a+b</td>
<td>+a</td>
<td>a++/++a</td>
<td>a+=b</td>
</tr>
<tr>
<td>a-b</td>
<td>-b</td>
<td><code>b--/--b</code></td>
<td>a-=b</td>
</tr>
<tr>
<td>a*b</td>
<td></td>
<td></td>
<td>a*=b</td>
</tr>
<tr>
<td>a/b</td>
<td></td>
<td></td>
<td>a/=b</td>
</tr>
<tr>
<td>a%b</td>
<td></td>
<td></td>
<td>a%=b</td>
</tr>
</tbody>
</table>
<p>[toc]</p>
<h2 id="2-1-术语"><a href="#2-1-术语" class="headerlink" title="2.1    术语"></a>2.1    术语</h2><ul>
<li>运算符</li>
</ul>
<table>
<thead>
<tr>
<th>按照操作数数量分类</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一元运算符</td>
<td>分为前值运算符和后值运算符</td>
<td><code>!</code>、<code>++</code>、<code>--</code>等</td>
</tr>
<tr>
<td>二元运算符</td>
<td>在两个操作数之间</td>
<td>大部分运算符都属于二元运算符</td>
</tr>
<tr>
<td>三元运算符</td>
<td>和C语言一样只有一个三目运算符</td>
<td><code>a ? b : c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>操作数：受运算影响的值叫做操作数</li>
</ul>
<h2 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2    赋值运算符"></a>2.2    赋值运算符</h2><blockquote>
<p><strong>说明：</strong>用来跟新或初始化变量或常量。</p>
<ul>
<li>右边如果是元组，会被分解成多个常量或变量</li>
<li>不返回值（不同于c和o-c）</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-3-算术运算符"><a href="#2-3-算术运算符" class="headerlink" title="2.3    算术运算符"></a>2.3    算术运算符</h2><h3 id="2-3-1-四则运算"><a href="#2-3-1-四则运算" class="headerlink" title="2.3.1    四则运算"></a>2.3.1    四则运算</h3><blockquote>
<p><strong>说明：</strong>其中<code>+</code>允许操作数为字符串，此时不再是四则运算中的加法运算，而是用来拼接字符串。</p>
</blockquote>
<table>
<thead>
<tr>
<th>四则运算符</th>
<th>说明</th>
<th>操作数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法或连接符</td>
<td>数值类型或字符串</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>数值类型</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>数值类型</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>数值类型（两个操作数都是整数则结果取整(<code>Int</code>)，否则为<code>Double</code>）</td>
</tr>
</tbody>
</table>
<h3 id="2-3-2-求余运算符"><a href="#2-3-2-求余运算符" class="headerlink" title="2.3.2    求余运算符"></a>2.3.2    求余运算符</h3><blockquote>
<p><strong>说明：</strong>在其它语言中也叫做取膜运算。<br><strong>规则：</strong><code>余数 = a % b</code>，其中<code>a = (|b| x 倍数) + 余数</code></p>
<ul>
<li><code>b</code>的符号将会被忽略，也就是说 <code>a % b</code>和<code>a % -b</code>相同</li>
</ul>
</blockquote>
<h3 id="2-3-3-浮点数求余运算"><a href="#2-3-3-浮点数求余运算" class="headerlink" title="2.3.3    浮点数求余运算"></a>2.3.3    浮点数求余运算</h3><blockquote>
<p><strong>说明：</strong>不同于<code>c</code>和<code>o-c</code>，<code>Swift</code>中可以对浮点数进行求余。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> % <span class="number">2.5</span><span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-自增和自减运算"><a href="#2-3-4-自增和自减运算" class="headerlink" title="2.3.4    自增和自减运算"></a>2.3.4    自增和自减运算</h3><blockquote>
<p><strong>操作对象：</strong>整型和浮点型<br><strong>技巧：</strong>先修改后返回更符合我们的逻辑，因此除非需要<code>i++（i--）</code>的特性，否则推荐使用<code>++i(--i)</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>相对操作数的位置</th>
<th>自增</th>
<th>自减</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置</td>
<td><code>++i</code></td>
<td><code>--i</code></td>
<td>先自增，后返回</td>
</tr>
<tr>
<td>后置</td>
<td><code>i++</code></td>
<td><code>i++</code></td>
<td>先返回，后自增</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = ++a<span class="comment">// a 1, b 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a++<span class="comment">// a 2, c 1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-一元负号运算符"><a href="#2-3-5-一元负号运算符" class="headerlink" title="2.3.5    一元负号运算符"></a>2.3.5    一元负号运算符</h3><blockquote>
<p><strong>符号：</strong><code>-</code><br><strong>说明：</strong>写在操作数之前，中间没有空格</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three</span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-一元正号运算符"><a href="#2-3-6-一元正号运算符" class="headerlink" title="2.3.6    一元正号运算符"></a>2.3.6    一元正号运算符</h3><blockquote>
<p><strong>说明：</strong>不做任何改变地返回操作数的值<br><strong>用途：</strong>和负数一起使用时为整数添加<code>+</code>符号使代码看起来更加对称。</p>
</blockquote>
<h2 id="2-4-复合赋值"><a href="#2-4-复合赋值" class="headerlink" title="2.4    复合赋值"></a>2.4    复合赋值</h2><table>
<thead>
<tr>
<th>自返运算(复合赋值)</th>
</tr>
</thead>
<tbody>
<tr>
<td>a+=2</td>
</tr>
<tr>
<td>a-=2</td>
</tr>
<tr>
<td>a*=2</td>
</tr>
<tr>
<td>a/=2</td>
</tr>
<tr>
<td>a%=2</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span><span class="comment">// a 3</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-比较运算符"><a href="#2-5-比较运算符" class="headerlink" title="2.5    比较运算符"></a>2.5    比较运算符</h2><blockquote>
<p><strong>应用：</strong>多用于<code>if</code>语句</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a == b</td>
<td>等于</td>
</tr>
<tr>
<td>a != b</td>
<td>不等于</td>
</tr>
<tr>
<td>a &gt; b</td>
<td>大于</td>
</tr>
<tr>
<td>a &lt; b</td>
<td>小于</td>
</tr>
<tr>
<td>a === b</td>
<td>两个引用指向同一个对象实例</td>
</tr>
<tr>
<td>a !== b</td>
<td>两个引用不指向同一个对象实例</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"word"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"wword"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm sorry \(name), but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-三目运算符"><a href="#2-6-三目运算符" class="headerlink" title="2.6    三目运算符"></a>2.6    三目运算符</h2><blockquote>
<p><strong>语法：</strong><code>问题 ? 答案1 : 答案2</code><br><strong>技巧：</strong>过度使用三目运算符会使简洁的代码变得难懂。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-7-空合运算符"><a href="#2-7-空合运算符" class="headerlink" title="2.7    空合运算符"></a>2.7    空合运算符</h2><blockquote>
<p><strong>语法：</strong><code>a ?? b</code><br><strong>说明：</strong>对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>。</p>
<ul>
<li><code>a ?? b</code>等价于<code>a != nil ? a! : b</code></li>
<li>表达式<code>a</code>必须是<code>Optional</code>类型</li>
<li>默认值<code>b</code>的类型必须要和<code>a</code>存储的类型保持一致</li>
<li>短路求值：如果<code>a</code>不是<code>nil</code>，则<code>b</code>不会被估值</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?<span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName<span class="comment">// red</span></span><br></pre></td></tr></table></figure>
<h2 id="2-8-区间运算符"><a href="#2-8-区间运算符" class="headerlink" title="2.8    区间运算符"></a>2.8    区间运算符</h2><blockquote>
<p><strong>说明：</strong>分两种</p>
<ul>
<li>闭区间运算符（<code>a...b</code>）：包含a和b</li>
<li>半开区间运算符（<code>a..&lt;b</code>）：包含a不包含b</li>
</ul>
<p><strong>应用：</strong>在迭代一个区间的所有值时非常有用，比如在<code>for-in</code>循环中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brain"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第 \(i + 1) 个人叫 \(names[i])"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-9-逻辑运算符"><a href="#2-9-逻辑运算符" class="headerlink" title="2.9    逻辑运算符"></a>2.9    逻辑运算符</h2><blockquote>
<p><strong>说明：</strong>一共3个</p>
</blockquote>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>是否短路</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!a</code></td>
<td>逻辑非</td>
<td></td>
</tr>
<tr>
<td><code>a &amp;&amp; b</code></td>
<td>逻辑与</td>
<td>是</td>
<td>左结合</td>
</tr>
<tr>
<td><code>a｜｜b</code></td>
<td>逻辑或</td>
<td>是</td>
<td>左结合</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>提高可读性：</strong></p>
<ul>
<li>多个逻辑运算符组合运算时使用括号来明确优先级</li>
<li>小心地选择布尔常量或变量</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_01  基础部分/" itemprop="url">
                  1 基础部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:31:53+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_01  基础部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_01  基础部分/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-常量和变量"><a href="#1-1-常量和变量" class="headerlink" title="1.1    常量和变量"></a>1.1    常量和变量</h2><blockquote>
<p><strong>描述：</strong>常量和变量把一个名字和一个指定类型的值关良起来。<br><strong>说明：</strong>两者的区别在于设定后是否还能修改</p>
<ul>
<li>常量：设定后不可能修改</li>
<li>变量：可以随意更改</li>
</ul>
</blockquote>
<h3 id="1-1-1-声明常量和变量"><a href="#1-1-1-声明常量和变量" class="headerlink" title="1.1.1    声明常量和变量"></a>1.1.1    声明常量和变量</h3><blockquote>
<p><strong>共同规则：</strong></p>
<ul>
<li>可以在一行中声明多个，用<code>,</code>分隔</li>
</ul>
<p><strong>关键字：</strong></p>
<ul>
<li><code>let</code>：常量</li>
<li><code>var</code>：变量</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量声明</span></span><br><span class="line"><span class="keyword">let</span> maximunNumberOfLoginAttemts = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempts = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-类型标注"><a href="#1-1-2-类型标注" class="headerlink" title="1.1.2    类型标注"></a>1.1.2    类型标注</h3><blockquote>
<p><strong>用途：</strong>说明常量或者变量中要存储的值的类型<br><strong>注意：</strong></p>
<ul>
<li>如果没有类型标注，声明时都必须设置一个值作为初始值，否则报错</li>
<li>类型标注可以省略，此时Swift可以通过赋的初始值推断其类型</li>
</ul>
<p><strong>语法：</strong><code>var welcomeMessage: String</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>var</th>
<th>welcomeMessage:</th>
<th></th>
<th>String</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let(var)</code></td>
<td>常量(变量)名</td>
<td><code>:</code></td>
<td><code>空格</code></td>
<td>类型名称</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明：</strong>可以在一行中定义多个同样类型的变量，<code>,</code>分隔，并在最后一个比变量名之后添加<code>类型标注</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">welcomeMessage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明多个具有相同类型标注的变量的略写方式</span></span><br><span class="line"><span class="keyword">var</span> red, green, blue:<span class="type">Double</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-常量和变量的命名"><a href="#1-1-3-常量和变量的命名" class="headerlink" title="1.1.3    常量和变量的命名"></a>1.1.3    常量和变量的命名</h3><blockquote>
<p><strong>说明：</strong>声明完成后，一些特性将不能再次修改</p>
<ul>
<li>已经声明的名字不能再次用来声明</li>
<li>声明时确定的类型不能更改</li>
<li>常量与变量不能相互转换</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>不允许的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学符号</td>
</tr>
<tr>
<td>箭头</td>
</tr>
<tr>
<td>保留的（非法的）<code>Univode</code>码位</td>
</tr>
<tr>
<td>连线</td>
</tr>
<tr>
<td>制表符</td>
</tr>
<tr>
<td>数字（仅开头不能使用）</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量和变量的命名</span></span><br><span class="line"><span class="keyword">let</span> π = <span class="number">3.141592654</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">let</span> ？？ = <span class="string">"dog"</span><span class="comment">// 中文全角的</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-4-输出常量和变量"><a href="#1-1-4-输出常量和变量" class="headerlink" title="1.1.4    输出常量和变量"></a>1.1.4    输出常量和变量</h3><h4 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h4><blockquote>
<p><strong>描述：</strong>一个用来输出一个或多个值到适当输出区的全局函数。<br><strong>说明：</strong>可以直接通过<code>\(表达式)</code>的方式在字符串中插值（<code>String interprolation</code>）<br><strong>原型：</strong><code>全局函数</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Any...&#125; items 可变个任意类型的参数</span><br><span class="line">&gt;* @param &#123;String=&#125; separator 连接符（默认为空格，可省略）</span><br><span class="line">&gt;* @param &#123;String=&#125; terminator 自动追加再末尾的字串（默认为换行符，可省略）</span><br><span class="line">&gt;* @param &#123;&amp;Target=&#125; toStream 输出流（默认为标准输出流，可省略）</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;void <span class="built_in">print</span>(items: <span class="type">Any</span>..., separator: <span class="type">String</span>, terminator: <span class="type">String</span>, toStream: &amp;<span class="type">Target</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"world"</span></span><br><span class="line"><span class="comment">// hello,world!</span></span><br><span class="line"><span class="built_in">print</span>(str1, str2, separator:<span class="string">","</span>, terminator:<span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world\n</span></span><br><span class="line"><span class="built_in">print</span>(str1, str2)</span><br></pre></td></tr></table></figure>
<h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2    注释"></a>1.2    注释</h2><blockquote>
<p><strong>说明：</strong>和C语言的注释非常相似</p>
<ul>
<li>单行注释：<code>// 这是一个注释</code></li>
<li>多行注释：<code>/* 多行注释 */</code></li>
</ul>
<p><strong>注意：</strong>和C语言不同的是，swift支持前套的多行注释。便于在原先多行注释的基础上扩大注释范围。</p>
</blockquote>
<h2 id="1-3-分号"><a href="#1-3-分号" class="headerlink" title="1.3    分号"></a>1.3    分号</h2><blockquote>
<p><strong>说明：</strong>和大部分语句有所不同</p>
<ul>
<li>单独占一行的语句的结尾处的分号可以省略</li>
<li>一行代码存在多个语句，则语句之间的<code>;</code>不能省略</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"?"</span>; <span class="built_in">print</span>(cat)</span><br></pre></td></tr></table></figure>
<h2 id="1-3-整数"><a href="#1-3-整数" class="headerlink" title="1.3    整数"></a>1.3    整数</h2><blockquote>
<p><strong>说明：</strong>一共有<code>10</code>种整数类型（<code>(U)Int(4种宽度)</code>）<br><strong>注意：</strong>其中8种类型是指定的宽度的，<code>Int</code>和<code>UInt</code>类型比较特殊，其宽度依赖于处理器架构。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度(bit)</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>Int8</td>
<td>UInt8</td>
</tr>
<tr>
<td>16</td>
<td>Int16</td>
<td>UInt16</td>
</tr>
<tr>
<td>32</td>
<td>Int32</td>
<td>UInt32</td>
</tr>
<tr>
<td>64</td>
<td>Int64</td>
<td>UInt64</td>
</tr>
<tr>
<td>依赖平台</td>
<td>Int</td>
<td>UInt</td>
</tr>
</tbody>
</table>
<h3 id="1-3-1-整数范围"><a href="#1-3-1-整数范围" class="headerlink" title="1.3.1    整数范围"></a>1.3.1    整数范围</h3><blockquote>
<p><strong>说明：</strong>可以通过<code>mix</code>和<code>max</code>属性获得相应类型的最大值和最小值。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-Int"><a href="#1-3-2-Int" class="headerlink" title="1.3.2    Int"></a>1.3.2    Int</h3><blockquote>
<p><strong>技巧：</strong>大多数时候使用<code>Int</code>类型</p>
<ul>
<li>可以提高代码的一致性和可复用性</li>
<li>即使在32位机器上，也足够大了（<code>-2,147,483,648~2,147,483,647</code>）</li>
</ul>
</blockquote>
<h3 id="1-3-3-UInt"><a href="#1-3-3-UInt" class="headerlink" title="1.3.3    UInt"></a>1.3.3    UInt</h3><blockquote>
<p><strong>技巧：</strong>尽可能使用<code>Int</code>而不是<code>UInt</code>，即使已知值是非负的</p>
<ul>
<li>一致型和可复用性</li>
<li>避免不同类型数字之间的转换(默认的对整数类型的表达式的推断类型为<code>Int</code>)</li>
</ul>
</blockquote>
<h2 id="1-4-浮点数"><a href="#1-4-浮点数" class="headerlink" title="1.4    浮点数"></a>1.4    浮点数</h2><blockquote>
<p><strong>定义：</strong>有小数部分的数字<br><strong>说明：</strong>有两种有符号浮点数类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>浮点类型</th>
<th>解释</th>
<th>最大精度（整数部分和小数部分数字位数之和）</th>
<th>适用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64位浮点数</td>
<td>7</td>
<td>需要存储很大或很高精度的浮点数时</td>
</tr>
<tr>
<td>Float</td>
<td>32位浮点数</td>
<td>16</td>
<td>精度要求不高时</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f:<span class="type">Float</span> = <span class="number">0.123456789</span><span class="comment">// 0.1234568</span></span><br><span class="line"><span class="keyword">var</span> d:<span class="type">Double</span> = <span class="number">0.12345678901234567</span><span class="comment">// 0.1234567890123457</span></span><br></pre></td></tr></table></figure>
<h2 id="1-5-类型安全和类型推断"><a href="#1-5-类型安全和类型推断" class="headerlink" title="1.5    类型安全和类型推断"></a>1.5    类型安全和类型推断</h2><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><strong>类型安全：</strong>编译器会在编译阶段进行类型检查，并把不匹配的类型标记为错误</li>
<li><strong>类型推断：</strong>如果在声明阶段没有显示指定类型，编译器回通过赋的值自动推断出表达式的类型</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>当推断浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code></li>
<li>如果表达式中同时出现整数和浮点数，则计算结果被推断为<code>Double</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式种出现了一个浮点字面量，所以表达式被推断为 Double 类型</span></span><br><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br></pre></td></tr></table></figure>
<h2 id="1-6-数值型字面量"><a href="#1-6-数值型字面量" class="headerlink" title="1.6    数值型字面量"></a>1.6    数值型字面量</h2><h3 id="整数字面量"><a href="#整数字面量" class="headerlink" title="整数字面量"></a>整数字面量</h3><blockquote>
<p><strong>说明：</strong>根据进制划分有<code>4</code>种</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>无</td>
</tr>
<tr>
<td>二进制</td>
<td><code>0b</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0x</code></td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> binaryInter = <span class="number">0b10001</span><span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span><span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span><span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点数字面量"><a href="#浮点数字面量" class="headerlink" title="浮点数字面量"></a>浮点数字面量</h3><blockquote>
<p><strong>说明：</strong>根据进制划分有<code>2</code>种</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>前缀</th>
<th>小数点两边</th>
<th>可选的指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>无</td>
<td>至少有一个十进制数</td>
<td><code>(E)e</code>， 基数为10</td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0x</code></td>
<td>至少有一个十六进制数</td>
<td><code>(P)p</code></td>
<td>基数为2</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10进制</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1.25e2</span><span class="comment">// 1.25 x 10^2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制</span></span><br><span class="line"><span class="keyword">let</span> b = 0xFp-<span class="number">2</span><span class="comment">// 15 x 2^-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.1875</span></span><br><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21876e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<h3 id="增强可读性"><a href="#增强可读性" class="headerlink" title="增强可读性"></a>增强可读性</h3><blockquote>
<p><strong>说明：</strong>整数和浮点数都可以添加额外的零并且包含下划线来增强可读性</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 额外的零</span></span><br><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="comment">// 额外的下划线</span></span><br><span class="line"><span class="keyword">let</span> oneMillon = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-数值型类型转换"><a href="#1-7-数值型类型转换" class="headerlink" title="1.7    数值型类型转换"></a>1.7    数值型类型转换</h2><blockquote>
<p><strong>使用<code>Int</code>：</strong>即使代码中的整数常量或变量已知非负，也尽量使用<code>Int</code></p>
<ul>
<li>保证整数变量或常量可以直接被复用</li>
<li>可以匹配整数类字面量的类型推断（整数字面量只会被推断为<code>Int</code>，赋值给其它类型的整数需要类型转换）</li>
</ul>
<p><strong>使用其它整数类型：</strong></p>
<ul>
<li>处理外部的长度明确的数据时，为了优化性能、内存占用等</li>
<li>可以及时发现溢出</li>
<li>可以暗示正在处理特殊数据</li>
</ul>
</blockquote>
<h3 id="1-7-1-整数转换"><a href="#1-7-1-整数转换" class="headerlink" title="1.7.1    整数转换"></a>1.7.1    整数转换</h3><h4 id="1-7-1-1-必要性"><a href="#1-7-1-1-必要性" class="headerlink" title="1.7.1.1    必要性"></a>1.7.1.1    必要性</h4><blockquote>
<ul>
<li>如果数字超过了常量或变量可存储的范围，编译的时候会报错</li>
<li>两种类型（<code>Int</code>除外）的整数不能直接相加</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会报错，因为 UInt8 不能存储负数</span></span><br><span class="line"><span class="keyword">let</span> cannotBeNegative:<span class="type">UInt8</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，因为超过了最大值</span></span><br><span class="line"><span class="keyword">let</span> tooBig:<span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-1-2-使用类型对应的构造器进行转换"><a href="#1-7-1-2-使用类型对应的构造器进行转换" class="headerlink" title="1.7.1.2    使用类型对应的构造器进行转换"></a>1.7.1.2    使用类型对应的构造器进行转换</h4><blockquote>
<p><strong>注意：</strong>不能传入任意类型的值给构造器，只能是有对应构造器的值<br><strong>扩展：</strong>可以通过扩展现有的类型让它可以接受其它类型的值</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 one 由 UInt8 转换为 UInt16，最终 twoThousandAndOne 被推断为 UInt16</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<h3 id="1-7-2-整数和浮点数转换"><a href="#1-7-2-整数和浮点数转换" class="headerlink" title="1.7.2    整数和浮点数转换"></a>1.7.2    整数和浮点数转换</h3><h4 id="1-7-2-1-整数-gt-浮点数"><a href="#1-7-2-1-整数-gt-浮点数" class="headerlink" title="1.7.2.1    整数-&gt;浮点数"></a>1.7.2.1    整数-&gt;浮点数</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><strong>强制转换：</strong>对与所有类型的整数常量或变量，可以强制转换为<code>Double</code>或<code>Float</code></li>
<li><strong>隐式转换：</strong>声明时指定<code>Double</code>或<code>Float</code>，则用来初始化的整数字面量会被自动转换</li>
</ul>
<p><strong>注意：</strong>数值类常量或变量不同于数值类字面量，后者可以不同类型可以一起运算，因为字面量本身没有明确的类型</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">let</span> d:<span class="type">Double</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFineNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFineNine</span><br></pre></td></tr></table></figure>
<h4 id="1-7-2-2-浮点数-gt-整数"><a href="#1-7-2-2-浮点数-gt-整数" class="headerlink" title="1.7.2.2    浮点数-&gt;整数"></a>1.7.2.2    浮点数-&gt;整数</h4><blockquote>
<p><strong>说明：</strong>声明变量或常量时指定任何一种整数类型，则用来初始化字面量只能是整数。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br></pre></td></tr></table></figure>
<h2 id="1-8-类型别名"><a href="#1-8-类型别名" class="headerlink" title="1.8    类型别名"></a>1.8    类型别名</h2><blockquote>
<p><strong>语法：</strong><code>typealias 别名 = 原始类型名</code><br><strong>用途：</strong>给现有类型起一个更有意义的名字。<br><strong>说明：</strong>定义了类型别名之后，可以在任何使用原始类型名的地方使用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br><span class="line"><span class="comment">// 调用类型别名</span></span><br><span class="line"><span class="keyword">var</span> maxAmolitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br></pre></td></tr></table></figure>
<h2 id="1-9-布尔值"><a href="#1-9-布尔值" class="headerlink" title="1.9    布尔值"></a>1.9    布尔值</h2><blockquote>
<p><strong>类型：</strong><code>Bool</code><br><strong>字面量：</strong></p>
<ul>
<li>true</li>
<li>false</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 橙子是橙子，true</span></span><br><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 萝卜很好吃，false</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-10-元组"><a href="#1-10-元组" class="headerlink" title="1.10    元组"></a>1.10    元组</h2><blockquote>
<p><strong>用途：</strong>元组把多个值组合成一个复合值<br><strong>说明：</strong></p>
<ul>
<li>元组内的值可以是任意类型，并不要求是相同类型。</li>
<li>可以作为函数的返回值</li>
<li>可以为元组中的每个元素命名</li>
<li>可以通过下标访问元组中的每个元素</li>
</ul>
<p><strong>语法：</strong><code>(字面量1, 字面量2, ...)</code></p>
<p><strong>限制：</strong>元组在临时组织值的时候很有用，但不适合创建复杂的数据结构。<br><strong>扩展：</strong>如果数据结构不是临时使用，请使用类或者结构体而不是元组。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明：一个类型为 (Int, String) 的元组</span></span><br><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not found"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(statusCode)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is \(statusMessage)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解时用_忽略</span></span><br><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标访问元组中的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(http404Error.1))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元组时为单个元素命名</span></span><br><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(http200Status.statusCode)"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="1-11-可选类型"><a href="#1-11-可选类型" class="headerlink" title="1.11    可选类型"></a>1.11    可选类型</h2><blockquote>
<p><strong>用途：</strong>值可能缺失的情况<br><strong>应用：</strong>任何类型</p>
</blockquote>
<h3 id="1-11-1-nil"><a href="#1-11-1-nil" class="headerlink" title="1.11.1    nil"></a>1.11.1    nil</h3><blockquote>
<p><strong>语法：</strong><code>var(let) 标识符: 类型? = 表达式</code><br><strong>相关字面量：</strong><code>nil</code></p>
<ul>
<li><code>nil</code>不能用于非可选的常量或变量</li>
<li>如果声明一个可选常量或者变量但是没有赋值，他们会自动被设置为<code>nil</code></li>
<li>任何类型的可选状态都可以被设置为<code>nil</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nil是一类可选类型字面量，表示没有值</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h3 id="1-11-2-if语句以及强制解析"><a href="#1-11-2-if语句以及强制解析" class="headerlink" title="1.11.2        if语句以及强制解析"></a>1.11.2        if语句以及强制解析</h3><blockquote>
<ol>
<li>通过判断可选型是否<code>!= nil</code>,判断可选型是否存在值</li>
<li>如果存在(否则会报错)通过<code>可选型变量或常量!</code>强制解析</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="comment">// 强制类型转换返回的是一个可选型</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 !强制解析</span></span><br><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of \(convertedNumber!)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-3-可选绑定"><a href="#1-11-3-可选绑定" class="headerlink" title="1.11.3    可选绑定"></a>1.11.3    可选绑定</h3><blockquote>
<p><strong>用途：</strong>更加便捷地解包可选型值。<br><strong>限制：</strong>只能结合<code>if</code>或<code>while</code>使用<br><strong>说明：</strong>如果包含值就把值赋给一个临时<code>常量</code>或者<code>变量</code>。</p>
</blockquote>
<h4 id="绑定一个"><a href="#绑定一个" class="headerlink" title="绑定一个"></a>绑定一个</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> possibleNumber = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="comment">// 如果确实包含一个值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' has an integer value of \(actualNumber)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 可选值为nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' could not be converted to an integer"</span>)<span class="comment">// 'abc' could not be converted to an intege</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="批量绑定"><a href="#批量绑定" class="headerlink" title="批量绑定"></a>批量绑定</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) <span class="keyword">where</span> firstNumber &lt; secondNumber &#123;</span><br><span class="line">    <span class="comment">// 4 &lt; 42</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(firstNumber) &lt; \(secondNumber)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-4-隐式解析可选类型"><a href="#1-11-4-隐式解析可选类型" class="headerlink" title="1.11.4    隐式解析可选类型"></a>1.11.4    隐式解析可选类型</h3><blockquote>
<p><strong>说明：</strong>相当于声明可选型(<code>类型?</code>)和强制解包(<code>可选型!</code>)两个过程的结合。</p>
<ul>
<li>被赋值后，值要么是解包后的值，要么是<code>nil</code></li>
<li>在可选绑定中仍然可以作为普通可选类型使用</li>
</ul>
<p><strong>限制：</strong>右边表达式的返回值必须是可选型，否则将报错。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明可选型并强制解析</span></span><br><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式解析(一步到位)</span></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在可选绑定中使用隐式解析可选类型</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-12-错误处理"><a href="#1-12-错误处理" class="headerlink" title="1.12    错误处理"></a>1.12    错误处理</h2><blockquote>
<p><strong>说明：</strong>分位两步</p>
<ol>
<li>定义函数时，使用<code>throws</code>标记可能抛出错误的函数</li>
<li>用<code>do-try-catch</code>包含函数的调用过程和错误处理方式</li>
</ol>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 可能报错的函数的调用前必须加关键字 try</span></span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    <span class="comment">// 如果没有报错则执行</span></span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</span><br><span class="line">    <span class="comment">// 捕获错误类型1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    <span class="comment">// 捕获错误类型2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-13-断言"><a href="#1-13-断言" class="headerlink" title="1.13    断言"></a>1.13    断言</h2><blockquote>
<p><strong>用途：</strong>当满足一定条件时结束代码运行通过调试来找到值缺失的原因。<br><strong>适用场景：</strong></p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>的值</li>
</ul>
</blockquote>
<h3 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h3><blockquote>
<p><strong>说明：</strong>在运行时判断一个逻辑条件是否为<code>true</code></p>
<ul>
<li>如果为<code>true</code>，代码继续运行</li>
<li>如果为<code>false</code>，代码执行结束</li>
<li>可以附加一条调试信息</li>
</ul>
<p><strong>注意：</strong>在Xcode 中使用<code>target Release</code>配置为<code>build</code>时，断言会被禁用。<br><strong>原型：</strong><code>全局</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;Bool&#125; condition 结果为true或false的表达式</span><br><span class="line">&gt;* @param &#123;String=&#125; message 调试信息</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="type">Void</span> <span class="built_in">assert</span>(condition: <span class="type">Bool</span>,  message: <span class="type">String</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"Aperson's age cannot be less than zero"</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/TSPL2_0 简介/" itemprop="url">
                  简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T19:31:15+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/TSPL2_0 简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/TSPL2_0 简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-1-关于Swift-About-Swift"><a href="#0-1-关于Swift-About-Swift" class="headerlink" title="0.1    关于Swift(About Swift)"></a>0.1    关于Swift(About Swift)</h2><blockquote>
<p><strong>用途：</strong>编写<code>IOS</code>、<code>OS X</code>、<code>watchOS</code>应用程序<br><strong>特点归纳：</strong></p>
<ul>
<li>基于<code>Cocoa</code>和<code>Cocoa Touch</code>框架</li>
<li>自动垃圾回收（自动引用计数）</li>
<li>采用了<code>Object-C</code>的命名参数和动态对象模型，兼容<code>Object-C</code>，可以无缝对接到现有的<code>Cocoa</code>框架</li>
<li>支持<code>过程式编程</code>和<code>面向对象编程</code></li>
<li>支持代码预览（像脚本语言一样，可以实时查看结果）</li>
</ul>
</blockquote>
<h2 id="0-2-Swift初见（A-Swift-Tour）"><a href="#0-2-Swift初见（A-Swift-Tour）" class="headerlink" title="0.2    Swift初见（A Swift Tour）"></a>0.2    Swift初见（A Swift Tour）</h2><h3 id="0-2-1-简单值（Simple-Values）"><a href="#0-2-1-简单值（Simple-Values）" class="headerlink" title="0.2.1    简单值（Simple Values）"></a>0.2.1    简单值（Simple Values）</h3><h4 id="0-2-1-1-自动推断类型"><a href="#0-2-1-1-自动推断类型" class="headerlink" title="0.2.1.1    自动推断类型"></a>0.2.1.1    自动推断类型</h4><blockquote>
<p><strong>说明：</strong>声明的同时赋值的话，如果不指定类型，编译器会自动推断其类型。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动推断类型为integer</span></span><br><span class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></span><br><span class="line"><span class="comment">// 自动推断类型为double</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-2-指定类型"><a href="#0-2-1-2-指定类型" class="headerlink" title="0.2.1.2    指定类型"></a>0.2.1.2    指定类型</h4><blockquote>
<p><strong>说明：</strong>指定类型会导致强制类型转换</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定类型为double</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble:<span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-3-显示转换（在表达式中）"><a href="#0-2-1-3-显示转换（在表达式中）" class="headerlink" title="0.2.1.3    显示转换（在表达式中）"></a>0.2.1.3    显示转换（在表达式中）</h4><blockquote>
<p><strong>说明：</strong>表达式中的值任何时候都不会发生隐式转化。需要转换为其它类型必须进行显示转换。<br><strong>特别：</strong><code>\(变量或表达式)</code>（转换成字符串类型）</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> label = <span class="string">"The width is"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer显示转换为string</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure>
<p><em><code>\(变量或表达式)</code></em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have \(apples) apples."</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have \(apples + oranges) pices of fruit."</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-1-4-数组和字典"><a href="#0-2-1-4-数组和字典" class="headerlink" title="0.2.1.4    数组和字典"></a>0.2.1.4    数组和字典</h4><p><em>声明并初始化（自动推断类型）</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>, <span class="string">"blue paint"</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">    <span class="string">"Malcolm"</span>: <span class="string">"Caption"</span>,</span><br><span class="line">    <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span></span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空（类型信息可以被推断出来）</span></span><br><span class="line">shoppingList = []</span><br><span class="line">occuations = [:]</span><br></pre></td></tr></table></figure>
<p><em>空数组和空字典</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空数组(指定每个元素的类型)</span></span><br><span class="line"><span class="keyword">let</span> emptyArry = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字典（指定键的类型和值的类型）</span></span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>:<span class="type">Float</span>]()</span><br></pre></td></tr></table></figure>
<h3 id="0-2-2-控制流（Control-Flow）"><a href="#0-2-2-控制流（Control-Flow）" class="headerlink" title="0.2.2    控制流（Control Flow）"></a>0.2.2    控制流（Control Flow）</h3><h4 id="0-2-2-1-条件判断"><a href="#0-2-2-1-条件判断" class="headerlink" title="0.2.2.1    条件判断"></a>0.2.2.1    条件判断</h4><blockquote>
<p><strong>说明：</strong>有两类</p>
<ul>
<li>if</li>
<li>switch</li>
</ul>
<p><strong>if语法：</strong></p>
<ul>
<li>包裹条件的<code>()</code>可以省略</li>
<li>语句的<code>{}</code>不可以省略</li>
<li><code>条件</code>必须是一个<code>布尔表达式</code>（其它数据类型会报错，因为不会隐式转换）</li>
</ul>
<p><strong>switch语法：</strong></p>
<ul>
<li>支持任意类型（不仅仅是整数）</li>
<li>支持各种比较操作（不仅仅是测试想等）</li>
<li><code>case</code>后可以有多个数据</li>
<li><code>case</code>后可以使用<code>where</code>字句</li>
<li>匹配字句后程序会退出<code>switch</code>，不需要在每个字句结尾写break</li>
<li>…<br><strong>技巧：</strong><code>if</code>和<code>let</code>组合起来使用可以来为可选值解包</li>
</ul>
</blockquote>
<p><em>if(配合let解包可选值)</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString:<span class="type">String</span>? = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(optionalString == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName:<span class="type">String</span>? = <span class="string">"Join Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello"</span></span><br><span class="line"><span class="comment">// 将可选值optionalName解包后的值给name</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">"Hello, \(name)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    greeting = <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>switch</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Is it a spicy \(x)?"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Everything tasts good in soup."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-2-2-2-循环"><a href="#0-2-2-2-循环" class="headerlink" title="0.2.2.2    循环"></a>0.2.2.2    循环</h4><blockquote>
<p><strong>说明：</strong>有4类</p>
<ul>
<li>for-in</li>
<li>for</li>
<li>while</li>
<li>repeat-while</li>
</ul>
</blockquote>
<p><em>for-in</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找字典中的所有数组中的最大值</span></span><br><span class="line">let interestingNumbers = [</span><br><span class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">]</span><br><span class="line">var largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) in interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number in numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(largest)<span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p><em>repeat-while</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m = m * <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<p><em>for</em></p>
<blockquote>
<p><strong>区间：</strong></p>
<ul>
<li>包含边界：<code>...</code></li>
<li>不包含上边界：<code>..&lt;</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间的方式</span></span><br><span class="line"><span class="keyword">var</span> firstForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    firstForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(firstForLoop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统的方式</span></span><br><span class="line"><span class="keyword">var</span> secondForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i &#123;</span><br><span class="line">    secondForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(secondForLoop)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-3-函数和闭包（Functions-and-Closures）"><a href="#0-2-3-函数和闭包（Functions-and-Closures）" class="headerlink" title="0.2.3    函数和闭包（Functions and Closures）"></a>0.2.3    函数和闭包（Functions and Closures）</h3><h4 id="0-2-3-1-简单函数"><a href="#0-2-3-1-简单函数" class="headerlink" title="0.2.3.1    简单函数"></a>0.2.3.1    简单函数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello \(name), today is \(day)."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"Bob"</span>, day: <span class="string">"Tuesday"</span>)<span class="comment">// 第一个参数不用说明label</span></span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-2-返回元组"><a href="#0-2-3-2-返回元组" class="headerlink" title="0.2.3.2    返回元组"></a>0.2.3.2    返回元组</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到元组的最大值、最小值和总和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum += score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> statistics = calculateStatistics([<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-3-可变参数"><a href="#0-2-3-3-可变参数" class="headerlink" title="0.2.3.3    可变参数"></a>0.2.3.3    可变参数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数函数</span></span><br><span class="line"><span class="comment">// 计算总和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf()</span><br><span class="line">sumOf(<span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-4-函数嵌套"><a href="#0-2-3-4-函数嵌套" class="headerlink" title="0.2.3.4    函数嵌套"></a>0.2.3.4    函数嵌套</h4><blockquote>
<p><strong>说明：</strong>如果嵌套的函数被返回，调用返回的函数就会出现闭包的效果。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 函数内部的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数内部的函数</span></span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-5-返回函数"><a href="#0-2-3-5-返回函数" class="headerlink" title="0.2.3.5    返回函数"></a>0.2.3.5    返回函数</h4><blockquote>
<p><strong>说明：</strong>返回的函数是闭包的一种</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-6-函数作为参数"><a href="#0-2-3-6-函数作为参数" class="headerlink" title="0.2.3.6    函数作为参数"></a>0.2.3.6    函数作为参数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: Int -&gt; Bool)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被作为参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanThen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(numbers, condition: lessThanThen)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-3-7-匿名函数（匿名闭包）"><a href="#0-2-3-7-匿名函数（匿名闭包）" class="headerlink" title="0.2.3.7    匿名函数（匿名闭包）"></a>0.2.3.7    匿名函数（匿名闭包）</h4><blockquote>
<p><strong>说明：</strong>匿名函数写法非常自由</p>
<ul>
<li>如果一个闭包的类型已知，比如作为一个回调函数，可以忽略参数的类型和返回值</li>
<li>单个语句闭包会把它语句的值当作结果返回</li>
<li>可以通过参数位置而不是参数名引用参数</li>
<li>当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面</li>
<li>当一个闭包是传给函数的唯一参数，可以完全忽略<code>()</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名闭包1（包含参数类型和返回值类型）</span></span><br><span class="line">numbers.<span class="built_in">map</span>(&#123;</span><br><span class="line">    (number:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 匿名闭包2（可以推导出闭包的参数类型和返回值类型的话，两者都可以省略）</span></span><br><span class="line"><span class="keyword">let</span> mappedNumbers = numbers.<span class="built_in">map</span>(&#123;number <span class="keyword">in</span> <span class="number">3</span> * number&#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名闭包3（函数体中通过参数位置而不是参数名访问参数）</span></span><br><span class="line"><span class="keyword">let</span> sortedNumbers = numbers.<span class="built_in">sort</span> &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-4-对象和类（Object-and-Classes）"><a href="#0-2-4-对象和类（Object-and-Classes）" class="headerlink" title="0.2.4    对象和类（Object and Classes）"></a>0.2.4    对象和类（Object and Classes）</h3><blockquote>
<p><strong>语法：</strong></p>
<ul>
<li><code>class 类型名 {...}</code></li>
<li>使用<code>.</code>访问实例的属性和方法</li>
<li>在成员方法中使用<code>self</code>引用当前实例对象</li>
<li>使用构造函数<code>init</code>初始化类实例</li>
<li>使用析构函数<code>deinit</code>在删除对象之前做一些清理工作</li>
<li>没有标准的根类（不同于<code>java</code>）</li>
<li>子类的定义：<code>class 子类名:父类名</code></li>
<li>重写父类的方法许必须用<code>override</code>标记</li>
</ul>
</blockquote>
<p><em>简单类</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形状</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作实例的成员</span></span><br><span class="line">shape.numberOfSides = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure>
<p><em>构造函数和子类</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带名字的形状（基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt;  <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length \(sideLength)."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-1-计算属性"><a href="#0-2-4-1-计算属性" class="headerlink" title="0.2.4.1    计算属性"></a>0.2.4.1    计算属性</h4><blockquote>
<p><strong>说明：</strong>计算属性有getter和setter</p>
<ul>
<li>get：读取属性时返回计算出的属性值</li>
<li>set：写入值时被调用，其中内置变量<code>newValue</code>存储新值</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等腰三角形（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算属性：提供get和set</span></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength = newValue / <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"An equilateral triagle with sides of length \(sideLength)."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle = <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">"a triangle"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问计算属性（get被调用）</span></span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line"><span class="comment">// 设置计算属性（set计算属性）</span></span><br><span class="line">triangle.perimeter = <span class="number">9.9</span></span><br><span class="line"><span class="comment">// 访问存储属性</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-2-属性监控"><a href="#0-2-4-2-属性监控" class="headerlink" title="0.2.4.2    属性监控"></a>0.2.4.2    属性监控</h4><blockquote>
<p><strong>说明：</strong>不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码。可以使用<code>willset</code>和<code>didSet</code>。</p>
<ul>
<li>willset：在设置之前调用</li>
<li>didSet：在设置后后调用</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含一个三角形实例和一个正方形实例作为成员，并确保边长相等</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="comment">// 设置新值前调用</span></span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="comment">// 设置新值之前调用</span></span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span> (size: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle = <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"another test shape"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置前</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置其中一个成员（会触发willset）</span></span><br><span class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">"larger square"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置之后</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure>
<h4 id="0-2-4-3-实例是可选值"><a href="#0-2-4-3-实例是可选值" class="headerlink" title="0.2.4.3    实例是可选值"></a>0.2.4.3    实例是可选值</h4><blockquote>
<p><strong>说明：</strong>当实例是nil是，需要避免访问实例的成员导致报错。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明可选型</span></span><br><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? = <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">"optional square"</span>)</span><br><span class="line"><span class="comment">// 在操作（方法调用／属性访问／子脚本访问）前加?</span></span><br><span class="line"><span class="keyword">let</span> sideLength = optionalSquare?.sideLength</span><br></pre></td></tr></table></figure>
<h3 id="0-2-5-枚举和结构体（Enumerations-and-Structures）"><a href="#0-2-5-枚举和结构体（Enumerations-and-Structures）" class="headerlink" title="0.2.5    枚举和结构体（Enumerations and Structures）"></a>0.2.5    枚举和结构体（Enumerations and Structures）</h3><h4 id="0-2-5-1-枚举"><a href="#0-2-5-1-枚举" class="headerlink" title="0.2.5.1    枚举"></a>0.2.5.1    枚举</h4><blockquote>
<p><strong>关键字：</strong><code>enum</code><br><strong>说明：</strong>swift中的所有命名类型都可以包含方法（包括枚举）。</p>
<ul>
<li>可以不设置枚举值的原始值类型</li>
<li>同一枚举类型的实例的成员（枚举值）的原始值（可以在创建实例的时候传入值）可以不同</li>
<li>如果原始值类型为<code>Int</code>，可以只设置第一个原始值，剩下的原始值会按照顺序自动完成赋值</li>
<li>也可以使用字符串或者浮点数作为枚举的原始值</li>
<li>使用<code>rawValue</code>属性来访问一个枚举成员的原始值</li>
<li>存在一个默认的初始化构造器<code>init?(rawValue:)</code>，这意味着可以通过原始值创建可选型美剧值（使用前需要解包）</li>
<li>声明枚举类型常量或在<code>switch</code>中时，当指定了枚举类型时，可以使用<code>.枚举值</code>的方式</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扑克牌级别</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Ace</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Two</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span></span><br><span class="line">    <span class="comment">// 枚举类型可以声明方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Queen</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"king"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类型变量</span></span><br><span class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.<span class="type">Ace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用枚举类型值的方法</span></span><br><span class="line">ace.simpleDescription()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型变量的原始值</span></span><br><span class="line"><span class="keyword">let</span> aceRawValue = ace.rawValue<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包通过init?(rawValue:)初始化构造器创建的枚举类型值</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank = <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> threeDescription = convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>不设置原始值类型</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扑克牌花色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Spades</span>, <span class="type">Hearts</span>, <span class="type">Diamonds</span>, <span class="type">Clubs</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Spades</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Hearts</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Diamonds</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Clubs</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举值</span></span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.<span class="type">Hearts</span></span><br><span class="line"><span class="comment">// 调用枚举值的方法查看枚举值对应的说明</span></span><br><span class="line"><span class="keyword">let</span> heartsDescription = hearts.simpleDescription()</span><br></pre></td></tr></table></figure>
<p><em>枚举的每个case还可以包含一些值</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器响应</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确响应</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Result</span>(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为实例传值</span></span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.<span class="type">Result</span>(<span class="string">"6:00 am"</span>, <span class="string">"8:09 pm"</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.<span class="type">Error</span>(<span class="string">"Out of cheese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Result</span>(sunrise, sunset):</span><br><span class="line">    <span class="comment">// 获取枚举实例的值</span></span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"sunset is at \(sunrise) and sunset is at \(sunset)."</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Error</span>(error):</span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"Failure... \(error)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-2-5-2-结构体"><a href="#0-2-5-2-结构体" class="headerlink" title="0.2.5.2    结构体"></a>0.2.5.2    结构体</h4><blockquote>
<p><strong>说明：</strong>结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的区别就是结构体是传值，类是传引用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扑克牌</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 级别</span></span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="comment">// 花色</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The \(rank.simpleDescription()) of \(suit.simpleDescription())"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 黑桃3</span></span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .<span class="type">Three</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="keyword">let</span> threeOfSpandesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure>
<h3 id="0-2-6-协议和扩展（Protocols-and-Extensions）"><a href="#0-2-6-协议和扩展（Protocols-and-Extensions）" class="headerlink" title="0.2.6    协议和扩展（Protocols and Extensions）"></a>0.2.6    协议和扩展（Protocols and Extensions）</h3><h4 id="0-2-6-1-协议"><a href="#0-2-6-1-协议" class="headerlink" title="0.2.6.1    协议"></a>0.2.6.1    协议</h4><blockquote>
<p><strong>关键字：</strong><code>protocol</code><br><strong>说明：</strong>类似于接句，类、枚举、结构体都可以实现协议。<br><strong>注意：</strong></p>
<ul>
<li>使用结构体实现协议时，如果实现的方法会修改结构体，需要用<code>mutating</code>标记。</li>
<li>可以直接使用协议声明变量或常量，但无法调用运行时类型实现的协议值完的方法或属性</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类实现这个协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A very simple class."</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">" Now 100% adjust."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"><span class="comment">// 像使用其他命名类型一样使用协议名，用其声明一个变量，并将实现了该协议的类的实例赋值给它</span></span><br><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</span><br><span class="line"><span class="comment">// 使用协议本身声明的变量或常量不能访问协议外定义成员</span></span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过结构体实现这个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A simple structure"</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"(adjusted)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="type">SimpleStructure</span>()</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDesctiption = b.simpleDescription</span><br></pre></td></tr></table></figure>
<h4 id="0-2-6-2-扩展"><a href="#0-2-6-2-扩展" class="headerlink" title="0.2.6.2    扩展"></a>0.2.6.2    扩展</h4><blockquote>
<p><strong>关键字：</strong><code>extension</code><br><strong>描述：</strong>为现有的类型添加功能，比如新的方法和计算属性。<br><strong>说明：</strong>你可以使用扩展在别处修改定义，甚至是从外部库活着框架引入的一个类型，使得这个类型遵循某个协议。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The number \(self)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure>
<h3 id="0-2-7-范型（Generics）"><a href="#0-2-7-范型（Generics）" class="headerlink" title="0.2.7    范型（Generics）"></a>0.2.7    范型（Generics）</h3><blockquote>
<p><strong>描述：</strong>在<code>&lt;&gt;</code>中写一个名字来创建一个范型函数或者类型。<br><strong>说明：</strong>可以应用于</p>
<ul>
<li>函数</li>
<li>方法</li>
<li>类</li>
<li>枚举</li>
<li>结构体</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>可以使用<code>where</code>来指定对类型的要求</li>
<li><code>&lt;T: Equatable&gt;</code>和<code>&lt;T where T: Equatable&gt;</code>等价</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span> &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; <span class="params">(lhs: T, <span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h2 id="0-3-Swift版本历史记录"><a href="#0-3-Swift版本历史记录" class="headerlink" title="0.3    Swift版本历史记录"></a>0.3    Swift版本历史记录</h2><h2 id="0-4-The-Swift-Programing-language中文版"><a href="#0-4-The-Swift-Programing-language中文版" class="headerlink" title="0.4    The Swift Programing language中文版"></a>0.4    The Swift Programing language中文版</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_20 NSPredicate/" itemprop="url">
                  20 NSpredicate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:43:10+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_20 NSPredicate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_20 NSPredicate/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Cocoa</code>提供了一个名为<code>NSPredicate</code>的类，用于指定过滤器的条件。<br><strong>原理：</strong>可以创建<code>NSPredicate</code>对象，通过它准确描述所需的条件，通过<code>谓词</code>(计算真值和假值的函数)筛选每个对象，判断它们是否与条件相匹配。</p>
</blockquote>
<h2 id="20-1-创建谓词"><a href="#20-1-创建谓词" class="headerlink" title="20.1    创建谓词"></a>20.1    创建谓词</h2><blockquote>
<p><strong>说明：</strong>使用<code>谓词</code>有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建许多<code>NSPredicate</code>对象，组合使用</td>
<td>构建通用用户界面来指定查询的场景</td>
</tr>
<tr>
<td>谓词字符串</td>
<td>适用于初学者使用，比较简单</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>通常将以使用<code>面向字符串</code>的<code>API</code>，尤其是在缺少编译器的错误检查和奇怪的运行时错误的时候。</p>
</blockquote>
<h3 id="predicateWithFormat工厂方法"><a href="#predicateWithFormat工厂方法" class="headerlink" title="predicateWithFormat工厂方法"></a>predicateWithFormat工厂方法</h3><blockquote>
<p><strong>说明：</strong>基于<code>谓词字符串</code>在后台构建<code>对象数</code>，创建<code>谓词</code>。<br><strong>谓词字符串：</strong>用途类似<code>sql</code>，语法类似标准c语言表达式<br><strong>原型：</strong><code>NSPredicate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; predicateFormat 谓词字符串（地位类似格式串）</span><br><span class="line">* @param &#123;...&#125; 对应为此字符串中的占位符</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSPredicate</span> *)predicateWithFormat:(<span class="built_in">NSString</span> *)predicateFormat, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存入汽车实例</span></span><br><span class="line">Car *car;</span><br><span class="line">car = makeCar(<span class="string">@"Herbie"</span>, <span class="string">@"Honda"</span>, <span class="string">@"CRX"</span>, <span class="number">1984</span>, <span class="number">2</span>, <span class="number">34000</span>, <span class="number">58</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建谓词：过滤 name 属性值为 Herbie 的车</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate;</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == 'Herbie'"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="20-2-计算谓词"><a href="#20-2-计算谓词" class="headerlink" title="20.2    计算谓词"></a>20.2    计算谓词</h2><h3 id="evaluateWithObject实例方法"><a href="#evaluateWithObject实例方法" class="headerlink" title="evaluateWithObject实例方法"></a>evaluateWithObject实例方法</h3><blockquote>
<p><strong>说明：</strong>通知接收对象（即<code>谓词</code>）根据<code>指定的对象</code>计算自身的值。<br><strong>用途：</strong>计算<code>某个对象</code>是否符合某个<code>谓词</code>中的判断逻辑。<br><strong>原型：</strong>``</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; object 谓词的主语</span><br><span class="line">* @return &#123;BOOL&#125; YES 判断为真， NO 判断为假</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateWithObject:(nullable <span class="keyword">id</span>)object;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 谓词1：过滤 name 属性值为 Herbie 的车</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate;</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == 'Herbie'"</span>];</span><br><span class="line"><span class="comment">// 搭配主语进行判断</span></span><br><span class="line"><span class="built_in">BOOL</span> match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词2：引擎马力大于150</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; 150"</span>];</span><br><span class="line">match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词3：和谓词1等价</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == %@"</span>, <span class="string">@"Herbie"</span>];</span><br><span class="line">match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="20-3-数组过滤器"><a href="#20-3-数组过滤器" class="headerlink" title="20.3    数组过滤器"></a>20.3    数组过滤器</h2><blockquote>
<p><strong>说明：</strong>某些<code>类别</code>将<code>谓词过滤方法</code>添加到了<code>Cocoa</code>集合类（比如<code>NSArray</code>）中。</p>
</blockquote>
<h3 id="filteredArrayUsingPredicate实例方法"><a href="#filteredArrayUsingPredicate实例方法" class="headerlink" title="filteredArrayUsingPredicate实例方法"></a>filteredArrayUsingPredicate实例方法</h3><blockquote>
<p><strong>说明：</strong>循环过滤数组内容，根据<code>谓词</code>计算每个对象的值，并将值为<code>YES</code>的对象累计到将被放回的新数组中。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组过滤 */</span></span><br><span class="line"><span class="comment">// 创建汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"><span class="comment">// 添加汽车实例</span></span><br><span class="line">car = makeCar (<span class="string">@"Badger"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Integra"</span>, <span class="number">1987</span>, <span class="number">5</span>, <span class="number">217036.7</span>, <span class="number">130</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Elvis"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Legend"</span>, <span class="number">1989</span>, <span class="number">4</span>, <span class="number">28123.4</span>, <span class="number">151</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Phoenix"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Firebird"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">85128.3</span>, <span class="number">345</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Streaker"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Silver Streak"</span>, <span class="number">1950</span>, <span class="number">2</span>, <span class="number">39100.0</span>, <span class="number">36</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Judge"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"GTO"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">45132.2</span>, <span class="number">370</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"></span><br><span class="line">car = makeCar (<span class="string">@"Paper Car"</span>, <span class="string">@"Plymouth"</span>, <span class="string">@"Valiant"</span>, <span class="number">1965</span>, <span class="number">2</span>, <span class="number">76800</span>, <span class="number">105</span>);</span><br><span class="line">[garage addCar: car];</span><br><span class="line"><span class="comment">// 创建谓词</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; 150"</span>];</span><br><span class="line"><span class="comment">// 获取汽车实例组成的数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *cars = [garage cars];</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (Car *car <span class="keyword">in</span> cars) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([predicate evaluateWithObject:car]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, car.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建谓词</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; %d"</span>, <span class="number">50</span>];</span><br><span class="line"><span class="comment">// 过滤数组：引擎马力大于50的</span></span><br><span class="line"><span class="built_in">NSArray</span> *results = [cars filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h3 id="filterUsingPredicate实例方法"><a href="#filterUsingPredicate实例方法" class="headerlink" title="filterUsingPredicate实例方法"></a>filterUsingPredicate实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>谓词</code>剔除可变数组中计算结果不为真的对象。<br><strong>原型：</strong><code>NSMutableArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSPredicate *&#125; predicate 谓词</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)filterUsingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------可变数组过滤</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *carsCopy = [cars mutableCopy];</span><br><span class="line"><span class="comment">// 过滤（有副作用的过滤）</span></span><br><span class="line">[carsCopy filterUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-4-格式说明符"><a href="#20-4-格式说明符" class="headerlink" title="20.4    格式说明符"></a>20.4    格式说明符</h2><blockquote>
<p><strong>说明：</strong>硬编码并非好事，可以通过两种方式将不同的内同放入<code>谓词格式字符串</code>中</p>
<ul>
<li>格式说明符：<code>%格式说明符</code></li>
<li>变量名：<code>$变量名</code></li>
</ul>
</blockquote>
<h3 id="20-4-1-格式说明符"><a href="#20-4-1-格式说明符" class="headerlink" title="20.4.1    格式说明符"></a>20.4.1    格式说明符</h3><blockquote>
<p><strong>说明：</strong>分3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>printf说明符</td>
<td><code>c</code>语言使用的格式说明符</td>
<td><code>%d</code>、<code>%f</code>等</td>
</tr>
<tr>
<td><code>%@</code></td>
<td>插入<code>O-C</code>字符串值</td>
<td></td>
</tr>
<tr>
<td><code>%K</code></td>
<td>插入键路径</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用printf式格式字符串</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; %d"</span>, <span class="number">50</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="comment">// 使用%@插入字符串值</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == %@"</span>, <span class="string">@"Herbie"</span>];</span><br><span class="line"><span class="comment">// 使用%K指定键路径</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"%K == %@"</span>, <span class="string">@"name"</span>, <span class="string">@"Herbie"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="20-4-2-插入变量名"><a href="#20-4-2-插入变量名" class="headerlink" title="20.4.2    插入变量名"></a>20.4.2    插入变量名</h3><blockquote>
<p><strong>说明：</strong>需要配合<code>字典</code>和<code>predicateWithSubstitutionVariables</code>实例方法一起使用。</p>
</blockquote>
<h4 id="predicateWithSubstitutionVariables"><a href="#predicateWithSubstitutionVariables" class="headerlink" title="predicateWithSubstitutionVariables"></a>predicateWithSubstitutionVariables</h4><blockquote>
<p><strong>说明：</strong>通过已有的<code>谓词</code>（<code>谓词字符串</code>中包含插入的变量名）创建更加具体的<code>专用谓词</code>。<br><strong>原型：</strong><code>NSPredicate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSDictionary&lt;NSString *, id&gt; *&#125; variables 用于具体化谓词的字典</span><br><span class="line">* @return &#123;NSPredicate&#125; 专用谓词</span><br><span class="line">*/</span></span><br><span class="line">- (instancetype)predicateWithSubstitutionVariables:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)variables;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字典的键名插入到谓词字符串中</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name == $NAME"</span>];<span class="comment">// 创建谓词模版</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *varDict;</span><br><span class="line"><span class="comment">// 变量名为NSString类型</span></span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"Heribie"</span>, <span class="string">@"NAME"</span>, <span class="literal">nil</span>];<span class="comment">// 用来为上述谓词模版的$NAME赋值的字典</span></span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];<span class="comment">// 通过谓词模版创建谓词</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"SNORGLE：%@"</span>, predicate);</span><br><span class="line">match = [predicate evaluateWithObject:car];<span class="comment">// 主语结合谓词进行计算</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (match) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"engine.horsepower &gt; $POWER"</span>];</span><br><span class="line"><span class="comment">// 变量名为NSNumber类型</span></span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>], <span class="string">@"POWER"</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"OOP %@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-5-运算符"><a href="#20-5-运算符" class="headerlink" title="20.5    运算符"></a>20.5    运算符</h2><blockquote>
<p><strong>说明：</strong><code>NSPredicate</code>的格式串中包含大量不同的运算符。<br><strong>注意：</strong>本章将介绍大多数运算符，其余的可以通过苹果公司的<code>在线文档</code>进行查询。</p>
</blockquote>
<h3 id="20-5-1-比较和逻辑运算符"><a href="#20-5-1-比较和逻辑运算符" class="headerlink" title="20.5.1    比较和逻辑运算符"></a>20.5.1    比较和逻辑运算符</h3><blockquote>
<p><strong>说明：</strong><code>谓词字符串</code>语法支持<code>C</code>语言中一些常用的运算符</p>
<ul>
<li>等号运算符：<code>==</code></li>
<li>不等号运算符：<code>&gt;</code>、<code>&lt;=</code>、<code>!=</code>等</li>
<li>赋值运算符：<code>=</code></li>
<li>逻辑运算符：<code>AND(&amp;&amp;)</code>、<code>OR(||)</code>、<code>NOT(!)</code></li>
</ul>
</blockquote>
<h4 id="20-5-1-1-比较运算符"><a href="#20-5-1-1-比较运算符" class="headerlink" title="20.5.1.1    比较运算符"></a>20.5.1.1    比较运算符</h4><blockquote>
<p><strong>说明：</strong>包括<code>等号运算符</code>和<code>不等号运算符</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code>(<code>&lt;&gt;</code>)</td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;=</code>(<code>=&lt;</code>)</td>
<td>小于或等于</td>
</tr>
<tr>
<td><code>&gt;=</code>(<code>=&gt;</code>)</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较运算符：过滤出数组中name属性小于"Newton"的对象组成的新数组</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name &lt; 'Newton'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [results valueForKey:<span class="string">@"name"</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="20-5-1-2-逻辑运算符"><a href="#20-5-1-2-逻辑运算符" class="headerlink" title="20.5.1.2    逻辑运算符"></a>20.5.1.2    逻辑运算符</h4><blockquote>
<p><strong>说明：</strong>共3个</p>
</blockquote>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th><code>O-C</code>形式</th>
<th>c语言形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>与</td>
<td><code>AND</code></td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>或</td>
<td><code>OR</code></td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td>非</td>
<td><code>NOT</code></td>
<td><code>!</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>谓词字符串</code>中的运算符不区分大小写</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"(engine.horsepower &gt; 50) AND (engine.horsepower &lt; 200)"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oop %@"</span>, results);</span><br></pre></td></tr></table></figure>
<h3 id="20-5-2-数组运算符"><a href="#20-5-2-数组运算符" class="headerlink" title="20.5.2    数组运算符"></a>20.5.2    数组运算符</h3><blockquote>
<p><strong>说明：</strong>有2个</p>
</blockquote>
<p>|数组运算符|说明|<br>|<code>BETWEEN</code>|判断是否介于两个值之间|<br>|<code>IN</code>|判断数组中是否包含某个值|</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组字面量</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:</span><br><span class="line">             <span class="string">@"engine.horsepower BETWEEN &#123; 50, 200 &#125;"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组变量</span></span><br><span class="line"><span class="built_in">NSArray</span> *betweens = [<span class="built_in">NSArray</span> arrayWithObjects:</span><br><span class="line">                     [<span class="built_in">NSNumber</span> numberWithInt: <span class="number">50</span>], [<span class="built_in">NSNumber</span> numberWithInt: <span class="number">200</span>], <span class="literal">nil</span>];</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"engine.horsepower BETWEEN %@"</span>, betweens];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"><span class="comment">// 数组运算符 BETWEEN：使用数组变量＋谓词模版</span></span><br><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"engine.horsepower BETWEEN $POWERS"</span>];</span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: betweens, <span class="string">@"POWERS"</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables: varDict];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组运算符 IN：使用数组字面量</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name IN &#123; 'Herbie', 'Snugs', 'Badger', 'Flap' &#125;"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, [results valueForKey: <span class="string">@"name"</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="20-6-有-SELF-就足够了"><a href="#20-6-有-SELF-就足够了" class="headerlink" title="20.6    有 SELF 就足够了"></a>20.6    有 SELF 就足够了</h2><blockquote>
<p><strong>说明：</strong>在谓词字符串的<code>键路径</code>部分，除了可以使用对象的属性名外，还可以通过<code>SELF</code>引用自身。<br><strong>用途：</strong><code>SELF</code>表示的是响应谓词计算的对象本身，适用于将谓词应用于简单的值（例如纯文本字符串），而非哪些可以通过键路径进行操作的复杂对象。<br><strong>技巧：</strong>可以使用<code>谓词</code>计算两个数组的交集，其中一个数组作为<code>主语</code>，另一个在<code>谓词</code>中，使用<code>IN</code>运算符。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------ SELF ：应用于复杂对象</span></span><br><span class="line"><span class="comment">// 判断 name 属性是不是在指定 字符串数组中</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF.name IN &#123;'Herbie', 'Snugs', 'Badger', 'Flap'&#125;"</span>];</span><br><span class="line"><span class="comment">// 使用谓词过滤汽车数组，获取子数组</span></span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------ SELF：应用于简单对象</span></span><br><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line">names = [cars valueForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// 判断字符串自身是不是在指定 字符串数组中</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF IN &#123;'Herbie', 'Snugs', 'Bager', 'Flap'&#125;"</span>];</span><br><span class="line"><span class="comment">// 主语＋谓词</span></span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- 使用 IN 运算符计算两个数组的交集</span></span><br><span class="line"><span class="built_in">NSArray</span> *names1 = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Herbie"</span>, <span class="string">@"Badger"</span>, <span class="string">@"Judge"</span>, <span class="string">@"Elvis"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *names2 = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Judge"</span>, <span class="string">@"Paper Car"</span>, <span class="string">@"Badger"</span>, <span class="string">@"Phoenix"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"SELF IN %@"</span>, names1];</span><br><span class="line">results = [names2 filteredArrayUsingPredicate: predicate];</span><br></pre></td></tr></table></figure>
<h2 id="20-7-字符串运算符"><a href="#20-7-字符串运算符" class="headerlink" title="20.7    字符串运算符"></a>20.7    字符串运算符</h2><blockquote>
<p><strong>说明：</strong>3个专门针对字符串的运算符</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BEGINSWITH</code></td>
<td>前缀是否是某一个字符串</td>
</tr>
<tr>
<td><code>ENDSWITH</code></td>
<td>后缀是某一个字符串</td>
</tr>
<tr>
<td><code>CONTAINS</code></td>
<td>是否包含某一个子串</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>运算符修饰符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c</code></td>
<td>不区分大小写</td>
</tr>
<tr>
<td><code>d</code></td>
<td>不区分发音符号</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>不区分大小写和发音符号</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>处分是需要区分大小写或重音符号的特殊原因，否则请尽力使用<code>cd</code>修饰符。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------- 字符串运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH 'Bad'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH 'HERB'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name BEGINSWITH[cd] 'HERB'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-8-LIKE-运算符"><a href="#20-8-LIKE-运算符" class="headerlink" title="20.8    LIKE 运算符"></a>20.8    LIKE 运算符</h2><blockquote>
<p><strong>说明：</strong><code>LIKE</code>运算符包含2个通配符</p>
</blockquote>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>与任意个任意字符匹配</td>
</tr>
<tr>
<td><code>?</code></td>
<td>与一个任意字符匹配</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>如果热衷于正则表达式，可以使用<code>MATCHES</code>运算符。<br><strong>技巧：</strong>由于正则表达式计算开销比较大，因此可以在使用<code>MATCH</code>之前先使用其它运算符做初步过滤，从而提高运算速度。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- like 运算符</span></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name LIKE[cd] '*er*'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br><span class="line"></span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat: <span class="string">@"name LIKE[cd] '???er*'"</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate: predicate];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, results);</span><br></pre></td></tr></table></figure>
<h2 id="20-9-结语"><a href="#20-9-结语" class="headerlink" title="20.9    结语"></a>20.9    结语</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_19 使用静态分析器/" itemprop="url">
                  19 使用静态分析器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:52+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_19 使用静态分析器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_19 使用静态分析器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>从<code>Xcode 3.2</code>开始加入的新功能，不需要运行程序就可以从逻辑上检测代码的工具，它可以寻找会演变成bug的错误。</p>
</blockquote>
<h2 id="19-1-静态工作"><a href="#19-1-静态工作" class="headerlink" title="19.1    静态工作"></a>19.1    静态工作</h2><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>可以识别以下几种错误</p>
<ul>
<li><strong>安全问题：</strong>比如内存泄漏和缓冲区溢出</li>
<li><strong>并发性问题：</strong>比如静态条件（也就是依赖时间的两个或多个任务失效）</li>
<li><strong>逻辑问题：</strong>包括废代码和不好的编码习惯</li>
</ul>
<p><strong>注意：</strong><code>静态分析器</code>存在以下不足</p>
<ul>
<li>拖慢构建程序的过程：因为需要消耗时间来进行分析</li>
<li>有时会误报错误</li>
<li>需要适应：因为改变了熟悉的工作流程</li>
</ul>
</blockquote>
<h3 id="19-1-1-开始分析"><a href="#19-1-1-开始分析" class="headerlink" title="19.1.1    开始分析"></a>19.1.1    开始分析</h3><blockquote>
<p><strong>运行静态分析器：</strong><code>Product(菜单) -&gt; Analyze</code>，分解决过在导航栏<code>issue</code>中可以看到<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%885.26.58.png" alt="Alt text"></p>
</blockquote>
<h4 id="19-1-1-1-废代码"><a href="#19-1-1-1-废代码" class="headerlink" title="19.1.1.1    废代码"></a>19.1.1.1    废代码</h4><blockquote>
<p><strong>废代码：</strong>创建了一个对象<code>pool</code>，但从没有在代码中直接访问过，没有向它发送消息也没有更改过它。<br><strong>优化手段：</strong>移除<code>废代码</code><br><strong>优化意义：</strong>废代码并不一定会给程序带来功能上的问题，但终归会浪费性能，移除废代码可以使应用程序更加高效。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.42.15.png" alt="Alt text"></p>
<h4 id="19-1-1-2-内存泄漏：对象被释放之前程序return"><a href="#19-1-1-2-内存泄漏：对象被释放之前程序return" class="headerlink" title="19.1.1.2    内存泄漏：对象被释放之前程序return"></a>19.1.1.2    内存泄漏：对象被释放之前程序return</h4><blockquote>
<p><strong>说明：</strong>通常还没有释放掉分配的内存的对象，就过早返回时便会出现这种情况。<br><strong>扩展：</strong>可以通过点击带有<code>分析器图标</code>的代码来观察代码从开始到当前行的运行流程</p>
<ol>
<li>触发“运行流程”<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.50.10.png" alt="Alt text"></li>
<li>完毕<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%886.55.01.png" alt="Alt text"></li>
</ol>
</blockquote>
<h4 id="19-1-1-3-内存泄漏：副本没有释放"><a href="#19-1-1-3-内存泄漏：副本没有释放" class="headerlink" title="19.1.1.3    内存泄漏：副本没有释放"></a>19.1.1.3    内存泄漏：副本没有释放</h4><blockquote>
<p><strong>说明：</strong>创建一个对象的副本，要在适当的时候对其进行释放，否则引发内存泄漏。<br><strong>优化手段：</strong>在<code>main</code>函数结尾处释放<code>carCopy</code>。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-31%20%E4%B8%8B%E5%8D%887.02.18.png" alt="Alt text"></p>
</blockquote>
<h4 id="19-1-1-4-内存泄漏：description方法中的desc在返回前没有释放"><a href="#19-1-1-4-内存泄漏：description方法中的desc在返回前没有释放" class="headerlink" title="19.1.1.4    内存泄漏：description方法中的desc在返回前没有释放"></a>19.1.1.4    内存泄漏：description方法中的desc在返回前没有释放</h4><blockquote>
<p><strong>说明：</strong><code>AllWeatherRadial类</code>中的<code>description</code>方法中分配了一个字符串<code>desc</code>，但没有在返回函数之前释放它。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:</span><br><span class="line">                   <span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>,</span><br><span class="line">               [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth],</span><br><span class="line">               [<span class="keyword">self</span> rainHandling], </span><br><span class="line">               [<span class="keyword">self</span> snowHandling]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [desc autorelease];</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// description</span></span><br></pre></td></tr></table></figure>
<h3 id="19-1-2-协助分析器"><a href="#19-1-2-协助分析器" class="headerlink" title="19.1.2    协助分析器"></a>19.1.2    协助分析器</h3><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>分析出的“问题”如果是我们有意的，可以通过在声明方法时使用一些<code>关键字</code>避免误报；或者有些情况下，想要使通常没问题的方式发出警报。比如</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用途</th>
<th>对应的惯例</th>
<th>返回对象为<code>Core Foundation</code>对象时</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NS_RETURNS_RETAINTED</code></td>
<td>标记方法，以返回一个保留计数器的值不是零的对象</td>
<td>分配内存的地方也要负责清理内存</td>
<td><code>CF_RETURNS_RETAINTED</code></td>
</tr>
<tr>
<td><code>NS_RETURNS_NOT_RETAINED</code></td>
<td>使<code>静态分析器</code>在方法试图返回一个保留对象时发出<code>issue</code></td>
<td>返回保留对象通常不需要做额外内存管理</td>
<td><code>NS_RETURNS_NOT_RETAINED</code></td>
</tr>
<tr>
<td><code>CLANG_ANALYZER_NORETURN</code></td>
<td>如果方法有值返回，就在<code>静态分析</code>是发出警报</td>
<td>方法返回值不会发生<code>issue</code></td>
<td>无意义</td>
</tr>
</tbody>
</table>
<h4 id="NS-RETURNS-RETAINTED：返回一个保留的对象"><a href="#NS-RETURNS-RETAINTED：返回一个保留的对象" class="headerlink" title="NS_RETURNS_RETAINTED：返回一个保留的对象"></a>NS_RETURNS_RETAINTED：返回一个保留的对象</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator <span class="built_in">NS_RETURNS_RETAINED</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *myArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 没将 myArray 释放就返回了</span></span><br><span class="line">	<span class="keyword">return</span> myArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NS-RETURNS-NOT-RETAINED：返回一个未保留的对象"><a href="#NS-RETURNS-NOT-RETAINED：返回一个未保留的对象" class="headerlink" title="NS_RETURNS_NOT_RETAINED：返回一个未保留的对象"></a>NS_RETURNS_NOT_RETAINED：返回一个未保留的对象</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分析器会在该方法视图返回一个保留对象时提出issue</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *) superDuperArrayCreator <span class="built_in">NS_RETURNS_NOT_RETAINED</span>;</span><br></pre></td></tr></table></figure>
<h3 id="19-1-3-了解更多"><a href="#19-1-3-了解更多" class="headerlink" title="19.1.3    了解更多"></a>19.1.3    了解更多</h3><blockquote>
<p><strong>说明：</strong><code>静态分析器</code>能够找到的其它问题</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>issue</code></th>
<th>说明</th>
<th>解决<code>issue</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>等号错误</td>
<td><code>if (myValue = expression)</code>存在歧义</td>
<td>赋值后判空：<code>if ((myValue = expression))</code>；判等：<code>if (nil != (myValue = expression))</code></td>
</tr>
<tr>
<td>内存泄漏</td>
<td>方法中的运行时错误使方法提前return，导致release代码没有执行而发生内存泄漏</td>
<td>无论什么时候退出了方法，都需要确认有没有分配了单海没有释放的对象</td>
</tr>
<tr>
<td>过度释放</td>
<td>重复<code>autorelease</code></td>
<td>移除多余的<code>autorelease</code></td>
</tr>
<tr>
<td><code>@synchronized语句中的空值</code></td>
<td><code>@synchronized(object)</code>中的<code>object</code>如果为<code>nil</code>就发出<code>issue</code></td>
<td>确保<code>object</code>不为<code>nil</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>把<code>静态分析器</code>作为一个善意但烦人的朋友，因为它所说的通常都是对的。<br><strong>注意：</strong>不要太依赖<code>静态分析器</code>来查找每一个内存泄漏和废代码，自己要对自己的代码负责。</p>
</blockquote>
<h2 id="19-2-小结"><a href="#19-2-小结" class="headerlink" title="19.2    小结"></a>19.2    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_18 键／值编码/" itemprop="url">
                  18 键/值编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:32+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_18 键／值编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_18 键／值编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="18-1-入门项目"><a href="#18-1-入门项目" class="headerlink" title="18.1    入门项目"></a>18.1    入门项目</h2><blockquote>
<p><strong>说明：</strong></p>
</blockquote>
<h2 id="18-2-KVC简介"><a href="#18-2-KVC简介" class="headerlink" title="18.2    KVC简介"></a>18.2    KVC简介</h2><blockquote>
<p><strong>说明：</strong>通过<code>键／值编码（KVC）</code>，没有相应<code>getter</code>方法也能获取属性值，没有相应<code>setter</code>方法也能设置属性值。<br><strong>自动开箱和装箱：</strong>仅<code>KVC</code>具有这种功能，常规方法调用和属性语法不具备该功能。</p>
</blockquote>
<h3 id="valueForKey实例方法"><a href="#valueForKey实例方法" class="headerlink" title="valueForKey实例方法"></a>valueForKey实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>获取属性的<code>值</code>。<br><strong>原理：</strong>在<code>Objective-C</code>的运行中使用元数据打开对象并进入其中查找需要的信息，查找顺序为</p>
<ol>
<li>以参数命名(<code>key</code>或<code>isKey</code>)的<code>getter</code></li>
<li>名称为<code>_key</code>或<code>key</code>的实例变量</li>
</ol>
<p><strong>自动装箱：</strong>通过该方法获取属性值时，如果属性为<code>标量(int、float、struct)</code>，该方法会根据需要将属性放入<code>NSNumber</code>或<code>NSValue</code>中。<br><strong>兼容性：</strong>在<code>C</code>或<code>C++</code>中不能执行这种操作。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; key 属性名</span><br><span class="line">* @return &#123;id&#125; 属性值（标量会被自动装箱）</span><br><span class="line">*/</span></span><br><span class="line">- (nullable <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<h3 id="setValue-forkey实例方法"><a href="#setValue-forkey实例方法" class="headerlink" title="setValue:forkey实例方法"></a>setValue:forkey实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>设置属性的<code>值</code>。<br><strong>自动开箱：</strong>使用该方法设置属性时，如果属性是<code>标量（int、float、struct）</code>，则会从新值（<code>id</code>）中提取出和属性类型相符的<code>标量</code>。<br><strong>技巧：</strong>如果想设置一个<code>标量</code>值，在调用<code>setValue</code>方法之前需要将它们包装掐来（封装到对象中）。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; value 要设置的值（需要的话会被开箱）</span><br><span class="line">* @param &#123;NSString *&#125; key 属性名</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(nullable <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建 Car 对象</span></span><br><span class="line">Car *car = [[Car alloc] init];</span><br><span class="line">car.name = <span class="string">@"Herbie"</span>;</span><br><span class="line">car.make = <span class="string">@"Honda"</span>;</span><br><span class="line">car.model = <span class="string">@"CRX"</span>;</span><br><span class="line">car.modelYear = <span class="number">1984</span>;</span><br><span class="line">car.numberOfDoors = <span class="number">2</span>;</span><br><span class="line">car.mileage = <span class="number">110000</span>;</span><br><span class="line"><span class="comment">// 初始化轮胎</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AllWeatherRadial *tire;</span><br><span class="line">    tire = [[AllWeatherRadial alloc] init];</span><br><span class="line">    [car setTire: tire atIndex:i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化引擎</span></span><br><span class="line">Slant6 *engine = [[Slant6 alloc] init];</span><br><span class="line">car.engine = engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 访问车的引擎的马力</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [engine valueForKey:<span class="string">@"horsepower"</span>]);</span><br><span class="line"><span class="comment">// 通过 KVC 重新设置车的引擎的马力</span></span><br><span class="line">[engine setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>] forKey:<span class="string">@"horsepower"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [engine valueForKey:<span class="string">@"horsepower"</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Car is %@"</span>, car);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 访问车的名字</span></span><br><span class="line"><span class="built_in">NSString</span> *name = [car valueForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, name);</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的制造商</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"make is %@"</span>, [car valueForKey:<span class="string">@"make"</span>]);</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的车型出厂日期</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"model year is %@"</span>, [car valueForKey:<span class="string">@"modelYear"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 设置车名</span></span><br><span class="line">[car setValue:<span class="string">@"Harold"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"new car name is %@"</span>, [car name]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KVC 设置里程数</span></span><br><span class="line">[car setValue:[<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">25062.4</span>] forKey:<span class="string">@"mileage"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"new mileage is %.1f"</span>, [car mileage]);</span><br></pre></td></tr></table></figure>
<h2 id="18-3-键路径"><a href="#18-3-键路径" class="headerlink" title="18.3    键路径"></a>18.3    键路径</h2><blockquote>
<p><strong>说明：</strong>进行<code>get</code>和<code>set</code>操作，除了通过<code>键</code>，还可以通过<code>键路径</code>。<code>键路径</code>可以根据<code>对象图</code>访问到任意深度的对象，比使用一系列嵌套方法调用更容易访问到对象。</p>
</blockquote>
<h3 id="valueForKeyPath实例方法"><a href="#valueForKeyPath实例方法" class="headerlink" title="valueForKeyPath实例方法"></a>valueForKeyPath实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>获取属性的<code>值</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; keyPath 键路径</span><br><span class="line">* @return &#123;id&#125; 属性值（标量会被自动装箱）</span><br><span class="line">*/</span></span><br><span class="line">- (nullable <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<h3 id="setValue-forKeyPath实例方法"><a href="#setValue-forKeyPath实例方法" class="headerlink" title="setValue:forKeyPath实例方法"></a>setValue:forKeyPath实例方法</h3><blockquote>
<p><strong>说明：</strong>将属性名作为<code>键</code>设置属性的<code>值</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; value 要设置的值（需要的话会被开箱）</span><br><span class="line">* @param &#123;NSString *&#125; keyPath 键路径</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(nullable <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 KVC 设置车的引擎的马力</span></span><br><span class="line">[car setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">155</span>] forKeyPath:<span class="string">@"engine.horsepower"</span>];</span><br><span class="line"><span class="comment">// 通过 KVC 访问车的引擎的马力</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"horsepower is %@"</span>, [car valueForKeyPath:<span class="string">@"engine.horsepower"</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="18-4-整体操作"><a href="#18-4-整体操作" class="headerlink" title="18.4    整体操作"></a>18.4    整体操作</h2><blockquote>
<p><strong>说明：</strong>如果使用<code>键值</code>或<code>键路径</code>访问位于对象中的数组类型的<code>实例属性</code>的元素，实际上会对数组中所有元素进行操作。如果是查询操作，则还会将查询结果打包到另一个数组中并返回。<br><strong>注意：</strong>这种<code>整体操作</code>意味着无法在<code>键路径</code>中单独索引数组类型的属性的其中一个元素。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 KVC 访问车的轮胎的胎压，会便利tires的每个属性，并将所有tires的属性的pressure变量封装到 NSNumber 对象中并返回</span></span><br><span class="line"><span class="built_in">NSArray</span> *pressures = [car valueForKeyPath:<span class="string">@"tires.pressure"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"pressures %@"</span>, pressures);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-休息一下"><a href="#18-4-1-休息一下" class="headerlink" title="18.4.1    休息一下"></a>18.4.1    休息一下</h3><blockquote>
<p><strong>说明：</strong>创建一个新的类用于后面的学习使用。</p>
</blockquote>
<p><em>Garage.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Car</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Garage</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *cars;</span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *stuff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) addCar: (Car *) car;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Garage</span></span><br></pre></td></tr></table></figure>
<p><em>Garage.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Garage.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Garage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) addCar: (Car *) car &#123;</span><br><span class="line">	<span class="keyword">if</span> (cars == <span class="literal">nil</span>) &#123;</span><br><span class="line">		cars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">	[cars addObject: car];</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// addCar</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	[name release];</span><br><span class="line">	[cars release];</span><br><span class="line">	[stuff release];</span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print &#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@:"</span>, name);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Car *car <span class="keyword">in</span> cars) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"    %@"</span>, car);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setValue: (<span class="keyword">id</span>) value  forUndefinedKey: (<span class="built_in">NSString</span> *) key &#123;</span><br><span class="line">	<span class="keyword">if</span> (stuff == <span class="literal">nil</span>) &#123;</span><br><span class="line">		stuff = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">	[stuff setValue: value forKey: key];</span><br><span class="line">&#125; <span class="comment">// setValueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">	<span class="keyword">id</span> value = [stuff valueForKey: key];</span><br><span class="line">	<span class="keyword">return</span> (value);</span><br><span class="line">&#125; <span class="comment">// valueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span>  <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汽车集合</span></span><br><span class="line">Garage *garage = [[Garage alloc] init];</span><br><span class="line">garage.name = <span class="string">@"Joe's Garage"</span>;</span><br><span class="line"><span class="comment">// 创建一些汽车实例</span></span><br><span class="line">Car *car;</span><br><span class="line">car = makeCar(<span class="string">@"Herbie"</span>, <span class="string">@"Honda"</span>, <span class="string">@"CRX"</span>, <span class="number">1984</span>, <span class="number">2</span>, <span class="number">110000</span>, <span class="number">58</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Badger"</span>, <span class="string">@"Acura"</span>, <span class="string">@"integra"</span>, <span class="number">1987</span>, <span class="number">5</span>, <span class="number">217036</span>, <span class="number">130</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Elvis"</span>, <span class="string">@"Acura"</span>, <span class="string">@"Legend"</span>, <span class="number">1989</span>, <span class="number">4</span>, <span class="number">28123.4</span>, <span class="number">151</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">car = makeCar(<span class="string">@"Phoenix"</span>, <span class="string">@"Pontiac"</span>, <span class="string">@"Firebird"</span>, <span class="number">1969</span>, <span class="number">2</span>, <span class="number">85128.3</span>, <span class="number">345</span>);</span><br><span class="line">[garage addCar:car];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察汽车集合</span></span><br><span class="line">[garage print];</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-快速运算"><a href="#18-4-2-快速运算" class="headerlink" title="18.4.2    快速运算"></a>18.4.2    快速运算</h3><blockquote>
<p><strong>说明：</strong><code>键路径</code>中可以使用进行引用一些运算符进行一些运算，比如</p>
<ul>
<li><strong>prevProperty.<code>@count</code>：</strong>计算 <strong>prevProperty</strong> 包含的对象的总数</li>
<li><strong>prevProperty.<code>@sum</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的总和</li>
<li><strong>prevProperty.<code>@avg</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的平均值</li>
<li><strong>prevProperty.<code>@max</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的最大值</li>
<li><strong>prevProperty.<code>@min</code>.nextProperty：</strong>计算<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性的最小值</li>
<li><strong>prevProperty.<code>@distinctUnionOfObjects</code>.nextProperty：</strong>获得从<strong>prevProperty</strong>包含的所有对象的<strong>nextProperty</strong>属性构成的集合去重后的集合</li>
</ul>
<p><strong>注意：</strong>不要滥用<code>KVC</code>通过<code>键路径</code>提供的处理集合类的<code>快速运算</code>特性，因为</p>
<ul>
<li>速度比较慢</li>
<li>编译器无法对它进行错误检查（出现运行时错误时才能发觉）</li>
</ul>
<p><strong>限制：</strong>无法添加自定义的运算符</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// @count</span></span><br><span class="line"><span class="built_in">NSNumber</span> *count = [garage valueForKeyPath:<span class="string">@"cars.@count"</span>];</span><br><span class="line"><span class="comment">// @sum</span></span><br><span class="line"><span class="built_in">NSNumber</span> *sum = [garage valueForKeyPath:<span class="string">@"cars.@sum.mileage"</span>];</span><br><span class="line"><span class="comment">// @avg</span></span><br><span class="line"><span class="built_in">NSNumber</span> *avgMileage = [garage valueForKeyPath:<span class="string">@"cars.@avg.mileage"</span>];</span><br><span class="line"><span class="comment">// @max、 @min</span></span><br><span class="line"><span class="built_in">NSNumber</span> *min, *max;</span><br><span class="line">max = [garage valueForKeyPath:<span class="string">@"cars.@max.mileage"</span>];</span><br><span class="line">min = [garage valueForKeyPath:<span class="string">@"cars.@max.mileage"</span>];</span><br><span class="line"><span class="comment">// @distinctUnionOfObjects</span></span><br><span class="line"><span class="built_in">NSArray</span> *manufacture = [garage valueForKeyPath:<span class="string">@"cars.@distinctUnionOfObjects.make"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="18-5-批处理"><a href="#18-5-批处理" class="headerlink" title="18.5    批处理"></a>18.5    批处理</h2><blockquote>
<p><strong>说明：</strong><code>KVC</code>提供了对对象进行批量操作的方式。</p>
</blockquote>
<h3 id="setValuesForKeysWithDictionary实例方法"><a href="#setValuesForKeysWithDictionary实例方法" class="headerlink" title="setValuesForKeysWithDictionary实例方法"></a>setValuesForKeysWithDictionary实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>字典</code>对对象进行批量<code>set</code>。<br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSDictionary&lt;NSString *, id&gt; *&#125; keyedValues 包含一系列属性名和值的字典</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>
<h3 id="dictionaryWithValuesForKeys实例方法"><a href="#dictionaryWithValuesForKeys实例方法" class="headerlink" title="dictionaryWithValuesForKeys实例方法"></a>dictionaryWithValuesForKeys实例方法</h3><blockquote>
<p><strong>说明：</strong>通过<code>数组</code>对对象进行批量<code>set</code><br><strong>原型：</strong><code>NSKeyValueCoding.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSArray&lt;NSString *&gt; *&#125; keys 包含要获取的属性的属性名</span><br><span class="line">* @return &#123;NSDictionary&lt;NSString *, id&gt; *&#125; 包含要获取的属性名/属性值对的字典</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取汽车集合中的最后一个汽车实例</span></span><br><span class="line">car = [[garage valueForKeyPath:<span class="string">@"cars"</span>] lastObject];</span><br><span class="line"><span class="comment">// 创建一个数组：包含创建字典需要的键集合</span></span><br><span class="line"><span class="built_in">NSArray</span> *keys = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"make"</span>, <span class="string">@"model"</span>, <span class="string">@"modelYear"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 批量get：利用上一步创建的包含一系列键的数组</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *carValues = [car dictionaryWithValuesForKeys:keys];</span><br><span class="line"><span class="comment">// 创建字典：用于初始化汽车实例的属性</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *newValues = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                           <span class="string">@"Chevy"</span>, <span class="string">@"make"</span>,</span><br><span class="line">                           <span class="string">@"Nova"</span>,<span class="string">@"model"</span>,</span><br><span class="line">                           [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1964</span>], <span class="string">@"modelYear"</span>,</span><br><span class="line">                           [<span class="built_in">NSNull</span> null], <span class="string">@"mileage"</span>,</span><br><span class="line">                           <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 批量set汽车</span></span><br><span class="line">[car setValuesForKeysWithDictionary:newValues];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"car with new values is %@"</span>, car);</span><br></pre></td></tr></table></figure>
<h2 id="18-6-nil-仍然可用"><a href="#18-6-nil-仍然可用" class="headerlink" title="18.6    nil 仍然可用"></a>18.6    nil 仍然可用</h2><blockquote>
<p><strong>背景：</strong>默认情况下，应用<code>KVC</code>调用<code>setValue:forKey</code>设置某个属性的值为<code>nil</code>时，编译器会给出警告。<br><strong>解决：</strong>可以通过重写<code>setNilValueForKey</code>方法给出有意义个返回值而避免警告。<br><strong>扩展：</strong>这里的 <code>nil</code>是标量<code>nil</code>，不要和<code>[NSNull null]</code>相混淆</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setNilValueForKey: (<span class="built_in">NSString</span> *) key &#123;</span><br><span class="line">	<span class="keyword">if</span> ([key isEqualToString: <span class="string">@"mileage"</span>]) &#123;</span><br><span class="line">		mileage = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		[<span class="keyword">super</span> setNilValueForKey: key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">// setNilValueForKey</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会将 mileage 设置为 0</span></span><br><span class="line">[car setValue: <span class="literal">nil</span> forKey: <span class="string">@"mileage"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="18-7-处理未定义键"><a href="#18-7-处理未定义键" class="headerlink" title="18.7    处理未定义键"></a>18.7    处理未定义键</h2><blockquote>
<p><strong>背景：</strong>如果<code>KVC</code>机制无法找到处理方法，会退回并询问该如何处理。默认的实现会取消操作。<br><strong>解决：</strong>通过重写<code>setValue:forUndefinedKey</code>和<code>valueForUndefinedKey</code>更改默认行为，使对象可以设置和获取任何键。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  @override</span><br><span class="line"> *  处理通过 KVC 设置不存在的属性的值</span><br><span class="line"> *</span><br><span class="line"> *  @param value 要设置的值</span><br><span class="line"> *  @param key   要设置的属性名</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setValue:(<span class="keyword">id</span>)value forUndefinedKey: (<span class="built_in">NSString</span> *) key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 惰性初始化</span></span><br><span class="line">    <span class="keyword">if</span> (stuff == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stuff = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    [stuff setValue:value forKey:key];</span><br><span class="line">&#125;<span class="comment">// setValueForUndefinedKey</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @override</span><br><span class="line"> *  处理通过 KVC 方式获取不存在的属性的值</span><br><span class="line"> *</span><br><span class="line"> *  @param key 属性名</span><br><span class="line"> *</span><br><span class="line"> *  @return 试图获取不存在的属性的值时的返回值</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) valueForUndefinedKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> value = [stuff valueForKey:key];</span><br><span class="line">    <span class="keyword">return</span> (value);</span><br><span class="line">&#125;<span class="comment">// valueForUnderfinedKey</span></span><br></pre></td></tr></table></figure>
<h2 id="18-8-小结"><a href="#18-8-小结" class="headerlink" title="18.8    小结"></a>18.8    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_17 文件的加载于保存/" itemprop="url">
                  17 文件的加载与保存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:42:12+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_17 文件的加载于保存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_17 文件的加载于保存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-属性列表"><a href="#17-1-属性列表" class="headerlink" title="17.1    属性列表"></a>17.1    属性列表</h2><h3 id="17-1-1-NSDate"><a href="#17-1-1-NSDate" class="headerlink" title="17.1.1    NSDate"></a>17.1.1    NSDate</h3><h4 id="date类方法"><a href="#date类方法" class="headerlink" title="date类方法"></a>date类方法</h4><blockquote>
<p><strong>说明：</strong>获取当前日期和时间。<br><strong>原型：</strong><code>NSDate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;instancetype&#125; NSDate类实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)date;</span><br></pre></td></tr></table></figure>
<h4 id="dateWithTimeIntervalSinceNow类方法"><a href="#dateWithTimeIntervalSinceNow类方法" class="headerlink" title="dateWithTimeIntervalSinceNow类方法"></a>dateWithTimeIntervalSinceNow类方法</h4><blockquote>
<p><strong>说明：</strong>获取与当前时间相隔一定时差的日期<br><strong>原型：</strong><code>NSDate</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@return &#123;instancetype&#125; NSDate实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)dateWithTimeIntervalSinceNow:(<span class="built_in">NSTimeInterval</span>)secs;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的日期和时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"today is %@"</span>, date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取24小时之前的时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *yesterday = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-(<span class="number">24</span>* <span class="number">60</span> *<span class="number">60</span>)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"yesterday is %@"</span>, yesterday);</span><br></pre></td></tr></table></figure>
<h3 id="17-1-2-NSData"><a href="#17-1-2-NSData" class="headerlink" title="17.1.2    NSData"></a>17.1.2    NSData</h3><blockquote>
<p><strong>说明：</strong>该类可以包含大量的字节，可以获得数据的长度和指向字节启示位置的指针<br><strong>用途：</strong>如果想将数据块传递给一个函数或方法，可以通过传递一个<code>NSData</code>来实现。<br>注意：<code>NSData</code>是一个对象，支持<code>自动释放</code>的，常规的内存管理对它是有效的，因而无需担心内存清理的问题。</p>
</blockquote>
<h4 id="dataWithBytes类方法"><a href="#dataWithBytes类方法" class="headerlink" title="dataWithBytes类方法"></a>dataWithBytes类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个保存一个普通C字符串（一个字节序列）的<code>NSData</code>对象。<br><strong>原型：</strong><code>NSData</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;nullable const void *&#125; bytes 字符串</span><br><span class="line">* @param &#123;NSUInteger&#125; length 字符串的长度（包括尾部的`\0`）</span><br><span class="line">* @return &#123;instancetype&#125; NSData实例</span><br><span class="line">*/</span></span><br><span class="line">+ (instancetype)dataWithBytes:(nullable <span class="keyword">const</span> <span class="keyword">void</span> *)bytes length:(<span class="built_in">NSUInteger</span>)length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong><code>NSData</code>是不可变的，创建后不能改变其中的内容来；<code>NSMutableData</code>是可变的，可以在数据中添加和删除字节。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 语言字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="string">"hi there, this is a C string!"</span>;</span><br><span class="line"><span class="comment">// 创建 NSData 对象</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:string length:strlen(string) + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 操作 NSData 对象</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"data is %@"</span>, data);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld byte string is '%s'"</span>, [data length], [data bytes]);</span><br></pre></td></tr></table></figure>
<h3 id="17-1-3-写入和读取属性列表"><a href="#17-1-3-写入和读取属性列表" class="headerlink" title="17.1.3    写入和读取属性列表"></a>17.1.3    写入和读取属性列表</h3><blockquote>
<p><strong>说明：</strong>属性列表类可以存储到文件中，也可以从文件中读取出来。此外，<code>Xcode</code>包含一个属性列表编辑器，可以用来方便地查看<code>plist</code>文件。<br><strong>注意：</strong>如果出现问题，下面介绍的函数都不会返回具体的错误的原因。</p>
</blockquote>
<h4 id="writeToFile实例方法"><a href="#writeToFile实例方法" class="headerlink" title="writeToFile实例方法"></a>writeToFile实例方法</h4><blockquote>
<p><strong>说明：</strong>将属性列表的内容写入到文件。<br><strong>技巧：</strong>应尽量使用<code>atomically</code>的方式保存文件，除非保存的文件容量非常大，会占用用户大量的磁盘空间。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; 文件路径</span><br><span class="line">* @param &#123;BOOL&#125;useAuxiliaryFile 是否首先将文件内容保存到临时文件中（防止极端情况下原始文件被破坏）</span><br><span class="line">*/</span></span><br><span class="line">(<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path atomically:(<span class="built_in">BOOL</span>)useAuxiliaryFile;</span><br></pre></td></tr></table></figure>
<h4 id="arrayWithContentsOfFile类方法"><a href="#arrayWithContentsOfFile类方法" class="headerlink" title="arrayWithContentsOfFile类方法"></a>arrayWithContentsOfFile类方法</h4><blockquote>
<p><strong>说明：</strong>读取文件中的数组信息并据此创建数组。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; path 文件路径</span><br><span class="line">* @return &#123;NSArray&#125; 数组实例</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="built_in">NSArray</span>&lt;ObjectType&gt; *)arrayWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 NSArray 实例</span></span><br><span class="line"><span class="built_in">NSArray</span> *phrase;</span><br><span class="line">phrase = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"I"</span>, <span class="string">@"seem"</span>, <span class="string">@"to"</span>, <span class="string">@"be"</span>, <span class="string">@"a"</span>, <span class="string">@"verb"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 将 NSArray 对象写入文件</span></span><br><span class="line">[phrase writeToFile:<span class="string">@"/tmp/verbiage.txt"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 通过文件创建 NSArray 实例</span></span><br><span class="line"><span class="built_in">NSArray</span> *phrase2 = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:<span class="string">@"/tmp/veribage.txt"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, phrase2);</span><br></pre></td></tr></table></figure>
<p><em>/tmp/verbiage.txt</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>I<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>seem<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>to<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>be<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>a<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>verb<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="17-1-4-修改对象类型"><a href="#17-1-4-修改对象类型" class="headerlink" title="17.1.4    修改对象类型"></a>17.1.4    修改对象类型</h3><blockquote>
<p><strong>说明：</strong>存储或加载属性列表时可以使用<code>NSPropertyListSerialization</code>添加一些设定项。</p>
</blockquote>
<h4 id="dataFromPropertyList类方法"><a href="#dataFromPropertyList类方法" class="headerlink" title="dataFromPropertyList类方法"></a>dataFromPropertyList类方法</h4><blockquote>
<p><strong>说明：</strong>存储到文件时指定设定项。已过时。<br><strong>原型：</strong><code>NSPropertyListSerialization</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; plist 属性列表类型对象</span><br><span class="line">* @param &#123;NSPropertyListFormat&#125; format 存储属性列表的方式</span><br><span class="line">* @param &#123;NSString *&#125; errorDescription 错误信息</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="built_in">NSData</span> *)dataFromPropertyList:(<span class="keyword">id</span>)plist format:(<span class="built_in">NSPropertyListFormat</span>)format errorDescription:(<span class="keyword">out</span> __<span class="keyword">strong</span> <span class="built_in">NSString</span> * __nullable * __nullable)errorString <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_0, <span class="number">10</span>_10, <span class="number">2</span>_0, <span class="number">8</span>_0, <span class="string">"Use dataWithPropertyList:format:options:error: instead."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变数组(首都集合)</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *capitols = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 第一个国家</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *capitol = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="string">@"Canada"</span> forKey:<span class="string">@"country"</span>];</span><br><span class="line">[capitol setObject:<span class="string">@"Ottawa"</span> forKey:<span class="string">@"capitol"</span>];</span><br><span class="line">[capitols addObject:capitol];</span><br><span class="line"><span class="comment">// 第二个国家</span></span><br><span class="line">capitol = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="string">@"Norway"</span> forKey:<span class="string">@"country"</span>];</span><br><span class="line">[capitol setObject:<span class="string">@"Oslo"</span> forKey:<span class="string">@"capitol"</span>];</span><br><span class="line">[capitols addObject:capitol];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 将 plist 数据内容以二进制形式写入文件</span></span><br><span class="line"><span class="built_in">NSData</span> *encodeArray = [<span class="built_in">NSPropertyListSerialization</span> dataFromPropertyList:capitols format:<span class="built_in">NSPropertyListXMLFormat_v1_0</span> errorDescription:&amp;error];</span><br><span class="line">[encodeArray writeToFile:<span class="string">@"/tmp/capitols.txt"</span> atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<h4 id="propertyListFromData实例方法"><a href="#propertyListFromData实例方法" class="headerlink" title="propertyListFromData实例方法"></a>propertyListFromData实例方法</h4><blockquote>
<p><strong>说明：</strong>以指定形式将文件读取到内存。<br><strong>原型：</strong><code>NSPropertyListSerialization</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSData *&#125; data 从文件读取原始数据</span><br><span class="line">* @param &#123;NSPropertyListMutabilityOptions&#125; opt format 读取形式</span><br><span class="line">* @param &#123;NSString *&#125; errorString 可能的错误信息</span><br><span class="line">*/</span></span><br><span class="line">+ (nullable <span class="keyword">id</span>)propertyListFromData:(<span class="built_in">NSData</span> *)data mutabilityOption:(<span class="built_in">NSPropertyListMutabilityOptions</span>)opt format:(nullable <span class="built_in">NSPropertyListFormat</span> *)format errorDescription:(<span class="keyword">out</span> __<span class="keyword">strong</span> <span class="built_in">NSString</span> * __nullable * __nullable)errorString <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_0, <span class="number">10</span>_10, <span class="number">2</span>_0, <span class="number">8</span>_0, <span class="string">"Use propertyListWithData:options:format:error: instead."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件中读取属性列表数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/tmp/capitols.txt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定的格式将文件中的内容读取到内存</span></span><br><span class="line"><span class="built_in">NSPropertyListFormat</span> properyListFormat = <span class="built_in">NSPropertyListXMLFormat_v1_0</span>;</span><br><span class="line"><span class="built_in">NSString</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *capitols = [<span class="built_in">NSPropertyListSerialization</span> propertyListFromData:data mutabilityOption:<span class="built_in">NSPropertyListMutableContainersAndLeaves</span> format:&amp;properyListFormat errorDescription:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"capitols %@"</span>, capitols);</span><br></pre></td></tr></table></figure>
<h2 id="17-2-编码对象"><a href="#17-2-编码对象" class="headerlink" title="17.2    编码对象"></a>17.2    编码对象</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>具备一种将任意对象转换成某种格式并保存到磁盘中的机制。</p>
<ul>
<li><strong>序列化（编码）：</strong>将对象的实例变量和其他数据编码为数据块，然后保存到磁盘</li>
<li><strong>反序列化（解码）：</strong>将数据块读回内存，并基于保存的数据创建新对象</li>
</ul>
</blockquote>
<h3 id="NSCoding协议"><a href="#NSCoding协议" class="headerlink" title="NSCoding协议"></a>NSCoding协议</h3><blockquote>
<p><strong>说明：</strong>通过采纳该协议，可以使对象具备<code>序列化和反序列化</code>的能力。<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCoding</span></span></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) encoder;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder;</span><br><span class="line">&gt;<span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="archiveDataWithRootObject类方法"><a href="#archiveDataWithRootObject类方法" class="headerlink" title="archiveDataWithRootObject类方法"></a>archiveDataWithRootObject类方法</h3><blockquote>
<p><strong>说明：</strong>对对象进行编码。</p>
<ol>
<li>创建了一个<code>KSKeyedArchier</code>实例</li>
<li>将上一步创建的实例传递给参数指定的对象的<code>encodeWithCoder</code>方法</li>
<li>递归编码自身使用到的其它对象，比如字符串、数组及放入数组中的任何对象</li>
<li>所有对象完成键值编码后，被放入一个<code>NSData</code>对象并返回</li>
</ol>
<p><strong>原型：</strong><code>KSKeyedArchiver</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; rootObject 要被序列化的对象</span><br><span class="line">* @return &#123;NSData *&#125; 序列化为 NSData 型数据</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)archivedDataWithRootObject:(<span class="keyword">id</span>)rootObject;</span><br></pre></td></tr></table></figure>
<p><em>Thingie.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Thingie</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    <span class="keyword">int</span> magicNumber;</span><br><span class="line">    <span class="keyword">float</span> shoeSize;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *subThingies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> magicNumber;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> shoeSize;</span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSMutableArray</span> *subThingies;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithName: (<span class="built_in">NSString</span> *) n</span><br><span class="line">        magicNumber: (<span class="keyword">int</span>) mn</span><br><span class="line">           shoeSize: (<span class="keyword">float</span>) ss;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Thingie.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Thingie.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Thingie</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"><span class="keyword">@synthesize</span> magicNumber;</span><br><span class="line"><span class="keyword">@synthesize</span> shoeSize;</span><br><span class="line"><span class="keyword">@synthesize</span> subThingies;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 便利构造函数：通过用户名</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithName:(<span class="built_in">NSString</span> *)</span><br><span class="line">        magicNumber:(<span class="keyword">int</span>)mn</span><br><span class="line">        shoeSize:(<span class="keyword">float</span>)ss</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = n;</span><br><span class="line">        <span class="keyword">self</span>.magicNumber = mn;</span><br><span class="line">        <span class="keyword">self</span>.showSize = ss;</span><br><span class="line">        <span class="keyword">self</span>.subThingies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采纳协议:反序列化</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [decoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">        <span class="keyword">self</span>.magicNumber = [decoder decodeIntForKey:<span class="string">@"magicNumber"</span>];</span><br><span class="line">        <span class="keyword">self</span>.shoeSize = [decoder decodeIntForKey:<span class="string">@"shoeSize"</span>];</span><br><span class="line">        <span class="keyword">self</span>.subThingies = [decoder decodeObjectForKey:<span class="string">@"subThingies"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采纳协议：序列化</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) coder</span><br><span class="line">&#123;</span><br><span class="line">    [coder encodeObject:name</span><br><span class="line">                 forKey:<span class="string">@"name"</span>];</span><br><span class="line">    [coder encodeInt:magicNumber</span><br><span class="line">              forKey:<span class="string">@"magicNumber"</span>];</span><br><span class="line">    [coder encodeFloat:shoeSize</span><br><span class="line">                forKey:<span class="string">@"shoeSize"</span>];</span><br><span class="line">    [coder encodeObject:subThingies</span><br><span class="line">                 forKey:<span class="string">@"subThingies"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@: %d/%.1f %@"</span>, name, magicNumber, shoeSize, subThingies];</span><br><span class="line">    <span class="keyword">return</span> (description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [name release];</span><br><span class="line">    [subThingies release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Thingie.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">/** 简单情形 **/</span></span><br><span class="line">        <span class="comment">// 创建可序列化的对象</span></span><br><span class="line">        Thingie *thing1;</span><br><span class="line">        thing1 = [[Thingie alloc]</span><br><span class="line">                  initWithName:<span class="string">@"thing1"</span></span><br><span class="line">                  magicNumber:<span class="number">42</span></span><br><span class="line">                  shoeSize:<span class="number">10.5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"some thing: @"</span>, thing1);</span><br><span class="line">        <span class="comment">// 序列化为 NSData 对象</span></span><br><span class="line">        <span class="built_in">NSData</span> *freezeDried;</span><br><span class="line">        freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        [thing1 release];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued thing: %@"</span>, thing1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 复杂情形：递归序列化 */</span></span><br><span class="line">        <span class="comment">// 初始化thing1.subThingies（数组）</span></span><br><span class="line">        Thingie *anotherThing;</span><br><span class="line">        anotherThing = [[[Thingle alloc]</span><br><span class="line">                         initWithName:<span class="string">@"thing2"</span></span><br><span class="line">                         magicNumber:<span class="number">23</span> shoeSize:<span class="number">13.0</span>]];</span><br><span class="line">        [thing1.subThingies addObject:anotherThing];</span><br><span class="line">        anotherThing = [[[Thingle alloc]</span><br><span class="line">                         initWithName:<span class="string">@"thing3"</span></span><br><span class="line">                         magicNumber:<span class="number">17</span> shoeSize:<span class="number">9.0</span>]];</span><br><span class="line">        [thing1.subThingies addObject:anotherThing];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued muthing: %@"</span>, thing1);</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        [freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reconstitued multiting: %@"</span>, thing1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 复杂情形：设置一处引用自己的数据，序列化和反序列化仍能正常工作 */</span></span><br><span class="line">        [thing1.subThingies addObject:thing1];</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        freezeDried = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:thing1];</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        thing1 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:freezeDried];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-小结"><a href="#17-3-小结" class="headerlink" title="17.3    小结"></a>17.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_16 UIKit简介/" itemprop="url">
                  16 UIKit简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:48+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_16 UIKit简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_16 UIKit简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Mac</code>应用程序使用的是<code>AppKit</code>框架，而<code>iOS</code>应用程序使用的是<code>UIKit</code>框架，它包含了所有的<code>UI</code>组件和构成<code>iOS</code>应用程序的资源。<br><strong>注意：</strong><code>iOS</code>和<code>OS X</code>存在以下区别</p>
<ul>
<li>没有<code>shell</code>和控制台</li>
<li>应用程序在<code>Mac</code>电脑的模拟器中运行</li>
<li>无法支持一些无<code>UI</code>界面的<code>API</code></li>
<li>大部分程序员都认为开发<code>iOS</code>应用更加轻松</li>
</ul>
<p><strong>项目创建：</strong>步骤如下</p>
<ol>
<li><code>File-&gt;New-&gt;New Project</code>(command + shift + n)</li>
<li>选择应用程序模版：左边列表选择<code>iOS</code>下的<code>Application</code>，然后右边选择<code>Single View Application</code></li>
</ol>
<ul>
<li><code>Master-Detail</code>：用一个导航控制器和一个表视图来显示项目列表遗迹项目的详细信息</li>
<li><code>OpenGL Game</code>：游戏</li>
<li><code>Page-Based</code>：创建电子书式的应用，拥有翻页动画效果（该效果支持ipad）</li>
<li><code>Tabbed</code>：多视图应用程序，底部又一个标签栏并且每个标签都有一个视图香关联的那种应用程序</li>
<li><code>Utility</code>：和<code>Single View Application</code>相似，但还多处一个翻转视图</li>
<li><code>Empty</code>：是一个高级选项，如果没有合适的模版，或是你非常了解如何构建你的应用程序，那么刻意选择使用这个模版</li>
</ul>
<ol>
<li>点击<code>Next</code>按钮，弹出询问程序名等信息的对话框</li>
</ol>
<ul>
<li>复选框：不选择<code>Use Storyboard</code>和<code>Include Unit Tests</code>，选中<code>Use Automatic Reference Counting</code></li>
<li><code>Device Family</code>：选择<code>Universal</code>（意味着可以同时运行在<code>iPhone</code>、<code>iPod</code>、<code>iPad</code>上）</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%8811.15.54.png" alt="Alt text"></p>
<p><em>AppDelegate.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">ViewController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"><span class="comment">// 视图控制器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ViewController *viewController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>AppDelegate.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> window = _window;</span><br><span class="line"><span class="keyword">@synthesize</span> viewController = _viewController;</span><br><span class="line"><span class="comment">// 窗口被创建时回被调用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">/* 初始化窗口对象 */</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始视图控制器 */</span></span><br><span class="line">    <span class="comment">// iPhone</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice] userInterfaceIdiom] == <span class="built_in">UIUserInterfaceIdiomPhone</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController_iPhone"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// iPad</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController_iPad"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将视图控制器的视图添加到应用程序层级</span></span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.viewController;</span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span></span><br><span class="line">    <span class="comment">// Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span></span><br><span class="line">    <span class="comment">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="16-1-视图控制器"><a href="#16-1-视图控制器" class="headerlink" title="16.1    视图控制器"></a>16.1    视图控制器</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>主要使用的是<code>MVC</code>模式</p>
<ul>
<li><strong>视图：</strong>从<code>nib</code>文件中获取视图</li>
<li><strong>模型：</strong>一组数据</li>
<li><strong>控制器：</strong><code>UIViewController</code>的子类</li>
</ul>
</blockquote>
<h3 id="16-1-1-在Nib文件中添加控件"><a href="#16-1-1-在Nib文件中添加控件" class="headerlink" title="16.1.1    在Nib文件中添加控件"></a>16.1.1    在Nib文件中添加控件</h3><blockquote>
<p><strong>说明：</strong>完成视图的部分</p>
<ul>
<li>拖进一个<code>TextField</code>对象</li>
<li>拖进一个<code>Label</code></li>
<li>拖进两个<code>Button</code></li>
</ul>
</blockquote>
<p><img src="./屏幕快照 2016-01-26 下午10.07.01.png" alt="Alt text"></p>
<h3 id="16-1-2-视图（Nib文件）和控制器建立连接"><a href="#16-1-2-视图（Nib文件）和控制器建立连接" class="headerlink" title="16.1.2    视图（Nib文件）和控制器建立连接"></a>16.1.2    视图（Nib文件）和控制器建立连接</h3><blockquote>
<p><strong>说明：</strong>打开辅助窗口，通过拖拽完成<code>视图</code>(<code>Nib</code>文件)和<code>控制器</code>(<code>ViewController.h</code>)之间的连接。</p>
<ol>
<li>代开辅助窗口：<code>Command+Option+Return</code>或<code>Editor</code>组中间的按钮</li>
<li>为<code>Text Field</code>和<code>Label</code>创建输出口（<code>outlet</code>）：按住<code>control</code>键，将鼠标从视图中的图像元素一直拖到<code>ViewController.h</code>相应位置<br><img src="./屏幕快照 2016-01-26 下午10.01.24 2.png" alt="Alt text"><br><img src="./屏幕快照 2016-01-26 下午10.01.30 2.png" alt="Alt text"></li>
<li>为两个按钮创建<code>操作</code>(Action)</li>
</ol>
<ul>
<li>Name：操作的名称</li>
<li>Type：操作方法参数的类型（默认为<code>id</code>）</li>
<li>Event：事件类型</li>
<li>Arguments：<code>None</code>、<code>Sender</code>和<code>Event</code>（包含一个<code>UIEvent</code>类型的参数）<br><img src="./屏幕快照 2016-01-26 下午10.23.36.png" alt="Alt text"></li>
</ul>
</blockquote>
<h3 id="16-1-3-完成代码的手动编写部分"><a href="#16-1-3-完成代码的手动编写部分" class="headerlink" title="16.1.3    完成代码的手动编写部分"></a>16.1.3    完成代码的手动编写部分</h3><blockquote>
<p><strong>说明：</strong>包括程序核心功能的实现以及一些事件的回调。</p>
</blockquote>
<p><em>ViewController.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *textField;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase;</span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ViewController.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> textField;</span><br><span class="line"><span class="keyword">@synthesize</span> resultsField;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  重写父类的便利构造器：完成视图和控制器的绑定</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"init: text %@ / result %@"</span>, textField, resultsField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  系统在nib文件加载和对象初始化完成后调用：从ios 5 不会再调用该方法了</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"awake: text %@ / result %@"</span>, textField, resultsField);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  系统在nib文件加载和对象初始化完成后调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewDidLoad: text %@ / results %@"</span>, textField, resultsField);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置输入框的placeholder(占位符)</span></span><br><span class="line">    [textField setPlaceholder:<span class="string">@"Enter text here"</span>];</span><br><span class="line">    <span class="comment">// 设置Label的默认值</span></span><br><span class="line">    resultsField.text = <span class="string">@"Result"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  视图从视图层级中移除后会调用这个方法，可以在这里做一些内存清理的事情</span><br><span class="line"> *  该方法已过时</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidUnload &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTextField:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> setResultsField:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">super</span> viewDidUnload];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图出现前调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图出现后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图消失前调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 视图消失后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *original = textField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *uppercase = [original uppercaseString];</span><br><span class="line">    resultsField.text = uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *original = textField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *lowercase = [original lowercaseString];</span><br><span class="line">    resultsField.text = lowercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-小结"><a href="#16-2-小结" class="headerlink" title="16.2    小结"></a>16.2    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_15 AppKit简介/" itemprop="url">
                  15 AppKit简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:28+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_15 AppKit简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_15 AppKit简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Application Kit</code>中包含<code>Cocoa</code>中关于用户界面的大量资源。<br><strong>注意：</strong>学习这一章节时，<code>Xcode</code>的最新版本是<code>7.2</code>，部分知识已经过时。比如目前<code>storyboard</code>已经基本取代了<code>xib</code>。</p>
</blockquote>
<h2 id="15-1-构建项目"><a href="#15-1-构建项目" class="headerlink" title="15.1    构建项目"></a>15.1    构建项目</h2><blockquote>
<p><strong>说明：</strong>下面是通过<code>Xcode</code>构建<code>Cocoa</code>应用程序项目的步骤。</p>
<ol>
<li>File-&gt;New-&gt;New Project（Create a New Xcode Project）</li>
<li>左边列表<code>Mac OS X</code>下的<code>Application</code>选项-&gt;<code>Cocoa Application</code>-&gt;Next</li>
<li>项目信息</li>
</ol>
<ul>
<li><code>Product Name</code>：应用名称</li>
<li><code>Company Identifier</code>：企业标识符，用来区分应用程序</li>
<li><code>Class Prefix</code>：伪命名空间，避免文件名冲突</li>
</ul>
<ol>
<li>复选框</li>
</ol>
<ul>
<li><code>Create Document-Based Application</code></li>
<li><code>Use Core Data</code></li>
<li><code>Include Unit Test</code></li>
<li><code>Use Automatic Reference Counting</code></li>
</ul>
</blockquote>
<h2 id="15-2-创建委托文件-interface部分"><a href="#15-2-创建委托文件-interface部分" class="headerlink" title="15.2    创建委托文件@interface部分"></a>15.2    创建委托文件<code>@interface</code>部分</h2><blockquote>
<p><strong><code>Interface Builder</code>：</strong>简称<code>IB</code>，用可视化的方式为<code>OS X</code>和<code>iOS</code>布局窗口内容，构建用户界面。<br><strong><code>IBOutlet</code>和<code>IBAction</code>：</strong>这两个关键字会经常出现在代码中，用于</p>
<ul>
<li>为<code>Interface Builder</code>提供标记</li>
<li>帮助阅读代码</li>
</ul>
</blockquote>
<h2 id="15-3-Interface-Builder"><a href="#15-3-Interface-Builder" class="headerlink" title="15.3    Interface Builder"></a>15.3    Interface Builder</h2><blockquote>
<p><strong>说明：</strong>通过<code>.xib</code>文件就可以打开<code>IB</code>的可视化编辑器。</p>
<ul>
<li><strong>nib文件：</strong>编译时，<code>.xib</code>(<code>XML</code>格式)文件会被编译为<code>nib(NeXT Interface Builder)</code>文件，它是包含了压缩对象的二进制文件，</li>
<li><strong>对象库：</strong>包含了大量可以拖入窗口的不同类型的对象。</li>
</ul>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-25%20%E4%B8%8B%E5%8D%8810.17.36.png" alt="Alt text"></p>
</blockquote>
<h2 id="15-4-设计用户界面"><a href="#15-4-设计用户界面" class="headerlink" title="15.4    设计用户界面"></a>15.4    设计用户界面</h2><blockquote>
<p><strong>说明：</strong>对用户界面进行布局</p>
<ol>
<li>拖入一个<code>Text Filed</code></li>
<li>拖入一个<code>Label</code></li>
<li>拖入一个<code>push button</code></li>
</ol>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-25%20%E4%B8%8B%E5%8D%8810.42.36.png" alt="Alt text"></p>
<h2 id="15-5-创建连接"><a href="#15-5-创建连接" class="headerlink" title="15.5    创建连接"></a>15.5    创建连接</h2><blockquote>
<p><strong>说明：</strong>将<code>代码</code>与刚创建的<code>用户界面元素</code>相连接。</p>
</blockquote>
<h3 id="15-5-1-连接输出口（IBOutlet）"><a href="#15-5-1-连接输出口（IBOutlet）" class="headerlink" title="15.5.1    连接输出口（IBOutlet）"></a>15.5.1    连接输出口（IBOutlet）</h3><blockquote>
<p><strong>说明：</strong>通过拖动自动生成界面元素对应的代码。以其中的<code>Text Field</code>为例子</p>
<ol>
<li>打开辅助编辑器</li>
<li>按住<code>Control</code>键将光标从<code>文本框</code>拖动到<code>头文件</code>中<code>@property</code>那一行的下面</li>
<li>出现<code>Insert Outlet orAction</code>提示消息时松开鼠标</li>
<li>在弹出的对话框中输入<code>textField</code>，点击<code>Connect</code></li>
</ol>
</blockquote>
<h3 id="15-5-2-连接操作（IBAction）"><a href="#15-5-2-连接操作（IBAction）" class="headerlink" title="15.5.2    连接操作（IBAction）"></a>15.5.2    连接操作（IBAction）</h3><blockquote>
<p><strong>说明：</strong>将按钮连接到操作，这样按下按钮就会触发代码。以<code>UpperCae</code>按钮为例</p>
<ol>
<li>按住<code>Control</code>键和<code>UpperCase</code>按钮</li>
<li>拖动一条直线到<code>头文件</code>的最后一行<code>@property</code>语句下</li>
<li>弹出连接对话框，选择<code>Action</code>类型</li>
<li>在Name文本框中输入<code>uppercase</code>，并点击<code>Connect</code>(自动在头文件中创建方法的声明，并在实现文件中创建方法的实现)</li>
</ol>
</blockquote>
<h2 id="15-6-应用程序委托的实现"><a href="#15-6-应用程序委托的实现" class="headerlink" title="15.6    应用程序委托的实现"></a>15.6    应用程序委托的实现</h2><blockquote>
<p><strong>说明：</strong><code>IBOutlet</code>的工作方式</p>
<ol>
<li>应用程序启动时，<code>MainMenu.nib</code>被自动加载，界面对象被创建</li>
<li>分配并初始化<code>MSCApplelegate</code>实例（<code>IBOutlet</code>的实例变量）</li>
<li>建立连接：将<code>NSTextField</code>等对象的地址添加到<code>MSCAppDelegate</code>实例变量中，然后像每个每个<code>界面对象</code>发送<code>awakeFromNib</code>消息。</li>
</ol>
</blockquote>
<p><em>MSCAppDelegate.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MSCAppDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSWindow</span> *window;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *textField;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase:(<span class="keyword">id</span>)sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase:(<span class="keyword">id</span>)sender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>MSCAppDelegate.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MSCAppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MSCAppDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> window = _window;</span><br><span class="line"><span class="keyword">@synthesize</span> textField = _textField;</span><br><span class="line"><span class="keyword">@synthesize</span> resultsField = _resultsField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="comment">// 此时还没和界面对象建立连接，因此都是 nil</span></span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"init: text %@ / results %@"</span>, _textField, _resultsField);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 对界面对象进行一些初始化工作</span><br><span class="line"> * 连接建立后会被调用</span><br><span class="line"> *  @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"awake: text %@ / results %@"</span>, _textField, _resultsField);</span><br><span class="line">	</span><br><span class="line">	[_textField setStringValue:<span class="string">@"Enter text here"</span>];</span><br><span class="line">	[_resultsField setStringValue:<span class="string">@"Results"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">NSNotification</span> *)aNotification &#123;</span><br><span class="line">    <span class="comment">// Insert code here to initialize your application</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)uppercase:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *original = [_textField stringValue];</span><br><span class="line">	<span class="built_in">NSString</span> *uppercase = [original uppercaseString];</span><br><span class="line">	[_resultsField setStringValue:uppercase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)lowercase:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *original = [_textField stringValue];</span><br><span class="line">	<span class="built_in">NSString</span> *lowercase = [original lowercaseString];</span><br><span class="line">	[_resultsField setStringValue:lowercase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="15-7-小结"><a href="#15-7-小结" class="headerlink" title="15.7    小结"></a>15.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_14 代码块和并发性/" itemprop="url">
                  14 代码块和并发行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:10+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_14 代码块和并发性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_14 代码块和并发性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="14-1-代码块"><a href="#14-1-代码块" class="headerlink" title="14.1    代码块"></a>14.1    代码块</h2><blockquote>
<p><strong>说明：</strong><code>代码块</code>是由C语言实现的，是对C语言中函数的扩展。<br><strong>支持的语言：</strong><code>Objective-C</code>、<code>C</code> 、<code>C++</code>、<code>Objective-C++</code><br><strong>用途：</strong><code>替代函数</code>或实现<code>闭包</code><br><strong>现状：</strong><code>代码块</code>在<code>Xcode</code>的<code>GCC</code>和<code>CLang</code>工具中是有效的，但它不属于<code>ANSI</code>的<code>C</code>语言标准。关于代码块的提议已经提交给C语言标准团体。</p>
</blockquote>
<h3 id="14-1-1-代码块和函数指针"><a href="#14-1-1-代码块和函数指针" class="headerlink" title="14.1.1    代码块和函数指针"></a>14.1.1    代码块和函数指针</h3><blockquote>
<p><strong>说明：</strong><code>代码块</code>的语法借鉴了<code>函数指针</code></p>
<ul>
<li><strong>返回类型</strong>可以手动声明也可以由编译器通过代码块推导</li>
<li>具有指定类型的<strong>参数</strong>列表</li>
<li>拥有<strong>名称</strong></li>
<li>代码放在<code>{}</code>中</li>
</ul>
<p><strong>语法：</strong><code>&lt;returntype&gt; (^blockname)(list of arguments) = ^(arguments){body;}</code><br><em>实现部分推导出返回值类型</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现部分省略了返回值类型，没有参数列表</span></span><br><span class="line"><span class="keyword">void</span> (^theBlock)() = ^&#123;</span><br><span class="line">	printf(<span class="string">"Hello Blocks!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定义并实现代码块 square_block</span><br><span class="line">* 计算乘方</span><br><span class="line">* @param &#123;int&#125; number 数值</span><br><span class="line">* @return &#123;int&#125; number 乘方结果</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> (^square_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="keyword">return</span> (number * number);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="keyword">int</span> result = square_block(<span class="number">5</span>);</span><br><span class="line">printf(<span class="string">"Result = %d\n"</span>, result);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-1-通过代码块名调用代码块"><a href="#14-1-1-1-通过代码块名调用代码块" class="headerlink" title="14.1.1.1    通过代码块名调用代码块"></a>14.1.1.1    通过代码块名调用代码块</h4><blockquote>
<p><strong>说明：</strong>可以像调用<code>函数</code>一样调用<code>代码块</code>。<br><strong>比函数强大：</strong>代码块可以访问与它相同的有效范围内声明的变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化变量：声明时的作用域和代码块相同</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">int</span> (^multiply_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="comment">// 访问外部同作用域声明的变量</span></span><br><span class="line">	<span class="keyword">return</span> (value * number);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-2-直接调用代码块（匿名）"><a href="#14-1-1-2-直接调用代码块（匿名）" class="headerlink" title="14.1.1.2    直接调用代码块（匿名）"></a>14.1.1.2    直接调用代码块（匿名）</h4><blockquote>
<p><strong>说明：</strong>使用代码块时通常不需要创建一个代码块变量，而是在代码中内联代码块的内容。<br><strong>使用场景：</strong>作为参数传递给方法或函数</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Amir"</span>, <span class="string">@"Mishal"</span>, <span class="string">@"Irrum"</span>, <span class="string">@"Adam"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Unsorted Array %@"</span>, array);</span><br><span class="line"><span class="comment">// 传递匿名代码块</span></span><br><span class="line"><span class="built_in">NSArray</span> *soredArray = [array sortedArrayUsingComparator: ^(<span class="built_in">NSString</span> *object1, <span class="built_in">NSString</span> *object2)] &#123;</span><br><span class="line">	<span class="keyword">return</span> [object1 compare: object2];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Sorted Array %@"</span>, sortedArray);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-3-使用typedef关键字"><a href="#14-1-1-3-使用typedef关键字" class="headerlink" title="14.1.1.3    使用typedef关键字"></a>14.1.1.3    使用<code>typedef</code>关键字</h4><blockquote>
<p><strong>说明：</strong>将<code>代码块</code>声明定义为一种类型，更易于代码的编写。<br><strong>语法：</strong><code>typedef 代码块定义;</code><br><strong>注意：</strong><code>typedef</code>后面的<code>代码块</code>定义中的代码块名不再具备<code>代码块名</code>的功能，而是一种类型名。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将代码块定义为一种类型： MKSampleMultiply2BlockRef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 使用新类型创建代码块</span></span><br><span class="line"><span class="built_in">MKSampleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line">printf(<span class="string">"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-4-代码块和变量"><a href="#14-1-1-4-代码块和变量" class="headerlink" title="14.1.1.4    代码块和变量"></a>14.1.1.4    代码块和变量</h4><blockquote>
<p><strong>说明：</strong>代码块被声明后会捕捉到创建时的上下文中的变量或函数。</p>
<ul>
<li>全局变量（包括在封闭范围内声明的本地静态变量）</li>
<li>全局函数</li>
<li>封闭范围内的参数</li>
<li><code>Objective-C</code>的实例变量</li>
<li>代码块内部的本地变量</li>
</ul>
</blockquote>
<h5 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h5><blockquote>
<p><strong>说明：</strong>与代码块在同一范围内声明的变量。<br><strong>捕获情况：</strong>代码块会在定义时把本地变量当作<code>常量</code>复制并保存它们的状态。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiplyBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 本地变量</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 声明并实现代码块，复制并保存状态</span></span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	reutrn a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改本地变量</span></span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">b = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote>
<p><strong>说明：</strong>可以根据需要将变量标记为<code>静态的（全局的）</code>。<br><strong>捕获情况：</strong>同本地变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">MKSimpleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h5><blockquote>
<p><strong>说明：</strong>代码块中的参数变量与函数中的参数变量具有相同的作用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 声明并实现代码块</span></span><br><span class="line"><span class="built_in">MKSimpleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h5 id="block变量"><a href="#block变量" class="headerlink" title="_block变量"></a>_block变量</h5><blockquote>
<p><strong>关键字：</strong><code>_block</code><br><strong>说明：</strong><code>本地变量</code>会被<code>代码块</code>当作<code>常量</code>获取到，如果想要修改它们的值，必须通过<code>_black</code>将它们声明为<code>可修改</code>的。<br><strong>限制：</strong>由两种情况不能使用<code>_block</code>修饰</p>
<ul>
<li>长度可变数组</li>
<li>包含长度可变数组的结构体</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用_block 修饰，使变量 c 在代码块中的副本可修改</span></span><br><span class="line">_block <span class="keyword">double</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">	c = a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="代码块内部的本地变量"><a href="#代码块内部的本地变量" class="headerlink" title="代码块内部的本地变量"></a>代码块内部的本地变量</h5><blockquote>
<p><strong>说明：</strong>对<code>代码块来说</code>，和<code>本地变量</code>一样使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">void</span> (^<span class="built_in">MKSampleBlockRef</span>)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, a * c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">MKSimpleBlockRef</span>();</span><br></pre></td></tr></table></figure>
<h3 id="14-1-2-Objective-C代码块内存管理"><a href="#14-1-2-Objective-C代码块内存管理" class="headerlink" title="14.1.2    Objective-C代码块内存管理"></a>14.1.2    Objective-C代码块内存管理</h3><blockquote>
<p><strong>说明：</strong>代码块是对象，所以可以向它发送任何与内存管理由关的信息。</p>
<ul>
<li>如果引用了一个<code>Objective-C</code>对象，必须要<code>保留</code>它</li>
<li>如果类的方法中的<code>代码块</code>通过引用访问了一个实例变量，要<code>保留</code>一次<code>self</code>（执行所在方法的对象）</li>
<li>如果通过数值访问了一个实例变量，变量需要<code>保留</code></li>
</ul>
</blockquote>
<p><em>ProcessString.h：方法中包含代码块的类</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProcessStrings</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ProcessString.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProcessStrings</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> theString = _theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 代码块1</span></span><br><span class="line">    <span class="built_in">NSString</span> *string1 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则2：直接通过引用（实例变量名）访问了实例变量，若没有ARC则应该保留self</span></span><br><span class="line">        <span class="keyword">return</span> [_theString stringByAppendingString:_theString];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *localObject = _theString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块2</span></span><br><span class="line">    <span class="built_in">NSString</span> *string2 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则3: 通过中间变量间接访问了实例变量，如果没有ARC则要保留localObject</span></span><br><span class="line">        <span class="keyword">return</span> [localObject stringByAppendingString:localObject];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessStrings *myStringProcessor = [[ProcessStrings alloc] init];</span><br><span class="line">        myStringProcessor.theString = <span class="string">@"Hello Objective Blocks!"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用对象中包含代码块的方法</span></span><br><span class="line">        [myStringProcessor testMyString];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>在C语言中，必须使用<code>Block_copy()</code>和<code>Block_release()</code>函数来适当地管理内存。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^<span class="built_in">MKSampleVoidBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block1 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block1"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block1();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block2 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block2"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block2();</span><br><span class="line">        Block_release(block2);</span><br><span class="line">        </span><br><span class="line">        block2 = Block_copy(block1);</span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-2-并发性"><a href="#14-2-并发性" class="headerlink" title="14.2    并发性"></a>14.2    并发性</h2><blockquote>
<p><strong>说明：</strong>能够在同一时间执行多个任务的程序称为<code>并发的(concurrent)</code>程序。苹果公司提供了多种可以利用多核特性的<code>API</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关技术选择</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSIX线程</td>
<td>利用并发行最基础的方法是使用<code>POSIX</code>线程来处理程序的不同部分使其能够独立运行。<code>POSIX线程</code>拥有支持<code>C</code>和<code>Objective-C</code>的API。</td>
<td>因为线程是级别较低的API，必须手动管理，挑战很大</td>
</tr>
<tr>
<td>GDC(Grand Central Dipatch)</td>
<td>运行在系统级别，减少了不少线程管理的麻烦</td>
<td>可以平衡应用程序所有内同的家在，从而提高计算机或设备的运行效率</td>
</tr>
</tbody>
</table>
<h3 id="14-2-1-同步"><a href="#14-2-1-同步" class="headerlink" title="14.2.1    同步"></a>14.2.1    同步</h3><blockquote>
<p><strong>关键字：</strong><code>@synchronized</code><br><strong>说明：</strong>用来设置<code>临界区</code>，确保多个线程不会在同一时间进入<code>临界区</code>。<br><strong>相关：</strong><code>@property</code>指令的<code>atomic</code>特性会让编译器通过插入<code>@synchronize(mutex, atomic)</code>生成强制彼此互斥的<code>getter</code>和<code>setter</code>方法（降低了代码性能），而<code>nonatomic</code>特性（默认）则不会。</p>
</blockquote>
<h4 id="14-2-1-1-选择性能"><a href="#14-2-1-1-选择性能" class="headerlink" title="14.2.1.1    选择性能"></a>14.2.1.1    选择性能</h4><blockquote>
<p><strong>说明：</strong><code>NSObject</code>提供了一些可以使代码在后台以较低性能运行的方法（方法名带有<code>performSelector</code>前缀）</p>
</blockquote>
<h5 id="performSelectorInBackground实例方法"><a href="#performSelectorInBackground实例方法" class="headerlink" title="performSelectorInBackground实例方法"></a>performSelectorInBackground实例方法</h5><blockquote>
<p><strong>说明：</strong>通过创建一个线程，在后端运行一个指定的方法。<br><strong>限制：</strong>指定运行的方法（第一个参数）要遵从以下限制</p>
<ul>
<li>方法中需要<code>@autoreleasepool</code></li>
<li>方法不能有返回值，参数最多一个且必须为<code>id</code>类型</li>
</ul>
<ol>
<li><code>- (void) myMethod;</code></li>
<li><code>- (void) myMethod:(id)myObject;</code></li>
</ol>
<p><strong>原型：</strong><code>NSObject</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;SEL&#125; 希望在后台运行的方法</span><br><span class="line">* @param &#123;id&#125; object 可以传递一个对象</span><br><span class="line">*/</span></span><br><span class="line">(<span class="keyword">void</span>) performSelectorInBackground:(nonnull SEL) withObject:(nullable <span class="keyword">id</span>)&gt;</span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SelectorTester</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SelectorTester.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SelectorTester</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  封装对性能选择器的调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors &#123;</span><br><span class="line">    <span class="comment">// 在后端运行不带参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod1) withObject:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 在后端运行带一个参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod2:) withObject:<span class="string">@"Hello Selector"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Done performing selectors"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：不带参数</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod1 &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：只有一个参数</span><br><span class="line"> *  @param &#123;id&#125; object 一个对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod2: (<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod2 %@"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="14-2-1-2-调度队列"><a href="#14-2-1-2-调度队列" class="headerlink" title="14.2.1.2    调度队列"></a>14.2.1.2    调度队列</h4><blockquote>
<p><strong>说明：</strong><code>GDC</code>可以使用<code>调度队列（dispatch queue）</code>，共有3种。</p>
</blockquote>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>说明</th>
<th>并行／串行</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>连续队列</td>
<td>根据指派的顺序执行任务</td>
<td>串行，先入先出（FIFO，栈）</td>
<td>可以创建多个<code>连续</code>队列，彼此并行</td>
</tr>
<tr>
<td>并发队列</td>
<td>并发执行一个或多个任务</td>
<td>并行，根据指派到队列的顺序开始执行</td>
<td>无法创建，只能从系统提供的并发队列中选择（一共3个）</td>
</tr>
<tr>
<td>主队列</td>
<td>应用程序的有效的主队列</td>
<td>主线程只有一个，无所谓串/并行</td>
<td>执行的应用程序的主线程任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>调度队列数据类型：</strong><code>dispatch_queue_t</code></p>
</blockquote>
<h5 id="连续队列"><a href="#连续队列" class="headerlink" title="连续队列"></a>连续队列</h5><blockquote>
<p><strong>说明：</strong>只要任务是异步提交的，队列会确保任务根据预定顺序执行，不会发生死锁。<br><strong>适用：</strong>一连串的任务需要按照一定的顺序执行的场景</p>
</blockquote>
<h6 id="dispatch-queue-create全局方法"><a href="#dispatch-queue-create全局方法" class="headerlink" title="dispatch_queue_create全局方法"></a>dispatch_queue_create全局方法</h6><blockquote>
<p><strong>说明：</strong>创建连续队列<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;const char *&#125; label 队列的名称</span><br><span class="line">* @param &#123;dispatch_queue_attr_t&#125; attr 队列的特性（可以为NULL）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明连续队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_serial_queue;</span><br><span class="line"><span class="comment">// 创建连续队列</span></span><br><span class="line">my_serial_queue = dispatch_queue_create(<span class="string">"com.apress.MySerialQueue1"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h5 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h5><blockquote>
<p><strong>说明：</strong>并发调度队列适用于那些可以并行运行的任务</p>
<ul>
<li>开始执行时间遵从FIFO</li>
<li>任务可以在前一个任务结束前就开始执行</li>
<li>一次所运行的任务数量是无法预测的（根据其它运行的任务的状况）</li>
</ul>
<p><strong>技巧：</strong>如果需要确保每次运行的任务的数量都是一样的，可以通过线程<code>API</code>来手动管理线程。</p>
</blockquote>
<h6 id="dispatch-get-global-queue全局方法"><a href="#dispatch-get-global-queue全局方法" class="headerlink" title="dispatch_get_global_queue全局方法"></a>dispatch_get_global_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取系统的并发队列。<br><strong>原型：</strong><code>/usr/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long&#125; identifier 优先级选项</span><br><span class="line">* @param &#123;unsigned long&#125; flags 标记（可以为0）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">long</span> identifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_global_queue;</span><br><span class="line"><span class="comment">// 获取并发队列（默认优先级）</span></span><br><span class="line">my_global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h5><h6 id="dispatch-get-current-queue全局方法"><a href="#dispatch-get-current-queue全局方法" class="headerlink" title="dispatch_get_current_queue全局方法"></a>dispatch_get_current_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取<code>当前运行的</code>队列代码块，如果在代码块的对象之外调用了这个函数，则它会返回<code>主队列</code>。<br><strong>注意：</strong>该方法在从<code>OS X 10.9</code>和<code>ios 6</code>开始被废弃，因为GCD队列本身是不可重入的，同步阻塞会导致死锁。<br><strong>用途：</strong>仍然可以作为调试手段在代码中使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程或当前队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> theQueue = dispatch_get_current_queue();</span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-队列也要内存管理"><a href="#14-2-2-队列也要内存管理" class="headerlink" title="14.2.2    队列也要内存管理"></a>14.2.2    队列也要内存管理</h3><blockquote>
<p><strong>说明：</strong><code>调度队列</code>是引用计数对象，可以使用<code>dispatch_retain()</code>和<code>dispatch_release()</code>来修改队列的保留计数器的值。</p>
</blockquote>
<h4 id="14-2-2-1-队列的上下文"><a href="#14-2-2-1-队列的上下文" class="headerlink" title="14.2.2.1    队列的上下文"></a>14.2.2.1    队列的上下文</h4><blockquote>
<p><strong>说明：</strong>可以向<code>调度对象（包括调度队列）</code>指派<code>全局数据上下文</code>，可以在上下文中指派任意类型的数据，比如<code>Objective-C</code>对象或指针。<br><strong>内存管理：</strong>必须在需要<code>队列上下文</code>的时候分配内存并在队列销毁之前进行清理。</p>
</blockquote>
<h5 id="dispatch-set-context全局方法"><a href="#dispatch-set-context全局方法" class="headerlink" title="dispatch_set_context全局方法"></a>dispatch_set_context全局方法</h5><blockquote>
<p><strong>说明：</strong>为指定队列设置<code>全局上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_set_context(dispatch_object_t object, <span class="keyword">void</span> *context);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-get-context全局方法"><a href="#dispatch-get-context全局方法" class="headerlink" title="dispatch_get_context全局方法"></a>dispatch_get_context全局方法</h5><blockquote>
<p><strong>说明：</strong>获得<code>调度队列</code>的<code>全局数据上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @return &#123;void *&#125; 全局数据上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> * dispatch_get_context(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可变字典（作为全局数据上下文）</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *myContext = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 为全局上下文添加队列需要的数据</span></span><br><span class="line">[myContext setObject:<span class="string">@"My Context"</span> forKey:<span class="string">@"title"</span>];</span><br><span class="line">[myContext setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>] forKey:<span class="string">@"value"</span>];</span><br><span class="line"><span class="comment">// 为连续队列 my_serial_queue 设置全局数据上下文</span></span><br><span class="line">dispatch_set_context(my_serial_queue, (__bridge_retained <span class="keyword">void</span> *)myContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取全局数据上下文(桥接转换__bridge，告诉ARC不想自己来管理上下文的内存)</span></span><br><span class="line">myContext = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-2-全局数据上下文内存管理"><a href="#14-2-2-2-全局数据上下文内存管理" class="headerlink" title="14.2.2.2    全局数据上下文内存管理"></a>14.2.2.2    全局数据上下文内存管理</h4><blockquote>
<p><strong>说明：</strong>编写一个<code>终结器(finalizer)</code>函数，在<code>dealloc</code>中调用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 终结器函数</span><br><span class="line">* @param &#123;void *&#125; context 全局数据上下文对象</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> myFinalizerFunction(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"myFinalizerFunction"</span>);</span><br><span class="line">	<span class="comment">// 桥接转换：将全局数据上下文对象桥接转换为具体类型</span></span><br><span class="line">	<span class="comment">// 其中，__bridge_transfer 将拥有权限转移到了本函数中，意味着该对象的内存管理由全局释放池换成了我们的函数</span></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *theData = (__bridge_transfer <span class="built_in">NSMutableDictionary</span>*)context;</span><br><span class="line">	<span class="comment">// 清空作为全局数据上下文的对象</span></span><br><span class="line">	[theData removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-向调度队列添加任务"><a href="#14-2-2-3-向调度队列添加任务" class="headerlink" title="14.2.2.3    向调度队列添加任务"></a>14.2.2.3    向调度队列添加任务</h4><blockquote>
<p><strong>说明：</strong>有两种方式可以向队列中添加任务，每种方式针对<code>代码块</code>和<code>函数</code>各有一个调度函数（共4个）</p>
<ul>
<li><strong>同步：</strong>队列会一直等待前面任务结束</li>
<li><strong>异步：</strong>添加任务后，不必等待任务，函数会立刻返回（推荐，因为不会阻塞其他代码的运行）</li>
</ul>
</blockquote>
<p>|<em>**</em>|同步|异步|<br>|代码块|<code>dispatch_sync</code>|<code>dispatch_async</code>|<br>|函数|<code>dispatch_sync_f</code>|<code>dispatch_async_f</code>|</p>
<h5 id="dispatch-sync全局函数"><a href="#dispatch-sync全局函数" class="headerlink" title="dispatch_sync全局函数"></a>dispatch_sync全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async全局函数"><a href="#dispatch-async全局函数" class="headerlink" title="dispatch_async全局函数"></a>dispatch_async全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步添加代码块：内联方式</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步添加代码块：非内联</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^dispatch_block_t)(<span class="keyword">void</span>);</span><br><span class="line">dispatch_block_t myBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"My Prefined block"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, myBlock);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-sync-f全局函数"><a href="#dispatch-sync-f全局函数" class="headerlink" title="dispatch_sync_f全局函数"></a>dispatch_sync_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async-f全局函数"><a href="#dispatch-async-f全局函数" class="headerlink" title="dispatch_async_f全局函数"></a>dispatch_async_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义好要添加到队列的函数</span></span><br><span class="line"><span class="keyword">void</span> myDispatchFunction (<span class="keyword">void</span> *argument) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task %@"</span>, (__bridge <span class="built_in">NSNumber</span> *)argument);</span><br><span class="line">    <span class="comment">// 获得当前队列的全局数据上下文</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *context = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(dispatch_get_current_queue());</span><br><span class="line">    <span class="comment">// 在字典中索引</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *value = [context objectForKey:<span class="string">@"value"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步向队列中添加函数</span></span><br><span class="line">dispatch_async_f(my_serial_queue, (__bridge <span class="keyword">void</span> *)[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>], (dispatch_function_t)myDispatchFunction);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-调度队列的暂停和重启"><a href="#14-2-2-3-调度队列的暂停和重启" class="headerlink" title="14.2.2.3    调度队列的暂停和重启"></a>14.2.2.3    调度队列的暂停和重启</h4><h5 id="dispatch-suspend全局方法"><a href="#dispatch-suspend全局方法" class="headerlink" title="dispatch_suspend全局方法"></a>dispatch_suspend全局方法</h5><blockquote>
<p><strong>说明：</strong>暂停队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_suspend(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-resume全局方法"><a href="#dispatch-resume全局方法" class="headerlink" title="dispatch_resume全局方法"></a>dispatch_resume全局方法</h5><blockquote>
<p><strong>说明：</strong>重启队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_resume(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停队列</span></span><br><span class="line">dispatch_suspend(my_serial_queue);</span><br><span class="line"><span class="comment">// 重启队列</span></span><br><span class="line">dispatch_resume(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-操作队列"><a href="#14-2-3-操作队列" class="headerlink" title="14.2.3    操作队列"></a>14.2.3    操作队列</h3><blockquote>
<p><strong>说明：</strong>有一些称为<code>操作（operation）</code>的<code>API</code>，可以让队列使用起来更加简单。</p>
<ol>
<li>创建一个<code>操作</code>对象</li>
<li>将其指派给<code>操作队列</code></li>
<li><code>操作</code>被队列执行</li>
</ol>
</blockquote>
<h4 id="操作的创建方式"><a href="#操作的创建方式" class="headerlink" title="操作的创建方式"></a><code>操作</code>的创建方式</h4><blockquote>
<p><strong>说明：</strong>一共有3种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用操作（<code>NSInvocationOperation</code>）</td>
<td>前提是已经拥有一个可以完成工作的类，并且想在队列上执行</td>
</tr>
<tr>
<td>代码块操作（<code>NSBlockOperation</code>）</td>
<td>类似包含了要执行代码块的<code>dispatch_async</code>函数</td>
</tr>
<tr>
<td>自定义的<code>操作</code></td>
<td>通过继承<code>NSOperation</code>定义自己的<code>操作</code></td>
</tr>
</tbody>
</table>
<h5 id="方式一：创建调用操作"><a href="#方式一：创建调用操作" class="headerlink" title="方式一：创建调用操作"></a>方式一：创建<code>调用操作</code></h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyCustomClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span> *)operationWithData: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget: <span class="keyword">self</span> selectorL <span class="keyword">@selector</span>(myWorkerMethod:)object:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做具体工作的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)myWorkerMethod: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"My Worker Method %@"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="方式二：创建代码块操作"><a href="#方式二：创建代码块操作" class="headerlink" title="方式二：创建代码块操作"></a>方式二：创建<code>代码块操作</code></h5><blockquote>
<p><strong>说明：</strong>创建时作为参数的<code>代码块</code>的类型和在<code>调度队列</code>中使用的相同。</p>
<ul>
<li>一旦创建了第一个<code>代码块操作</code>，便可以通过<code>addExecutionBlock</code>方法继续添加更多的<code>代码块</code></li>
<li>根据<code>队列</code>的类型，代码块会分别以连续或并行的方式运行</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock: ^ &#123;</span><br><span class="line">	<span class="comment">// 具体工作内容</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过代码块操作，继续添加代码块</span></span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">	<span class="comment">// 更多要做工作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="向队列中添加操作"><a href="#向队列中添加操作" class="headerlink" title="向队列中添加操作"></a>向队列中添加操作</h4><blockquote>
<p><strong>说明：</strong>可以使用<code>NSOperationQueue</code>来取代之前使用的<code>dispatch_queue</code>函数，特点如下</p>
<ul>
<li>并发执行<code>操作</code></li>
<li>具有<code>相关性</code>，也就是说，如果某个<code>操作</code>是基于其它<code>操作</code>的，则也会先被执行</li>
</ul>
<p><strong>技巧：</strong>如果要确保添加的<code>操作</code>是连续执行（串行）的，可以设置最大并发操作数为1，这样会按照<code>先入先出</code>的规范执行</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *currentQueue = [<span class="built_in">NSOperation</span> currentQueue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line">[theQueue addOperation:blockOperation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加代码块替代操作对象</span></span><br><span class="line">[theQueue addOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"my work"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="14-3-小结"><a href="#14-3-小结" class="headerlink" title="14.3    小结"></a>14.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_13 协议/" itemprop="url">
                  13 协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:50+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_13 协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_13 协议/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="13-1-正式协议"><a href="#13-1-正式协议" class="headerlink" title="13.1    正式协议"></a>13.1    正式协议</h2><blockquote>
<p><strong>说明：</strong>正式协议类似<code>Java</code>的接口。</p>
<ul>
<li><strong>声明协议：</strong>通过<code>@protocol</code>创建协议的声明。</li>
<li><strong>采用协议：</strong>在类的<code>@interface</code>声明中列出协议的名称。</li>
<li><strong>遵守协议：</strong>在类的<code>@implementation</code>中实现协议的所有方法（否则编译器会生成警告）。</li>
</ul>
</blockquote>
<h3 id="13-1-1-声明协议"><a href="#13-1-1-声明协议" class="headerlink" title="13.1.1    声明协议"></a>13.1.1    声明协议</h3><blockquote>
<p><strong>说明：</strong>类似类或类别的声明</p>
<ul>
<li>可以继承父协议，类似继承父类</li>
<li>内部是方法声明列表</li>
<li>在协议中不会引入新的实例变量</li>
</ul>
<p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> 协议名 &lt;父协议名</span></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="Cocoa的NSCopying协议"><a href="#Cocoa的NSCopying协议" class="headerlink" title="Cocoa的NSCopying协议"></a>Cocoa的<code>NSCopying</code>协议</h4><blockquote>
<p><strong>说明：</strong>如果采用了该协议，对象就会知道如何创建自己的副本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCopying</span></span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone: (<span class="built_in">NSZone</span> *) zone;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="Cocoa的NSCoding协议"><a href="#Cocoa的NSCoding协议" class="headerlink" title="Cocoa的NSCoding协议"></a>Cocoa的<code>NSCoding</code>协议</h4><blockquote>
<p><strong>说明：</strong>能够对自身进行编码和解码</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCoding</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 接收对象的实例变量并将其转换为NSCoder类的对象</span><br><span class="line">*</span><br><span class="line">* @param &#123;NSCoder *&#125; encoder</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) encodeWithCoder: (<span class="built_in">NSCoder</span> *) encoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 从NSCoder对象中提取经过转换雪藏的实例变量，并使用它们去初始化新的对象</span><br><span class="line">*</span><br><span class="line">* @param &#123;NSCoder *&#125; decoder</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithCoder: (<span class="built_in">NSCoder</span> *) decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-采用协议"><a href="#13-1-2-采用协议" class="headerlink" title="13.1.2    采用协议"></a>13.1.2    采用协议</h3><blockquote>
<p><strong>说明：</strong>要采用某个协议，可以在类的声明中列出该协议的名称，并用<code>&lt;&gt;</code>括起来<br><strong>语法：</strong>可以同时实现多个协议，中间用<code>,</code>分隔</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 类名: 父类明 &lt;协议1, 协议2, ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守协议实现的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span>: <span class="title">NSObject</span> &lt;<span class="title">NSCoping</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 实例变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守协议实现的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-实现协议"><a href="#13-1-3-实现协议" class="headerlink" title="13.1.3    实现协议"></a>13.1.3    实现协议</h3><h2 id="13-2-复制"><a href="#13-2-复制" class="headerlink" title="13.2    复制"></a>13.2    复制</h2><blockquote>
<p><strong>说明：</strong>复制分为两类，<code>浅层复制（shallow copy）</code>和<code>深层复制（deep copy）</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>复制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浅层复制</td>
<td>只会复制指向引用对象的指针</td>
</tr>
<tr>
<td>深层复制</td>
<td>将复制引用的对象</td>
</tr>
</tbody>
</table>
<h3 id="13-2-1-复制-Engine"><a href="#13-2-1-复制-Engine" class="headerlink" title="13.2.1    复制 Engine"></a>13.2.1    复制 Engine</h3><blockquote>
<p><strong>说明：</strong>没有实例变量或属性。</p>
</blockquote>
<p><em>Engine.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  采纳 NSCopying 协议</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Engine</span></span><br></pre></td></tr></table></figure>
<p><em>Engine.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  遵守协议，实现复制自身的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param zone 内存区域</span><br><span class="line"> *</span><br><span class="line"> *  @return &#123;id&#125; 复制的对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Engine *engineCopy;</span><br><span class="line">    <span class="comment">// 创建一个当前类（Engine或其子类）创建一个新对象</span></span><br><span class="line">    engineCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] init];</span><br><span class="line">    <span class="keyword">return</span> engineCopy;</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-2-复制-Tire"><a href="#13-2-2-复制-Tire" class="headerlink" title="13.2.2    复制 Tire"></a>13.2.2    复制 Tire</h3><blockquote>
<p><strong>说明：</strong>有属性，要考虑实例变量（包括子类的）的复制，需要选择合适的构造函数或者使用<code>setter</code>修改对象的属性。<br><strong>扩展：</strong>可以使用<code>C</code>语言风格的<code>指针运算符</code>直接访问实例变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">tireCopy-&gt;pressure = presssure;</span><br><span class="line">tireCopy-&gt;treadDepth = treadDepth;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>一般来说，当设置属性不太可能涉及额外工作时，我们尽量使用init方法和访问器方法。</p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> pressure;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> treadDepth;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure:(<span class="keyword">float</span>)pressure treadDepth:(<span class="keyword">float</span>)treadDepth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  遵守协议，实现复制自身的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param zone 内存区域</span><br><span class="line"> *</span><br><span class="line"> *  @return 复制的对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Tire *tireCopy;</span><br><span class="line">    <span class="comment">// 调用便利构造器创建对象（属性相同）</span></span><br><span class="line">    tireCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] initWithPressure:<span class="keyword">self</span>.pressure treadDepth:<span class="keyword">self</span>.treadDepth];</span><br><span class="line">    <span class="keyword">return</span> (tireCopy);</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-3-复制-Car"><a href="#13-2-3-复制-Car" class="headerlink" title="13.2.3    复制 Car"></a>13.2.3    复制 Car</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Car *carCopy;</span><br><span class="line">    <span class="comment">// 创建车身</span></span><br><span class="line">    carCopy = [[[<span class="keyword">self</span> class] allocWithZone:zone] init];</span><br><span class="line">    <span class="comment">// 基本设置</span></span><br><span class="line">    carCopy.name = <span class="keyword">self</span>.name;</span><br><span class="line">    Engine *engineCopy;</span><br><span class="line">    engineCopy = [engine <span class="keyword">copy</span>];</span><br><span class="line">    carCopy.engine = engineCopy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Tire *tireCopy;</span><br><span class="line">        tireCopy = [[<span class="keyword">self</span> tireAtIndex:i] <span class="keyword">copy</span>];</span><br><span class="line">        [carCopy setTire:tireCopy atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (carCopy);</span><br><span class="line">&#125;<span class="comment">// copyWithZone</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-4-协议和数据"><a href="#13-2-4-协议和数据" class="headerlink" title="13.2.4    协议和数据"></a>13.2.4    协议和数据</h3><blockquote>
<p><strong>说明：</strong>可以在实例变量和方法参数的后面添加<code>&lt;协议名&gt;</code>来对对象是够遵守协议进行类型检查。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求 object 遵守 NSCopying 协议,否则编译器会给出警告</span></span><br><span class="line">- (<span class="keyword">void</span>) setObjectValue: (<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;) object;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-Objective-C-2-0-的新特性"><a href="#13-3-Objective-C-2-0-的新特性" class="headerlink" title="13.3    Objective-C 2.0 的新特性"></a>13.3    Objective-C 2.0 的新特性</h2><blockquote>
<p><strong>说明：</strong><code>Objective-C 2.0</code>中增加了两个新的协议修饰符：<code>@optional</code>和<code>@required</code>，用来取代<code>非正式协议</code></p>
<ul>
<li><code>@optional</code>：后面的方法声明列表可以实现也可以不实现</li>
<li><code>@required</code>后面的方法列表中的方法必须被实现</li>
</ul>
<p><strong>优点(相比非正式协议)：</strong>可以用来在类声明中明确表达我们的意图。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">@proptocol BaseballPlayer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line">- (<span class="keyword">void</span>) drawHugeSalary;</span><br><span class="line"><span class="comment">// 可以实现</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>) slideeHome;</span><br><span class="line">- (<span class="keyword">void</span>) catchBall;</span><br><span class="line">- (<span class="keyword">void</span>) throwBall;</span><br><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>) swingBat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h2 id="13-4-委托方法"><a href="#13-4-委托方法" class="headerlink" title="13.4    委托方法"></a>13.4    委托方法</h2><blockquote>
<p><strong>说明：</strong><code>委托</code>是一个经常与<code>协议</code>共用的特性。<br><strong>举例：</strong><code>管理者</code>将部分具体工作委托给<code>工作人员</code>完成，<code>工作人员类</code>采纳了指定<code>协议</code>。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-22%20%E4%B8%8B%E5%8D%886.19.00.png" alt="Alt text"></p>
</blockquote>
<p><em>WorkerProtocol.h：工作人员类采纳的协议</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WorkerProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomeOptionalWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Worker1.h + Worker1.m</em> </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"><span class="comment">// 采纳了协议 WorkerProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Worker1</span> : <span class="title">NSObject</span> &lt;<span class="title">WorkerProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Worker1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Worker1</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker1 doing required work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Worker2.h + Worker2.m</em> </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"><span class="comment">// 采纳了协议 WorkerProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Worker2</span> : <span class="title">NSObject</span> &lt;<span class="title">WorkerProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Worker2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Worker2</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeRequiredWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker2 doing required work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomeOptionalWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Worker2 doing optional work."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Manager.h + Manager.m：管理者（会委托部分工作给设置的委托对象）</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WorkerProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Manager</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">id</span> &lt;WorkerProtocol&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doWork;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Manager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有方法</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Manager</span> ()</span></span><br><span class="line">- (<span class="keyword">void</span>)myWork;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doWork</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用委托对象完成必要工作</span></span><br><span class="line">    [delegate doSomeRequiredWork];</span><br><span class="line">    <span class="comment">// 检查是否有额外工作，有则做</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">YES</span> == [delegate respondsToSelector:<span class="keyword">@selector</span>(doSomeOptionalWork)])</span><br><span class="line">    &#123;</span><br><span class="line">        [delegate doSomeOptionalWork];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行自己的私有方法</span></span><br><span class="line">    [<span class="keyword">self</span> myWork];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myWork &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I am a manager and I am working"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Manager.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Worker1.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Worker2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 管理者</span></span><br><span class="line">        Manager *manager = [[Manager alloc] init];</span><br><span class="line">        <span class="comment">// 委托对象</span></span><br><span class="line">        Worker1 *worker1 = [[Worker1 alloc] init];</span><br><span class="line">        <span class="comment">// 为管理者设置委托对象</span></span><br><span class="line">        manager.delegate = worker1;</span><br><span class="line">        <span class="comment">// 工作（内部委托 worker1 工作）</span></span><br><span class="line">        [manager doWork];</span><br><span class="line">        </span><br><span class="line">        Worker2 *worker2 = [[Worker2 alloc] init];</span><br><span class="line">        manager.delegate = worker2;</span><br><span class="line">        [manager doWork];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-小结"><a href="#13-5-小结" class="headerlink" title="13.5    小结"></a>13.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_12 类别/" itemprop="url">
                  12 类别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:26+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_12 类别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_12 类别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>利用<code>Objective-C</code>的动态运行时分配机制，你可以为现有的类添加<code>方法</code>或<code>计算属性</code>，这种机制称为<code>类别(category)</code>。</p>
<ul>
<li>可以在类中添加属性（<code>@property</code>），且只能是<code>计算属性</code>（不能添加<code>实例变量</code>）</li>
<li>可以向一个<code>类</code>添加任意数量的<code>类别</code></li>
<li><code>类别</code>可以访问其扩展的类的<code>实例变量</code></li>
</ul>
<p><strong>总结：</strong>我将<code>类别</code>分3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>种类</th>
<th><code>@interface</code></th>
<th><code>@implementation</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>类别</td>
<td><code>@interface 类名(类别名)</code></td>
<td><code>@implementation 类名(类别名)</code></td>
</tr>
<tr>
<td>类扩展（匿名类别）</td>
<td><code>@interface 类名()</code></td>
<td>无</td>
</tr>
<tr>
<td>前向引导</td>
<td><code>@interface 类名(类别名)</code></td>
<td><code>@implementation 类名</code></td>
</tr>
</tbody>
</table>
<h2 id="12-1-创建类别"><a href="#12-1-创建类别" class="headerlink" title="12.1    创建类别"></a>12.1    创建类别</h2><blockquote>
<p><strong>说明：</strong>可以为人和类添加新的方法，包括那些没有源代码的类。<br><strong>技巧：</strong>通常把类别代码放在<code>独立</code>的文件中，通常以<code>类名称+类别名称</code>的风格命名。</p>
</blockquote>
<h3 id="12-1-1-开始创建类别独立文件"><a href="#12-1-1-开始创建类别独立文件" class="headerlink" title="12.1.1    开始创建类别独立文件"></a>12.1.1    开始创建类别独立文件</h3><blockquote>
<p><strong>说明：</strong>使用<code>Xcode</code>往项目中添加类别非常容易，甚至可以<code>类名称+类别名称</code>命名类别文件。</p>
<ol>
<li>新建文件<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.23.09.png" alt="Alt text"></li>
<li>选择模版<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.23.39.png" alt="Alt text"></li>
<li>文件相关<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.24.00.png" alt="Alt text"></li>
<li>完成<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-20%20%E4%B8%8A%E5%8D%8811.24.16.png" alt="Alt text"></li>
</ol>
</blockquote>
<h3 id="12-1-2-interface部分"><a href="#12-1-2-interface部分" class="headerlink" title="12.1.2    @interface部分"></a>12.1.2    @interface部分</h3><p><em>NSString+NumberConvience.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">NumberConvience</span>)</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *) lengthAsNumber;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// NumberConvience</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-implementation部分"><a href="#12-1-3-implementation部分" class="headerlink" title="12.1.3    @implementation部分"></a>12.1.3    @implementation部分</h3><p><em>NSString+NumberConvience.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSString+NumberConvience.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">NumberConvience</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取NSNumber 类型的字符串长度</span><br><span class="line"> * @return &#123;NSNumber *&#125; 字符串长度</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *) lengthAsNumber &#123;</span><br><span class="line">    <span class="comment">// 获得字符串长度：NSInteger 底层是个 long int</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [<span class="keyword">self</span> length];</span><br><span class="line">    <span class="comment">// 将字符串长度转换为 NSNumber 类型</span></span><br><span class="line">    <span class="keyword">return</span> ([<span class="built_in">NSNumber</span> numberWithUnsignedLong: length]);</span><br><span class="line">&#125;<span class="comment">// lengthAsNumber</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSString+NumberConvience.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 可变字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="comment">// 添加键/值对</span></span><br><span class="line">        [dict setObject:[<span class="string">@"hello"</span> lengthAsNumber] forKey:<span class="string">@"hello"</span>];</span><br><span class="line">        [dict setObject:[<span class="string">@"iLikeFish"</span> lengthAsNumber] forKey:<span class="string">@"iLikeFish"</span>];</span><br><span class="line">        [dict setObject:[<span class="string">@"Once upon a time"</span> lengthAsNumber] forKey:<span class="string">@"Once upon a time"</span>];</span><br><span class="line">        <span class="comment">// 打印字典</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-类别的缺陷"><a href="#12-1-4-类别的缺陷" class="headerlink" title="12.1.4    类别的缺陷"></a>12.1.4    类别的缺陷</h3><blockquote>
<p><strong>说明：</strong>类别有2个局限性</p>
<ul>
<li>无法向类中添加实例变量</li>
<li>当类别添加的方法和类中原有的方法重名时，类别具有更高的优先级</li>
</ul>
<p><strong>解决命名冲突：</strong>可以在类别的方法名中添加一个前缀，以确保不会发生名称冲突。<br><strong>添加实例变量：</strong>使用全局字典来存储对象与想关联的额外变量之间的映射。</p>
</blockquote>
<h3 id="12-1-5-类别的优势"><a href="#12-1-5-类别的优势" class="headerlink" title="12.1.5    类别的优势"></a>12.1.5    类别的优势</h3><blockquote>
<p><strong>说明：</strong>类别主要有3个用途</p>
<ul>
<li>将类的实现代码分散到多个不同文件或框架中</li>
<li>创建对私有方法的前向引用</li>
<li>向对象添加非正式协议（informal protocol）</li>
</ul>
</blockquote>
<h3 id="12-1-6-类扩展"><a href="#12-1-6-类扩展" class="headerlink" title="12.1.6    类扩展"></a>12.1.6    类扩展</h3><blockquote>
<p><strong>说名：</strong><code>类扩展（class extension）</code>是一个特殊的<code>类别</code>，它不需要命名(只有<code>@interface</code>没有<code>@implementation</code>)。</p>
<ul>
<li>可以包含源代码的类中使用</li>
<li>可以添加实例变量</li>
<li>可以将只读权限改成可读写的权限</li>
<li>创建数量不限</li>
</ul>
<p><strong>信息隐藏：</strong>分2种情况</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>类扩展</code>所在文件</th>
<th>可访问性</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩展的目标类的<code>@implementation</code>所在<code>.m</code>文件</td>
<td>目标类的内部</td>
</tr>
<tr>
<td>单独的私有<code>.h</code>文件</td>
<td>目标类的内部、目标类的子类和友类</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>可以拥有多个<code>类扩展</code>，不过这样会引发很难察觉的<code>bug</code>，所以请理智使用。</p>
</blockquote>
<p><em>Things.h：类的<code>@interface</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Things</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing2;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)resetAllValues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Things.m：类的<code>@implementation</code>和类扩展</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Things.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  在实现文件中添加类扩展（匿名类别）</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Things</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加实例变量</span></span><br><span class="line">    <span class="built_in">NSInteger</span> thing4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原有属性的特性（只读－&gt;读写）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing2;</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> thing3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Things ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类的原始定义</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Things</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) resetAllValues &#123;</span><br><span class="line">    thing1 = <span class="number">100</span>;</span><br><span class="line">    thing2 = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Things</span></span><br></pre></td></tr></table></figure>
<p><em>main.m：使用被扩展后的<code>NSString</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Things *things = [[Things alloc] init];</span><br><span class="line">        things.thing1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, things);</span><br><span class="line">        [things resetAllValues];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, things);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-2-利用类别分散实现代码"><a href="#12-2-利用类别分散实现代码" class="headerlink" title="12.2    利用类别分散实现代码"></a>12.2    利用类别分散实现代码</h2><blockquote>
<p><strong>说明：</strong>如果想将大型的单个类分散到多个不同的<code>.m</code>文件中，可以使用<code>类别</code>。<br><strong>举例：</strong><code>AppKit</code>中的<code>NSWindow</code>，拥有大量的<code>类别</code>声明</p>
<ul>
<li><code>@interface NSWindow(NSKeyboardUI)</code></li>
<li><code>@interface NSWindow(NSToolbarSupport)</code></li>
<li><code>@interface NSWindow(NSDrag)</code></li>
<li><code>@interface NSWindow(NSCarbonExtensions)</code></li>
</ul>
<p><strong>扩展：</strong><code>类别</code>还可以将<code>方法</code>分散到<code>逻辑群组</code>中，使编程人员可以更加容易地阅读头<code>文件</code>。</p>
</blockquote>
<h3 id="在项目中使用类别"><a href="#在项目中使用类别" class="headerlink" title="在项目中使用类别"></a>在项目中使用类别</h3><blockquote>
<p><strong>说明：</strong>将类的<code>类别</code>的实现部分分散在三个独立的文件中。<br><img src="./屏幕快照 2016-01-20 下午10.54.50.png" alt="Alt text"></p>
</blockquote>
<p><em>CategoryThing.h：类的<code>@interface</code>和3个类别的<code>@interface</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing1;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing2;</span><br><span class="line">    <span class="built_in">NSInteger</span> thing3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// CategoryThing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing1</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing1</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing1: (<span class="built_in">NSInteger</span>) thing1;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing2</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing2</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing2: (<span class="built_in">NSInteger</span>) thing2;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  类扩展：Thing3</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CategoryThing</span> (<span class="title">Thing3</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) setThing3: (<span class="built_in">NSInteger</span>) thing3;</span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing3;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing.m：类的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  描述</span><br><span class="line"> *</span><br><span class="line"> *  @return 字符串表示的描述内容</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld %ld %ld"</span>, thing1, thing2, thing3];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;<span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="comment">// CategoryThing</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing1.m：类别Thing1的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing1</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setThing1:(<span class="built_in">NSInteger</span>)t1</span><br><span class="line">&#123;</span><br><span class="line">    thing1 = t1;</span><br><span class="line">&#125; <span class="comment">// setThing1</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (thing1);</span><br><span class="line">&#125; <span class="comment">// thing1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// CategoryThing</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing2.m：类别Thing2的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing2</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setThing2:(<span class="built_in">NSInteger</span>)t2 &#123;</span><br><span class="line">    thing2 = t2;</span><br><span class="line">&#125; <span class="comment">// setthing2</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing2 &#123;</span><br><span class="line">    <span class="keyword">return</span> (thing2);</span><br><span class="line">&#125; <span class="comment">// thing2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>CategoryThing+Thing3.m：类别Thing3的<code>@implementation</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CategoryThing</span> (<span class="title">Thing3</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setThing3:(<span class="built_in">NSInteger</span>)t3 &#123;</span><br><span class="line">    thing3 = t3;</span><br><span class="line">&#125; <span class="comment">// setthing3</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>) thing3 &#123;</span><br><span class="line">    <span class="keyword">return</span> (thing3);</span><br><span class="line">&#125; <span class="comment">// thing3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m：调用<code>类</code>通过<code>类别</code>扩展的功能</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CategoryThing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 创建物品集合</span></span><br><span class="line">        CategoryThing *thing = [[CategoryThing alloc] init];</span><br><span class="line">        <span class="comment">// 调用通过“类别”扩展来的方法</span></span><br><span class="line">        [thing setThing1: <span class="number">5</span>];</span><br><span class="line">        [thing setThing2: <span class="number">23</span>];</span><br><span class="line">        [thing setThing3: <span class="number">42</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Things are %@"</span>, thing);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-通过类别创建前向引用"><a href="#12-3-通过类别创建前向引用" class="headerlink" title="12.3    通过类别创建前向引用"></a>12.3    通过类别创建前向引用</h2><blockquote>
<p><strong>背景：</strong><code>Objective-C</code>的<code>私有方法</code>分两种</p>
<ul>
<li>如果在一个类的<code>@implementation</code>部分定义了某个方法，而对应的<code>@interface</code>部分没有相应的方法声明</li>
<li>通过<code>类扩展（匿名类别）</code>扩展的方法</li>
</ul>
<p>然而，<code>O-C</code>并不真的支持<code>私有方法</code>，所以<code>私有方法</code>仍然可以通过对象调用，只不过这时<code>Xcode</code>会给出警告。<br><strong>说明：</strong>当从外部访问某个<code>类</code>的<code>私有方法</code>时，为了避免<code>Xcode</code>给出警告，可以通过<code>类别</code>补充一个声明，即<code>前向引导</code>。<br><strong>扩展：</strong>实际上，苹果公司官网在知道方针中指出，应用程序不能访问类里面的私有变量和方法，如果你的应用程序有这样的行为，那么苹果公司会拒绝让它上架。<br><em>main.m：在最前面创建<code>类别</code>来补充<code>私有方法</code>的声明</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> (<span class="title">Private</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) moveTireFromPosition: (<span class="keyword">int</span>) pos1 toPosition: (<span class="keyword">int</span>) pos2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>Car.m：方法的实现部分是Car的<code>私有方法</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>) moveTireFromPosition: (<span class="keyword">int</span>) pos1 toPosition: (<span class="keyword">int</span>) pos2 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="12-4-非正式协议和委托类别"><a href="#12-4-非正式协议和委托类别" class="headerlink" title="12.4    非正式协议和委托类别"></a>12.4    非正式协议和委托类别</h2><blockquote>
<p><strong>委托：</strong>将某些工作交给另一个类执行就叫做<code>委托(delegate)</code>。<br><strong>委托对象：</strong><code>委托</code>技术中，被委托用来执行某些工作的<code>对象</code>。<br><strong>说明：</strong>除了通过<code>继承</code>创建<code>委托对象</code>外，可以通过<code>类别</code>扩展<code>NSObject</code>（即创建了一个<code>非正式协议</code>），使其获得<code>委托方法</code>，从而将任何对象都变成<code>委托对象</code>。</p>
</blockquote>
<h3 id="12-4-1-iTunesFinder项目"><a href="#12-4-1-iTunesFinder项目" class="headerlink" title="12.4.1    iTunesFinder项目"></a>12.4.1    iTunesFinder项目</h3><blockquote>
<p><strong>说明：</strong>用来说明<code>Cocoa</code>中是如何使用<code>委托</code>技术的。</p>
</blockquote>
<h4 id="Bonjour"><a href="#Bonjour" class="headerlink" title="Bonjour"></a>Bonjour</h4><blockquote>
<p><strong>说明：</strong>查找由<code>Bonjour</code>发布的网络服务的<code>Cocoa类</code>是<code>NSNetServiceBrowser</code>。<br><strong>用法：</strong>告诉<code>网络服务浏览器</code>你需要的服务，并为其提供一个<code>委托对象</code>。<code>浏览器对象</code>将会向该<code>委托对象</code>发送消息，告知其发现新服务的时间。<br><em>ITunesFinder.h</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ITunesFinder</span> : <span class="title">NSObject</span> &lt;<span class="title">NSNetServiceBrowserDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ITunesFinder.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ITunesFinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ITunesFinder</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  找到了网络服务时的回调方法</span><br><span class="line"> *</span><br><span class="line"> *  @param b          网络服务浏览器对象</span><br><span class="line"> *  @param service    被发现的服务</span><br><span class="line"> *  @param moreComing 一批通知是否已经完成的标记</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b</span><br><span class="line">            didFindService:(<span class="built_in">NSNetService</span> *) service</span><br><span class="line">                moreComing:(<span class="built_in">BOOL</span>) moreComing &#123;</span><br><span class="line">    <span class="comment">// 获取关于该服务的所有有趣的属性</span></span><br><span class="line">    [service resolveWithTimeout:<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"found one! Name is %@"</span>, [service name]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// didFindService</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  某个网络服务消失时的回调方法（用于状态刷新）</span><br><span class="line"> *</span><br><span class="line"> *  @param b          网络服务浏览器对象</span><br><span class="line"> *  @param service    被发现的服务</span><br><span class="line"> *  @param moreComing 一批通知是否已经完成的标记</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b</span><br><span class="line">          didRemoveService:(<span class="built_in">NSNetService</span> *) service</span><br><span class="line">                moreComing:(<span class="built_in">BOOL</span>) moreComing</span><br><span class="line">&#123;</span><br><span class="line">    [service resolveWithTimeout:<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"lost one! Name is %@"</span>, [service name]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// didRemoveService</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// ITunesFinder</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ITunesFinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建 网络服务浏览器对象</span></span><br><span class="line">        <span class="built_in">NSNetServiceBrowser</span> *browser = [[<span class="built_in">NSNetServiceBrowser</span> alloc] init];</span><br><span class="line">        <span class="comment">// 创建 委托对象（自定义的查找iTunes资源的对象）</span></span><br><span class="line">        ITunesFinder *finder = [[ITunesFinder alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 网络服务浏览器对象所使用的委托对象为自定义的 ITunes 对象</span></span><br><span class="line">        [browser setDelegate:finder];</span><br><span class="line">        <span class="comment">// 搜索 iTunes 共享（使用TCP协议、只在本地网络中）</span></span><br><span class="line">        [browser searchForServicesOfType:<span class="string">@"_daap._tcp"</span></span><br><span class="line">                                inDomain:<span class="string">@"local."</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"begun browsing"</span>);</span><br><span class="line">        <span class="comment">// run循环（在 网络服务浏览器 发现新的 iTunes 共享之前会一直保持运行而不返回，即阻塞在此处而不执行后面的代码）</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-2-委托和类别"><a href="#12-4-2-委托和类别" class="headerlink" title="12.4.2    委托和类别"></a>12.4.2    委托和类别</h3><blockquote>
<p><strong>说明：</strong>除了通过<code>继承</code>创建<code>委托对象</code>外，可以通过<code>类别</code>扩展<code>NSObject</code>（即创建了一个<code>非正式协议</code>），使其获得<code>委托方法</code>，从而将任何对象都变成<code>委托对象</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSNetServerBrowserDelegateMethods</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowserWillSearch: (<span class="built_in">NSNetServiceBrowser</span> *) browser;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b didFindService:(<span class="built_in">NSNetService</span> *) service moreComing:(<span class="built_in">BOOL</span>) moreComing;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowserDidStopSearch: (<span class="built_in">NSNetServiceBrowser</span> *) browser;</span><br><span class="line">- (<span class="keyword">void</span>) netServiceBrowser:(<span class="built_in">NSNetServiceBrowser</span> *) b didRemoveService:(<span class="built_in">NSNetService</span> *) service moreComing:(<span class="built_in">BOOL</span>) moreComing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="12-4-3-响应选择器"><a href="#12-4-3-响应选择器" class="headerlink" title="12.4.3    响应选择器"></a>12.4.3    响应选择器</h3><blockquote>
<p><strong>说明：</strong><code>NSNetServiceBrowser</code>为了确定其<code>委托对象</code>是否能够处理那些发送给它的消息，会首先检查对象，询问其能否响应该选择器，是泽发送消息，否则忽略这个委托对象，程序继续运行。</p>
</blockquote>
<h4 id="选择器（selector）"><a href="#选择器（selector）" class="headerlink" title="选择器（selector）"></a>选择器（selector）</h4><blockquote>
<p><strong>说明：</strong>只是一个方法名称，但以<code>Objective-C</code>运行时使用的特殊方式编码，以快速执行查询。<br><strong>语法：</strong><code>@selector(方法名)</code><br><strong>用途：</strong><code>NSObject</code>提供了一个名为<code>responendsToSelector</code>的方法，该方法询问对象以确定其是否能够响应某个特定的消息。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br><span class="line"><span class="keyword">if</span> ([car responengsToSelector: <span class="keyword">@selector</span>(setEngine:)]) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"yowza!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-4-选择器的其它应用"><a href="#12-4-4-选择器的其它应用" class="headerlink" title="12.4.4    选择器的其它应用"></a>12.4.4    选择器的其它应用</h3><blockquote>
<p><strong>说明：</strong>选择器可以</p>
<ul>
<li>被传递</li>
<li>作为方法的参数</li>
<li>作为实例变量被存储</li>
</ul>
<p><strong>举个例子：</strong><code>Foundation</code>框架中的<code>NSTimer</code></p>
</blockquote>
<h2 id="12-5-小结"><a href="#12-5-小结" class="headerlink" title="12.5    小结"></a>12.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_11 属性/" itemprop="url">
                  11 属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:40:03+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_11 属性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_11 属性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>O-C 2.0</code>引入了<code>属性（property）</code>，即<code>@property</code>预编译指令，它组合了新的预编译指令和新的属性访问器语法。<br><strong>用途：</strong>除非自己定义了相关代码，否则<code>@property</code>会根据<code>特性</code>自动生成属性及其<code>setter</code>和<code>getter</code>的声明和实现。<br><strong>兼容性：</strong><code>10.5+</code><br><strong>语法：</strong><code>@property[(特性)] 实例变量类型 实例变量名;</code><br><strong>注意：</strong>还有一个编译指令<code>@synthesize</code>，用来配合<code>@property</code>生成<code>getter</code>和<code>setter</code>的实现，可以省略（<code>XCode 4.4</code>之后）。</p>
</blockquote>
<h2 id="11-1-使用属性值"><a href="#11-1-使用属性值" class="headerlink" title="11.1    使用属性值"></a>11.1    使用属性值</h2><p><em>AllWeatherRadial.h</em></p>
<blockquote>
<p><strong>说明：</strong>对需要设置<code>setter</code>和<code>getter</code>的实例变量使用<code>@property</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎再潮湿的道路上的性能</span></span><br><span class="line">    <span class="keyword">float</span> rainHandling;</span><br><span class="line">    <span class="keyword">float</span> snowHandling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对需要设置setter和getter的实例变量使用@property(不在需要为每个属性分别声明setter和getter)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> rainHandling;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> snowHandling;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// AllWeatherRadial</span></span><br></pre></td></tr></table></figure>
<p><em>AllWeatherRadial.m</em></p>
<blockquote>
<p><strong>说明：</strong>不需要实现被设置了<code>@propery</code>的实例属性的<code>getter</code>和<code>setter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithPressure: p treadDepth:td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>, [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth], [<span class="keyword">self</span> rainHandling], [<span class="keyword">self</span> snowHandling]];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<blockquote>
<p><strong>说明：</strong>调用相应的属性的<code>setter</code>和<code>getter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 车身</span></span><br><span class="line">        Car *car = [[Car alloc] init];</span><br><span class="line">        <span class="comment">// 安装轮胎</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            AllWeatherRadial *tire;</span><br><span class="line">            tire = [[AllWeatherRadial alloc] init];</span><br><span class="line">            <span class="comment">// 调用通过@property指令获得的setter和getter</span></span><br><span class="line">            [tire setRainHandling:<span class="number">23</span> + i];</span><br><span class="line">            [tire setSnowHandling:<span class="number">33</span> - i];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"tire %d's handling is %.f %.f"</span>, i, [tire rainHandling], [tire snowHandling]);</span><br><span class="line">            [car setTire:tire atIndex:i];</span><br><span class="line">            [tire release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安装引擎</span></span><br><span class="line">        Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">        [car setEngine:engine];</span><br><span class="line">        <span class="comment">// 使用Car</span></span><br><span class="line">        [car print];</span><br><span class="line">        [car release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-1-1-简化接口代码"><a href="#11-1-1-简化接口代码" class="headerlink" title="11.1.1    简化接口代码"></a>11.1.1    简化接口代码</h3><h3 id="11-1-2-简化实现代码"><a href="#11-1-2-简化实现代码" class="headerlink" title="11.1.2    简化实现代码"></a>11.1.2    简化实现代码</h3><h3 id="11-1-3-点表达式的妙用"><a href="#11-1-3-点表达式的妙用" class="headerlink" title="11.1.3    点表达式的妙用"></a>11.1.3    点表达式的妙用</h3><blockquote>
<p><strong>说明：</strong><code>O-C 2.0</code>引入的新的语法特性，可以更加容易地访问对象的属性。<br><strong>限制：</strong>只能用于对象属性的<code>setter</code>或<code>getter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getter</span></span><br><span class="line">tire.rainHandling = <span class="number">20</span> + i;</span><br><span class="line">tire.snowHandling = <span class="number">28</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"tire %d's handling is %.f %.f"</span>, i, tire.rainHandling, tire.snowHandling);</span><br></pre></td></tr></table></figure>
<h2 id="11-2-属性扩展"><a href="#11-2-属性扩展" class="headerlink" title="11.2    属性扩展"></a>11.2    属性扩展</h2><blockquote>
<p><strong>说明：</strong><code>@property</code>对如何生成代码还有一些<code>特性</code>可以指定，这些<code>特性</code>将影响<code>setter</code>代码的生成。</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>@property</code>特性</th>
<th>说明</th>
<th>适用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>简单赋值，不更改<code>引用计数</code></td>
<td>基础数据类型和C数据类型</td>
<td>默认</td>
</tr>
<tr>
<td>copy</td>
<td>通过就对象复制出一个新对象（引用计数为1），并<code>释放</code>旧对象</td>
<td>不可变对象（例如NSString）</td>
<td></td>
</tr>
<tr>
<td>retain</td>
<td><code>释放</code>旧对象，将旧对象的值赋予输入对象，再<code>保留</code>输入对象</td>
<td>其它<code>O-C</code>对象</td>
<td></td>
</tr>
<tr>
<td>nonatomic</td>
<td>非线程安全</td>
<td>所有类型</td>
<td>默认，性能更好</td>
</tr>
<tr>
<td>atomic</td>
<td>某种程度的线程安全</td>
<td>所有类型</td>
<td>在多线程的环境保证<code>get</code>和<code>set</code>正确执行，但前提是是使用<code>@synthesize</code>生成的实现</td>
</tr>
<tr>
<td>readwrite</td>
<td>可读写</td>
<td>所有类型</td>
<td>默认</td>
</tr>
<tr>
<td>readonly</td>
<td>只读</td>
<td>所有类型</td>
<td>只生成<code>getter</code></td>
</tr>
<tr>
<td>getter=getter名称</td>
<td>指定生成的<code>getter</code>方法名</td>
<td>所有类型</td>
<td>默认为<code>属性名</code></td>
</tr>
<tr>
<td>setter=setter名称</td>
<td>指定生成的<code>setter</code>方法名</td>
<td>所有类型</td>
<td><code>set属性名</code>，匈牙利命名法</td>
</tr>
</tbody>
</table>
<h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用<code>@property</code></h4><blockquote>
<p><strong>说明：</strong><code>name</code>属性为<code>@property(copy)</code>，<code>engine</code>属性为<code>@property(retain)</code></p>
</blockquote>
<p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *) name;</span><br><span class="line">- (<span class="keyword">void</span>) setName: (<span class="built_in">NSString</span> *) newName;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (retain) Engine *engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="built_in">NSString</span> *) name &#123;</span><br><span class="line">	<span class="keyword">return</span> (name);</span><br><span class="line">&#125;<span class="comment">// name</span></span><br><span class="line">- (<span class="keyword">void</span>) setName: (<span class="built_in">NSString</span> *) newName &#123;</span><br><span class="line">	[name release];</span><br><span class="line">	name = [newName <span class="keyword">copy</span>];</span><br><span class="line">&#125;<span class="comment">// setName</span></span><br><span class="line"></span><br><span class="line">- (Engine *) engine &#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine &#123;</span><br><span class="line">    [newEngine retain];</span><br><span class="line">    [engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h4 id="不使用-property"><a href="#不使用-property" class="headerlink" title="不使用@property"></a>不使用<code>@property</code></h4><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用copy特性</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSString</span> name;</span><br><span class="line"><span class="comment">// 使用retain特性</span></span><br><span class="line"><span class="keyword">@property</span>(retain) Engine *engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<blockquote>
<p><strong>说明：</strong><code>@synthesize</code>用来生成成员变量的<code>setter</code>和<code>getter</code>的实现。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="comment">// xcode4.4 之后@synthesize就不再需要了</span></span><br><span class="line"><span class="keyword">@synthesize</span> name;</span><br><span class="line"><span class="keyword">@synthesize</span> engine;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-1-名称的使用"><a href="#11-2-1-名称的使用" class="headerlink" title="11.2.1    名称的使用"></a>11.2.1    名称的使用</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appellation;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> name = appellation;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-只读属性"><a href="#11-2-2-只读属性" class="headerlink" title="11.2.2    只读属性"></a>11.2.2    只读属性</h3><blockquote>
<p><strong>说明：</strong>假设某个属性，不想让任何人修改它，则可以对这个<code>@property</code>使用<code>readonly</code>特性，这时，只生成一个<code>getter</code>方法而不会生成<code>setter</code>。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Me</span>: <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> showSize;</span><br><span class="line">	<span class="built_in">NSString</span> *licenseNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">float</span> showSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *licenseNumber;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-自己动手有时更好"><a href="#11-2-3-自己动手有时更好" class="headerlink" title="11.2.3    自己动手有时更好"></a>11.2.3    自己动手有时更好</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><blockquote>
<p><strong>说明：</strong>可以通过<code>@property</code>配合<code>@dynamic</code>指令告诉编译器不生成人和代码或实例变量，通过自定义的<code>getter</code>创建一个能在运行时计算出此值的访问方法。<br><strong>注意：</strong>如果使用了<code>@dynamic</code>指令，并企图调用不存在的<code>getter</code>或<code>setter</code>方法，你将会的到一个报错。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @property</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">float</span> bodyMassIndex;</span><br><span class="line"><span class="comment">// @dynamic</span></span><br><span class="line"><span class="keyword">@dynamic</span> bodyMassIndex;</span><br><span class="line"><span class="comment">// getter</span></span><br><span class="line">- (<span class="keyword">float</span>) bodyMassIndex &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定getter和setter方法名"><a href="#指定getter和setter方法名" class="headerlink" title="指定getter和setter方法名"></a>指定getter和setter方法名</h4><blockquote>
<p><strong>说明：</strong>可以通过<code>@property(getter=getter名称)</code>和<code>@property(setter=setter名称)</code>自定义<code>geter</code>和<code>setter</code>方法的名称。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getter为isHidden，setter为setHidden（默认）</span></span><br><span class="line"><span class="keyword">@property</span> (getter=isHidden) <span class="built_in">BOOL</span> hidden;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-4-特性不是万能的"><a href="#11-2-4-特性不是万能的" class="headerlink" title="11.2.4    特性不是万能的"></a>11.2.4    特性不是万能的</h3><blockquote>
<p><strong>说明：</strong><code>@property</code>只能生成严格意义上的<code>getter</code>和<code>setter</code>，不支持那些需要接收额外参数的方法。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setter有额外的参数</span></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"><span class="comment">// getter有额外的参数</span></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-小结"><a href="#11-3-小结" class="headerlink" title="11.3    小结"></a>11.3    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_10 对象初始化/" itemprop="url">
                  10 对象初始化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:39:41+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_10 对象初始化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_10 对象初始化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>创建对象有两种方式</p>
<ul>
<li><code>类名 new</code></li>
<li><code>[[类名 alloc] init]</code></li>
</ul>
<p><strong>技巧：</strong><code>Cocoa</code>惯例是使用后一种方式</p>
</blockquote>
<h2 id="10-1-分配对象"><a href="#10-1-分配对象" class="headerlink" title="10.1    分配对象"></a>10.1    分配对象</h2><blockquote>
<p><strong>说明：</strong>就是从操作系统获得一块内存，并将其指定为存放对象的实例变量的位置。<br><strong>语法：</strong>像某个类发送<code>alloc</code>消息</p>
</blockquote>
<h4 id="alloc实例方法"><a href="#alloc实例方法" class="headerlink" title="alloc实例方法"></a>alloc实例方法</h4><blockquote>
<p><strong>说明：</strong>为类实例分配一块足够大的内存，并将这块内存区域全部初始化为对应的<code>0</code>值</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例变量类型</th>
<th><code>0</code>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>BOOL</td>
<td>NO</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>指针</td>
<td>nil</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>刚刚分配的对象不能立即使用，初始化后才能使用。<code>Objective-C</code>将对象的创建拆分为两个明确的步骤：<code>分配</code>和<code>初始化</code>。<br><strong>扩展：</strong>有些语言（包括<code>c++</code>和<code>java</code>）使用构造函数在一次操作中便执行完对象的分配和初始化。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配</span></span><br><span class="line">Car *car = [Car alloc];<span class="comment">// 还需要init，之后才能使用</span></span><br></pre></td></tr></table></figure>
<h3 id="10-1-1-初始化对象"><a href="#10-1-1-初始化对象" class="headerlink" title="10.1.1    初始化对象"></a>10.1.1    初始化对象</h3><blockquote>
<p><strong>说明：</strong>从操作系统取得一块内存（不一定是<code>分配</code>的内存）用于存储对象。<br><strong>语法：</strong>通过嵌套方式向<code>分配</code>操作的返回值发送<code>init</code>消息。<br><strong>注意：</strong><code>init</code>方法返回的对象可能与<code>分配</code>的对象不同，因为某些类型底层其实是<code>类蔟</code>。</p>
</blockquote>
<p><em>错误示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Car *car = [Car alloc];</span><br><span class="line"><span class="comment">// 我们需要的是init后的对象，car指向的对象未必和init返回的是一个对象</span></span><br><span class="line">[car init];</span><br></pre></td></tr></table></figure>
<p><em>正确示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Car *car = [[Car alloc] init];</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-编写初始化方法"><a href="#10-1-2-编写初始化方法" class="headerlink" title="10.1.2    编写初始化方法"></a>10.1.2    编写初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">id</span>) init &#123;</span><br><span class="line">	<span class="comment">// 1. 兼容超类返回nil的情况</span></span><br><span class="line">	<span class="comment">// 2. 更新self表示的内存位置（因为超类的init可能返回另一个位置）</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		<span class="comment">// ...	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-3-初始化时要做些什么"><a href="#10-1-3-初始化时要做些什么" class="headerlink" title="10.1.3    初始化时要做些什么"></a>10.1.3    初始化时要做些什么</h3><blockquote>
<p><strong>说明：</strong>有两种方式可以选择，取决于灵活性和性能的权衡</p>
</blockquote>
<table>
<thead>
<tr>
<th>是否为实例变量创建对象</th>
<th>说明</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>方便，一步到位，出产即用</td>
<td>实例变量不需要定制</td>
</tr>
<tr>
<td>否</td>
<td>在某些情况下避免资源的浪费</td>
<td>实例变量需要定制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong><code>惰性求值</code>，指的是即是目前没有设置自定义属性的值，也等到调用着需要时再创建对象，可以提高程序的性能。</p>
</blockquote>
<h2 id="10-2-便利初始化函数"><a href="#10-2-便利初始化函数" class="headerlink" title="10.2    便利初始化函数"></a>10.2    便利初始化函数</h2><blockquote>
<p><strong>说明：</strong>相比<code>init</code>，完成某些额外的初始化工作，名称以<code>init</code>开头。<br><strong>适用：</strong>加入对象必须要用某些信息进行初始化，那么应该将这些信息作为init方法的一部分添加进来。</p>
</blockquote>
<h3 id="initWithContentsofFile便利初始化方法"><a href="#initWithContentsofFile便利初始化方法" class="headerlink" title="initWithContentsofFile便利初始化方法"></a>initWithContentsofFile便利初始化方法</h3><blockquote>
<p><strong>说明：</strong>打开指定路径上的文本文件，读取文件内容，并即用文件内容初始化为一个字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;/**</span><br><span class="line">&gt;* @param &#123;nonnull NSString *&#125; 非空字符串</span><br><span class="line">&gt;* @param &#123;nullable NSStringEncoding *&#125; usedEncoding 编码方式</span><br><span class="line">&gt;* @param &#123;NSError * _Nullable __autoreleasing * _Nullable&#125; error 错误对象</span><br><span class="line">&gt;* @return &#123;instancetype _Nullable&#125; 字符串对象（可以为空）</span><br><span class="line">&gt;*/</span><br><span class="line">&gt;- (instancetype _Nullable) initWithContentsOfFile:(nonnull NSString *) usedEncoding: (nullable NSStringEncoding *) error:(NSError * _Nullable __autoreleasing * _Nullable);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:<span class="string">@"/tmp/words.txt"</span> usedEncoding:&amp;encoding error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取出错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unable to read data from file, %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取成功</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-3-更多部件改进"><a href="#10-3-更多部件改进" class="headerlink" title="10.3    更多部件改进"></a>10.3    更多部件改进</h2><blockquote>
<p><strong>注意：</strong>如果做<code>iOS</code>开发，由于不支持垃圾回收，必须使用<code>ARC</code>技术。</p>
</blockquote>
<h3 id="10-3-1-Tire类的初始化"><a href="#10-3-1-Tire类的初始化" class="headerlink" title="10.3.1    Tire类的初始化"></a>10.3.1    Tire类的初始化</h3><p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎压力</span></span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="comment">// 轮胎花纹</span></span><br><span class="line">    <span class="keyword">float</span> treadDepth;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) setPressure: (<span class="keyword">float</span>) pressure;</span><br><span class="line">- (<span class="keyword">float</span>) pressure;</span><br><span class="line">- (<span class="keyword">void</span>) setTreadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">float</span>)treadDepth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">- (<span class="keyword">id</span>) init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = <span class="number">34.0</span>;</span><br><span class="line">        treadDepth = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setPressure:(<span class="keyword">float</span>) p &#123;</span><br><span class="line">    pressure = p;</span><br><span class="line">&#125;<span class="comment">// setPressure</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) pressure &#123;</span><br><span class="line">    <span class="keyword">return</span> (pressure);</span><br><span class="line">&#125;<span class="comment">// pressure</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTreadDepth:(<span class="keyword">float</span>) td &#123;</span><br><span class="line">    treadDepth = td;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">float</span>) treadDepth &#123;</span><br><span class="line">    <span class="keyword">return</span> treadDepth;</span><br><span class="line">&#125;<span class="comment">// treadDepth</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    <span class="comment">// 不是通过alloc、copy、new创建的，按照内存管理规则，不需要做什么（可以认为它被加入到了自动释放池中）</span></span><br><span class="line">    desc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Tire: Pressure: %.1f TreadDepth: %1f"</span>, pressure, treadDepth];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;<span class="comment">// description</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-2-更新main-函数"><a href="#10-3-2-更新main-函数" class="headerlink" title="10.3.2    更新main()函数"></a>10.3.2    更新main()函数</h3><p><em>既没有启用<code>ARC</code>，也没有启用<code>垃圾回收</code>的情形－手动管理</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 车身</span></span><br><span class="line">        Car *car = [[Car alloc] init];</span><br><span class="line">        <span class="comment">// 安装轮胎</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Tire *tire;</span><br><span class="line">            tire = [[Tire alloc] init];</span><br><span class="line">            [tire setPressure:<span class="number">23</span> + i];</span><br><span class="line">            [tire setTreadDepth:<span class="number">33</span> - i];</span><br><span class="line">            [car setTire:tire atIndex:i];</span><br><span class="line">            <span class="comment">// 按照内存管理规则，应当释放一次，其余交给自动释放池</span></span><br><span class="line">            [tire release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安装引擎</span></span><br><span class="line">        Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">        [car setEngine:engine];</span><br><span class="line">        <span class="comment">// 使用Car</span></span><br><span class="line">        [car print];</span><br><span class="line">        <span class="comment">// 按照内存管理规则，应当释放一次，其余交给自动释放池</span></span><br><span class="line">        [car release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>启用了<code>ARC</code>或<code>垃圾回收</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Slant6.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 车身</span></span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    <span class="comment">// 安装轮胎</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Tire *tire;</span><br><span class="line">        tire = [[Tire alloc] init];</span><br><span class="line">        [tire setPressure:<span class="number">23</span> + i];</span><br><span class="line">        [tire setTreadDepth:<span class="number">33</span> - i];</span><br><span class="line">        [car setTire:tire atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 安装引擎</span></span><br><span class="line">    Engine *engine = [[Slant6 alloc] init];</span><br><span class="line">    [car setEngine:engine];</span><br><span class="line">    <span class="comment">// 使用Car</span></span><br><span class="line">    [car print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-3-清理Car类"><a href="#10-3-3-清理Car类" class="headerlink" title="10.3.3    清理Car类"></a>10.3.3    清理Car类</h3><p><em>Car.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用可变数组代替C数组（Tire *tires[4]），就不用上限检查了</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tires;</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        tires = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">// 将每个轮胎初始化为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            [tires addObject: [<span class="built_in">NSNull</span> null]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine &#123;</span><br><span class="line">    [newEngine retain];</span><br><span class="line">    [engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [tires replaceObjectAtIndex:index withObject:tire];</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Tire *tire;</span><br><span class="line">    tire = [tires objectAtIndex:index];</span><br><span class="line">    <span class="keyword">return</span> (tire);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 不直接访问数组，避免代码收到将来更改的影响</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> tireAtIndex: i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 确保car对象呗销毁时所有的内存都被回收</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">    [tires release];</span><br><span class="line">    [engine release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h2 id="10-4-Car-类的内存清理（垃圾回收方式和ARC方式）"><a href="#10-4-Car-类的内存清理（垃圾回收方式和ARC方式）" class="headerlink" title="10.4    Car 类的内存清理（垃圾回收方式和ARC方式）"></a>10.4    Car 类的内存清理（垃圾回收方式和ARC方式）</h2><blockquote>
<p><strong>说明：</strong>启用了<code>垃圾回收</code>或<code>ARC</code>，则不用手动管理内存。</p>
<ul>
<li>不再需要手动<code>释放</code>或<code>保留</code></li>
<li>不需要重写<code>dealloc</code>方法完成内存的清理，如果要销毁时执行一些特别的操作，可以重写<code>-finalize</code>方法</li>
</ul>
<p><strong>注意：</strong>启用了<code>垃圾回收</code>则不需要<code>@autoreleasepool</code>；启用<code>ARC</code>，则代码中必要时仍然可以使用<code>@autoreleasepool</code>。</p>
</blockquote>
<h3 id="构造便利初始化函数"><a href="#构造便利初始化函数" class="headerlink" title="构造便利初始化函数"></a>构造便利初始化函数</h3><blockquote>
<p><strong>说明：</strong>构造一个能同时获取轮胎压力和花纹深度的便利初始化函数。</p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) pressure treadDepth: (<span class="keyword">float</span>) treadDepth;</span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Tire *tire;</span><br><span class="line">tire = [[Tire alloc] initWithPressure: <span class="number">23</span> + i treadDepth: <span class="number">33</span> - i];</span><br></pre></td></tr></table></figure>
<h2 id="10-5-指定初始化函数"><a href="#10-5-指定初始化函数" class="headerlink" title="10.5    指定初始化函数"></a>10.5    指定初始化函数</h2><blockquote>
<p><strong>说明：</strong>先增加几个<code>便利初始化函数</code></p>
</blockquote>
<p><em>Tire.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) pressure treadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) treadDepth;</span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure:(<span class="keyword">float</span>)pressure;</span><br></pre></td></tr></table></figure>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithTreadDepth</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-1-子类化问题"><a href="#10-5-1-子类化问题" class="headerlink" title="10.5.1    子类化问题"></a>10.5.1    子类化问题</h3><blockquote>
<p><strong>说明：</strong><code>指定初始化函数</code>，即该中的某个初始化方法被指派为指定初始化函数，该类的所有初始化方法都调用指定初始化函数完成初始化。<br><strong>技巧：</strong>通常，接收参数最多的初始化方法是最终的指定初始化函数。</p>
</blockquote>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p><strong>说明：</strong><code>AllWeatherRadial</code>的超类<code>Tire</code>中的构造器都没有使用<code>指定初始化函数</code>，导致<code>AllWeatherRadial</code>需要重写所有<code>Tire</code>的构造器完成对自身实例变量的初始化。</p>
</blockquote>
<p><em>AllWeatherRadial.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 轮胎再潮湿的道路上的性能</span></span><br><span class="line">    <span class="keyword">float</span> rainHandling;</span><br><span class="line">    <span class="keyword">float</span> snowHandling;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) setRainHandling: (<span class="keyword">float</span>) rainHandling;</span><br><span class="line">- (<span class="keyword">float</span>) rainHandling;</span><br><span class="line">- (<span class="keyword">void</span>) setSnowHandling: (<span class="keyword">float</span>) snowHandling;</span><br><span class="line">- (<span class="keyword">float</span>) snowHandling;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// AllWeatherRadial</span></span><br></pre></td></tr></table></figure>
<p><em>AllWeatherRadial.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AllWeatherRadial.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line">- (<span class="keyword">void</span>) setRainHandling:(<span class="keyword">float</span>) rh &#123;</span><br><span class="line">    rainHandling = rh;</span><br><span class="line">&#125;<span class="comment">// setRainHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) rainHandling &#123;</span><br><span class="line">    <span class="keyword">return</span> (rainHandling);</span><br><span class="line">&#125;<span class="comment">// rainHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setSnowHandling: (<span class="keyword">float</span>) sh &#123;</span><br><span class="line">    snowHandling = sh;</span><br><span class="line">&#125;<span class="comment">// setSnowHandling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>) snowHandling &#123;</span><br><span class="line">    <span class="keyword">return</span> (snowHandling);</span><br><span class="line">&#125;<span class="comment">// snowHandling</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @override</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *desc;</span><br><span class="line">    desc = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f"</span>, [<span class="keyword">self</span> pressure], [<span class="keyword">self</span> treadDepth], [<span class="keyword">self</span> rainHandling], [<span class="keyword">self</span> snowHandling]];</span><br><span class="line">    <span class="keyword">return</span> (desc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-2-Tire-类的初始化函数改进后的版本"><a href="#10-5-2-Tire-类的初始化函数改进后的版本" class="headerlink" title="10.5.2    Tire 类的初始化函数改进后的版本"></a>10.5.2    Tire 类的初始化函数改进后的版本</h3><blockquote>
<p><strong>说明：</strong>要解决上述问题，首先需要将<code>Tire</code>改造为使用<code>指定初始化函数</code>的版本。</p>
</blockquote>
<p><em>Tire.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: <span class="number">34.0</span> treadDepth: <span class="number">20.0</span>]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// init</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure: (<span class="keyword">float</span>) p &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: p treadDepth: <span class="number">20</span>]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithTreadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure: <span class="number">34</span> treadDepth: td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithTreadDepth</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 参数最多的作为指定初始化函数</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pressure = p;</span><br><span class="line">        treadDepth = td;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;<span class="comment">// initWithPressure: treadDepth</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-3-添加AllWeatherPressure类的初始化函数"><a href="#10-5-3-添加AllWeatherPressure类的初始化函数" class="headerlink" title="10.5.3    添加AllWeatherPressure类的初始化函数"></a>10.5.3    添加AllWeatherPressure类的初始化函数</h3><blockquote>
<p><strong>说明：</strong>然后，将<code>AllWeatherPressure</code>改造为使用<code>指定初始化函数</code>的版本。只需要重载父类的<code>指定初始化函数</code>，所有构造器就可以正常使用了（因为其他构造器都调用的<code>指定初始化函数</code>）。<br><em>AllWeatherPressure.m</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) initWithPressure: (<span class="keyword">float</span>) p treadDepth: (<span class="keyword">float</span>) td &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithPressure: p treadDepth:td]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-6-初始化函数规则"><a href="#10-6-初始化函数规则" class="headerlink" title="10.6    初始化函数规则"></a>10.6    初始化函数规则</h2><blockquote>
<p><strong>说明：</strong>不是一定要为自己的类创建初始化函数</p>
<ul>
<li>如果不需要设置任何状态，或者<code>alloc</code>方法将内存清零的默认行为相当不错，则不可以不设置<code>指定初始化函数</code>。</li>
<li>如果子类中创建类<code>指定初始化函数</code>，则一定要在这个<code>制定初始化函数</code>中调用超类的<code>指定初始化函数</code>。</li>
</ul>
</blockquote>
<h2 id="10-7-小结"><a href="#10-7-小结" class="headerlink" title="10.7    小结"></a>10.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_09  内存管理/" itemprop="url">
                  9 内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:39:18+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_09  内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_09  内存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="9-1-对象生命周期"><a href="#9-1-对象生命周期" class="headerlink" title="9.1    对象生命周期"></a>9.1    对象生命周期</h2><blockquote>
<p><strong>说明：</strong>4个过程</p>
<ol>
<li>诞生：通过<code>alloc</code>或<code>new</code>方法实现</li>
<li>生存：接收消息并执行操作</li>
<li>交友：通过复合以及向方法传递参数</li>
<li>死去：被释放掉</li>
</ol>
</blockquote>
<h3 id="9-1-1-引用计数"><a href="#9-1-1-引用计数" class="headerlink" title="9.1.1    引用计数"></a>9.1.1    引用计数</h3><blockquote>
<p><strong>说明：</strong>也叫<code>保留计数</code>，每个对象都有一个与之想关联的整数，被称作它的<code>引用计数器</code>或<code>保留计数器</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关操作</th>
<th>说明</th>
<th>相关方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>引用计数器</code>初始化</td>
<td>被设置为1</td>
<td><code>alloc</code>、<code>new</code>、<code>copy</code></td>
</tr>
<tr>
<td><code>引用计数器</code>+1</td>
<td>新增对象引用时</td>
<td><code>retain</code></td>
</tr>
<tr>
<td><code>引用计数器</code>-1</td>
<td>引用生命周期结束或引用被断开时</td>
<td><code>release</code></td>
</tr>
<tr>
<td>销毁对象</td>
<td>释放掉已经分配的全部相关资源</td>
<td><code>dealloc</code></td>
</tr>
</tbody>
</table>
<h4 id="retain实例方法"><a href="#retain实例方法" class="headerlink" title="retain实例方法"></a>retain实例方法</h4><blockquote>
<p><strong>说明：</strong>增加对象的<code>引用计数器</code>的值。<br><strong>注意：</strong><code>Objective-C</code> 会在需要的时候自动调用它。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 接收消息的对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) retain;</span><br></pre></td></tr></table></figure>
<h4 id="release实例方法"><a href="#release实例方法" class="headerlink" title="release实例方法"></a>release实例方法</h4><blockquote>
<p><strong>说明：</strong>减少对象的<code>引用计数器</code>的值。<br><strong>注意：</strong><code>Objective-C</code> 会在需要的时候自动调用它。<br><strong>技巧：</strong>因为<code>retain</code>方法返回一个id类型的值，可以在接收其他消息的同时进行<code>retain</code>调用，增加对象的<code>引用计数器</code>的值并执行其他操作。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release;</span><br></pre></td></tr></table></figure>
<h4 id="retainCount实例方法"><a href="#retainCount实例方法" class="headerlink" title="retainCount实例方法"></a>retainCount实例方法</h4><blockquote>
<p><strong>说明：</strong>获取对象的<code>引用计数器</code>的值。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSUInteger&#125; 引用计数器当前值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>) retaonCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RetainTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RetainTracker</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"init: Retain count of %lu."</span>, [<span class="keyword">self</span> retainCount]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写dealloc,当引用计数器的值为0时将被自动调用</span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"dealloc called. Bye Bye."</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    RetainTracker *tracker = [RetainTracker new];</span><br><span class="line">    <span class="comment">// count: 1</span></span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count: 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count: 3</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 1</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker retain]; <span class="comment">// count 2</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count 1</span></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%lu"</span>, [tracker retainCount]);</span><br><span class="line">    </span><br><span class="line">    [tracker release]; <span class="comment">// count: 0, dealloc it</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-对象所有权"><a href="#9-1-2-对象所有权" class="headerlink" title="9.1.2    对象所有权"></a>9.1.2    对象所有权</h3><blockquote>
<p><strong>说明：</strong>如果一个对象（或函数）内有指向其他对象的实例变量，则称该对象（或函数）拥有这些对象，并负责确保对其拥有的对象进行清理。</p>
</blockquote>
<h3 id="9-1-3-访问方法中的保留和释放"><a href="#9-1-3-访问方法中的保留和释放" class="headerlink" title="9.1.3    访问方法中的保留和释放"></a>9.1.3    访问方法中的保留和释放</h3><blockquote>
<p><strong>说明：</strong><code>setEngine</code>方法的第一个内存管理版本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line">- (Engine *) engine;</span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// newEngin引用计数器加1</span></span><br><span class="line">	[newEngin retain];</span><br><span class="line">	<span class="comment">// engine应用计数器减1</span></span><br><span class="line">	[engine release];</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-自动释放"><a href="#9-1-4-自动释放" class="headerlink" title="9.1.4    自动释放"></a>9.1.4    自动释放</h3><blockquote>
<p><strong>说明：</strong>有些情况下，拥有对象的实体并不能负责清理拥有的对象，如下</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能在description中释放对象，因为先释放decription字符串对象再返回它，则保留计数器的值归0，对象马上被销毁。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *description;</span><br><span class="line">	description = [[<span class="built_in">NSString</span> alloc] initWithFormat: <span class="string">@"I'm %d years old"</span>, <span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> (description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>解决办法：不够优雅</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回的字符串赋在某个变量中</span></span><br><span class="line"><span class="built_in">NSString</span> *desc = [someObject description];</span><br><span class="line"><span class="comment">// 使用这个字符串</span></span><br><span class="line"><span class="built_in">NSSLog</span>(<span class="string">@"%@"</span>, desc);</span><br><span class="line"><span class="comment">// 销毁它</span></span><br><span class="line">[desc release];</span><br></pre></td></tr></table></figure>
<h3 id="9-1-5-所有对象放入池中"><a href="#9-1-5-所有对象放入池中" class="headerlink" title="9.1.5    所有对象放入池中"></a>9.1.5    所有对象放入池中</h3><blockquote>
<p><strong>关键字：</strong><code>@autoreleasepool</code>、<code>NSAutoreleasePool</code><br><strong>说明：</strong><code>自动释放池</code>是一个用来存放对象的池子（集合），并且能够自动释放。当自动释放池被销毁时，会想该池中所有的对象发送<code>release</code>消息。</p>
</blockquote>
<h4 id="autorelease实例方法"><a href="#autorelease实例方法" class="headerlink" title="autorelease实例方法"></a>autorelease实例方法</h4><blockquote>
<p><strong>说明：</strong>当向一个对象发送<code>autorelease</code>消息时，实际上是将该对象添加到自动释放池中。<br><strong>原型：</strong><code>id</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 接收对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) autorelease;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *description;</span><br><span class="line">	description = [[<span class="built_in">NSString</span> alloc] initWithFormat: <span class="string">@"I'm %d years old"</span>, <span class="number">4</span>];</span><br><span class="line">	<span class="comment">// 通过autorelease方法将字符串加入到自动释放池</span></span><br><span class="line">	<span class="keyword">return</span> ([description autorelease]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSLog函数的代码运行结束以后，自动释放池会被自动销毁（假设上下文存在已经创建好的自动释放池）</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [someObject description]);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-自动释放池的创建和销毁"><a href="#9-1-6-自动释放池的创建和销毁" class="headerlink" title="9.1.6    自动释放池的创建和销毁"></a>9.1.6    自动释放池的创建和销毁</h3><blockquote>
<p><strong>说明：</strong>自动释放池应该什么时候创建？什么时候销毁？</p>
</blockquote>
<h4 id="9-1-6-1-创建"><a href="#9-1-6-1-创建" class="headerlink" title="9.1.6.1    创建"></a>9.1.6.1    创建</h4><blockquote>
<p><strong>说明：</strong>有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>自动释放池的创建</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@autorelease{}</code></td>
<td><code>{}</code>内的代码都会被放入这个新池子中</td>
<td>定义在<code>{}</code>内的变量在外部无法使用</td>
</tr>
<tr>
<td><code>NSAutoreleasePool</code>对象</td>
<td>创建和释放<code>NSAutoreleasePool</code>对象之间的代码会使用这个新的池子</td>
<td>性能不如<code>@autorelease{}</code>方式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>可以使用<code>drain方法</code>清空自定释放池中的对象而不销毁自动释放池（Mac OS 10.4+）</p>
</blockquote>
<h4 id="9-1-6-2-销毁"><a href="#9-1-6-2-销毁" class="headerlink" title="9.1.6.2    销毁"></a>9.1.6.2    销毁</h4><blockquote>
<p><strong>说明：</strong>使用<code>AppKit</code>时，<code>Cocoa</code>定期自动地为你创建和销毁自动释放池，通常是在程序处理完当前事件（如鼠标单击或者键盘按下）以后执行这些操作。</p>
</blockquote>
<h3 id="9-1-7-自动释放池的工作流程"><a href="#9-1-7-自动释放池的工作流程" class="headerlink" title="9.1.7    自动释放池的工作流程"></a>9.1.7    自动释放池的工作流程</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RetainTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RetainTracker</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"init: Retain count of %lu."</span>, [<span class="keyword">self</span> retainCount]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"dealloc called. Bye Bye."</span>);</span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125; <span class="comment">// dealloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// RetainTracker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 方式一：NSAutoreleasePool对象 */</span></span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	</span><br><span class="line">    RetainTracker *tracker = [RetainTracker new]; <span class="comment">// count: 1</span></span><br><span class="line">	</span><br><span class="line">    [tracker retain]; <span class="comment">// count: 2</span></span><br><span class="line">    [tracker autorelease]; <span class="comment">// count: still 2</span></span><br><span class="line">    [tracker release]; <span class="comment">// count: 1</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"releasing pool"</span>);</span><br><span class="line">    [pool release];<span class="comment">// 销毁自动释放池</span></span><br><span class="line">    <span class="comment">// gets nuked, sends release to tracker</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 方式二：@autorelease代码块 */</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        RetainTracker *tracker2 = [RetainTracker new]; <span class="comment">// count: 1</span></span><br><span class="line">        </span><br><span class="line">        [tracker2 retain]; <span class="comment">// count: 2</span></span><br><span class="line">        [tracker2 autorelease]; <span class="comment">// count: still 2</span></span><br><span class="line">        [tracker2 release]; <span class="comment">// count: 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"auto releasing pool"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-Cocoa-的内存管理规则"><a href="#9-2-Cocoa-的内存管理规则" class="headerlink" title="9.2    Cocoa 的内存管理规则"></a>9.2    Cocoa 的内存管理规则</h2><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>有一些内存管理约定，它们都是一些很简单的规则，可用用于整个工具集內。</p>
<ul>
<li>如果使用<code>new</code>、<code>alloc</code>、<code>copy</code>方法创建了一个对象：当不再使用该对象时，应该向该对象发送一条<code>release</code>或<code>autorelease</code>消息</li>
<li>如果通过其他方法获得一个对象：如果对象的保留计数器的值为1，而且已经被设置为自动释放，那么你不需要执任何操作来确保对象的到清理，除非打算在一段时间内拥有该对象，则需要<code>保留</code>它并确保在操作完成时<code>释放</code>它。</li>
<li>如果<code>保留</code>了某个对象：需要（最终）<code>释放</code>或<code>自动释放</code>该对象（即保持<code>retain</code>方法和<code>release</code>方法使用次数相等）。<br><strong>技巧：</strong>以上规则可以归结为下表(两个维度：对象的来历？用完就销毁还是保留？)</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>对象的来历</th>
<th>用完就销毁</th>
<th>和拥有者同命</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alloc</code>、<code>new</code>、<code>copy</code></td>
<td>不在使用时释放对象</td>
<td>在<code>dealloc方法中释放对象</code></td>
</tr>
<tr>
<td><strong>其它方法</strong></td>
<td>不需要执行任何操作</td>
<td>获得对象时<code>保留</code>，在<code>dealloc</code>方法中<code>释放</code>对象</td>
</tr>
</tbody>
</table>
<h3 id="9-2-1-临时对象"><a href="#9-2-1-临时对象" class="headerlink" title="9.2.1    临时对象"></a>9.2.1    临时对象</h3><blockquote>
<p><strong>说明：</strong>临时对象指的是，在代码中使用某个对象，但是并未打算长期拥有该对象。<br><strong>内存管理：</strong>如果是用<code>new</code>、<code>alloc</code>、<code>copy</code>方法获得这个对象，就需要安排好该对象的内存释放（通常使用<code>release</code>）。<br><em>alloc</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维度1:通过alloc创建可变数组</span></span><br><span class="line"><span class="comment">// 维度2:临时使用</span></span><br><span class="line">KSMutableArray *array;</span><br><span class="line">array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="comment">// 使用array</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用时销毁</span></span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure>
<p><em>其它方法</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维度1:其它方法（工厂方法arrayWithCapacity已经将该对象的引用计数器设置为1且设置了自动释放，即已经放在了自动释放池中）</span></span><br><span class="line"><span class="comment">// 维度2:临时使用</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array;</span><br><span class="line">array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">17</span>];</span><br><span class="line"><span class="comment">// 使用array</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><em>其它方法（全局单例）</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSColor</span> *color;</span><br><span class="line"><span class="comment">// blueColor方法返回一个全局单例对象，这个对象永远不会被销毁，也不需要手动销毁</span></span><br><span class="line">color = [<span class="built_in">NSColor</span> blueColor];</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-拥有对象"><a href="#9-2-2-拥有对象" class="headerlink" title="9.2.2    拥有对象"></a>9.2.2    拥有对象</h3><blockquote>
<p><strong>说明：</strong><code>拥有对象</code>指的是希望在多个代码中一直拥有某个对象，比如</p>
<ul>
<li>将对象放进<code>集合</code>中（<code>NSArray</code>、<code>NSDictionary</code>等）</li>
<li>作为其它对象的<code>实例变量</code>使用</li>
<li>作为<code>全局变量</code>使用（比较罕见）</li>
</ul>
<p><strong>内存管理：</strong>见<a href="">9.2-技巧</a></p>
<ul>
<li>使用<code>new</code>、<code>alloc</code>、<code>copy</code>方法获得一个对象：只需保证在拥有者的<code>dealloc</code>方法中释放它</li>
<li>其它方法获得一个对象：获得后<code>保留</code>该对象，并保证在拥有者的<code>dealloc</code>方法中释放它<br><em><code>new</code>、实例变量</em></li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) doStuff &#123;</span><br><span class="line">	<span class="comment">// 通过new获得一个对象并赋值给实例变量</span></span><br><span class="line">	flonkArray = [<span class="built_in">NSMutableArray</span> new];<span class="comment">// count 1, autoreleased</span></span><br><span class="line">	[flonkArray retain];<span class="comment">// count 2, autoreleased</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	<span class="comment">// 释放实例变量指向的空间</span></span><br><span class="line">	[flonkArray release];<span class="comment">// count 0</span></span><br><span class="line">	<span class="comment">// 重写了dealloc别忘记调用超类的dealloc</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>其它方法、实例变量</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) doStuff &#123;</span><br><span class="line">	<span class="comment">// 通过new获得一个对象并赋值给实例变量</span></span><br><span class="line">	flonkArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">17</span>];<span class="comment">// count 1</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">	<span class="comment">// 释放实例变量指向的空间</span></span><br><span class="line">	[flonkArray release];<span class="comment">// count 0</span></span><br><span class="line">	<span class="comment">// 重写了dealloc别忘记调用超类的dealloc</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理自动释放池"><a href="#清理自动释放池" class="headerlink" title="清理自动释放池"></a>清理自动释放池</h4><blockquote>
<p><strong>说明：</strong>自动释放池被清理的时间是完全确定的</p>
<ul>
<li>在代码中手动销毁</li>
<li>使用AppKit时是在循环结束时销毁</li>
</ul>
<p><strong>原理：</strong>自动释放池存放在栈中，新建的自动释放池被添加到栈顶，接收<code>autorelease</code>消息的对象将被放入最顶端的自动释放池。<br><strong>注意：</strong>自动释放池的分配和销毁操作代价很小，如果一个循环中会创建大量对象，可以创建在循环中常见自己的自动释放池，每创建一批就释放一批。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自动释放池</span></span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool;</span><br><span class="line">pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 创建字符串对象</span></span><br><span class="line">	<span class="keyword">id</span> object = [someArray objectAtIndex: i];</span><br><span class="line">	<span class="built_in">NSString</span> *desc = [object description];</span><br><span class="line">	<span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 每创建1000个对象清理到上一个自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">		<span class="comment">// 并新建一个自动释放池</span></span><br><span class="line">		pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放最后一个自动释放池</span></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-垃圾回收"><a href="#9-2-3-垃圾回收" class="headerlink" title="9.2.3    垃圾回收"></a>9.2.3    垃圾回收</h3><blockquote>
<p><strong>说明：</strong><code>Objective-C2.0</code>引入了自动内存管理机制，也称为<code>垃圾回收</code><br><strong>触发：</strong>类似自动释放池</p>
<ul>
<li>在时间循环结束时触发</li>
<li>也可以自己触发（如果不是GUI程序）</li>
</ul>
<p><strong>开启：</strong><code>垃圾回收</code>是一个可选择的是否启动的功能（项目信息窗口-&gt;Build Settings选项卡-&gt;Require[-fobjc-gc-only]选项）<br><strong>限制：</strong>只支持<code>OS X</code>应用开发，无法在<code>iOS</code>应用程序上应用。<br><strong>扩展：</strong>苹果对<code>iOS</code>开发的一些建议</p>
<ul>
<li>不要在自己的代码中使用<code>autorelease</code>方法</li>
<li>不要使用会返回自动释放对象的一些便利方法（比如<code>NSString</code>中以<code>stringWith</code>开头的工厂方法）</li>
</ul>
</blockquote>
<h3 id="9-2-4-自动引用计数"><a href="#9-2-4-自动引用计数" class="headerlink" title="9.2.4    自动引用计数"></a>9.2.4    自动引用计数</h3><blockquote>
<p><strong>背景：</strong><code>iOS</code>不支持垃圾回收，因为移动设备比电脑更加私人化、资源更少，垃圾回收存在潜在的体验问题。但苹果提供了另外一个方案来祢补，那就是<code>自动引用计数（automatic regerence counting, ARC）</code><br><strong>说明：</strong><code>ARC</code>不是垃圾回收器，它是在编译期（而不是运行期）工作的，它在代码中插入了合适的<code>retain</code>和<code>release</code>语句。<br><strong>注意：</strong><code>ARC</code>是一个可选的功能，必需明确地启用或禁用。<br><strong>开发环境限制：</strong>以下是编写（或运行）<code>ARC</code>代码所需的条件</p>
<ul>
<li>Xcode4.2 以上的版本</li>
<li>Apple LLVM 3.0 以上版本的编译器</li>
<li><code>OS X 10.7</code>以上版本的系统</li>
</ul>
<p><strong>运行环境限制：</strong>以下是运行移动设备必需满足的条件</p>
<ul>
<li>ios 4.0以上的移动设备或<code>OS X10.6</code>以上版本的64位系统的电脑</li>
<li><code>归零弱引用</code>需要<code>iOS 5.0</code>或<code>OS X 10.7</code>以上版本的系统</li>
</ul>
<p><strong>作用对象限制：</strong><code>ARC</code>只对可保留的对象指针<code>(ROPs)</code>有效</p>
<ul>
<li>代码块指针</li>
<li><code>Objective-C</code>对象指针</li>
<li>通过<code>_attribute((NSObject))</code>类型定义的指针</li>
</ul>
<p><strong>技巧：</strong>如果想在代码中使用<code>ARC</code>，必需满足以下三个条件</p>
<ul>
<li>能够确定哪些对象需要进行内存管理</li>
<li>能够表明如何去管理对象：就是说必需能够对某个对象的引用计数器的值进行加1和减1的操作（<code>NSObject</code>的子类都可以）</li>
<li>有可行的办法传递对象的所有权（在调用者和接受者之间）</li>
</ul>
<p><strong>注意：</strong>如果使用的指针不支持<code>ARC</code>，那么你不得不亲自手动管理它们。</p>
</blockquote>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote>
<p><strong>说明：</strong>通常变量和<code>Objective-C</code>对象之间都是<code>强引用</code>，可以通过对属性使用了<code>assign</code>特性声明为<code>弱引用</code>。<br><strong>用途：</strong>处理<code>保留循环（retain cycle）</code>带来的内存泄漏。<br><strong>限制：</strong><code>弱引用</code>指向的对象有可能被提前释放，直接使用会导致问题。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-14%20%E4%B8%8B%E5%8D%8811.14.20.png" alt="Alt text"></p>
</blockquote>
<h4 id="归零弱引用"><a href="#归零弱引用" class="headerlink" title="归零弱引用"></a>归零弱引用</h4><blockquote>
<p><strong>说明：</strong>在指向的对象被释放之后，这种弱引用就会被设置为<code>nil</code>，然后就可以像平常的指针一样被处理了。<br><strong>语法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_weak</code>关键字</td>
<td>声明变量时使用<code>_weak</code>修饰</td>
<td><code>_weak NSString *myString;</code></td>
</tr>
<tr>
<td><code>@property(weak)</code></td>
<td>对属性使用<code>weak</code>特性</td>
<td><code>@property(weak) NSString *myString;</code></td>
</tr>
<tr>
<td><code>_unsafe_unretained</code>关键字和<code>unsafe_unretained</code>特性</td>
<td>告诉<code>ARC</code>这个特殊的引用是弱引用</td>
<td>前提是：不支持弱引用、使用了ARC</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>兼容性：</strong><code>iOS 5+</code>和<code>OS X 10.7+</code><br><strong>属性命名限制：</strong>使用<code>ARC</code>的时候，有两种命名规则</p>
<ul>
<li>属性名称不能以<code>new</code>开头</li>
<li>属性不能只有一个<code>read-only</code>而没有内存管理特性（除非启用了<code>ARC</code>功能）</li>
</ul>
<p><strong>注意：</strong>内存管理的<code>关键字</code>和<code>特性</code>是不能一起使用的，两者相互排斥。<br><strong>扩展：</strong><code>强引用</code>也有自己的<code>_strong</code>关键字和<code>strong</code>特性</p>
</blockquote>
<h4 id="将已有的项目转换成支持ARC的"><a href="#将已有的项目转换成支持ARC的" class="headerlink" title="将已有的项目转换成支持ARC的"></a>将已有的项目转换成支持<code>ARC</code>的</h4><blockquote>
<p><strong>前提：</strong>必须确保垃圾回收机制没有启动（<code>垃圾回收</code>和<code>ARC</code>是无法一同使用的）。<br><strong>说明：</strong><code>ARC</code>默认是启动了的，如果一个项目没有是在没有启动<code>ARC</code>的情况下开发的，可以转换（通过Edit-&gt;Convert-&gt;To Objective-C ARC…）</p>
</blockquote>
<h4 id="桥接转换"><a href="#桥接转换" class="headerlink" title="桥接转换"></a>桥接转换</h4><blockquote>
<p><strong>指针分两类：</strong><code>ROP</code>和<code>non-ROP</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>是否被<code>ARC</code>（启用了的话）管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>可保留对象指针(<code>ROP</code>)</td>
<td>NSobject的所有子类</td>
<td>是</td>
</tr>
<tr>
<td>不可保留对象指针(<code>non-ROP</code>)</td>
<td>C语言集合类型</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>拥有者权限：</strong>这个概念只有在启用了<code>ARC</code>的情况下才有意义。指的是<code>ROP</code>和<code>non-ROP</code>相互转换时指针所有权情况，用来告诉<code>ARC</code>如何工作</p>
<p><strong>用途：</strong>通过<code>桥接转换</code>，可以在转换类型的同时控制<code>拥有者权限</code><br><strong>说明：</strong>有3种类型的桥接转换</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>语法</th>
<th>对象的保留计数器</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_bridge</code></td>
<td><code>non-ROP变量=(__bridge)ROP变量;</code>或<code>ROP变量=(__bridge)non-ROP变量;</code></td>
<td>不变化</td>
<td>指针的所有权仍会留在原变量</td>
</tr>
<tr>
<td><code>_bridge_restained</code></td>
<td><code>non-ROP变量=(__bridge_restained)ROP变量;</code></td>
<td>加1</td>
</tr>
<tr>
<td><code>_bridge_transfer</code></td>
<td><code>ROP变量=(__bridge_transfer)non-ROP变量;</code></td>
<td>减1</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>结构体（<code>struct</code>）和集合体（<code>union</code>）不能使用<code>ROP</code>作为成员。可以通过使用<code>void *</code>和<code>桥接转换</code>来解决这个问题</li>
<li>有时需要释放不支持<code>ARC</code>的对象或执行其他清理操作，所以仍要实现<code>dealloc</code>方法，但是不能直接调用<code>[super dealloc]</code></li>
</ul>
<p><strong>注意：</strong><code>ARC</code>中的代码存在如下限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>内存管理方法</th>
<th>不能调用</th>
<th>不能重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>retain</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>retainCount</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>release</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>autorelease</td>
<td>- [x]</td>
<td>- [x]</td>
</tr>
<tr>
<td>dealloc</td>
<td>- [x]</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ROP</span></span><br><span class="line"><span class="built_in">NSString</span> *theString = <span class="string">@"Learn Objective-C"</span>;</span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    int32_t foo;</span><br><span class="line">    <span class="keyword">char</span> *bar;</span><br><span class="line">    <span class="built_in">NSString</span> *baz;</span><br><span class="line">&#125; MyStruct;</span><br><span class="line"><span class="comment">// 转成C语言提供的类型（void *），并指定所有权</span></span><br><span class="line">MyStruct.baz = (_bridge_restained <span class="keyword">void</span> *)theString;</span><br><span class="line"><span class="comment">// non-ROP 转 ROP</span></span><br><span class="line"><span class="built_in">NSString</span> *myString = (_bridge_transfer <span class="built_in">NSString</span> *)MyStruct.baz;</span><br></pre></td></tr></table></figure>
<h2 id="9-3-异常"><a href="#9-3-异常" class="headerlink" title="9.3    异常"></a>9.3    异常</h2><blockquote>
<p><strong>说明：</strong>异常就是异常事件，比如数组溢出，如果<code>捕捉</code>并<code>处理</code>，就会痰乱程序流程。</p>
<ul>
<li>异常对象：<code>Cocoa</code>中使用<code>NSException</code>类来表示异常，可以创建<code>NSException</code>子类作为自己的异常（如果通过其它类型的对象来<code>抛出异常</code>，<code>Cocoa</code>不会处理它们）</li>
<li>抛出异常：在运行时系统中创建并处理异常的行为</li>
<li>捕捉异常：处理被<code>抛出</code>的异常的行为</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果要项目支持异常特性，要确保<code>-fobj-exceptions</code>（Enable Objecytive-C Exception）项被打开</li>
<li><code>Cocoa</code>框架处理错误的方式通常是退出程序</li>
<li>如果一个异常被抛出但没有被捕捉，程序会在异常断点处停止运行并通知有这个异常</li>
</ul>
</blockquote>
<h3 id="9-3-1-与异常有关的关键字"><a href="#9-3-1-与异常有关的关键字" class="headerlink" title="9.3.1    与异常有关的关键字"></a>9.3.1    与异常有关的关键字</h3><blockquote>
<p><strong>说明：</strong>都以<code>@</code>开头</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@try</code></td>
<td>定义可能包含异常的代码块</td>
</tr>
<tr>
<td><code>@catch</code></td>
<td>定义处理已抛出异常的代码块，接收一个参数，通常是<code>NSException</code>或其子类</td>
</tr>
<tr>
<td><code>@finally</code></td>
<td>定义无论是够有抛出异常都会执行的代码块</td>
</tr>
<tr>
<td><code>@throw</code></td>
<td>抛出异常</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>语法：</strong><code>@try-catch-finally</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-捕捉不同类型的异常"><a href="#9-3-2-捕捉不同类型的异常" class="headerlink" title="9.3.2    捕捉不同类型的异常"></a>9.3.2    捕捉不同类型的异常</h3><blockquote>
<p><strong>说明：</strong>可以根据需要处理的异常类型过使用多个<code>@catch</code>代码块。处理代码应该按照从具体到抽象的顺序排序，并在最后使用一个通用的处理代码</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (myCustomException) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="keyword">id</span> value) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>C语言程序员经常会在异常处理代码中使用<code>setjmp</code>和<code>longjmp</code>语句。在<code>@try</code>中则不可以，但可以使用<code>goto</code>和<code>return</code>语句退出异常处理代码。</p>
</blockquote>
<h3 id="9-3-3-抛出异常"><a href="#9-3-3-抛出异常" class="headerlink" title="9.3.3    抛出异常"></a>9.3.3    抛出异常</h3><blockquote>
<p><strong>说明：</strong>异常的抛出分两种，<code>自动</code>和<code>手动</code>，后者有<code>2</code>中方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>手动抛出异常</th>
<th>异常对象类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@throw 异常对象</code></td>
<td>id</td>
</tr>
<tr>
<td>向某个异常对象发送<code>raise</code>消息</td>
<td><code>NSException</code>或其子类</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>在<code>@try</code>和<code>@catch</code>中都可以抛出异常，后者会引发下一个异常处理调用（<code>@finally</code>会在<code>@throw</code>之前被调用）<br><strong>扩展：</strong><code>Objective-C</code>的异常机制与<code>C++</code>的异常机制兼容。<br><strong>性能问题：</strong><code>@try</code>建立异常不会产生消耗，但捕捉异常会消耗大量资源并影响程序运行的速度。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSExceptionn</span> *theException = [<span class="built_in">NSException</span> exceptionWithName: _];</span><br><span class="line"><span class="keyword">@throw</span> theException;<span class="comment">// 或者[theException raise]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">	<span class="built_in">NSException</span> *e = _;</span><br><span class="line">	<span class="keyword">@throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">	<span class="comment">// 可以不指定异常对象（默认重复抛出）</span></span><br><span class="line">	<span class="keyword">@throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-异常也需要内存管理"><a href="#9-3-4-异常也需要内存管理" class="headerlink" title="9.3.4    异常也需要内存管理"></a>9.3.4    异常也需要内存管理</h3><blockquote>
<p><strong>说明：</strong>如果代码出现了异常，程序会被中断，原本没有内存问题的代码或许会因此出现内存泄漏。</p>
</blockquote>
<p><em>问题描述</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mySimpleMethod &#123;</span><br><span class="line">	<span class="comment">// 创建一个字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *dictionary = [[<span class="built_in">NSDictionary</span> alloc] initWith_.];</span><br><span class="line">	<span class="comment">// 对字典进行操作，假设操作中出现了异常，则程序会从方法中跳出寻找异常处理代码</span></span><br><span class="line">	[<span class="keyword">self</span> processDictionary: dictionary];</span><br><span class="line">	<span class="comment">// 释放字典：由于方法已经退出来了，所以字典没有释放</span></span><br><span class="line">	[dictionary release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>解决方式：<code>@try-@finally</code></em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mySimpleMethod &#123;</span><br><span class="line">	<span class="comment">// 创建一个字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *dictionary = [[<span class="built_in">NSDictionary</span> alloc] initWith_.];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 对字典进行操作，假设操作中出现了异常，则程序会从方法中跳出寻找异常处理代码</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionary: dictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放字典：由于方法已经退出来了，所以字典没有释放</span></span><br><span class="line">		[dictionary release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-5-异常和自动释放池"><a href="#9-3-5-异常和自动释放池" class="headerlink" title="9.3.5    异常和自动释放池"></a>9.3.5    异常和自动释放池</h3><blockquote>
<p><strong>说明：</strong>通常，开发人员并不知道异常对象何时释放，所以异常几乎总是作为自动释放对象创建。<br><strong>注意：</strong><code>@finally</code>代码块会在<code>@catch</code>中的<code>@throw</code>语句执行之前被调用，因此如果在<code>@finally</code>将自动释放池销毁，那么就会导致<code>僵尸异常</code>。</p>
</blockquote>
<p><em>僵尸异常示例</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMechod &#123;</span><br><span class="line">	<span class="comment">// 自动释放池</span></span><br><span class="line">	<span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	<span class="comment">// 字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *myDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKey: <span class="string">@"asdfads"</span>, <span class="literal">nil</span>];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 操作字典</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionaty: myDictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">		<span class="comment">// pool在下面的@throw被调用之前就被释放了，释放池中的异常对象随之被销毁，导致僵尸异常</span></span><br><span class="line">		<span class="keyword">@throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 销毁自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>避免僵尸异常：在<code>自动释放池</code>外<code>保留</code>异常对象</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMechod &#123;</span><br><span class="line">	<span class="keyword">id</span> savedException = <span class="literal">nil</span>;</span><br><span class="line">	<span class="comment">// 自动释放池</span></span><br><span class="line">	<span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">	<span class="comment">// 字典</span></span><br><span class="line">	<span class="built_in">NSDictionary</span> *myDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKey: <span class="string">@"asdfads"</span>, <span class="literal">nil</span>];</span><br><span class="line">	<span class="keyword">@try</span> &#123;</span><br><span class="line">		<span class="comment">// 操作字典</span></span><br><span class="line">		[<span class="keyword">self</span> processDictionaty: myDictionary];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@catch</span> (<span class="built_in">NSException</span> *e) &#123;</span><br><span class="line">		<span class="comment">// 通过retain方法，将异常对象放入当前池而不是pool中，因为savedException定义的位置在pool定义之前。</span></span><br><span class="line">		savedException = [e retain];</span><br><span class="line">		<span class="comment">// pool在下面的@throw被调用之前就被释放了</span></span><br><span class="line">		<span class="keyword">@throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">@finally</span> &#123;</span><br><span class="line">		<span class="comment">// 销毁自动释放池</span></span><br><span class="line">		[pool release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4    小结"></a>9.4    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/" itemprop="url">
                  8 Foundation Kit介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:55+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_08  Foundation Kit介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong><code>Cocoa</code>的几个重要框架</p>
</blockquote>
<table>
<thead>
<tr>
<th>框架</th>
<th>说明</th>
<th>兼容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Foundation Kit</td>
<td>两类UI框架的基础，包含很多有用的、面向数据的简单类和数据类型</td>
<td>ios和OS X</td>
<td>基于CoreFoundation框架</td>
</tr>
<tr>
<td>Application Kit(Appkit)</td>
<td>包含所有用户界面对象和高级类</td>
<td>OS X</td>
<td><a href="">16章</a></td>
</tr>
<tr>
<td>User Interface Kit(UIKit)</td>
<td>用户界面</td>
<td>ios</td>
<td><a href="">15章</a></td>
</tr>
</tbody>
</table>
<h2 id="8-1-稳固的-Foundation"><a href="#8-1-稳固的-Foundation" class="headerlink" title="8.1    稳固的 Foundation"></a>8.1    稳固的 Foundation</h2><blockquote>
<p><strong>说明：</strong>两类UI框架的基础，包含很多有用的、面向数据的简单类和数据类型。包含<code>NSString</code>、<code>NSArray</code>、<code>NSEnumerator</code>、和<code>NSNumber</code>等100多个类。<br><strong>扩展：</strong><code>Foundation</code>框架以<code>CoreFoundation</code>框架为（纯C编写）基础，<code>CoreFoundation</code>中的函数和变量的名称以<code>CF</code>开头。</p>
</blockquote>
<h2 id="8-2-使用项目样本代码"><a href="#8-2-使用项目样本代码" class="headerlink" title="8.2    使用项目样本代码"></a>8.2    使用项目样本代码</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-一些有用的数据类型"><a href="#8-3-一些有用的数据类型" class="headerlink" title="8.3    一些有用的数据类型"></a>8.3    一些有用的数据类型</h2><h3 id="8-3-1-范围"><a href="#8-3-1-范围" class="headerlink" title="8.3.1    范围"></a>8.3.1    范围</h3><blockquote>
<p><strong>类型：</strong><code>NSRange</code><br><strong>原型描述：</strong><code>Foundation.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span> _<span class="built_in">NSRange</span> &#123;</span><br><span class="line">&gt;    <span class="keyword">unsigned</span> <span class="keyword">int</span> location;</span><br><span class="line">&gt;    <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">&gt;&#125; <span class="built_in">NSRange</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>用来表示相关事物的范围，通常是字符串里字符范围或者数组里的元素范围。有<code>3</code>中创建方式</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：直接给字段赋值</span></span><br><span class="line"><span class="built_in">NSRange</span> range1;</span><br><span class="line">range.location = <span class="number">17</span>;</span><br><span class="line">range.length = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 方式二：利用c语言的聚合结构赋值机制</span></span><br><span class="line"><span class="built_in">NSRange</span> range2 = &#123;<span class="number">17</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 方式三：Cocoa提供的一个快捷函数NSMakeRange，优点是能够在任何能够使用函数的地方使用</span></span><br><span class="line"><span class="built_in">NSRange</span> range3 = <span class="built_in">NSMakeRange</span>(<span class="number">17</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h3 id="8-3-2-几何数据类型"><a href="#8-3-2-几何数据类型" class="headerlink" title="8.3.2    几何数据类型"></a>8.3.2    几何数据类型</h3><blockquote>
<p><strong>源：</strong><code>Cocoa</code>（引用<code>C</code>语言编写的<code>Core Graphics</code>框架）<br><strong>说明：</strong>包括一些用来处理图形的<code>数据类型</code>和创建这些数据类型的<code>快捷方法</code>。<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">CGPoint</span> &#123;</span><br><span class="line">	<span class="keyword">float</span> x;</span><br><span class="line">	<span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGSize</span> &#123;</span><br><span class="line">	<span class="keyword">float</span> width;</span><br><span class="line">	<span class="keyword">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</span><br><span class="line">	<span class="built_in">CGPoint</span> origin;</span><br><span class="line">	<span class="built_in">CGSize</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>所有的<code>O-C</code>对象都是动态分配的，而动态分配是一个代价较大的操作，会消耗大量的时间。所以为了性能，<code>GUI</code>程序更倾向使用结构体。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 矩形原点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 矩形大小</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 矩形</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-字符串"><a href="#8-4-字符串" class="headerlink" title="8.4    字符串"></a>8.4    字符串</h2><h3 id="8-4-1-创建字符串"><a href="#8-4-1-创建字符串" class="headerlink" title="8.4.1    创建字符串"></a>8.4.1    创建字符串</h3><h4 id="stringWithFormat方法"><a href="#stringWithFormat方法" class="headerlink" title="stringWithFormat方法"></a>stringWithFormat方法</h4><blockquote>
<p><strong>说明：</strong>通过格式字符串和参数来创建<code>NSString</code><br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; format 格式串</span><br><span class="line">* @param &#123;...&#125; 对应参数</span><br><span class="line">* @reuturn &#123;id&#125; NSString对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) stringWithFormat: (<span class="built_in">NSString</span> *) format, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *height;</span><br><span class="line">height = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Your height is %d feet, %d inches"</span>, <span class="number">5</span>, <span class="number">11</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-类方法"><a href="#8-4-2-类方法" class="headerlink" title="8.4.2    类方法"></a>8.4.2    类方法</h3><blockquote>
<p><strong>说明：</strong>如果在声明方法时添加了<code>+</code>，就是把这个方法定义为<code>类方法(class method)</code>。</p>
<ul>
<li>通常用于工厂方法</li>
<li>也可以用来访问全局数据</li>
</ul>
<p><strong>原理：</strong><code>Objective-C</code>运行时生成一个类的时候，会创建一个代表该类的<code>类对象（class object）</code>，包含了指向超类、类名和类方法列表的指针，还包含一个<code>long</code>类型的数据，为新创建的实例对象指定大小（以字节为单位）。</p>
<p><strong>扩展：</strong>类方法和实例方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>标识</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>类方法</td>
<td>属于类的方法</td>
</tr>
<tr>
<td>-</td>
<td>实例方法</td>
<td>将会在指定的对象实例中起作用</td>
</tr>
</tbody>
</table>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIColor的类方法：redColor（访问全局数据）</span></span><br><span class="line"><span class="built_in">NSColor</span> *haveTheBlues = [<span class="built_in">NSColor</span> blueColor];</span><br><span class="line"><span class="built_in">UIColor</span> *blueMan = [<span class="built_in">UIColor</span> blueColor];</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-关于大小"><a href="#8-4-4-关于大小" class="headerlink" title="8.4.4    关于大小"></a>8.4.4    关于大小</h3><h4 id="length实例方法"><a href="#length实例方法" class="headerlink" title="length实例方法"></a>length实例方法</h4><blockquote>
<p><strong>说明：</strong>返回字符串中字符的个数，能够准确无误地处理各种语言的字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @return &#123;NSUInter&#125; 字符串中字符的数目</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;- (<span class="built_in">NSUInter</span>) length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>在C语言中处理这些国际字符串很麻烦，因为一个字符占用的空间可能多于一个字节，使用<code>strlen</code>只能计算字节数的函数会返回错误的数值。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> height = <span class="string">@"Hello world!"</span>;</span><br><span class="line"><span class="keyword">if</span> ([height length] &gt; <span class="number">35</span>) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"wow, you're really tail!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-字符串比较"><a href="#8-4-4-字符串比较" class="headerlink" title="8.4.4    字符串比较"></a>8.4.4    字符串比较</h3><h4 id="isEqualToString实例方法"><a href="#isEqualToString实例方法" class="headerlink" title="isEqualToString实例方法"></a>isEqualToString实例方法</h4><blockquote>
<p><strong>说明：</strong>比较接收方和作为参数传递过来的字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @return &#123;BOOL&#125; YES 内容相同，NO 内容不同</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) isEqualToString: (<span class="built_in">NSString</span> *) aString</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong><code>==</code>运算符用来检查两个对象是否为同一事物；<code>isEqualToString</code>用来检查两个字符串的内容是否相等。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="built_in">NSString</span> *thing1 = <span class="string">@"hello 5"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *thing2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello %d"</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([thing1 isEqualToString:thing2]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"They are the same."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="compare实例方法"><a href="#compare实例方法" class="headerlink" title="compare实例方法"></a>compare实例方法</h4><blockquote>
<p><strong>说明：</strong>将接收对象和传递过来的字符串逐个进行比较</p>
<ul>
<li>区分大小写</li>
<li>返回一个显示比较结果的枚举类型</li>
</ul>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @return &#123;NSComparisonResult&#125; 包含比较结果的枚举类型</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>) compare: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>返回值原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">NSOrderedAscending</span> = <span class="number">-1</span>;<span class="comment">// 左侧小于右侧</span></span><br><span class="line">    <span class="built_in">NSOrderdSame</span>,<span class="comment">// 两侧字符串相同</span></span><br><span class="line">    <span class="built_in">NSOrderdDescending</span><span class="comment">// 左侧大于右侧</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span> <span class="built_in">NSComparisonResult</span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-5-不区分大小写的比较"><a href="#8-4-5-不区分大小写的比较" class="headerlink" title="8.4.5    不区分大小写的比较"></a>8.4.5    不区分大小写的比较</h3><h4 id="compare实例方法（2个参数）"><a href="#compare实例方法（2个参数）" class="headerlink" title="compare实例方法（2个参数）"></a>compare实例方法（2个参数）</h4><blockquote>
<p><strong>说明：</strong>比较字符串，有更多选择权，可以使用<code>位</code>或<code>bitwise-OR远端符（|）</code>来添加选项标记。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSCaseInsensitiveSearch</td>
<td>不区分大小写字符</td>
</tr>
<tr>
<td>NSLiteralSearch</td>
<td>进行完全比较，区分大小写</td>
</tr>
<tr>
<td>NSNumericSearch</td>
<td>比较字符串的字符个数，而不是字符串值</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 字符串</span><br><span class="line">* @option &#123;NSStringCompareOption&#125; mask 比较选项</span><br><span class="line">* @return &#123;NSComparisonResult&#125; 包含比较结果的枚举类型</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>) compare: (<span class="built_in">NSString</span> *) aString</span><br><span class="line">options: (<span class="built_in">NSStringCompareOption</span>) mask;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不区分大小写、比较字符串的字符个数（而不是值）</span></span><br><span class="line"><span class="keyword">if</span> ([thing1 compare:thing2 options:<span class="built_in">NSCaseInsensitiveSearch</span> | <span class="built_in">NSNumericSearch</span>] == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"They match!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-6-字符串是否还包含别的字符串"><a href="#8-4-6-字符串是否还包含别的字符串" class="headerlink" title="8.4.6    字符串是否还包含别的字符串"></a>8.4.6    字符串是否还包含别的字符串</h3><h3 id="hasPrefix实例方法"><a href="#hasPrefix实例方法" class="headerlink" title="hasPrefix实例方法"></a>hasPrefix实例方法</h3><blockquote>
<p><strong>说明：</strong>检查字符串是否是以另一个字符串开头<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*@return &#123;BOOL&#125; YES， NO</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) hasPrefix: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<h3 id="hasSuffix实例方法"><a href="#hasSuffix实例方法" class="headerlink" title="hasSuffix实例方法"></a>hasSuffix实例方法</h3><blockquote>
<p><strong>说明：</strong>检查字符串是否是以另一个字符串结尾<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*@param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*@return &#123;BOOL&#125; YES ， NO</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) hasSuffix: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *fileName = <span class="string">@"draft-chapter.pages"</span>;</span><br><span class="line"><span class="keyword">if</span> ([fileName hasPrefix:<span class="string">@"draft"</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"this is a draft."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ([fileName hasSuffix:<span class="string">@".mov"</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"this is a movie"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rangeOfString实例方法"><a href="#rangeOfString实例方法" class="headerlink" title="rangeOfString实例方法"></a>rangeOfString实例方法</h4><blockquote>
<p><strong>说明：</strong>查看字符串的某处是否包含指定子字符串。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; rangeOfString 子字符串</span><br><span class="line">* @return &#123;NSRange&#125; 包含匹配的位置信息和能够匹配上的字符个数</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSRange</span>) rangeOfString: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意位置</span></span><br><span class="line"><span class="built_in">NSRange</span> range = [fileName rangeOfString:<span class="string">@"chapter"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"range.location:%d, range.length: %d"</span>, range.location, range.length);</span><br></pre></td></tr></table></figure>
<h3 id="8-4-7-可变性"><a href="#8-4-7-可变性" class="headerlink" title="8.4.7    可变性"></a>8.4.7    可变性</h3><blockquote>
<p><strong>说明：</strong><code>NSString</code>是不可变（不能通过删除字符或添加字符的方式改变它）。的，<code>NSMutableString</code>是可变的。<br><strong>注意：</strong><code>NSMutableString</code>是<code>NSString</code>的子类。</p>
</blockquote>
<h4 id="stringWithCapacity类方法"><a href="#stringWithCapacity类方法" class="headerlink" title="stringWithCapacity类方法"></a>stringWithCapacity类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个新的<code>NSMutableString</code></p>
<ul>
<li><strong>参数：</strong>字符串的大小并不限于所提供的容量，这个容量仅是最优值，用来预分配一块内存，这样后续操作的速度会快很多。</li>
</ul>
<p><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSInteger&#125; 最优容量</span><br><span class="line">* @return &#123;id&#125; NSMutable对象</span><br><span class="line">*/</span></span><br><span class="line">+ <span class="keyword">id</span> stringWithCapacity: (<span class="built_in">NSUInteger</span>) capacity;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可变字符串对象</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithCapacity: <span class="number">42</span>];</span><br></pre></td></tr></table></figure>
<h4 id="appendString实例方法"><a href="#appendString实例方法" class="headerlink" title="appendString实例方法"></a>appendString实例方法</h4><blockquote>
<p><strong>说明：</strong>接收参数<code>aString</code>，然后将其复制到接收对象的末尾。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; aString 子字符串</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) appendString: (<span class="built_in">NSString</span> *) aString;</span><br></pre></td></tr></table></figure>
<h4 id="appendFormat实例方法"><a href="#appendFormat实例方法" class="headerlink" title="appendFormat实例方法"></a>appendFormat实例方法</h4><blockquote>
<p><strong>说明：</strong>将格式化的字符串附加在接收字符串的末尾<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; format 格式串</span><br><span class="line">* @param &#123;...&#125; 格式串对应的值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) appendFormat: (<span class="built_in">NSString</span> *) format, ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变字符串方法</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> stringWithCapacity:<span class="number">50</span>];</span><br><span class="line">[mString appendString:<span class="string">@"Hello there!"</span>];</span><br><span class="line">[mString appendFormat:<span class="string">@"human %d"</span>, <span class="number">42</span>];</span><br></pre></td></tr></table></figure>
<h4 id="deleteCharactersInRange实例方法"><a href="#deleteCharactersInRange实例方法" class="headerlink" title="deleteCharactersInRange实例方法"></a>deleteCharactersInRange实例方法</h4><blockquote>
<p><strong>说明：</strong>删除字符串中的字符。<br><strong>原型：</strong><code>NSString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSRange&#125; aRange 指定删除的部分坐在的区域</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) deleteCharactersInRange: (<span class="built_in">NSRange</span>) aRange;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可变字符串对象</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *friends = [<span class="built_in">NSMutableString</span> stringWithCapacity: <span class="number">50</span>];</span><br><span class="line"><span class="comment">// 查找子串</span></span><br><span class="line"><span class="built_in">NSRange</span> jackRange = [friends tangeOfString: <span class="string">@"Jack"</span>];</span><br><span class="line">jackRange.length++;<span class="comment">// eat the space that follows</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除"Jack"</span></span><br><span class="line">[friends deleteCharactersInRange: jackRange];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承自NSString的实例方法</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> strringWithFormat: <span class="string">@"jo%dy"</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h2 id="8-5-集合大家族"><a href="#8-5-集合大家族" class="headerlink" title="8.5    集合大家族"></a>8.5    集合大家族</h2><h3 id="8-5-1-NSArray"><a href="#8-5-1-NSArray" class="headerlink" title="8.5.1    NSArray"></a>8.5.1    NSArray</h3><blockquote>
<p><strong>说明：</strong>一个<code>Cocoa</code>类，用来存储对象的有序列表</p>
<ul>
<li>通过<code>工厂方法</code>创建</li>
<li>通过<code>字面量</code>创建（不需要在结尾处不上<code>nil</code>）</li>
</ul>
<p><strong>限制：</strong>有2个限制</p>
<ul>
<li>只能存储<code>Object-C</code>对象，不能存储原始的C语言基础数据类型</li>
<li>不能使用<code>nil（对象的零值）</code></li>
</ul>
<p><strong>技巧：</strong>可以通过一些<code>NSArray</code>的方法避开这些限制<br><strong>注意：</strong>为什么不能在<code>NSArray</code>中存放<code>nil</code>？</p>
<ul>
<li>使用工厂方法创建数组时，最后一个参数<code>nil</code>用来表示参数列表的末尾</li>
<li>没有办法判断<code>nil</code>是存储在数组中的数值还是代表循环结束的标志。</li>
</ul>
</blockquote>
<h4 id="arrayWithObjects类方法"><a href="#arrayWithObjects类方法" class="headerlink" title="arrayWithObjects类方法"></a>arrayWithObjects类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个新的<code>NSArray</code>，可以发送一个以<code>,</code>分隔的对象列表，在列表结尾添加<code>nil</code>代表列表结束。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id ...&#125; 对象列表</span><br><span class="line">* @return &#123;NSArray&#125; 数组</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>) arrayWithObjects(<span class="keyword">id</span> ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过工厂方法创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array2 = @[<span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="objectAtIndex实例方法"><a href="#objectAtIndex实例方法" class="headerlink" title="objectAtIndex实例方法"></a>objectAtIndex实例方法</h4><blockquote>
<p><strong>说明：</strong>索引数组元素。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问数组中的对象</span></span><br><span class="line"><span class="keyword">id</span> *myObject = array1[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (NAInteger i = <span class="number">0</span>; i &lt; [array count]; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过方法索引</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %d has %@."</span>, i, [array1 objectAtIndex:i]);</span><br><span class="line">    <span class="comment">// 通过下标（字面量方式）索引</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %d has %@."</span>, i, array1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切分数组"><a href="#切分数组" class="headerlink" title="切分数组"></a>切分数组</h3><h4 id="componentsSepartedByString实例方法"><a href="#componentsSepartedByString实例方法" class="headerlink" title="componentsSepartedByString实例方法"></a>componentsSepartedByString实例方法</h4><blockquote>
<p><strong>说明：</strong>将字符串切分为数组。</p>
</blockquote>
<h4 id="componentsJoinedByString实例方法"><a href="#componentsJoinedByString实例方法" class="headerlink" title="componentsJoinedByString实例方法"></a>componentsJoinedByString实例方法</h4><blockquote>
<p><strong>说明：</strong>合并<code>NSArray</code>中的元素并创建字符串。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"oop:ack:bork:greeble:poines"</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *chunks = [string componentsSeparatedByString:<span class="string">@":"</span>];</span><br><span class="line">string = [chunks componentsJoinedByString:<span class="string">@":-)"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-2-可变数组"><a href="#8-5-2-可变数组" class="headerlink" title="8.5.2    可变数组"></a>8.5.2    可变数组</h3><blockquote>
<p><strong>说明：</strong><code>NSArray</code>是不可变对象的数组，<code>NSMutableArray</code>是可变数组。<br><strong>注意：</strong>没有可以用来创建<code>NSMutableArray</code>对象的字面量语法。</p>
</blockquote>
<h4 id="arrayWithCapacity类方法"><a href="#arrayWithCapacity类方法" class="headerlink" title="arrayWithCapacity类方法"></a>arrayWithCapacity类方法</h4><blockquote>
<p><strong>说明：</strong>创建新的可变数组。<br><strong>原型：</strong><code>NSMutableString</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSInteger&#125; 容量</span><br><span class="line">* @return &#123;id&#125; 可变数组</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) arrayWithCapacity: (<span class="built_in">NSInteger</span>) numItems;</span><br></pre></td></tr></table></figure>
<h4 id="removeObjectAtIndex实例方法"><a href="#removeObjectAtIndex实例方法" class="headerlink" title="removeObjectAtIndex实例方法"></a>removeObjectAtIndex实例方法</h4><blockquote>
<p><strong>说明：</strong>删除指定索引处的对象。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSUInteger&#125; index 下标</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) removeObjectAtIndex: (<span class="built_in">NSUInteger</span>) index;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-遍历"><a href="#8-5-3-遍历" class="headerlink" title="8.5.3    遍历"></a>8.5.3    遍历</h3><blockquote>
<p><strong>说明：</strong>有<code>4</code>种方式</p>
<ul>
<li>从0到<code>[array count]</code>循环</li>
<li>使用迭代器：<code>NSEnumerator</code></li>
<li>使用快速迭代：<code>for-in</code>（10.5+）</li>
<li>使用代码块（依赖苹果最新的编译器：基于<code>CLang</code>和<code>LLVM</code>项目）</li>
</ul>
</blockquote>
<h4 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h4><blockquote>
<p><strong>说明：</strong>迭代器，<code>Cocoa</code>用它来表示集合中迭代出的对象。</p>
</blockquote>
<h4 id="objectEnumerator实例方法"><a href="#objectEnumerator实例方法" class="headerlink" title="objectEnumerator实例方法"></a>objectEnumerator实例方法</h4><blockquote>
<p><strong>说明：</strong>获取数组对应的迭代器(从前往后迭代)。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSEnumerator *&#125; 迭代器</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)objectEnumerator;</span><br></pre></td></tr></table></figure>
<h4 id="reverseObjectEnumerator实例方法"><a href="#reverseObjectEnumerator实例方法" class="headerlink" title="reverseObjectEnumerator实例方法"></a>reverseObjectEnumerator实例方法</h4><blockquote>
<p><strong>说明：</strong>获取数组对应的迭代器(从后往前迭代)。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSEnumerator *&#125; 迭代器</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)reverseObjectEnumerator;</span><br></pre></td></tr></table></figure>
<h4 id="nextObject实例方法"><a href="#nextObject实例方法" class="headerlink" title="nextObject实例方法"></a>nextObject实例方法</h4><blockquote>
<p><strong>说明：</strong>请求迭代器的下一个对象，返回<code>nil</code>时迭代结束。<br><strong>原型：</strong><code>NSEnumerator</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; 迭代器迭代的一个对象</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) nextObject;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>获取<code>可变数组</code>的迭代器后，如果再通过添加或删除对象<code>改变了数组的容量</code>，枚举起就会出现混乱。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过字面量创建数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"one"</span>, <span class="string">@"two"</span>, <span class="string">@"three"</span>];</span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *enumerator = [array objectEnumerator];</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">id</span> thingie = [enumerator nextObject]) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, thingie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-4-快速迭代"><a href="#8-5-4-快速迭代" class="headerlink" title="8.5.4    快速迭代"></a>8.5.4    快速迭代</h3><blockquote>
<p><strong>说明：</strong>在<code>Mac OS x 10.5</code>，<code>O-C</code>升级到<code>2.0</code>，引入了<code>快速枚举（迭代）</code>，类似一些脚本语言的<code>for-in</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> array) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enumerateObjectsUsingBlock实例方法"><a href="#enumerateObjectsUsingBlock实例方法" class="headerlink" title="enumerateObjectsUsingBlock实例方法"></a>enumerateObjectsUsingBlock实例方法</h4><blockquote>
<p><strong>说明：</strong>为了支持C语言的代码块功能，苹果公司添加了一个能在<code>NSArray</code>中通过<code>代码块</code>迭代对象的方法。<br><strong>优点：</strong>通过代码块可以让循环操作并发执行，而通过快速枚举，执行操作要一项项线性完成。<br><strong>原型：</strong><code>NSArray</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSString *&#125; string 迭代项</span><br><span class="line">* @param &#123;NSUInteger&#125; index 下标</span><br><span class="line">* @param &#123;BOOL *&#125; stop </span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) enumerateObjectUsingBlock:^(<span class="built_in">NSString</span> *string, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *string, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I found %@"</span>, string);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-5-NSDictionary"><a href="#8-5-5-NSDictionary" class="headerlink" title="8.5.5    NSDictionary"></a>8.5.5    NSDictionary</h3><blockquote>
<p><strong>说明：</strong>字典是关键字及其定义的合集。<br><strong>扩展：</strong>字典使用的是键查询的优化方式，可以立即找到要查询的数据，而不需要遍历整个数组。</p>
</blockquote>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><blockquote>
<p><strong>说明：</strong>创建字典最简单的方式就是用字典字面量。<br><strong>语法：</strong><code>@{key: value, ...}</code></p>
</blockquote>
<h4 id="dictionaryWithObjectsAndKeys类方法"><a href="#dictionaryWithObjectsAndKeys类方法" class="headerlink" title="dictionaryWithObjectsAndKeys类方法"></a>dictionaryWithObjectsAndKeys类方法</h4><blockquote>
<p><strong>说明：</strong>创建字典对象<br><strong>原型：</strong><code>NSDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id ...&#125; 键值对列表</span><br><span class="line">* @return &#123;id&#125; 字典对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) dictionaryWithObjectsAndKeys: (<span class="keyword">id</span>) firstObject, ...;</span><br></pre></td></tr></table></figure>
<h4 id="objectForKey实例方法"><a href="#objectForKey实例方法" class="headerlink" title="objectForKey实例方法"></a>objectForKey实例方法</h4><blockquote>
<p><strong>说明：</strong>根据<code>关键字</code>访问字典中的<code>值</code>。<br><strong>原型：</strong><code>NSDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; aKey 键</span><br><span class="line">* @return &#123;id&#125; 值</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">id</span>) objectForKey: (<span class="keyword">id</span>) aKey;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">Tire *t1 = [Tire new];</span><br><span class="line">Tire *t2 = [Tire new];</span><br><span class="line">Tire *t3 = [Tire new];</span><br><span class="line">Tire *t4 = [Tire new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象实例构建字典（工厂方法）</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *tires1 = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: t1, <span class="string">@"front-left"</span>, t2, <span class="string">@"front-right"</span>, t3, <span class="string">@"back-left"</span>, t3, <span class="string">@"back-left"</span>, t4, <span class="string">@"back-right"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 使用对象实例构建字典（字面量）</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *tires2 = @&#123;<span class="string">@"front-left"</span>: t1, <span class="string">@"front-right"</span>: t2, <span class="string">@"back-left"</span>: t3, <span class="string">@"back-right"</span>: t4&#125;;</span><br><span class="line"><span class="comment">// 通过方法索引</span></span><br><span class="line">Tire *tire = [tires objectForKey: <span class="string">@"back-right"</span>];</span><br><span class="line"><span class="comment">// 通过字面量索引</span></span><br><span class="line">tire = tires[<span class="string">@"back-right"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="可变字典"><a href="#可变字典" class="headerlink" title="可变字典"></a>可变字典</h4><blockquote>
<p><strong>说明：</strong><code>NSDictionary</code>容量是不可变的，<code>NSMutableDictionary</code>是可变的。<br><strong>注意：</strong>没有适用于<code>NSMutableDictionary</code>的字面量初始化语法。</p>
</blockquote>
<h5 id="dictionary类方法"><a href="#dictionary类方法" class="headerlink" title="dictionary类方法"></a>dictionary类方法</h5><blockquote>
<p><strong>说明：</strong>创建<code>NSMutableDictionary</code>实例。<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;id&#125; NSMutableDictionary实例</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="keyword">id</span>) dictionary;</span><br></pre></td></tr></table></figure>
<h5 id="dictionaryWithCapacity类方法"><a href="#dictionaryWithCapacity类方法" class="headerlink" title="dictionaryWithCapacity类方法"></a>dictionaryWithCapacity类方法</h5><blockquote>
<p><strong>说明：</strong>创建新的可变字典并告诉<code>Cocoa</code>该字典的最优大小。<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;NSUInteger&#125; numItems 最优容量</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) dictionaryWithCapacity: (<span class="built_in">NSUInteger</span>) numItems;</span><br></pre></td></tr></table></figure>
<h5 id="setObject实例方法"><a href="#setObject实例方法" class="headerlink" title="setObject实例方法"></a>setObject实例方法</h5><blockquote>
<p><strong>说明：</strong>为字典添加（设置）元素<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; anObject 值</span><br><span class="line">* @param &#123;id&#125; aKey  键</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) setObject: (<span class="keyword">id</span>)anObject forKey: (<span class="keyword">id</span>)aKey;</span><br></pre></td></tr></table></figure>
<h5 id="removeObjectForKey实例方法"><a href="#removeObjectForKey实例方法" class="headerlink" title="removeObjectForKey实例方法"></a>removeObjectForKey实例方法</h5><blockquote>
<p><strong>说明：</strong>在可变字典中删除元素<br><strong>原型：</strong><code>NSMutableDictionary</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;id&#125; aKey 要删除的元素的键</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>) removeObjectForKey: (<span class="keyword">id</span>) aKey;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可变字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *tires = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">Tire *t1 = [Tire new];</span><br><span class="line">Tire *t2 = [Tire new];</span><br><span class="line">Tire *t3 = [Tire new];</span><br><span class="line">Tire *t4 = [Tire new];</span><br><span class="line"><span class="comment">// 为字典添加元素</span></span><br><span class="line">[tires setObject: t1 forKey: <span class="string">@"front-left"</span>];</span><br><span class="line">[tires setObject: t2 forKey: <span class="string">@"front-right"</span>];</span><br><span class="line">[tires setObject: t3 forKey: <span class="string">@"back-left"</span>];</span><br><span class="line">[tires setObject: t4 forKey: <span class="string">@"back-right"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">[tires removeObjectForKey: <span class="string">@"back-left"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-5-6-请不要乱来"><a href="#8-5-6-请不要乱来" class="headerlink" title="8.5.6    请不要乱来"></a>8.5.6    请不要乱来</h3><blockquote>
<p><strong>类蔟：</strong>一群隐藏在通用接口之下与实现相关的类。<br><strong>说明：</strong>在<code>Cocoa</code>中，许多类实际上是以<code>类蔟</code>的方式实现。比如，创建<code>NSString</code>对象时，实际上获得的可能是<code>NSLiteralString</code>、<code>NSCFString</code>、<code>NSSimpleCString</code>、<code>NSBallOfString</code>或者其他未写入文档的与实现相关的对象。<br><strong>技巧：</strong>不要尝试给一个<code>类蔟</code>创建子类，可以将<code>NSString</code>或<code>NSArray</code>复合到某个类中或者使用别类。</p>
</blockquote>
<h2 id="8-6-其他数值"><a href="#8-6-其他数值" class="headerlink" title="8.6    其他数值"></a>8.6    其他数值</h2><blockquote>
<p><strong>说明：</strong><code>NSArray</code>和<code>NSDictionary</code>只能存储对象，而不能直接存储任何基本类型的数据，如<code>int</code>、<code>float</code>和<code>struct</code>。<br><strong>技巧：</strong>可以用对象封装基本数据类型，然后再放入<code>NSArray</code>或<code>NSDictionary</code>。<br><strong>注意：</strong><code>Objective-C</code>不支持<code>自动开箱</code>和<code>自动装箱</code>。</p>
</blockquote>
<h3 id="8-6-1-NSNumber"><a href="#8-6-1-NSNumber" class="headerlink" title="8.6.1    NSNumber"></a>8.6.1    NSNumber</h3><blockquote>
<p><strong>说明：</strong>可以用来封装和数字相关的一些基本数据类型。<br><strong>工厂方法：</strong>以最常用的为例</p>
<ul>
<li><code>+ (NSNumber *) numberWithChar: (char) value;</code></li>
<li><code>+ (NSNumber *) numberWithInt: (int) value;</code></li>
<li><code>+ (NSNumber *) numberWithFloat: (float) value;</code></li>
<li><code>+ (NSNumber *) numberWithBool: (BOOL) value;</code></li>
</ul>
<p><strong>实例方法：</strong>从<code>NSNumber</code>中提取数值</p>
<ul>
<li><code>- (char) charValue</code></li>
<li><code>- (int) intValue</code></li>
<li><code>- (float) floatValue</code></li>
<li><code>- (BOOL) boolValue</code></li>
<li><code>- (NSString *) stringValue</code></li>
</ul>
<p><strong>字面量：</strong>可以使用字面量语法创建<code>NSNumber</code>对象</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装几本类型</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number;</span><br><span class="line">number = @<span class="string">'X'</span>;<span class="comment">// 字符型</span></span><br><span class="line">number = @<span class="number">12345</span>;<span class="comment">// 整型</span></span><br><span class="line">number = @<span class="number">12345</span>ul;<span class="comment">// 无符号长整数</span></span><br><span class="line">number = @<span class="number">12345</span>ll;<span class="comment">// long long</span></span><br><span class="line">number = @<span class="number">123</span>,<span class="number">45</span>f;<span class="comment">// 浮点型</span></span><br><span class="line">number = @<span class="number">123</span>,<span class="number">45</span>;<span class="comment">// 双浮点型</span></span><br><span class="line">number = @YES;<span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity];</span><br><span class="line"><span class="comment">// 存储到数组中</span></span><br><span class="line">[array addObject number];</span><br><span class="line">[dictionary setObject: number forKey: @:<span class="string">"Bork"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="8-6-2-NSValue"><a href="#8-6-2-NSValue" class="headerlink" title="8.6.2    NSValue"></a>8.6.2    NSValue</h3><blockquote>
<p><strong>说明：</strong><code>NSValue</code>可以封装任意值。<br><strong>扩展：</strong><code>NSNumber</code>是<code>NSValue</code>的子类。</p>
</blockquote>
<h4 id="valueWithBytes类方法"><a href="#valueWithBytes类方法" class="headerlink" title="valueWithBytes类方法"></a>valueWithBytes类方法</h4><blockquote>
<p><strong>说明：</strong>创建新的<code>NSValue</code>对象。<br><strong>原型：</strong><code>NSValue</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;const void *&#125; value 要存储的变量的地址</span><br><span class="line">* @param &#123;const char *&#125; type 描述数据类的字符串</span><br><span class="line">* @return &#123;NSValue *&#125; NSValue对象</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSValue</span> *) valueWithBytes: (<span class="keyword">const</span> <span class="keyword">void</span> *) value objCType: (<span class="keyword">const</span> <span class="keyword">char</span> *) type;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>工厂方法：</strong><code>NSValue</code>，举例</p>
<ul>
<li><code>(NSValue *)valueWithPoint: (NSPoint) aPoint;</code></li>
<li><code>(NSValue *)valueWithSize: (NSSize) size;</code></li>
<li><code>(NSValue *)valueWithRect: (NSRect);</code></li>
</ul>
<p><strong>实例方法：</strong><code>NSValue</code>, 会进行类型转换</p>
<ul>
<li><code>(NSPoint)pointValue;</code></li>
<li><code>(NSSize)sizeValue;</code></li>
<li><code>(NSRect)rectValue;</code></li>
</ul>
</blockquote>
<h4 id="getValue实例方法"><a href="#getValue实例方法" class="headerlink" title="getValue实例方法"></a>getValue实例方法</h4><blockquote>
<p><strong>说明：</strong>提取数值，返回一个<code>NSValue</code>型值。<br><strong>注意：</strong>方法名中使用了<code>get</code>，表明我们提供的是一个指针，而指针所指向的空间则用来存储该方法生成的数据。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象（struct）</span></span><br><span class="line"><span class="built_in">NSRect</span> rect = <span class="built_in">NSMakeRect</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">// 包装包NSValue型值中</span></span><br><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithBytes:&amp;rect objCType:@encode(<span class="built_in">NSRect</span>)];</span><br><span class="line"><span class="comment">// 添加到数组中</span></span><br><span class="line">[array addObject:value];</span><br><span class="line">value = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 提取数值</span></span><br><span class="line">[value getValue:&amp;rect];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疯转NSRect</span></span><br><span class="line">value = [<span class="built_in">NSValue</span> valueWithRect:rect];</span><br><span class="line"><span class="comment">// 添加到数组</span></span><br><span class="line">[array addObject:value];</span><br><span class="line"><span class="comment">// 提取NSRect型值</span></span><br><span class="line"><span class="built_in">NSRect</span> anotherRect = [value rectValue];</span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-NSNull"><a href="#8-6-3-NSNull" class="headerlink" title="8.6.3    NSNull"></a>8.6.3    NSNull</h3><blockquote>
<p><strong>说明：</strong>集合中不能放入<code>nil</code>，但可以放入<code>NSNull</code>。</p>
</blockquote>
<h4 id="null类方法"><a href="#null类方法" class="headerlink" title="null类方法"></a>null类方法</h4><blockquote>
<p><strong>说明：</strong>创建一个<code>NSNull</code>实例<br><strong>原型：</strong><code>NSNull</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;NSNull *&#125; NSNull实例</span><br><span class="line">*/</span></span><br><span class="line">+ (<span class="built_in">NSNull</span> *) null;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想通讯录中加入一条信息（没有传真号）</span></span><br><span class="line">[contact setObject: [<span class="built_in">NSNull</span> null] forKey: <span class="string">@"home fax machine"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引这条信息</span></span><br><span class="line"><span class="keyword">id</span> homefax = [contact objectForKey: <span class="string">@"home fax machine"</span>];</span><br><span class="line"><span class="keyword">if</span> (homefax == [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">	<span class="comment">// 确实没有传真机</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-7-示例：查找文件"><a href="#8-7-示例：查找文件" class="headerlink" title="8.7    示例：查找文件"></a>8.7    示例：查找文件</h2><h3 id="8-7-1-使用迭代器的版本"><a href="#8-7-1-使用迭代器的版本" class="headerlink" title="8.7.1    使用迭代器的版本"></a>8.7.1    使用迭代器的版本</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建文件管理器</span></span><br><span class="line">        <span class="built_in">NSFileManager</span> *manager;</span><br><span class="line">        manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将~替换为相应的绝对目录</span></span><br><span class="line">        <span class="built_in">NSString</span> *home;</span><br><span class="line">        home = [<span class="string">@"~"</span> stringByExpandingTildeInPath];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取相应路径下文件集合的迭代器</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *direnum;</span><br><span class="line">        direnum = [manager enumeratorAtPath:home];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建存放文件的可变数组</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *files;</span><br><span class="line">        files = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">42</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过迭代器遍历寻找目标文件</span></span><br><span class="line">        <span class="built_in">NSString</span> *filename;</span><br><span class="line">        <span class="keyword">while</span> (filename = [direnum nextObject])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看扩展名是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> ([[filename pathExtension] isEqualTo: <span class="string">@"jpg"</span>]) &#123;</span><br><span class="line">                [files addObject: filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过迭代器遍历匹配到的文件的文件名</span></span><br><span class="line">        <span class="built_in">NSEnumerator</span> *fileenum;</span><br><span class="line">        fileenum = [files objectEnumerator];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (filename = [fileenum nextObject])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-7-2-使用快速迭代的版本"><a href="#8-7-2-使用快速迭代的版本" class="headerlink" title="8.7.2    使用快速迭代的版本"></a>8.7.2    使用快速迭代的版本</h3><blockquote>
<p><strong>说明：</strong>不支持<code>Leopard</code>之前的版本。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8    小结"></a>8.8    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_07  深入了解Xcode/" itemprop="url">
                  7 深入了解Xcode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:28+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_07  深入了解Xcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_07  深入了解Xcode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="7-1-窗口布局一览"><a href="#7-1-窗口布局一览" class="headerlink" title="7.1    窗口布局一览"></a>7.1    窗口布局一览</h2><blockquote>
<p><strong>说明：</strong>窗口的组成部分</p>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
<th>相关功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>工具栏</td>
<td>位于窗口的最顶端</td>
<td>上面由很多工具按钮</td>
</tr>
<tr>
<td>导航器面板</td>
<td>位于窗口的左边，通常用来显示项目中的文件列表，也可以浏览其他内容</td>
<td>符号(symbol)、搜索(Search)、问题(Issue)、调试(Debug)、断点(BreakPoints)、和日志(Logs)</td>
</tr>
<tr>
<td>编辑器面板</td>
<td>卫浴中间偏右的位置</td>
<td>大部分时间都在这里工作</td>
</tr>
<tr>
<td>检查器面板</td>
<td>位于窗口右边</td>
<td>显示的是与上下文有关的信息，以及修改选中项属性值的按钮</td>
</tr>
<tr>
<td>调试器面板</td>
<td>位于底部居中位置</td>
<td>调试器运行的时候，堆栈和调试器控制器会出现在这里</td>
</tr>
<tr>
<td>库面板</td>
<td>隐藏在窗口右下角</td>
<td>列有项目资源、对象、代码片段和其他在项目中可能会用到的东西</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-03%20%E4%B8%8B%E5%8D%8810.16.15.png" alt="Alt text"></p>
<h2 id="7-2-改变公司名称"><a href="#7-2-改变公司名称" class="headerlink" title="7.2    改变公司名称"></a>7.2    改变公司名称</h2><blockquote>
<p><strong>说明：</strong>公司的名称会出现在创建文件时自动生成的注释中。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-04%20%E4%B8%8A%E5%8D%8810.02.06.png" alt="Alt text"></p>
</blockquote>
<h2 id="7-3-使用编辑器的技巧"><a href="#7-3-使用编辑器的技巧" class="headerlink" title="7.3    使用编辑器的技巧"></a>7.3    使用编辑器的技巧</h2><blockquote>
<p><strong>说明：</strong>列举一下不同区域的使用的技巧<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-03%20%E4%B8%8B%E5%8D%8810.16.15.png" alt="Alt text"></p>
</blockquote>
<h3 id="7-3-1-导航器面板"><a href="#7-3-1-导航器面板" class="headerlink" title="7.3.1    导航器面板"></a>7.3.1    导航器面板</h3><blockquote>
<ol>
<li>导航器视图中使用<code>过滤搜索框</code>过滤列表文件（可以在任意导航器视图中使用）</li>
<li>双击源文件在新窗口中打开它</li>
</ol>
</blockquote>
<h3 id="7-3-2-工具栏"><a href="#7-3-2-工具栏" class="headerlink" title="7.3.2    工具栏"></a>7.3.2    工具栏</h3><blockquote>
<ol>
<li>右上方有一组标记为View的工具栏按钮，用来显示／隐藏部分窗口</li>
</ol>
</blockquote>
<h3 id="7-3-2-其它"><a href="#7-3-2-其它" class="headerlink" title="7.3.2    其它"></a>7.3.2    其它</h3><blockquote>
<ol>
<li>窗口顶端的工具栏下面看文件的路径</li>
<li>在多个标签页中打开多个视图：View(菜单) -&gt; Show Tab Bar -&gt; +</li>
</ol>
</blockquote>
<h2 id="7-4-在Xcode的帮助下编写代码"><a href="#7-4-在Xcode的帮助下编写代码" class="headerlink" title="7.4    在Xcode的帮助下编写代码"></a>7.4    在Xcode的帮助下编写代码</h2><h3 id="7-4-1-首行缩进（美观排版）"><a href="#7-4-1-首行缩进（美观排版）" class="headerlink" title="7.4.1    首行缩进（美观排版）"></a>7.4.1    首行缩进（美观排版）</h3><blockquote>
<p><strong>说明：</strong><code>O-C</code>并不要求缩进代码，但这么做是个好习惯。</p>
</blockquote>
<table>
<thead>
<tr>
<th>整理缩进</th>
<th>快捷键</th>
<th>菜单</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动整理缩进</td>
<td>Control + I</td>
<td>右键（代码编辑区）-&gt; Structure -&gt; Re Indent</td>
</tr>
<tr>
<td>向左缩进</td>
<td>Command + [</td>
<td>右键（代码编辑区）-&gt; Structure -&gt; Shift Right</td>
</tr>
<tr>
<td>向右缩进</td>
<td>Command + [</td>
<td>左键（代码编辑区）-&gt; Structure -&gt; Shift Left</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>扩展：</strong>设置<code>自动整理</code>的风格：Xcode(菜单) -&gt; Preferences -&gt; Text Editing -&gt; Indentation</p>
</blockquote>
<h3 id="7-4-2-代码自动完成"><a href="#7-4-2-代码自动完成" class="headerlink" title="7.4.2    代码自动完成"></a>7.4.2    代码自动完成</h3><blockquote>
<p><strong>说明：</strong>当输入代码时，Xcode 会不断地比较你输入的代码和它生成的符号索引，如果两者匹配，Xcode就会给出建议。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关快捷键</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Control + .(半角句号)</td>
<td>使推荐列表向后翻页</td>
</tr>
<tr>
<td>Shift + Control + .(半角句号)</td>
<td>使推荐列表向前翻页</td>
</tr>
<tr>
<td>esc</td>
<td>切换推荐列表的显示和隐藏</td>
</tr>
<tr>
<td>tap(或Enter)</td>
<td>使用推荐列表中高，亮的推荐项</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong></p>
<ol>
<li>查看对象或类可用消息：<code>[对象或类 + 空格 + esc键</code></li>
<li>打开推荐列表中推荐方法的迷你帮助窗口：将鼠标悬停在推荐列表中的方法名上，便会看法哦窗口右边由一个<code>?</code>，点击它</li>
</ol>
</blockquote>
<h3 id="7-4-3-括号配对"><a href="#7-4-3-括号配对" class="headerlink" title="7.4.3    括号配对"></a>7.4.3    括号配对</h3><blockquote>
<p><strong>说明：</strong>输入某些<code>闭括号</code>（比如<code>)、}、]</code>）时，如果匹配到对应的<code>开括号</code>，屏幕会闪烁。如果没有正确闭合，<code>Xcode</code>会发出警报声。这个功能叫做<code>括号配对</code>。<br><strong>技巧：</strong>双击某个<code>分隔符</code>，<code>Xcode</code>会选定它以及与它匹配的货号之间的全部代码。</p>
</blockquote>
<h3 id="7-4-4-批量编辑"><a href="#7-4-4-批量编辑" class="headerlink" title="7.4.4    批量编辑"></a>7.4.4    批量编辑</h3><blockquote>
<p><strong>注意：</strong>批量操作是一件危险的操作，因此可以先创建一个<code>快照</code>用来恢复项目，但是<code>Xcode7</code>已经将此功能移除。</p>
</blockquote>
<h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><blockquote>
<p><strong>说明：</strong><code>Edit -&gt; Find</code>子菜单中包含几个非常方便的选项</p>
</blockquote>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find in Workspace…</td>
<td>Command + Shift + F</td>
<td>在当前工作区中搜索</td>
</tr>
<tr>
<td>Find and Replace in Workspace…</td>
<td>Command + Alt + Shift + F</td>
<td>在当前工作区中搜索并替换</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>缺点：</strong>对于一些替换任务，查找和替换的功能并不好用</p>
<ul>
<li>修改的过于彻底，比如只想重命名函数中的变量，但事实上整个文件中的变量名都被修改了</li>
<li>不能修改文件名（修改类需要同时修改文件名）</li>
</ul>
</blockquote>
<h4 id="Edit-all-in-Scope"><a href="#Edit-all-in-Scope" class="headerlink" title="Edit all in Scope"></a>Edit all in Scope</h4><blockquote>
<p><strong>说明：</strong>在范围内编辑全部内容。</p>
<ol>
<li>在编辑器中选中要修改的<code>标记名</code></li>
<li>点击它，右边出现一个向下的箭头，点击箭头出现一个菜单</li>
<li>选择菜单，选择Edit all in Scope</li>
</ol>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%888.14.05.png" alt="Alt text"><br><strong>注意：</strong>如果Xcode中的语法高亮功能被关闭或改动很多，<code>Edit in all Scope</code>功能也许就会拒绝工作</p>
</blockquote>
<h4 id="Xcode内置的重构工具"><a href="#Xcode内置的重构工具" class="headerlink" title="Xcode内置的重构工具"></a>Xcode内置的重构工具</h4><blockquote>
<p><strong>说明：</strong>不仅能重命名类，还能重命名相应源文件。</p>
<ol>
<li>打开存在要修改的类名的文件，将光标放到类名中</li>
<li>Edit(菜单)-&gt;Refactor-&gt;Rename</li>
</ol>
<p><strong>注意：</strong>重构不能重命名注释中的文字。所以，<code>类里面的注释</code>、<code>Xcode生成的文件头注释</code>或者任何你编写的<code>文档注释</code>都需要手工编辑（可以通过查找和替换简化这一过程）。</p>
</blockquote>
<h3 id="7-4-5-代码导航"><a href="#7-4-5-代码导航" class="headerlink" title="7.4.5    代码导航"></a>7.4.5    代码导航</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><blockquote>
<p><strong>说明：</strong>源自<code>emacs</code>，同时适用于Xcode、TextEdit、Safari的地址栏和文本域、Pages和Keynote文本域。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%888.44.02.png" alt="Alt text"></p>
</blockquote>
<h4 id="快速打开"><a href="#快速打开" class="headerlink" title="快速打开"></a>快速打开</h4><blockquote>
<p><strong>说明：</strong>大致有2种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>用途</th>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>项目文件搜索</td>
<td>File(菜单)-&gt;Open Quickly</td>
<td>Command + Shift + D</td>
</tr>
<tr>
<td>辅助窗口（默认打开当前文件对应的<code>.m</code>文件或<code>.h</code>文件）</td>
<td>View(菜单)-&gt;Assistant Editor-&gt;Show Assistant Editor</td>
<td><strong>打开：</strong>Command + alt + Enter  <strong>关闭：</strong>Command + Enter</td>
</tr>
</tbody>
</table>
<h3 id="7-4-6-集中精力"><a href="#7-4-6-集中精力" class="headerlink" title="7.4.6    集中精力"></a>7.4.6    集中精力</h3><blockquote>
<p><strong>说明：</strong><code>边栏（gutter）</code>和<code>聚焦栏（focus ribbon）</code></p>
</blockquote>
<table>
<thead>
<tr>
<th><em>**</em></th>
<th>说明</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>边栏</td>
<td>代码调试</td>
</tr>
<tr>
<td>聚焦栏</td>
<td>代码折叠</td>
<td><strong>显示聚焦栏：</strong><code>Xcode(菜单)-&gt;Preferences...-&gt;Text Editing-&gt;勾选Code folding ribbon</code>；<strong>更多代码折叠操作：</strong><code>Editor-&gt;Code Folding</code></td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%20%E4%B8%8A%E5%8D%889.13.08.png" alt="Alt text"></p>
<h3 id="7-4-7-使用导航条"><a href="#7-4-7-使用导航条" class="headerlink" title="7.4.7    使用导航条"></a>7.4.7    使用导航条</h3><blockquote>
<p><strong>说明：</strong>里面的很多空间可以让你在项目中的原文件之间快速切换。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2011.05.05.png" alt="Alt text"></p>
</blockquote>
<h4 id="pragma指令"><a href="#pragma指令" class="headerlink" title="#pragma指令"></a><code>#pragma</code>指令</h4><blockquote>
<p><strong>说明：</strong>可以将<code>O-C</code>常规代码之外的一些信息或说明传递给编译器和代码编辑器。</p>
<ul>
<li><code>#pragma mark 说明</code>：添加标记到功能菜单</li>
<li><code>#pragma mark -</code>：在菜单中插入一条分割线</li>
</ul>
</blockquote>
<h4 id="注释中使用特殊字符"><a href="#注释中使用特殊字符" class="headerlink" title="注释中使用特殊字符"></a>注释中使用特殊字符</h4><blockquote>
<p><strong>说明：</strong>会将相应的注释信息放入功能菜单中，类似<code>#pragma mark</code>的效果。例如：</p>
<ul>
<li><code>MARK:说明</code></li>
<li><code>TODO:说明</code></li>
<li><code>FIXME:说明</code></li>
<li><code>!!!:说明</code></li>
<li><code>???:说明</code></li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2013.13.37.png" alt="Alt text"></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#pragma mark 初始化父类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        <span class="comment">// MARK:初始化实例属性</span></span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125; <span class="comment">// init</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-8-获取信息"><a href="#7-4-8-获取信息" class="headerlink" title="7.4.8    获取信息"></a>7.4.8    获取信息</h3><h4 id="7-4-8-1-获得帮助"><a href="#7-4-8-1-获得帮助" class="headerlink" title="7.4.8.1    获得帮助"></a>7.4.8.1    获得帮助</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-05%2013.52.23.png" alt="Alt text"></p>
<h4 id="7-4-8-2-文档管理程序"><a href="#7-4-8-2-文档管理程序" class="headerlink" title="7.4.8.2    文档管理程序"></a>7.4.8.2    文档管理程序</h4><blockquote>
<p><strong>说明：</strong>访问苹果官方API文档有以下方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>情景</th>
<th>操作</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>quick search</td>
<td>option + 单击某个标记</td>
<td>只弹出一个包含概要信息的帮助窗口</td>
</tr>
<tr>
<td>在文档浏览窗口查看相应文档</td>
<td>option + 双击某个标记（或 将光标移动到标记內  + control + option + command + /）</td>
</tr>
</tbody>
</table>
<h2 id="7-5-调试"><a href="#7-5-调试" class="headerlink" title="7.5    调试"></a>7.5    调试</h2><h3 id="7-5-1-暴力测试"><a href="#7-5-1-暴力测试" class="headerlink" title="7.5.1    暴力测试"></a>7.5.1    暴力测试</h3><blockquote>
<p><strong>说明：</strong>在程序中写入语句（如<code>NSLog</code>）来输出程序中的控制流程和一些数据值。</p>
</blockquote>
<h3 id="7-5-2-Xcode的调试器"><a href="#7-5-2-Xcode的调试器" class="headerlink" title="7.5.2    Xcode的调试器"></a>7.5.2    Xcode的调试器</h3><blockquote>
<p><strong>调试器：</strong>位于程序和操作系统之间的程序，能够</p>
<ul>
<li>中断程序，这样就可以检查程序的数据，甚至修改程序，然后恢复程序并查看运行结果</li>
<li>可以单步执行代码，减缓程序运行的速度，细致地查看代码会对数据进行哪些改动</li>
</ul>
<p><strong>调试窗口：</strong>可以提供大量概述信息<br><strong>调试控制台：</strong>可以直接向调试器发送调试命令的调试控制台。<br><strong>说明：</strong>调试窗口可以选择两种调试器，<code>GDB</code>和<code>LLDB</code>，区别主要是精细度和内联性。</p>
<ul>
<li><strong>GDB：</strong>GNU计划的一部分，可以在各种平台上兼容，享誉已久</li>
<li><strong>LLDB：</strong>LLVM计划多个Xcode工具中的一员</li>
</ul>
</blockquote>
<h3 id="7-5-3-精巧的调试符号"><a href="#7-5-3-精巧的调试符号" class="headerlink" title="7.5.3    精巧的调试符号"></a>7.5.3    精巧的调试符号</h3><blockquote>
<p><strong>说明：</strong>调试程序时可以让编译器发出额外的调试符号，可以使用Debug构建配置（Product-&gt;Schema-&gt;Edit Schema）。</p>
</blockquote>
<h3 id="7-5-4-开始调试"><a href="#7-5-4-开始调试" class="headerlink" title="7.5.4    开始调试"></a>7.5.4    开始调试</h3><blockquote>
<p><strong>说明：</strong>使用GUI比命令行进行调试更加容易一些</p>
<ol>
<li>设置断点</li>
<li>运行程序</li>
<li>调试</li>
</ol>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8A%E5%8D%8810.52.03.png" alt="Alt text"></p>
<h3 id="7-5-5-检查程序"><a href="#7-5-5-检查程序" class="headerlink" title="7.5.5    检查程序"></a>7.5.5    检查程序</h3><blockquote>
<p><strong>说明：</strong>在调试状态下，将鼠标放在变量名上时，会弹出一个<code>显示</code>当前数值信息的弹出窗，点击里面的值还可以<code>修改</code>当前值。</p>
</blockquote>
<h2 id="7-6-备忘表"><a href="#7-6-备忘表" class="headerlink" title="7.6    备忘表"></a>7.6    备忘表</h2><blockquote>
<p><strong>说明：</strong>Xcode键盘快捷键<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8B%E5%8D%8812.14.31.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-06%20%E4%B8%8B%E5%8D%8812.15.11.png" alt="Alt text"></p>
</blockquote>
<h2 id="7-7-小结"><a href="#7-7-小结" class="headerlink" title="7.7    小结"></a>7.7    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_06  源文件组织/" itemprop="url">
                  6 源文件组织
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:38:06+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_06  源文件组织/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_06  源文件组织/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>将程序拆分为多个小文件有助于更快地找到重要的代码。</p>
</blockquote>
<h2 id="6-1-拆分接口与实现"><a href="#6-1-拆分接口与实现" class="headerlink" title="6.1    拆分接口与实现"></a>6.1    拆分接口与实现</h2><blockquote>
<p><strong>说明：</strong>接口放在<code>.h</code>文件，实现放在<code>.m</code>文件。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件</th>
<th>存放代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>头文件(.h)</td>
<td>类的<code>@interface</code>指令、公共<code>struct</code>定义、<code>enum</code>常量、<code>#defines</code>和<code>extern</code>全局变量等</td>
</tr>
<tr>
<td>和类同名的.m(或.mm)文件</td>
<td>类的<code>@implementation</code>指令、全局变量的定义、私有struct等</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>如果用<code>.mm</code>做文件扩展名，编译器就会认为你是用<code>Objective-C++</code>（同时使用<code>C++</code>和<code>Objective-C</code>）编写的代码</p>
</blockquote>
<h3 id="在Xcode中创建新文件"><a href="#在Xcode中创建新文件" class="headerlink" title="在Xcode中创建新文件"></a>在Xcode中创建新文件</h3><blockquote>
<p><strong>说明：</strong>创建包含类的文件</p>
<ol>
<li>File（菜单）-&gt; New -&gt; File…</li>
<li>选择模版：ios -&gt; Source -&gt; Cocoa Class</li>
<li>填写类名</li>
<li>选择父类（默认NSObject）</li>
<li>选择群组和目标</li>
<li>选择存储位置并保存</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>群组（Group）</td>
<td>文件都放在群组内的文件夹中，将代码分组存放可以帮助组织项目中的源文件</td>
<td><code>1.</code> 设置群组时，Xcode并不会在硬盘上移动文件或者创建目录，群组关系仅仅是Xcode负责管理的一项奇妙的功能；<code>2.</code> 可以设置群组指向文件系统中某个特定的目录，Xcode会新建的文件放入该目录中</td>
</tr>
<tr>
<td>目标（Target）</td>
<td>复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同</td>
</tr>
</tbody>
</table>
<h2 id="6-2-拆分-Car-程序"><a href="#6-2-拆分-Car-程序" class="headerlink" title="6.2    拆分 Car 程序"></a>6.2    拆分 Car 程序</h2><blockquote>
<p><strong>说明：</strong>每个类都由头文件（<code>.h</code>）和实现文件（<code>.m</code>）组成，入口在<code>main.m</code></p>
<ul>
<li><strong>头文件（<code>.h</code>文件）：</strong>通过<code>import</code>引入模块的过程放在头文件</li>
<li><strong>实现文件（<code>.m</code>文件）：</strong>文件中需要引入相应的头文件（<code>.h</code>）文件</li>
</ul>
<p><strong>技巧：</strong>复合的程序文件中使用了其它类，如果只是通过指针引用了相应的类实例，可以用<code>@class</code>声明引用的类而不需要<code>import</code>，从而提升重新编译时的性能。</p>
<p><strong>导入文件：</strong><code>import</code>文件有两种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>导入</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#import &quot;文件&quot;</code></td>
<td>导入项目本地的头文件</td>
</tr>
<tr>
<td><code>#import &lt;文件&gt;</code></td>
<td>导入系统文件（只读）</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 6.2\ CarPaers-Split<span class="comment"># 存放代码的群组</span></span><br><span class="line">│   ├── AllWeatherRadial.h</span><br><span class="line">│   ├── AllWeatherRadial.m</span><br><span class="line">│   ├── Car.h</span><br><span class="line">│   ├── Car.m</span><br><span class="line">│   ├── Engine.h</span><br><span class="line">│   ├── Engine.m</span><br><span class="line">│   ├── Slant6.h</span><br><span class="line">│   ├── Slant6.m</span><br><span class="line">│   ├── Tire.h</span><br><span class="line">│   ├── Tire.m</span><br><span class="line">│   └── main.m<span class="comment"># 入口文件</span></span><br><span class="line">└── 6.2\ CarPaers-Split.xcodeproj</span><br><span class="line">    ├── project.pbxproj</span><br><span class="line">    └── xcuserdata</span><br><span class="line">        └── tonyearth.xcuserdatad</span><br></pre></td></tr></table></figure>
<h2 id="6-3-使用快文件依赖关系"><a href="#6-3-使用快文件依赖关系" class="headerlink" title="6.3    使用快文件依赖关系"></a>6.3    使用快文件依赖关系</h2><blockquote>
<p><strong>说明：</strong>依赖关系可以存在于两个或多个文件之间，并且具有传递性，如果其中一个文件发生变化，其它文件都会被重新编译。</p>
</blockquote>
<h3 id="6-3-1-重新编译须知"><a href="#6-3-1-重新编译须知" class="headerlink" title="6.3.1    重新编译须知"></a>6.3.1    重新编译须知</h3><blockquote>
<p><strong>说明：</strong>文件导入过于混乱会延长编译时间，也会导致不必要的重复编译，可以通过<code>@class</code>减少必需导入的头文件的数量，从而可以缩短编译时间。</p>
</blockquote>
<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><blockquote>
<p><strong>说明：</strong>创建一个前向引导，用在程序不需要知道类的所有信息的场景（比如创建了相应的变量，但没有向变量发送消息）。<br><strong>技巧：</strong>如果试图通过<code>#import</code>语句让两个类相互引用，那么就会出现编译错误，可以用<code>@class</code>替代。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Tire</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">         atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-让汽车跑一会儿"><a href="#6-3-2-让汽车跑一会儿" class="headerlink" title="6.3.2    让汽车跑一会儿"></a>6.3.2    让汽车跑一会儿</h3><p><em>Car.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Tire.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Tire *tires[<span class="number">4</span>];</span><br><span class="line">    Engine *engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line"></span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">    engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">         atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tires[index] = tire;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">               index);</span><br><span class="line">        exit (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (tires[index]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-导入和继承"><a href="#6-3-3-导入和继承" class="headerlink" title="6.3.3    导入和继承"></a>6.3.3    导入和继承</h3><blockquote>
<p><strong>说明：</strong>如果当前的文件头文件中的类会<code>继承</code>要引入的类，则不能通过<code>@class</code>引入，因为编译器需要知道父类中实例变量的完整信息。</p>
</blockquote>
<p><em>Slant6.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Slant6</span> : <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4    小结"></a>6.4    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_05  复合/" itemprop="url">
                  5 复合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:37:38+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_05  复合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_05  复合/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>建立类之间的关系除了<code>继承</code>还有<code>复合</code></p>
</blockquote>
<h2 id="5-1-什么是复合"><a href="#5-1-什么是复合" class="headerlink" title="5.1    什么是复合"></a>5.1    什么是复合</h2><blockquote>
<p><strong>说明：</strong>使用复合可组合多个对象，让它们分工协作<br><strong>原理：</strong>在<code>0-C</code> 中，复合是通过包含作为实例变量的对象指针实现的。</p>
</blockquote>
<h2 id="5-2-自定义NSLog"><a href="#5-2-自定义NSLog" class="headerlink" title="5.2    自定义NSLog()"></a>5.2    自定义NSLog()</h2><blockquote>
<p><strong>说明：</strong>在类中提供<code>description方法</code>就可以自定义<code>NSLog()</code>会如何输出对象。</p>
</blockquote>
<h3 id="在init中初始化实例属性"><a href="#在init中初始化实例属性" class="headerlink" title="在init中初始化实例属性"></a>在init中初始化实例属性</h3><blockquote>
<p><strong>说明：</strong>使用<code>new</code>创建新对象时后台进行了两步</p>
<ol>
<li>为对象分配内存，用来存放<code>实例变量</code>（如果实例属性是对象，被初始化为<code>nil</code>）</li>
<li>自动调用<code>init方法</code>，之后对象进入可用状态</li>
</ol>
<p><strong>扩展：</strong>在<code>init方法中</code>使用<code>if (self = [super init])</code>是为了完成父类的初始化并确保父类返回的对象和一开始创建的对象是一致的。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Engine *engine;</span><br><span class="line">    Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        engine = [Engine new];</span><br><span class="line">        </span><br><span class="line">        tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">        tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Car *car;</span><br><span class="line">    </span><br><span class="line">    car = [Car new];</span><br><span class="line">    [car print];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-存取方法"><a href="#5-3-存取方法" class="headerlink" title="5.3    存取方法"></a>5.3    存取方法</h2><blockquote>
<p><strong>说明：</strong>是用来读取或改变某个对象属性的方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>存取方法</th>
<th>方法命名（Cocoa惯例）</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getter</td>
<td>getPropertyName</td>
<td>返回实例变量的值</td>
</tr>
<tr>
<td>setter</td>
<td>propertyName</td>
<td>将实例变量的值赋为参数所指向的值</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>建议：</strong>如果要对对象中的属性进行操作，因该尽量使用对象提供的存取方法，而不是直接改变对象里面的值。<br><strong>注意：</strong>不要将<code>get</code>作为getter方法的前缀，因为<code>get</code>出现在<code>Cocoa</code>的方法名称中意味着这个方法会将你传递的参数作为指针来返回数值。</p>
</blockquote>
<h3 id="5-3-1-设置-engine-属性的存取方法"><a href="#5-3-1-设置-engine-属性的存取方法" class="headerlink" title="5.3.1    设置 engine 属性的存取方法"></a>5.3.1    设置 engine 属性的存取方法</h3><blockquote>
<p><strong>说明：</strong>在<code>@interface</code>和<code>@implementation</code>中同时增加存取方法。<br><strong>扩展：</strong>在内存管理和对象的多有权方面<code>Engin</code>的<code>getter</code>方法和<code>setter</code>方法还存在着问题。</p>
</blockquote>
<h3 id="5-3-2-设置-tires-属性的存取方法"><a href="#5-3-2-设置-tires-属性的存取方法" class="headerlink" title="5.3.2    设置 tires 属性的存取方法"></a>5.3.2    设置 tires 属性的存取方法</h3><blockquote>
<p><strong>说明：</strong>不仅要知道新轮胎，还要知道新轮胎的位置。<br><strong>注意：</strong><code>防御式编程</code><br>对无效索引进行防御。</p>
</blockquote>
<h3 id="5-3-3-Car-类代码的其他变化"><a href="#5-3-3-Car-类代码的其他变化" class="headerlink" title="5.3.3    Car 类代码的其他变化"></a>5.3.3    Car 类代码的其他变化</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	Engine *engine;</span><br><span class="line">	Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">		 atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		engine = [Engine new];</span><br><span class="line">		</span><br><span class="line">		tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire</span><br><span class="line">		 atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>,</span><br><span class="line">			   index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tires[index] = tire;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>,</span><br><span class="line">			   index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (tires[index]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) </span><br><span class="line">&#123;</span><br><span class="line">	Car *car = [Car new];</span><br><span class="line">	</span><br><span class="line">	Engine *engine = [Engine new];</span><br><span class="line">	[car setEngine: engine];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		Tire *tire = [Tire new];</span><br><span class="line">		</span><br><span class="line">		[car setTire: tire atIndex: i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	[car print];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-扩展-CarParts-程序"><a href="#5-4-扩展-CarParts-程序" class="headerlink" title="5.4    扩展 CarParts 程序"></a>5.4    扩展 CarParts 程序</h2><blockquote>
<p><strong>说明：</strong>结合<code>继承</code>和<code>复合</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tire</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Tire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">@"I am a tire. I last a while"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Tire</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 新型轮胎</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AllWeatherRadial</span> : <span class="title">Tire</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// AllWeatherRadial</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AllWeatherRadial</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am a tire for rain or shine."</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// AllWeatherRadial</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Engine</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am an engine.  Vrooom!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 新型引擎</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Slant6</span> : <span class="title">Engine</span></span></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Slant6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Slant6</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">@"I am a slant-6. VROOOM!"</span>);</span><br><span class="line">&#125; <span class="comment">// description</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Slant6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	Engine *engine;</span><br><span class="line">	Tire *tires[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Engine *) engine;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine;</span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">		engine = [Engine new];</span><br><span class="line">		</span><br><span class="line">		tires[<span class="number">0</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">1</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">2</span>] = [Tire new];</span><br><span class="line">		tires[<span class="number">3</span>] = [Tire new];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">self</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Engine *) engine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (engine);</span><br><span class="line">&#125; <span class="comment">// engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine *) newEngine</span><br><span class="line">&#123;</span><br><span class="line">	engine = newEngine;</span><br><span class="line">&#125; <span class="comment">// setEngine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setTire: (Tire *) tire atIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in setTire:atIndex:"</span>, index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tires[index] = tire;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// setTire:atIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Tire *) tireAtIndex: (<span class="keyword">int</span>) index</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span> (<span class="string">@"bad index (%d) in tireAtIndex:"</span>, index);</span><br><span class="line">		exit (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (tires[index]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// tireAtIndex:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) print</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, engine);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span> (<span class="string">@"%@"</span>, tires[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> <span class="comment">// Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) </span><br><span class="line">&#123;</span><br><span class="line">	Car *car = [Car new];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		Tire *tire = [AllWeatherRadial new];</span><br><span class="line">		</span><br><span class="line">		[car setTire: tire</span><br><span class="line">			 atIndex: i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Engine *engine = [Slant6 new];</span><br><span class="line">	[car setEngine: engine];</span><br><span class="line">	</span><br><span class="line">	[car print];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="comment">// main</span></span><br></pre></td></tr></table></figure>
<h2 id="5-5-复合还是继承"><a href="#5-5-复合还是继承" class="headerlink" title="5.5    复合还是继承"></a>5.5    复合还是继承</h2><blockquote>
<p><strong>说明：</strong>在进行面向对象编程时通常会犯这样的错误－任何东西都想使用继承。</p>
</blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th>类之间的关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td><code>is a</code></td>
</tr>
<tr>
<td>复合</td>
<td><code>has a</code></td>
</tr>
</tbody>
</table>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6    小结"></a>5.6    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_04  继承/" itemprop="url">
                  4 继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:36:44+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_04  继承/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_04  继承/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>处理类和对象的关系时，要重视<code>OOP</code>的两个方面</p>
<ul>
<li><strong>继承：</strong>定义一个具有父类所有功能的新类</li>
<li><strong>复合：</strong>在对象中引用其他对象</li>
</ul>
</blockquote>
<h2 id="4-1-为何使用继承"><a href="#4-1-为何使用继承" class="headerlink" title="4.1    为何使用继承"></a>4.1    为何使用继承</h2><blockquote>
<p><strong>说明：</strong>将所有重复的内容合并在一起，并在需要的地方拥有自定义的方法。<br><strong>不使用继承的架构</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.34.10.png" alt="Alt text"><br><strong>使用继承后的架构</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.35.04.png" alt="Alt text"></p>
</blockquote>
<h2 id="4-2-继承的语法格式"><a href="#4-2-继承的语法格式" class="headerlink" title="4.2    继承的语法格式"></a>4.2    继承的语法格式</h2><blockquote>
<p><strong>说明：</strong><code>@interface 子类名: 父类名</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>超类（或父类）</td>
<td>继承的类</td>
</tr>
<tr>
<td>子类（或孩子类）</td>
<td>执行继承的类</td>
</tr>
<tr>
<td>重写</td>
<td>如果想改变方法的实现，需要重写继承的方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>O-C</code>不支持多继承（可以使用类别和协议模拟多继承效果）</p>
</blockquote>
<h2 id="4-3-继承的工作机制"><a href="#4-3-继承的工作机制" class="headerlink" title="4.3    继承的工作机制"></a>4.3    继承的工作机制</h2><h3 id="4-3-1-方法调度"><a href="#4-3-1-方法调度" class="headerlink" title="4.3.1    方法调度"></a>4.3.1    方法调度</h3><blockquote>
<p><strong>说明：</strong>当发送消息时，<code>O-C</code>的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。<br><strong>注意：</strong>如果在最顶层的<code>NSObject</code>类中也没有找到该方法，则会出现一个运行时错误。</p>
</blockquote>
<h3 id="4-3-2-实例变量"><a href="#4-3-2-实例变量" class="headerlink" title="4.3.2    实例变量"></a>4.3.2    实例变量</h3><blockquote>
<p><strong>说明：</strong><code>O-C</code> 中图和访问实例变量</p>
<ul>
<li>子类会从父类继承实例变量</li>
<li>子类根据自己的情况添加额外的自己的实例变量</li>
<li>每个方法被调用时都获得了一个名为<code>self</code>的参数，<code>self</code>指向继承链中第一个类中的第一个实例变量。</li>
</ul>
<p><strong>多态性：</strong>使用更具体种类的对象来代替一般类型，这种能力被称为<code>多态性</code>。<br><strong>扩展：</strong>通过<code>对象基地址</code>（第一个实例变量的首个字节在内存中的位置）加上<code>偏移地址</code>，编译器就可以查找其他实例变量的位置。这个机制叫做<code>基地址加偏移</code>，通过硬编码实现，但存在<code>脆弱的基类问题</code>，<code>Leopard</code>系统中通过引入64位<code>Objective-C</code>运行时（使用间接寻址方式确定变量的位置）解决了这个问题。</p>
</blockquote>
<h2 id="4-4-重写方法"><a href="#4-4-重写方法" class="headerlink" title="4.4    重写方法"></a>4.4    重写方法</h2><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><blockquote>
<p><strong>说明：</strong>利用<code>super</code>，既可以重写方法的实现，又能调用超类中的实现方式。<br><strong>原理：</strong>既不是参数也不是实例变量，而是由<code>Objective-C</code>编译器提供的一种神奇的功能。当想<code>super</code>发送消息时，实际上是在请求<code>Obective-C</code>向该类的超类发送消息。如果超类中没有定义该消息，则向平常一样继续在<code>继承链</code>上一级中查找。</p>
</blockquote>
<h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5    小结"></a>4.5    小结</h2><h2 id="4-6-举个栗子"><a href="#4-6-举个栗子" class="headerlink" title="4.6    举个栗子"></a>4.6    举个栗子</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/" itemprop="url">
                  3 面向对象编程的基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:35:54+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_03  面向对象编程的基础知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>OOP历史：</strong>演变自20世纪60年代的<code>Simula</code>、70年代的<code>SmallTalk</code>、80年代的<code>Clascal</code>以及其他相关语言。<code>C++</code>、<code>Java</code>、<code>Python</code>和<code>Objective-C</code>等现代编程语言都从这个早期的语言中获得了灵感。</p>
</blockquote>
<h2 id="3-1-间接"><a href="#3-1-间接" class="headerlink" title="3.1    间接"></a>3.1    间接</h2><p><code>只要在多加一层间接，计算机科学中就没有解决不了的问题</code>。</p>
<blockquote>
<p><strong>说明：</strong>指的就是面向对象的<code>多态性</code>。<br><strong>原理：</strong>在程序运行期间，通过指针间接获取某个值，而不是直接获取（<code>指针指向</code>的变化对程序员不可见）。</p>
</blockquote>
<h3 id="3-1-1-变量与间接"><a href="#3-1-1-变量与间接" class="headerlink" title="3.1.1    变量与间接"></a>3.1.1    变量与间接</h3><blockquote>
<p><strong>说明：</strong>基本变量就是间接思想的一种实际应用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 通过修改 count 间接控制后面循环的次数，本身就蕴含着间接的思想</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The numbers from 1 to %d:"</span>, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-使用文件名的间接"><a href="#3-1-2-使用文件名的间接" class="headerlink" title="3.1.2    使用文件名的间接"></a>3.1.2    使用文件名的间接</h3><blockquote>
<p><strong>说明：</strong>程序中使用文件（而不是写死在代码中）也是间接思想的运用。<br><strong>技巧：</strong><code>xcode</code>中运行程序时提供文件路径的方式</p>
<ol>
<li>打开设置面板：Product（菜单）-&gt; Scheme -&gt; Edit Scheme</li>
<li>在面板中添加参数：Arguments -&gt; Arguments Passed On Launch—&gt;点击<code>+</code>添加</li>
</ol>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 命令中没有提供文件名，则退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"you need to provide a file name"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 打开文件</span></span><br><span class="line">    FILE *wordFile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 访问文件</span></span><br><span class="line">    <span class="keyword">char</span> word[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一行一行地读区</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(word, <span class="number">100</span>, wordFile)) &#123;</span><br><span class="line">        <span class="comment">// 将每行最后的换行符替换为字符串结束符（从而不会被后面的 strlen 计入字符串的长度）</span></span><br><span class="line">        word[strlen(word) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s is %lu characters long"</span>, word, strlen(word));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭文件</span></span><br><span class="line">    fclose(wordFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-在面向对象编程中使用间接"><a href="#3-2-在面向对象编程中使用间接" class="headerlink" title="3.2    在面向对象编程中使用间接"></a>3.2    在面向对象编程中使用间接</h2><blockquote>
<p><strong>说明：</strong><code>OOP</code>的核心在于使用间接来调用代码（而不是直接调用函数）</p>
</blockquote>
<h3 id="3-2-1-过程式编程"><a href="#3-2-1-过程式编程" class="headerlink" title="3.2.1    过程式编程"></a>3.2.1    过程式编程</h3><blockquote>
<p><strong>说明：</strong>在过程式编程中，数据通常保存在简单的数据结构中。要花时间连接数据和用来处理数据的函数。<br><strong>语言举例：</strong><code>BASIC</code>、<code>C</code>、<code>Tcl</code>和<code>Perl</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/******* 枚举：图形的基本元素 *******/</span></span><br><span class="line"><span class="comment">// 图形类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kCircle,</span><br><span class="line">    kRectangle,</span><br><span class="line">    kEgg</span><br><span class="line">&#125; ShapeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kRedColor,</span><br><span class="line">    kGreenColor,</span><br><span class="line">    kBlueColor</span><br><span class="line">&#125; ShapeColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 结构体：图形类型 ******/</span></span><br><span class="line"><span class="comment">// 绘图区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, width, height;<span class="comment">// 坐标和边长</span></span><br><span class="line">&#125; ShapeRect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ShapeType type;<span class="comment">// 类型</span></span><br><span class="line">    ShapeColor fillColor;<span class="comment">// 填充色</span></span><br><span class="line">    ShapeRect bounds;<span class="comment">// 边框</span></span><br><span class="line">&#125; Shape;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将传入的颜色值转换为字符串描述</span><br><span class="line"> * @param &#123;ShapeColor&#125; colorName 图形颜色</span><br><span class="line"> * @return &#123;NSString&#125; 枚举类型的颜色对应的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *colorName (ShapeColor colorName) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (colorName) &#123;</span><br><span class="line">        <span class="keyword">case</span> kRedColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kGreenColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"green"</span>;</span><br><span class="line">        <span class="keyword">case</span> kBlueColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"blue"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制圆形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawCircle (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a circle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制矩形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawRectangle (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a rectangle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制椭圆形</span><br><span class="line"> * @param &#123;ShapeRect&#125; bounds 绘制区域</span><br><span class="line"> * @param &#123;ShapeColor&#125; fillColor 图形填充色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawEgg (ShapeRect bounds, ShapeColor fillColor) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a egg at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.height, bounds.width, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  绘制图形</span><br><span class="line"> * @param &#123;Shape[]&#125; shapes 要绘制的一组图形</span><br><span class="line"> * @param &#123;int&#125; count 绘制数组中的前count个图形</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawShapes (Shape shapes[], <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (shapes[i].type) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCircle:</span><br><span class="line">                drawCircle (shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kRectangle:</span><br><span class="line">                drawRectangle (shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kEgg:</span><br><span class="line">                drawEgg(shapes[i].bounds, shapes[i].fillColor);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">// 存放图形实例的数组</span></span><br><span class="line">    Shape shapes[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 红色圆形</span></span><br><span class="line">    ShapeRect rect0 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    shapes[<span class="number">0</span>].type = kCircle;</span><br><span class="line">    shapes[<span class="number">0</span>].fillColor = kRedColor;</span><br><span class="line">    shapes[<span class="number">0</span>].bounds = rect0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绿色矩形</span></span><br><span class="line">    ShapeRect rect1 = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    shapes[<span class="number">1</span>].type = kRectangle;</span><br><span class="line">    shapes[<span class="number">1</span>].fillColor = kGreenColor;</span><br><span class="line">    shapes[<span class="number">1</span>].bounds = rect1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 蓝色椭圆</span></span><br><span class="line">    ShapeRect rect2 = &#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    shapes[<span class="number">2</span>].type = kEgg;</span><br><span class="line">    shapes[<span class="number">2</span>].fillColor = kBlueColor;</span><br><span class="line">    shapes[<span class="number">2</span>].bounds = rect2;</span><br><span class="line">    </span><br><span class="line">    drawShapes(shapes, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016-01-02 00:50:43.911 3.2.1-procedureOriented[834:55458] drawing a circle at (0 0 30 10) <span class="keyword">in</span> red</span><br><span class="line">2016-01-02 00:50:43.912 3.2.1-procedureOriented[834:55458] drawing a rectangle at (30 40 60 50) <span class="keyword">in</span> green</span><br><span class="line">2016-01-02 00:50:43.912 3.2.1-procedureOriented[834:55458] drawing a egg at (15 18 29 37) <span class="keyword">in</span> blue</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-实现面向对象编程"><a href="#3-2-2-实现面向对象编程" class="headerlink" title="3.2.2    实现面向对象编程"></a>3.2.2    实现面向对象编程</h3><blockquote>
<p><strong>说明：</strong>过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。<br><strong>原理：</strong>数据通过<code>间接方式</code>引用相应代码对数据进行操作（数据能够知道如何查找相应的函数）。</p>
</blockquote>
<h4 id="id（标识符）"><a href="#id（标识符）" class="headerlink" title="id（标识符）"></a>id（标识符）</h4><blockquote>
<p><strong>说明：</strong><code>identifier</code>，是一种泛型，可以用来定义引用任何类型对象的变量。</p>
</blockquote>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><blockquote>
<p><strong>说明：</strong>通知对象执行某种操作，也叫做<code>调用方法</code></p>
</blockquote>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><blockquote>
<p><strong>说明：</strong>不同于其他<code>OOP</code>系统，在<code>O-C</code>中，如果在运行时改变某个类，则该类的所有对象会<code>自动继承这些变化</code>。</p>
</blockquote>
<h2 id="3-3-有关术语"><a href="#3-3-有关术语" class="headerlink" title="3.3    有关术语"></a>3.3    有关术语</h2><blockquote>
<p><strong>说明：</strong>有关<code>面向对象</code>的术语</p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类(class)</strong></td>
<td>一种表示对象类型的结构体</td>
<td>类名首字母大写</td>
<td>对象通过它的类来获取自身的各种信息</td>
</tr>
<tr>
<td><strong>对象或实例(object)</strong></td>
<td>一种包含值和指向其类的隐藏指针的结构体</td>
<td>指向对象的变量通常首字母不要大些</td>
<td></td>
</tr>
<tr>
<td><strong>消息(message)</strong></td>
<td>对象可以执行的操作，用于通知对象做什么</td>
<td></td>
</tr>
<tr>
<td><strong>方法(method)</strong></td>
<td>响应消息运行的代码</td>
<td></td>
<td>根据对象的类，消息可以调用不同的方法</td>
</tr>
<tr>
<td><strong>方法调度(method dispatcher)</strong></td>
<td>用于推测执行什么方法以响应某个特定的消息</td>
<td></td>
</tr>
<tr>
<td><strong>接口(interface)</strong></td>
<td>类为对象提供的特性描述</td>
<td></td>
</tr>
<tr>
<td><strong>实现(implementation)</strong></td>
<td>使接口能正常工作的代码</td>
</tr>
</tbody>
</table>
<h2 id="3-4-Object-C语言中的OOP"><a href="#3-4-Object-C语言中的OOP" class="headerlink" title="3.4    Object-C语言中的OOP"></a>3.4    Object-C语言中的OOP</h2><h3 id="3-4-1-interface部分"><a href="#3-4-1-interface部分" class="headerlink" title="3.4.1    @interface部分"></a>3.4.1    @interface部分</h3><blockquote>
<p><strong>说明：</strong>定义类的公共接口，真正运行的代码位于<code>@implementation</code>中。<br><strong>用途：</strong>在特定类的对象被创建时，为编译器提供有关该类的信息，尤其是对象的数据成员及其提供的功能。<br><strong>组成：</strong>语法上包含以下几个部分</p>
<ul>
<li>继承其它<code>interface</code></li>
<li>实现<code>protocol</code></li>
<li>实例变量</li>
<li>方法声明</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 类名: 父类名 </span>&#123;</span><br><span class="line">	<span class="comment">// 实例属性</span></span><br><span class="line">	属性类型 属性名;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (返回值类型) 方法名: (参数<span class="number">1</span>类型)参数<span class="number">1</span>名称, (参数<span class="number">2</span>类型)参数<span class="number">2</span>名称;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// 类名（便于代码阅读）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>在声明方法时，如果方法有参数，则需要冒号，否则不需要。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Circle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Circle</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-implementation部分"><a href="#3-4-2-implementation部分" class="headerlink" title="3.4.2    @implementation部分"></a>3.4.2    @implementation部分</h3><blockquote>
<p><strong>说明：</strong><code>@implementation</code>是一个编译器指令，表明将为某个类提供代码</p>
<ul>
<li>方法的定义不必按照在<code>@interface</code>指令中的顺序出现</li>
<li>可以定义没有在<code>@interface</code>中声明过的方法</li>
<li>同一个类中，方法的参数名不可以和实例属性名相同，否则方法被调用时会覆盖实例属性的值</li>
</ul>
<p><strong>扩展：</strong></p>
<ul>
<li><strong>实例变量名：</strong>如果实例变量取一个和方法名相同的名字，<code>Cocoa</code>还可以发挥出某些神奇的威力</li>
<li><strong>运行时：</strong><code>O-C运行时</code>是指用户应用程序时，支持这些应用程序的代码块</li>
<li><strong>self：</strong>类的方法被调用时，一个名为<code>self</code>的秘密隐藏参数将被传递给接受对象，而这个参数引用的就是该接收对象</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Circle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-实例化对象"><a href="#3-4-3-实例化对象" class="headerlink" title="3.4.3    实例化对象"></a>3.4.3    实例化对象</h3><blockquote>
<p><strong>说明：</strong>实例化对象时，需要分配内存，然后将这些内存初始化并保存为有用的默认值。<br><strong>语法：</strong>向相应的<code>类</code>(或已经存在的<code>对象</code>)发送<code>new</code>消息，该类接收并处理完<code>new</code>消息后，我们就会得到一个可以使用的新对象实例。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 图形类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kCircle,</span><br><span class="line">    kRectangle,</span><br><span class="line">    kEgg</span><br><span class="line">&#125; ShapeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 图形颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    kRedColor,</span><br><span class="line">    kGreenColor,</span><br><span class="line">    kBlueColor</span><br><span class="line">&#125; ShapeColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// 绘图区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, width, height;<span class="comment">// 坐标和边长</span></span><br><span class="line">&#125; ShapeRect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将传入的颜色值转换为字符串描述</span><br><span class="line"> * @param &#123;ShapeColor&#125; colorName 图形颜色</span><br><span class="line"> * @return &#123;NSString&#125; 枚举类型的颜色对应的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *colorName (ShapeColor colorName) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (colorName) &#123;</span><br><span class="line">        <span class="keyword">case</span> kRedColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kGreenColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"green"</span>;</span><br><span class="line">        <span class="keyword">case</span> kBlueColor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"blue"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Circle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Circle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Circle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a circle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Rectangle类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Rectangle</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Rectangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Rectangle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a rectangle at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">// Egg类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Egg</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    ShapeColor fillColor;</span><br><span class="line">    ShapeRect bounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor: (ShapeColor) fillColor;</span><br><span class="line">- (<span class="keyword">void</span>) setBounds: (ShapeRect) bounds;</span><br><span class="line">- (<span class="keyword">void</span>) draw;</span><br><span class="line"><span class="keyword">@end</span><span class="comment">// Egg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Egg类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Egg</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置图形填充色</span><br><span class="line"> * @param &#123;ShapeColor&#125; c 颜色</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setFillCollor:(ShapeColor)c &#123;</span><br><span class="line">    fillColor = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置绘图区域</span><br><span class="line"> * @param &#123;ShapeRect&#125; b 绘图区域</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setBounds:(ShapeRect)b &#123;</span><br><span class="line">    bounds = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 绘制</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) draw &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"drawing a egg at (%d %d %d %d) in %@"</span>, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  绘制图形</span><br><span class="line"> * @param &#123;id[]&#125; shapes 要绘制的一组图形</span><br><span class="line"> * @param &#123;int&#125; count 绘制数组中的前count个图形</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> drawShapes (<span class="keyword">id</span> shapes[], <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">id</span> shape = shapes[i];</span><br><span class="line">        [shape draw];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> shapes[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 红色圆形</span></span><br><span class="line">    ShapeRect rect0 =&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    shapes[<span class="number">0</span>] = [Circle new];</span><br><span class="line">    [shapes[<span class="number">0</span>] setBounds: rect0];</span><br><span class="line">    [shapes[<span class="number">0</span>] setFillCollor:kRedColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绿色矩形</span></span><br><span class="line">    ShapeRect rect1 = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    shapes[<span class="number">1</span>] = [Rectangle new];</span><br><span class="line">    [shapes[<span class="number">1</span>] setBounds: rect1];</span><br><span class="line">    [shapes[<span class="number">1</span>] setFillCollor:kGreenColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 蓝色椭圆</span></span><br><span class="line">    ShapeRect rect2 = &#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    shapes[<span class="number">2</span>] = [Egg new];</span><br><span class="line">    [shapes[<span class="number">2</span>] setBounds: rect2];</span><br><span class="line">    [shapes[<span class="number">2</span>] setFillCollor:kBlueColor];</span><br><span class="line">    </span><br><span class="line">    drawShapes(shapes, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-4-扩展-Shapes-Object-程序"><a href="#3-4-4-扩展-Shapes-Object-程序" class="headerlink" title="3.4.4    扩展 Shapes-Object 程序"></a>3.4.4    扩展 Shapes-Object 程序</h3><blockquote>
<p><strong>说明：</strong>软件实体应该对扩展开放，而对修改关闭</p>
</blockquote>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5    小结"></a>3.5    小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="url">
                  2 对c的扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T22:36:43+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-1-最简单的-Objective-C-程序"><a href="#2-1-最简单的-Objective-C-程序" class="headerlink" title="2.1   最简单的 Objective-C 程序"></a>2.1   最简单的 Objective-C 程序</h2><blockquote>
<p><strong>说明：</strong>项目创建过程如下</p>
<ol>
<li>创建 workspace：File-New-Workspace</li>
<li>创建 project：File-New-&gt;Project</li>
</ol>
<ul>
<li>选择模版：OS X-&gt;Applicetion-&gt; Command Line</li>
<li>选择语言：Object-C</li>
<li>选择 Workspace</li>
</ul>
</blockquote>
<h2 id="2-2-解构-Hello-Objective-C-程序"><a href="#2-2-解构-Hello-Objective-C-程序" class="headerlink" title="2.2   解构 Hello Objective-C 程序"></a>2.2   解构 Hello Objective-C 程序</h2><blockquote>
<p><strong>默认编译器：</strong> XCode 的默认编译器为<code>LLVM</code>，可以处理<code>C</code>（.c文件）、<code>C++</code>（.cpp）、<code>Objective-C</code>（.m）。<br><strong>扩展：</strong>扩展名<code>.m</code>代表<code>message</code>，它值得是<code>Object-C</code>的一个主要特征。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O-C 支持的模块导入方式</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main 的声明语句和结尾的 return 语句和 C 一样</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-1-import-语句"><a href="#2-2-1-import-语句" class="headerlink" title="2.2.1    #import 语句"></a>2.2.1    #import 语句</h3><blockquote>
<p><strong>功能：</strong>通知编译器查询头文件中相应的代码并导入，一个文件中只会被包含一次（无论调用多少次<code>#import</code>语句）<br><strong>说明：</strong>相比<code>C</code>的<code>#include</code>，<code>#import</code>能避免文件相互包含的情况导致的错误（<code>C</code>语言通过<code>ifdef</code>实现）。<br><strong>注意：</strong><code>Foundation</code>框架的头文件占用了近1MB的磁盘空间，使用<code>#import &lt;Foundation/Foundation.h&gt;</code>包含头文件时，Xcode使用<code>预编译头文件</code>加快读取速度。</p>
</blockquote>
<h3 id="2-2-2-框架"><a href="#2-2-2-框架" class="headerlink" title="2.2.2    框架"></a>2.2.2    框架</h3><blockquote>
<p><strong>框架：</strong>是一种把<code>头文件、库、图片、声音等内容</code>聚集在一个独立单元中的集合体。<br><strong>框架集：</strong>一系列框架的集合。</p>
</blockquote>
<h4 id="苹果公司提供的框架集"><a href="#苹果公司提供的框架集" class="headerlink" title="苹果公司提供的框架集"></a>苹果公司提供的框架集</h4><blockquote>
<p><strong>说明：</strong>苹果公司将<code>Cocoa</code>、<code>Carbon</code>、<code>QuickTime</code>、<code>OpenGL</code>等技术作为框架集来提供。<br><strong>Cocoa框架集：</strong>包括以下框架</p>
<ul>
<li>Foundation</li>
<li>Application Kit（简称AppKit）</li>
<li>支持性框架（Core Animation 和 Core Image）</li>
</ul>
<p><strong>扩展：</strong><a href="">Learn Cocoa On The Mac</a></p>
</blockquote>
<h3 id="2-2-3-NSLog-和-quot-字符串-quot"><a href="#2-2-3-NSLog-和-quot-字符串-quot" class="headerlink" title="2.2.3    NSLog()和@&quot;字符串&quot;"></a>2.2.3    <code>NSLog()</code>和<code>@&quot;字符串&quot;</code></h3><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>给其所有函数、常量和类型名都添加了<code>NS前缀</code>（使用<code>NS</code>而不是<code>Cocoa</code>源自历史遗留：<code>Cocoa</code>的前身为<code>NextSTEP</code>工具包）。</p>
</blockquote>
<h4 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h4><blockquote>
<p><strong>说明：</strong>用于向控制台输出内容<br><strong>原型：</strong><code>NSObjCRuntime.h</code><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">** @param &#123;NSString *&#125; format 字符串（可以包含格式说明符） </span><br><span class="line">** @param &#123;...&#125; 对应格式串中格式说明符可变参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...)</span><br></pre></td></tr></table></figure></p>
<p><strong>技巧：</strong>建议在<code>O-C</code>中使用<code>NSLog</code>替代<code>printf</code>，因为它添加了一些特性，比如</p>
<ul>
<li>时间戳</li>
<li>日期戳</li>
<li>自动附带换行符<code>\n</code>等</li>
</ul>
</blockquote>
<h4 id="NSString-quot-字符串-quot"><a href="#NSString-quot-字符串-quot" class="headerlink" title="NSString(@&quot;字符串&quot;)"></a>NSString(<code>@&quot;字符串&quot;</code>)</h4><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>提供的<code>NSString</code>集成了大量<code>C</code>语言字符串没有的特性。<code>@&quot;字符串&quot;</code>表明其中的<code>字符串</code>作为<code>Cocoa</code>的<code>NSString</code>元素来处理。</p>
<ul>
<li>字符串的长度</li>
<li>字符串比较</li>
<li>转换为整数和浮点数</li>
</ul>
<p><strong>格式串：</strong>输出对象使用<code>%@</code>，会调用对象的<code>description</code>方法</p>
</blockquote>
<h2 id="2-3-布尔类型"><a href="#2-3-布尔类型" class="headerlink" title="2.3   布尔类型"></a>2.3   布尔类型</h2><blockquote>
<p><strong>关键字：</strong><code>BOOL</code>(比<code>C</code>语言的<code>bool</code>早十多年)<br><strong>说明：</strong>本质是<code>signed char</code>（通过<code>typedef</code>定义），使用8位存储空间</p>
<ul>
<li><code>NO</code>：本质是<code>signed char</code>值0</li>
<li><code>YES</code>：本质是<code>signed char</code>值1</li>
</ul>
<p><strong>注意：</strong><code>O-C</code>的<code>BOOL</code>不仅能保存<code>NO</code>和<code>YES</code>，编译器将其作为<code>8位二进制数</code>处理，也就是说可以赋值其它整数和<code>char</code>类型值（大于一个字节将溢出）。</p>
</blockquote>
<h3 id="2-3-1-BOOL-强大的实用功能"><a href="#2-3-1-BOOL-强大的实用功能" class="headerlink" title="2.3.1    BOOL 强大的实用功能"></a>2.3.1    BOOL 强大的实用功能</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较两个 int 型值是否相等</span><br><span class="line"> * @param &#123;int&#125; thing1 第一个值</span><br><span class="line"> * @param &#123;int&#125; thing2 第二个值</span><br><span class="line"> * @return &#123;BOOL&#125; YES 相等， NO 不相等</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> areIntsDifferent (<span class="keyword">int</span> thing1, <span class="keyword">int</span> thing2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thing1 == thing2) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NO</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 输出 BOOL 值对应的描述</span><br><span class="line"> * @param &#123;BOOL&#125; yesNo BOOL值</span><br><span class="line"> * @return &#123;NSString&#125; YES "YES", NO "NO"</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *boolString (<span class="built_in">BOOL</span> yesNo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (yesNo == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"NO"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"YES"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> areTheyDifferent;</span><br><span class="line">    <span class="comment">// 调用areTheDifferent函数</span></span><br><span class="line">    areTheyDifferent = areIntsDifferent(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 调用boolString函数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"are %d and %d different? %@"</span>, <span class="number">5</span>, <span class="number">5</span>, boolString(areTheyDifferent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4   小结"></a>2.4   小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_01 启程/" itemprop="url">
                  1 启程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T11:14:49+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_01 启程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_01 启程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-预备知识"><a href="#1-1-预备知识" class="headerlink" title="1.1 预备知识"></a>1.1 预备知识</h2><h2 id="1-2-历史"><a href="#1-2-历史" class="headerlink" title="1.2 历史"></a>1.2 历史</h2><blockquote>
<p><strong>Objective-C：</strong>20世纪80年代，<code>Brad Cox</code>为了融合流行的、可移植的<code>C语言</code>和<code>Smalltalk语言</code>的优势，设计出了<code>Objective-C语言</code>。 <strong>NeXT公司：</strong>1985年，<code>史蒂夫.乔布斯</code>创建，致力于创建功能强大且经济实惠的工作站。<br><strong>NextSTEP：</strong>使用<code>Object-C</code>开发的一款功能强大的用户界面工具包。 <strong>Cocoa：</strong>1996年，苹果收购了<code>NeXT</code>,之后<code>NextSTEP</code>更名为<code>Cocoa</code>。</p>
</blockquote>
<h2 id="1-3-内容简介"><a href="#1-3-内容简介" class="headerlink" title="1.3 内容简介"></a>1.3 内容简介</h2><h2 id="1-4-准备工作"><a href="#1-4-准备工作" class="headerlink" title="1.4 准备工作"></a>1.4 准备工作</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/25 国际化特性/" itemprop="url">
                  25 国际化特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:30:56+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/25 国际化特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/25 国际化特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>地区：</strong>可能是国家、洲或省活着一种特定的文化。<br><strong>扩展：</strong>1994年通过的<code>ISO C标准修正草案1</code>提供了编写额外国际化程序增加的额外库</p>
<ul>
<li>iso646.h</li>
<li>wctype.h</li>
<li>wchar.h</li>
</ul>
</blockquote>
<h2 id="25-1-locale-h：本地化"><a href="#25-1-locale-h：本地化" class="headerlink" title="25.1 locale.h：本地化"></a>25.1 locale.h：本地化</h2><blockquote>
<p><strong>标准库中依赖地区的部分：</strong></p>
<ul>
<li><strong>数值的格式：</strong>例如，一些地区小数点是一个圆点（297.48），而在另一些地方则是逗号（297,48）<br><strong>货币的格式：</strong>例如，不同国家的货币符号不同<br><strong>字符集：</strong>例如，亚洲国家通常比西方国家需要更大的字符集<br><strong>日期和时间的表示形式：</strong>例如，一些地方习惯在写日期时先写月（8/24/97），而另一些地方习惯先写日（24/8/97）</li>
</ul>
</blockquote>
<h3 id="25-1-1-类别"><a href="#25-1-1-类别" class="headerlink" title="25.1.1    类别"></a>25.1.1    类别</h3><blockquote>
<p><strong>说明：</strong><code>locale.h</code>提供了一系列的以<code>LC_</code>开头的宏来，这些宏分别对某些库的某些方面的行为产生影响。<br><strong>扩展：</strong>C语言的实现提供了其它类型并且定义了上面未列出的以<code>LC_</code>开头的宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>影响</th>
<th>头文件</th>
<th>相关章节</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE</td>
<td>strcoll函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td></td>
<td>strxfrm函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td>LC_CTYPES</td>
<td>isdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>isxdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>多字节函数</td>
<td>stdlib.h</td>
<td><a href="">25.2.1</a></td>
<td></td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>影响该函数返回的货币格式信息</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>格式化输入输出函数中使用的小数点字符</td>
<td>stdio.h</td>
<td><a href="">22</a></td>
<td>比如<code>printf</code>和<code>scanf</code></td>
</tr>
<tr>
<td></td>
<td>字符串转换函数</td>
<td>stdlib.h</td>
<td><a href="">26.2.1</a></td>
<td><code>atof</code>和<code>strtod</code></td>
</tr>
<tr>
<td></td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>该函数返回的非货币格式信息</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>strftime函数</td>
<td>time.h</td>
<td><a href="">26.3.2</a></td>
<td>该函数用于将时间转换为字符串</td>
</tr>
</tbody>
</table>
<h3 id="25-1-2-setlocale函数"><a href="#25-1-2-setlocale函数" class="headerlink" title="25.1.2    setlocale函数"></a>25.1.2    setlocale函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>用来修改当前的地区，也可以用来获取当前地区的信息。<br><strong>参数：</strong><br><strong>1：</strong> 可以针对一种类型，也可以针对所有类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数1取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE、LC_CTYPE、LC_MONETARY 、LC_NUMERIC、LC_TIME</td>
<td>针对一种类型</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>针对所有类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>2：</strong> C语言标准为第二个参数仅定义了两种可能值：”c”或” “。其他地区可以针对不同的实现定义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数二取值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;C&quot;</code></td>
<td>按正常方式执行，小数点是一个句点</td>
<td></td>
</tr>
<tr>
<td><code>&quot; &quot;</code></td>
<td>换到<code>本地模式（native locale）</code></td>
<td><code>C语言标准</code>没有定义切换到本地模式的具体影响</td>
</tr>
<tr>
<td><code>&quot;Germany&quot;</code></td>
<td>德国</td>
<td>部分编译器支持</td>
</tr>
<tr>
<td>类似<code>en_GB.WIN1252</code>格式的字符串</td>
<td>英语_英国.Windows多语言字符集</td>
<td>一些常用编译器支持</td>
</tr>
<tr>
<td><code>NULL</code></td>
<td>不设置任何东西</td>
<td>仅仅返回指向与当前地区类型的设置相关联的字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>如果需要获得与当前地区关联字符串，可以在调用setlocale函数时第一个参数给<code>LC_ALL</code>，第二个参数给<code>NULL</code>.<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; category  指定影响哪些库的哪些方面</span><br><span class="line">* @param &#123;char *&#125; locale 指定地区</span><br><span class="line">* @return &#123;char *&#125; 指向字符串（可能是地点名字自身）：成功；空指针：调用失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setlocale</span><span class="params">(<span class="keyword">int</span> category, <span class="keyword">const</span> <span class="keyword">char</span> *locale)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意程序执行开始时，都会隐含执行调用</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取地区信息字符串 */</span></span><br><span class="line"><span class="keyword">char</span> *temp, *old_locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前地区信息 */</span></span><br><span class="line">temp = setlocale(LC_ALL, NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查是否获取到信息 */</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为信息的副本分配空间 */</span></span><br><span class="line">old_locale = <span class="built_in">malloc</span>(strlen(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (old_locale == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* 分配内存失败 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将信息拷贝进去 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(old_locale, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换到本地模式 */</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按照存储的信息恢复就的地区设置 */</span></span><br><span class="line">setlocale(LU_ALL, old_locale);</span><br></pre></td></tr></table></figure>
<h3 id="25-1-3-localeconv函数"><a href="#25-1-3-localeconv函数" class="headerlink" title="25.1.3    localeconv函数"></a>25.1.3    localeconv函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>获取当前地区的各种信息<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;struct lconv *&#125; 指向包含当前地区的详细信息的结构体指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> lconv *<span class="title">localeconv</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="struct-lconv"><a href="#struct-lconv" class="headerlink" title="struct lconv"></a>struct lconv</h4><hr>
<blockquote>
<p><strong>说明：</strong>存储当前地区的各种信息的结构体<br><strong>结构成员：</strong>有<code>char *</code>和<code>char</code>两种类型</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">char *型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.50.57.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">char型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.53.18.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>p_sign_posn和n_sign_posn的值：</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.56.18.png" alt="Alt text"></p>
</blockquote>
<p><strong>案例：用于美国和意大利两国的lconv结构成员的货币型常用值</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.57.34.png" alt="Alt text"></p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.59.18.png" alt="Alt text"></p>
<h2 id="25-2-多字节字符和宽字符"><a href="#25-2-多字节字符和宽字符" class="headerlink" title="25.2 多字节字符和宽字符"></a>25.2 多字节字符和宽字符</h2><blockquote>
<p><strong>字符集（美国）：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>地位</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII</td>
<td>主流计算机采用</td>
</tr>
<tr>
<td>EBCDIC</td>
<td>其他计算机</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>可扩展字符集：</strong>C语言允许编译器提供一种可扩展的字符集</p>
</blockquote>
<table>
<thead>
<tr>
<th>可扩展字符集编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>多字节字符（multibyte character）</td>
<td>一个或多个字节表示一个可扩展的字符</td>
</tr>
<tr>
<td>宽字符（wide character）</td>
<td>一种其值表示字符的整数，具有相同的字节数</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>基本字符：</strong>任何可扩展的字符集必须包含C语言要求的<code>基本字符</code>（即<code>字母</code>、<code>数字</code>、<code>运算符</code>、<code>标点符</code>、<code>空白字符</code>），而且这些字符要求是单字节的。<br><strong>用途：</strong>c语言同时提供了多字节字符和宽字符用于不同的目的</p>
<ul>
<li><strong>多字节字符：</strong>多用于输入／输出，因为输入／输出设备经常是面向字节的</li>
<li><strong>宽字符：</strong>更适用于程序内部，因为没个宽字符占有相同的空间，便于程序内部操作。</li>
</ul>
<p><strong>技巧：</strong>程序可以读入多字节字符，然后转为便于程序内部操作的宽字符格式，谈后再把宽字符转换回用于输出的多字节格式。</p>
</blockquote>
<h3 id="25-2-1-多字节字符"><a href="#25-2-1-多字节字符" class="headerlink" title="25.2.1    多字节字符"></a>25.2.1    多字节字符</h3><blockquote>
<p><strong>空字符(<code>\0</code>)：</strong>无论移位状态如何，c标准都要求<code>\0</code>始终用来表示空字符。而且，<code>\0</code>不能是多字节字符的第二个（或之后）字节。<br><strong>按是否依赖状态分类：</strong><code>mblen函数</code>、<code>mbtowc函数</code>、<code>wctomb函数</code>都可用检测对字节字符是否是依赖状态的。只要其char *型参数给予NULL实参，则返回非零说明依赖状态；返回零说明依赖状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖状态编码（state-dependent enciding）</td>
<td>每个多字节字符序列都以<code>初始移位状态（initial shift state）</code>开始，序列中稍后遇到的一些多字节字符会改变移位状态，并且会影响后续字节的含义</td>
<td>日本的JIS编码</td>
</tr>
<tr>
<td>不依赖状态编码</td>
<td>每个字符要求一个或者两个字节，但是双字节字符的第一个字节可以始终区别与单字节字符</td>
<td>日本的Shift-JIS编码</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关宏：</strong>两个</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>头文件</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>MB_LEN_MAX</td>
<td>limit.h</td>
<td>任意支持区域的最大值</td>
<td></td>
</tr>
<tr>
<td>MB_CUR_MAX</td>
<td>stdlib.h</td>
<td>当前区域的最大值</td>
<td>改变地区可能会影响多字节字符的解释</td>
</tr>
</tbody>
</table>
<h3 id="25-2-2-宽字符"><a href="#25-2-2-宽字符" class="headerlink" title="25.2.2    宽字符"></a>25.2.2    宽字符</h3><blockquote>
<p><strong>说明：</strong>采用特殊实现（比如<code>unsigned short int</code>）支持的所有宽字符都要求相同的字节数。<br><strong>宽字符类型：</strong><code>wchar_t</code> (<code>stddef.h</code>、<code>stdlib.h</code>)<br><strong>宽字符常量和宽字符串常量：</strong><code>L字符（串）常量</code></p>
<ul>
<li>宽字符常量：<code>L&#39;a&#39;</code></li>
<li>宽字符串常量：<code>L&quot;abc&quot;</code></li>
</ul>
</blockquote>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><blockquote>
<p><strong>说明：</strong>非常重要的固定长度编码的字符集。<br><strong>字符宽度：</strong>两个字节</p>
</blockquote>
<h3 id="25-2-3-多字节字符／宽字符转换函数"><a href="#25-2-3-多字节字符／宽字符转换函数" class="headerlink" title="25.2.3    多字节字符／宽字符转换函数"></a>25.2.3    多字节字符／宽字符转换函数</h3><h4 id="mblen函数"><a href="#mblen函数" class="headerlink" title="mblen函数"></a>mblen函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>检测s是否指向形成由效多字节字符的字节序列<br><strong>原型：</strong><code>stdlib.h</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符的字节序列</span><br><span class="line">* @param &#123;size_t&#125; a 最多能将测的字节的数量（通常为MB_CUR_MAX）</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符序列；0:空字符；-1：不是多字节字符序列</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mblen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, size_t a)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 确定字符串是否由有效的多字节字符构成</span><br><span class="line">* @param &#123;char *s&#125; 指向以空字符结尾的普通字符串</span><br><span class="line">* @return &#123;int&#125; 0或－1</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbcheck</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 通过mblen(NULL, 0)设置该函数的移位状态，以便可以正确解释字符串中稍后的字符</span></span><br><span class="line">	<span class="keyword">for</span> (mblen(NULL, <span class="number">0</span>); ; s += n) &#123;</span><br><span class="line">		<span class="comment">// 当</span></span><br><span class="line">		<span class="keyword">if</span> ((n = mblen(s, MB_CUR_MAX)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mbtowc函数"><a href="#mbtowc函数" class="headerlink" title="mbtowc函数"></a>mbtowc函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将多字节字符串转换为宽字符<br><strong>原型：</strong><code>stdlib.h.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;wchar_t *&#125; pwc 函数将存储结果的变量</span><br><span class="line">* @para &#123;char *&#125; s 多字节字符</span><br><span class="line">* @param &#123;size_t&#125; n 最大将检测的字节的数量</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符；0:空字符；-1：不是多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbtowc</span><span class="params">(wchar_t *pwc, <span class="keyword">const</span> <span class="keyword">char</span> *s, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="wctomb函数"><a href="#wctomb函数" class="headerlink" title="wctomb函数"></a>wctomb函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把宽字符转换为多字节字符<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储结果的变量（不回附加空字符）</span><br><span class="line">* @param &#123;wchar_t&#125; wchar 多字节字符</span><br><span class="line">* @return &#123;int&#125; 字符中的字节数：有效；1：空字符；-1：无效</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wctomb</span><span class="params">(<span class="keyword">char</span> *s, wchar_t wchar)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将测是否可以把宽字符的字符串转换为有效的多字节字符</span><br><span class="line">* @param &#123;wchar_t *&#125; wcs 宽字符序列</span><br><span class="line">* @return &#123;int&#125; -1：不可以；0：可以</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wccheck</span> <span class="params">(wchar_t *wcs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[MB_len_max];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span> (wctpmb (NULL, <span class="number">0</span>); ; ++wcs) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((n = wctomb(buf, *wcs)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (buf[n - <span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">			return <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-2-4-多字节字符／宽字符串函数"><a href="#25-2-4-多字节字符／宽字符串函数" class="headerlink" title="25.2.4    多字节字符／宽字符串函数"></a>25.2.4    多字节字符／宽字符串函数</h3><h4 id="mbstowcs函数"><a href="#mbstowcs函数" class="headerlink" title="mbstowcs函数"></a>mbstowcs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把多字节字符序列转换为宽字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（存储在宽字符数组中的)<code>\0</code>时，函数停止</li>
<li>假设要转换的字符串以初始迁移状态开始</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 宽字符数组</span><br><span class="line">* @param &#123;char *&#125; s 待转换的多字节字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的宽字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无效的多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> mbstowcs(<span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h4 id="wcstombs函数"><a href="#wcstombs函数" class="headerlink" title="wcstombs函数"></a>wcstombs函数</h4><blockquote>
<p><strong>说明：</strong>把宽字符序列转换为多字节字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（自己存入的)<code>\0</code>时，函数停止</li>
<li>产生的字符串是以初始迁移状态开始的</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符数组</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 待转换的宽字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的多字节字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无法转换为对应多字节字符的宽字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> wcstombs(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h2 id="25-3-三字符序列"><a href="#25-3-三字符序列" class="headerlink" title="25.3    三字符序列"></a>25.3    三字符序列</h2><blockquote>
<p><strong>三字符序列（trigraph sequence）：</strong>简称“三字符”，是一种三个字符的字符码。以<code>??字符</code>的形式出现。<br><strong>用途：</strong>可以替换ASCII中的一些特殊字符。<br><strong>兼容性：</strong>尽管不是一直需要，但是所有标准C编译器都要求接受三字符序列。<br><strong>技巧：</strong>字符串中的<code>??</code>可能会被编译器作为三字符序列的开始标志，可以通过使用<code>\</code>将第二个<code>?</code>转义（即<code>?\?</code>）来避免。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-21%20%E4%B8%8A%E5%8D%889.53.05.png" alt="Alt text"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">??=include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main () ??&lt;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world??/n"</span>); </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">??&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">85</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
