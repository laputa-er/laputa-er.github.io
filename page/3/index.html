<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/3/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/3/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/26 其它库函数/" itemprop="url">
                  26 其他库函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:25:08+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="26-1-stdarg-h：可变实参"><a href="#26-1-stdarg-h：可变实参" class="headerlink" title="26.1    stdarg.h：可变实参"></a>26.1    stdarg.h：可变实参</h2><blockquote>
<p><strong>带有可变参数的函数：</strong>带有可变数量参数的函数必须至少有一个“正常的”形式参数，在最后一个正常参数的后边始终会有省略号出现在参数列表的末尾。<br><strong>可变部分实参提升：</strong>当调用带有可变实参列表的函数时，编译器会在匹配省略号的全部参数上执行默认的<code>实参提升</code>（<a href="">9.3</a>）</p>
<ul>
<li>char -&gt; int</li>
<li>short -&gt; int</li>
<li>float -&gt; double</li>
</ul>
</blockquote>
<h4 id="va-arg宏（函数）"><a href="#va-arg宏（函数）" class="headerlink" title="va_arg宏（函数）"></a>va_arg宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>获得所在函数的可变参数中的下一个参数<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 指向可变参数列表的某个位置</span><br><span class="line">* @param &#123;类型&#125; 期待相应位置实参的类型</span><br><span class="line">* @return &#123;类型&#125; 相应位置(下一个)实参</span><br><span class="line">*/</span></span><br><span class="line">类型 va_arg(va_list ap, 类型);</span><br></pre></td></tr></table></figure>
<h4 id="va-start宏（函数）"><a href="#va-start宏（函数）" class="headerlink" title="va_start宏（函数）"></a>va_start宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过支持实参列表中可变长度部分开始的位置初始化<code>va_list</code>类型的实参列表。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 存储参数列表的变量</span><br><span class="line">* @param &#123;*&#125; paramN 可变参数前的最后一个正常实参</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(va_list ap, paramN)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="va-end宏（函数）"><a href="#va-end宏（函数）" class="headerlink" title="va_end宏（函数）"></a>va_end宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>执行对<code>va_list</code>类型变量的清理，使其无法被继续使用。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 可变实参部分的列表</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; n 后面可变参数的数量</span><br><span class="line">* @param &#123;*&#125; ... 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 可变实参中的最大值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span> <span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明存储可变实参列表的变量</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">int</span> i, current, largest;</span><br><span class="line">	<span class="comment">// 初始化存储可变部分的实参的列表</span></span><br><span class="line">	va_start(ap, n);</span><br><span class="line">	<span class="comment">// 遍历寻找最大值</span></span><br><span class="line">	largest = va_arg(ap, int);</span><br><span class="line">	<span class="keyword">for</span> (i = i; i &lt; n; i ++) &#123;</span><br><span class="line">		current = va_arg(ap, int);</span><br><span class="line">		<span class="keyword">if</span> (current &gt; largest) &#123;</span><br><span class="line">			largest = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清理存储可变实参的列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	return largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-1-1-调用可变实参列表的函数"><a href="#26-1-1-调用可变实参列表的函数" class="headerlink" title="26.1.1    调用可变实参列表的函数"></a>26.1.1    调用可变实参列表的函数</h3><blockquote>
<p><strong>说明：</strong>调用带有可变实参列表的函数带有一定风险，需要一些措施规避</p>
<ul>
<li><p>确定可变参数数量</p>
<blockquote>
<p><strong>例子：</strong>max_int函数依靠第一个是惨知名跟随其后的其他参数的数量</p>
</blockquote>
</li>
<li><p>确定每种参数的类型</p>
<blockquote>
<p><strong>例子：</strong>像printf函数和scanf函数依靠格式化字符串来描述其他的参数的数量和每种参数的类型</p>
</blockquote>
</li>
<li><p>特别处理<code>NULL</code>作为参数：当把<code>NULL</code>(0)传递给带有可变实参列表的函数时，编译器会假定它表示的是一个整数</p>
<blockquote>
<p><strong>强制类型转换：</strong><code>(void *) NULL</code>代替<code>NULL</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="26-1-2-v…printf类函数"><a href="#26-1-2-v…printf类函数" class="headerlink" title="26.1.2    v…printf类函数"></a>26.1.2    v…printf类函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...printf类函数</code>相比，由一个<code>va_list</code>类型的参数取代了可变参数部分。<br><strong>用途：</strong>编写“包装”函数。外部的包装函数接受可变数量的实参，并且稍后把这些参数传递给<code>v...printf类函数</code>。</p>
</blockquote>
<h4 id="vfprintf函数"><a href="#vfprintf函数" class="headerlink" title="vfprintf函数"></a>vfprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向第一个参数说明的流（任何输出流）中写输出。<br><strong>关联的函数：</strong><code>vfprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（流）</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE * <span class="keyword">restrict</span> stream, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vprintf函数"><a href="#vprintf函数" class="headerlink" title="vprintf函数"></a>vprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向stdout输出，利用格式串控制输出的形式<br><strong>关联的函数：</strong><code>vprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @param &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list rga)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vsprintf函数"><a href="#vsprintf函数" class="headerlink" title="vsprintf函数"></a>vsprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>类似printf函数和fprintf函数，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定制错误输出</span><br><span class="line">* @param &#123;char *&#125; format 格式化字符串</span><br><span class="line">* @param &#123;...*&#125; 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 输出的字符数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">errorf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num_errors = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 声明可变数组列表</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	num_errors++;</span><br><span class="line">	<span class="comment">// 打印需要增强的部分</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"** Error %d: "</span>, num_errors);</span><br><span class="line">	<span class="comment">// 初始化可变数组列表</span></span><br><span class="line">	va_start(ap, format);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入字符串（打印到屏幕）</span></span><br><span class="line">	n = <span class="built_in">vfprintf</span>(stderr, format, ap);</span><br><span class="line">	<span class="comment">// 清理可变参数列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入“换行”</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-2-stdlib-h-通用的使用工具"><a href="#26-2-stdlib-h-通用的使用工具" class="headerlink" title="26.2    stdlib.h:    通用的使用工具"></a>26.2    stdlib.h:    通用的使用工具</h2><blockquote>
<p><strong>说明：</strong>涵盖累全部不适合于任何其他头的函数。</p>
<ul>
<li>字符串转换函数</li>
<li>伪随机序列生成函数</li>
<li>内存管理函数</li>
<li>与外部环境的通信</li>
<li>搜索与排序使用工具</li>
<li>整数算术运算函数(<a href="">17</a>)</li>
<li>多子节字符和字符串函数(<a href="">25.2</a>)</li>
</ul>
</blockquote>
<h3 id="26-2-1-字符串转换函数"><a href="#26-2-1-字符串转换函数" class="headerlink" title="26.2.1    字符串转换函数"></a>26.2.1    字符串转换函数</h3><blockquote>
<p><strong>字符串中的特殊子串：</strong></p>
<ul>
<li><strong>十六进制浮点数</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>0x(X)</code></th>
<th>一个或多个<code>十六进制数字</code>（可能包括<code>小数点</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>无穷数</strong>：<code>INF</code>（不要求大小写）或`INFINITY（不要求大小写）</li>
<li><strong>NaN</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>NAN</code></th>
<th><code>(</code></th>
<th><code>空</code>或<code>一系列字符</code></th>
<th><code>)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>不要求大小写</td>
<td></td>
<td>可以包含字母、数组或下划线，用于<code>为NaN值的二进制表示指定某些位</code>或被<code>nan函数</code>(<a href="">23.4</a>)调用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="atof函数（c89之前）"><a href="#atof函数（c89之前）" class="headerlink" title="atof函数（c89之前）"></a>atof函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>double</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;double&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoi函数（c89之前）"><a href="#atoi函数（c89之前）" class="headerlink" title="atoi函数（c89之前）"></a>atoi函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span><br><span class="line">int atoi (const chat *nptr)；</span><br></pre></td></tr></table></figure>
<h4 id="atol函数（c89之前）"><a href="#atol函数（c89之前）" class="headerlink" title="atol函数（c89之前）"></a>atol函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>long int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtod函数（c89）"><a href="#strtod函数（c89）" class="headerlink" title="strtod函数（c89）"></a>strtod函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>double</code>，相比<code>atof函数（c89之前）</code></p>
<ul>
<li>返回值为<code>double</code>而不是<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtold</code>、<code>strtof</code>)</li>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回正或负的<code>HUGE_VAL</code>(<a href="">23.3</a>)</li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）<br><strong>原型：</strong><code>stdlib.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">strtod</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtol函数（c89）"><a href="#strtol函数（c89）" class="headerlink" title="strtol函数（c89）"></a>strtol函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code>，相比<code>atol函数（c89之前）</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoul函数（c89）"><a href="#strtoul函数（c89）" class="headerlink" title="strtoul函数（c89）"></a>strtoul函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtold函数-C99"><a href="#strtold函数-C99" class="headerlink" title="strtold函数(C99)"></a>strtold函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long double</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>long double</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtof</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;long double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">strtold</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoll函数-c99"><a href="#atoll函数-c99" class="headerlink" title="atoll函数(c99)"></a>atoll函数(c99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，和<code>atol函数（c89之前）</code>相比</p>
<ul>
<li>转换为<code>long long int</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code></li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtof函数-C99"><a href="#strtof函数-C99" class="headerlink" title="strtof函数(C99)"></a>strtof函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>float</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtold</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;float&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">strtof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoll函数-C99"><a href="#strtoll函数-C99" class="headerlink" title="strtoll函数(C99)"></a>strtoll函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，类似<code>strtol函数（c89）</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoull函数-C99"><a href="#strtoull函数-C99" class="headerlink" title="strtoull函数(C99)"></a>strtoull函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>unsigned long long int</code>，类似<code>strtoul函数(c89)</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoull</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试数值转换函数"><a href="#程序：测试数值转换函数" class="headerlink" title="程序：测试数值转换函数"></a>程序：测试数值转换函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Test c89 numeric conversion functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHK_VALID printf(<span class="string">"    %s        %s\n"</span>, \</span><br><span class="line"> 					     errno != ERANGE ? <span class="string">"Yes"</span> : <span class="string">"No "</span>, \</span><br><span class="line"> 					     *ptr == <span class="string">'\0'</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="comment">/* 检测程序启动方式是否正确 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: tnumconv string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使用c89之前的3个旧转换函数 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function Return Value\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------    --------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atof        %g\n"</span>, atof(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atoi        %d\n"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atol        %ld\n"</span>, atol(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function    Return Value    Valid?    "</span></span><br><span class="line">		   <span class="string">"String Consumed?\n"</span></span><br><span class="line">		   <span class="string">"--------    ------------    ------    "</span></span><br><span class="line">		   <span class="string">"------------------\n"</span>);</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtod    %-12g\n"</span>, strtod(argv[<span class="number">1</span>], &amp;ptr));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtol    %-12ld\n"</span>, strtol(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtoul    %-12lu\n"</span>, strtoul(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-24%20%E4%B8%8A%E5%8D%8810.36.50.png" alt="Alt text"></p>
<h3 id="26-2-3-伪随机序列生成函数"><a href="#26-2-3-伪随机序列生成函数" class="headerlink" title="26.2.3    伪随机序列生成函数"></a>26.2.3    伪随机序列生成函数</h3><h4 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>返回一个<code>0～RAND_MAX(stdlib.h)</code>的随机数。<br><strong>说明：</strong><code>rand函数</code>返回的数事实上不是随机的，这些数是由“种子”值（默认为1）产生的，但对于偶然的观察者而言，rand函数似乎能能够产生不相关的数值序列。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;int&#125; `0～RAND_MAX(stdlib.h)`的随机数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="srand函数"><a href="#srand函数" class="headerlink" title="srand函数"></a>srand函数</h4><blockquote>
<p><strong>描述：</strong>在<code>rand函数</code>执行前执行该函数来为<code>rand函数</code>提供种子值。<br><strong>注意：</strong>同一个种子值对应着一组特定的随机序列<br><strong>技巧：</strong>把<code>time函数</code>的返回值传递给<code>srand函数</code>设置“随机化”的种子值，这样可以使<code>rand函数</code>在每次运行时的行为都不相同。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests the pseudo-random sequence generation functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program displays the first five value of "</span></span><br><span class="line">		   <span class="string">"rand.\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter new seed value (0 to terminate):"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seed);</span><br><span class="line">		<span class="keyword">if</span> (seed == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		srand(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-3-与环境的通信"><a href="#26-2-3-与环境的通信" class="headerlink" title="26.2.3    与环境的通信"></a>26.2.3    与环境的通信</h3><blockquote>
<p><strong>说明：</strong>一组简单的操作系统接口。</p>
<ol>
<li>正常或不正常地终止程序，并且想操作系统反悔一个状态码</li>
<li>从用户的外部环境获取信息</li>
<li>执行操作系统的命令</li>
</ol>
</blockquote>
<h4 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统。<br><strong>细节：</strong>通常还会在后台做一些最后的动作</p>
<ul>
<li>清洗包好未输出数据的输出缓冲区</li>
<li>关闭打开的流</li>
<li>删除临时文件</li>
<li>调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
</ul>
<p><strong>说明：</strong>通常等价于在<code>main函数</code>中执行<code>return n</code>，具有可移植性的状态码包括</p>
<ul>
<li><strong>EXIT_SUCCESS宏：</strong>正常退出(整数0)</li>
<li><strong>EXIT_FAILURE宏：</strong>非正常退出</li>
</ul>
<p><strong>注意：</strong><code>exit函数</code>和<code>return语句</code>的不同表现在</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>exit函数</th>
<th>return语句</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main函数</code>中局部变量的生命周期</td>
<td>不结束</td>
<td>结束（如果用<code>atexit函数</code>注册的函数或<code>清洗输出流的缓冲区</code>访问这些变量就会出现问题）</td>
</tr>
<tr>
<td>使用<code>int</code>之外的类型</td>
<td>可以</td>
<td>必须和<code>mian函数</code>的返回类型保持一致，否则</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>当把函数指针传递给<code>aexit函数</code>时，它会把指针保存起来，当程序正常终止时会被调用。</p>
<ul>
<li>通过<code>exit函数</code>被调用或<code>main函数</code>中的<code>return</code>语句触发</li>
<li>如果注册了两个或更多函数，那么将按照与注册顺序<code>相反</code>的顺序调用它们</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void (*func)(void)&#125; func 函数指针</span><br><span class="line">* @return &#123;int&#125; 未知</span><br><span class="line">*/</span><br><span class="line">int atexit (void (*func)(void));</span><br></pre></td></tr></table></figure>
<h4 id="Exit函数（c99）"><a href="#Exit函数（c99）" class="headerlink" title="_Exit函数（c99）"></a>_Exit函数（c99）</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统<br><strong>说明：</strong>类似<code>exit函数</code></p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
<li>不会调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
<li>不回发送信号触发<code>signal函数</code>（<a href="">24.3</a>）注册的函数</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> _Exit (<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>通常会导致异常的程序终止，长生<code>SIGABRT信号</code>并向系统返回一个表示“不成功”的状态码。<br><strong>注意：</strong>有一种情况下不会导致程序终止，那就是通过<code>signal函数</code>为<code>SIGABRT信号</code>注册处理函数，且处理函数调用了<code>longjmp函数</code>恢复到之前的执行环境。<br><strong>说明：</strong>类似<code>exit</code>函数，特点是</p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a>getenv函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>提供了访问用户环境中的任意字符串（环境变量）的功能。<br><strong>说明：</strong>获得的指针指向的字符串是静态的，有可能会被其它函数调用或系统自身修改。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; name 环境变量名</span><br><span class="line">* @return &#123;char *&#125; 指向静态分配的字符串的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* "/usr/local/bin:/bin:/usr/bin:." */</span></span><br><span class="line"><span class="keyword">char</span> *p = getenv(<span class="string">"PATH"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>运行另一个c程序（可以是操作系统命令）<br><strong>说明：</strong>类似在操作系统终端使用命令行</p>
<ul>
<li><strong>参数：</strong>以<code>NULL</code>作为参数有特殊含义</li>
<li><strong>返回值</strong>：（由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; string 命令</span><br><span class="line">* @return &#123;int&#125; 由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用UNIX(Linux)的ls命令，并将结果存入myfiles</span></span><br><span class="line">system(<span class="string">"ls &gt;myfiles"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="26-2-4-搜索和排序使用工具"><a href="#26-2-4-搜索和排序使用工具" class="headerlink" title="26.2.4    搜索和排序使用工具"></a>26.2.4    搜索和排序使用工具</h3><h4 id="bsearch函数"><a href="#bsearch函数" class="headerlink" title="bsearch函数"></a>bsearch函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据键在<code>有序数组</code>中搜索一个特定的值。<br><strong>说明：</strong>通常会使用<code>二分搜索算法</code>来搜索在数组中搜索<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; key 指向键（匹配依据）的指针</span><br><span class="line">* @param &#123;void *&#125; base 数组</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @param &#123;Function *&#125; compar 指向比较函数的指针</span><br><span class="line">* @return &#123;void *&#125; 指向与键匹配的指针：匹配到；NULL：没匹配到</span><br><span class="line">*/</span><br><span class="line">void *bsearch (const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h4 id="qsort函数"><a href="#qsort函数" class="headerlink" title="qsort函数"></a>qsort函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>为数组进行排序<br><strong>相关：</strong><a href="">17.1</a><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;Function *&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h3 id="程序：确定航空里程"><a href="#程序：确定航空里程" class="headerlink" title="程序：确定航空里程"></a>程序：确定航空里程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine air mileage from New York City.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> city_info &#123;</span><br><span class="line">	<span class="keyword">char</span> *city;</span><br><span class="line">	<span class="keyword">int</span> miles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> city_name[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">struct</span> city_info *ptr;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> city_info mileage[] = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Berlin"</span>, <span class="number">3965</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Buenos Aires"</span>, <span class="number">5297</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cairo"</span>, <span class="number">5602</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Calcutta"</span>, <span class="number">7918</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cape Town"</span>, <span class="number">7764</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter city name:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%80[^\n]"</span>, city_name);</span><br><span class="line">	ptr = bsearch(city_name, mileage, sizeof(mileage) / sizeof(mileage[<span class="number">0</span>]), sizeof(mileage[<span class="number">0</span>]), compare_cityes);</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is %d miles from New York City.\n"</span>, city_name, ptr-&gt;miles);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s wasn't found."</span>, city_name);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">strcmp</span>((char *) key_ptr, ((struct city_info *) element_ptr)-&gt;city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-5-整数运算函数"><a href="#26-2-5-整数运算函数" class="headerlink" title="26.2.5    整数运算函数"></a>26.2.5    整数运算函数</h3><h4 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; j 需要求绝对值的整数</span><br><span class="line">* @return &#123;int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="labs函数"><a href="#labs函数" class="headerlink" title="labs函数"></a>labs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="llabs函数"><a href="#llabs函数" class="headerlink" title="llabs函数"></a>llabs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="div函数"><a href="#div函数" class="headerlink" title="div函数"></a>div函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>ldiv</code><br>|比较|<code>div(ldiv)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>div（ldiv）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; number 除数</span><br><span class="line">* @param &#123;int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> div (<span class="keyword">int</span> number, <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="ldiv函数（c99）"><a href="#ldiv函数（c99）" class="headerlink" title="ldiv函数（c99）"></a>ldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>div</code><br>|比较|<code>ldiv(div)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>ldiv（div）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; number 除数</span><br><span class="line">* @param &#123;long  int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="lldiv函数（c99）"><a href="#lldiv函数（c99）" class="headerlink" title="lldiv函数（c99）"></a>lldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; number 除数</span><br><span class="line">* @param &#123;long long int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h2 id="26-3-time-h：日期和时间"><a href="#26-3-time-h：日期和时间" class="headerlink" title="26.3    time.h：日期和时间"></a>26.3    time.h：日期和时间</h2><blockquote>
<p><strong>说明：</strong>存储时间的数据结构。</p>
<ul>
<li><code>clock_t</code>：按照“时钟滴答”进行度量的时间值。</li>
<li><code>time_t</code>：紧凑的时间和日期编码（日历时间）</li>
<li><code>struct tm</code>：包含分解的时间的结构体<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-02%20%E4%B8%8B%E5%8D%889.40.49.png" alt="Alt text"><br>❶ 允许两个额外的“闰秒”。c99中最大值为60。<br>❷ 如果夏令时有效，就为正数；如果无效，为零；如果这一信息未知，就为负数。</li>
</ul>
</blockquote>
<h3 id="26-3-1-时间处理函数"><a href="#26-3-1-时间处理函数" class="headerlink" title="26.3.1    时间处理函数"></a>26.3.1    时间处理函数</h3><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回程序从开始执行到当前时刻的处理器时间（时钟数）。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;clock_t&#125; 程序从此启动到当前经过的处理器时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">clock_t</span> clock (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>为了将处理器时间转换为秒，将其除以<code>CLOCK_PER_SEC</code>(定义在<code>time.h</code>)。</li>
<li>当用<code>clock</code>函数来确定程序已经运行多长时间时（不包括到达<code>main函数</code>之前的时间），习惯做法时调用<code>clock函数</code>两次：一次在<code>main函数</code>开始处，一次在程序要终止之前。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 第一次调用 */</span></span><br><span class="line">	<span class="keyword">clock_t</span> start_clock = clock();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* 第二次调用 */</span></span><br><span class="line">	<span class="comment">/* CLOCK_PER_SEC：类型由实现定义，c99指定其为clock_t类型 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Processor time used: %g sec.\n"</span>, (clock() - start_clock / (double) CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回当前的日历时间。</p>
<ul>
<li>如果参数不为<code>NULL</code>,那么<code>time函数</code>还会把日历时间存储在实参指向的空间中。</li>
</ul>
<p><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t *&#125; timer 指向存储当前日历时间的存储空间（可以为NULL）</span><br><span class="line">* @return &#123;time_t&#125; 当前的日历时间 </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">time_t</span> time (<span class="keyword">time_t</span> *timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用返回值</span></span><br><span class="line">cur_time = time(NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过参数指定存储的位置</span></span><br><span class="line">time(&amp;cur_time);</span><br></pre></td></tr></table></figure>
<h4 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过两个时间点的日历时间，返回两个时间点之间的时间差（秒）<br><strong>用途：</strong>计算程序的运行时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; 日历时间</span><br><span class="line">* @param &#123;time_t&#125; 日历时间（较早的时间）</span><br><span class="line">* @return &#123;double&#125; time0和time1之间按秒衡量的差值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(time_t time1, time_t time0)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第一个日历时间</span></span><br><span class="line">	<span class="keyword">time_t</span> start_time = time(NUULL);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 第二个日历时间，并计算时间差</span></span><br><span class="line">	ptintf(<span class="string">"Return time: %g sec.\n"</span>, difftime(NULL), start_time);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把<code>struct tm</code>(分解时间)类型的时间转换为日历时间并返回。<br><strong>用途：</strong>对于和时间、日期相关的计算非常有用。<br><strong>副作用：</strong>会按照一定规则调整结构的成员</p>
<ul>
<li><strong>改变值不在合法范围内的成员：</strong>一个成员的数值的调整可能会导致接连对其它成员的调整，直到全部合法。</li>
<li>初始化<code>tm_wday</code>（一星期的第几天）和<code>tm_yday</code>（一年中的第几天）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明分解时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化分解时间 */</span></span><br><span class="line">t.tm_mday = <span class="number">27</span>;<span class="comment">/* 日 */</span></span><br><span class="line">t.tm_mon = <span class="number">6</span>;<span class="comment">/* 月 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保证其他成员被正确初始化 */</span></span><br><span class="line">t.tm_sec = <span class="number">0</span>;</span><br><span class="line">t.tm_min = <span class="number">0</span>;</span><br><span class="line">t.tm_hour = <span class="number">0</span>;</span><br><span class="line">t.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 制造超出取值范围的情况 */</span></span><br><span class="line">t.tm_mday = += <span class="number">16</span>; <span class="comment">/* 43 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将分解时间转为日历时间，将导致原本的分解时间成员被修改 */</span></span><br><span class="line">mktime(&amp;t);</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.42.02.png" alt="Alt text"></p>
<h3 id="26-3-2-时间转换函数"><a href="#26-3-2-时间转换函数" class="headerlink" title="26.3.2    时间转换函数"></a>26.3.2    时间转换函数</h3><blockquote>
<p><strong>说明：</strong>转换示意图<br> <img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.44.39.png" alt="Alt text"><br><strong>注意：</strong>其中的<code>mktime函数</code>被C标准定义为<code>处理函数</code>而不是<code>转换函数</code>。</p>
</blockquote>
<h4 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是<code>UTC</code>(协调世界时间)。<br><strong>注意：</strong>返回值指向的是一个静态分配的结构，会被后续的<code>getime函数</code>或<code>localtime函数</code>调用修改。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; timer 日历时间</span><br><span class="line">* @return &#123;struct tm&#125; 分解时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是本地时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;&#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asctime函数"><a href="#asctime函数" class="headerlink" title="asctime函数"></a>asctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将分解时间转换为字符串格式。</p>
<blockquote>
<p><code>Sun Jun 3 17:48:34 2007\n</code></p>
</blockquote>
<p><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 指向分解时间结构体的指针</span><br><span class="line">* @return &#123;char *&#125; 字符串形式的时间(ASCII时间)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ctime函数"><a href="#ctime函数" class="headerlink" title="ctime函数"></a>ctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为字符串格式。<br><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; time 日历时间</span><br><span class="line">* @return &#123;char *&#125; 描述本地时间的字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span> <span class="params">(<span class="keyword">const</span> time_t *time)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strftime函数"><a href="#strftime函数" class="headerlink" title="strftime函数"></a>strftime函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>把分解时间转换成字符串格式。<br><strong>注意：</strong>函数对地区敏感，改变<code>LC_TIME</code>可能会影响转换说明符的行为。<br><strong>转换说明符：</strong></p>
<ul>
<li>针对<code>&quot;C&quot;</code>地区（c89~c99），支持<code>ISO 8601</code><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.54.27.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.55.24.png" alt="Alt text"></li>
<li>一些转换说明符在<code>&quot;C&quot;</code>地区的替换字符串（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.58.53.png" alt="Alt text"></li>
<li><code>E</code>或<code>O</code>修饰符：修改特定的转换说明符，替换为依赖当前地区的备选格式（<code>&quot;C&quot;</code>地区忽略<code>E</code>或<code>O</code>）（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8811.04.15.png" alt="Alt text"></li>
</ul>
<p><strong>说明：</strong>类似<code>asctime函数</code>，但提供了大量对时间进行格式化的控制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 指向用来存储字符串形式的时间的空间</span><br><span class="line">* @param &#123;size_t&#125; maxsize 存储在s中的字符数量上限</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 分解时间</span><br><span class="line">* @return &#123;size_t&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strftime (<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, <span class="keyword">const</span> <span class="keyword">struct</span> tm * restricy timeptr);</span><br></pre></td></tr></table></figure>
<h3 id="程序：显示日期和时间"><a href="#程序：显示日期和时间" class="headerlink" title="程序：显示日期和时间"></a>程序：显示日期和时间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Display the current date and time in three formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 1. 获得日历时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> current = time(NULL);</span><br><span class="line">	<span class="keyword">struct</span> tm *ptr;</span><br><span class="line">	<span class="keyword">char</span> date_time[<span class="number">21</span>];</span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="keyword">char</span> am_or_pm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：ctime默认的的字符串形式 */</span></span><br><span class="line">	<span class="built_in">puts</span>(ctime(&amp;current));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：strftime默认的字符串形式 */</span></span><br><span class="line">	strftime(date_time, <span class="keyword">sizeof</span>(date_time), <span class="string">"%m-%d-%Y %I:%M%p\n"</span>, localtime(&amp;current));</span><br><span class="line">	<span class="built_in">puts</span>(date_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期和时间：使用printf结合分解时间 */</span></span><br><span class="line">	ptr = localtime(&amp;current);</span><br><span class="line">	hour = ptr-&gt;tm_hour;</span><br><span class="line">	<span class="keyword">if</span> (hour &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">		am_or_pm = <span class="string">'a'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hour -= <span class="number">12</span>;</span><br><span class="line">		am_or_pm = <span class="string">'p'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour == <span class="number">0</span>) &#123;</span><br><span class="line">		hour = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2d-%.2d-%.2d %2d:%.2d%c\n"</span>, ptr-&gt;tm_mon + <span class="number">1</span>, ptr-&gt;tm_mday, ptr-&gt;tm_year + <span class="number">1900</span>, hour, ptr-&gt;tm_min, am_or_pm);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./datetime</span><br><span class="line"> Wed Nov  4 10:41:12  2015</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41AM</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41a</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/24 错误处理/" itemprop="url">
                  24 错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T11:42:41+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>C语言的弱项：</strong>错误的检测和处理并不是c语言的强项</p>
<ul>
<li>C语言对运行时错误以多种形式表示，而没有提供一种统一的方式</li>
<li>程序员必须将检测错误的代码编写在程序代码中，因此很容易忽略一些错误</li>
</ul>
<p><strong>扩展：</strong>C++语言对C语言的这一弱点进行了改进，提供了一种新的错误错误的方式－异常处理（exception handling）。</p>
</blockquote>
<h2 id="24-1-assert-h：诊断"><a href="#24-1-assert-h：诊断" class="headerlink" title="24.1    assert.h：诊断"></a>24.1    <code>assert.h</code>：诊断</h2><h4 id="assert宏（函数）"><a href="#assert宏（函数）" class="headerlink" title="assert宏（函数）"></a>assert宏（函数）</h4><blockquote>
<p><strong>断言：</strong>一个我们认为在正常情况下一顶为真的表达式。<br><strong>错误信息：</strong>标准C要求在显示的消息中指明以下内容</p>
<ul>
<li>传递给assert函数的参数</li>
<li>包括assert调用的文件名</li>
<li>assert调用所在的行号</li>
</ul>
<p><strong>说明：</strong>检查断言，如果值不为0，会向<code>stderr</code>输出一条信息，并调用<code>abort函数</code>终止程序。<br><strong>技巧：</strong>因为引入了额外的检查，因此会增加程序的运行时间。可以在测试没问题后通过<code>NDEBUG</code>（宏）进制<code>assert</code>调用。<br><strong>注意：</strong>因为assert可能会被禁用，因此不要在assert调用中使用有副作用的表达式。<br><strong>原型</strong><code>assert.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; expresstion 断言</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i];</span><br><span class="line">assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; N);<span class="comment">// 保证下标不回溢出</span></span><br><span class="line">a [i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><em>禁止assert调用</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG<span class="comment">// 值不重要，定义了就行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="24-2-errno-h：错误"><a href="#24-2-errno-h：错误" class="headerlink" title="24.2    errno.h：错误"></a>24.2    <code>errno.h</code>：错误</h2><blockquote>
<p><strong>说明：</strong>除了<code>EDOM</code>和<code>ERANGE</code>,还定义了其他宏，这是合法的，但命名要遵循C标准，即<code>E数组或大写字母</code></p>
</blockquote>
<h4 id="errno宏"><a href="#errno宏" class="headerlink" title="errno宏"></a>errno宏</h4><hr>
<blockquote>
<p><strong>描述：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和变量一样使用。<br><strong>说明：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和普通变量一样使用。<br><strong>用途：</strong>函数被调用后会会为<code>errno</code>赋值，如果<code>errno</code>不为0，代表函数调用过程中有错误发生。<br><strong>应用：</strong>大部分使用<code>errno</code>变量的函数集中在<code>math.h</code>，也有一些在标准库的其他部分。<br><strong>相关宏：</strong><code>EDOM</code>和<code>ERANGE</code>,errno中存储的值通常是这两个宏</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏（errno的值）</th>
<th>错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDOM</td>
<td>定义域错误</td>
<td>传递给函数的一个参数不属于函数的定义域</td>
</tr>
<tr>
<td>ERANGE</td>
<td>取值范围错误</td>
<td>函数的返回值太大，无法用double</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用库函数</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sqrt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>向<code>stderr</code>输出一条错误信息。<br><strong>错误信息：</strong><code>sqrt error: Math argument</code>（定义域错误）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">perror的参数</th>
<th style="text-align:center">分号</th>
<th style="text-align:center">空格</th>
<th style="text-align:center">出错消息</th>
<th style="text-align:center">换行符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sqrt error</td>
<td style="text-align:center">:</td>
<td style="text-align:center"></td>
<td style="text-align:center">Math argument</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 错误描述</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sqrt</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测运行状况</span></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"sqrt error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据错误类型行值返回指向错误字符串的指针。<br><strong>原型：</strong><code>string.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; errnum 错误类型值</span><br><span class="line">* @return &#123;char *&#125; 对应的错误字符串 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="24-3-signal-h：信号处理"><a href="#24-3-signal-h：信号处理" class="headerlink" title="24.3    signal.h：信号处理"></a>24.3    <code>signal.h</code>：信号处理</h2><blockquote>
<p><strong>信号（signal）：</strong>处理异常情况的工具</p>
<ul>
<li><p>运行时错误</p>
<blockquote>
<p>例如：除以0</p>
</blockquote>
</li>
<li><p>程序以外导致的事件</p>
<blockquote>
<p>例如：许多操作系统都允许用户终端或终止运行的程序</p>
</blockquote>
</li>
</ul>
<p><strong>异步的：</strong>它们可以在程序执行过程中的任意时刻发生，而不仅是在程序员所知道的特定时刻发生</p>
</blockquote>
<h3 id="24-3-1-信号宏"><a href="#24-3-1-信号宏" class="headerlink" title="24.3.1    信号宏"></a>24.3.1    信号宏</h3><blockquote>
<p><strong>兼容性：</strong>C标准不要求下面列表中的信号都会发生，大多数C语言的实现都至少支持其中一部分。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>异常终止（可能由于调用abort导致）</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>在数学运算中发生错误（可能是除以0或溢出）</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGINT</td>
<td>中断</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法存储访问</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止请求</td>
</tr>
</tbody>
</table>
<h3 id="24-3-2-signal函数"><a href="#24-3-2-signal函数" class="headerlink" title="24.3.2    signal函数"></a>24.3.2    signal函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>为指定信号注册指定处理函数。<br><strong>相关宏：</strong><code>SIG_ERR</code></p>
<blockquote>
<p><strong>说明：</strong>当注册失败时会返回该值<br><strong>用途：</strong>检测注册处理函数是否成功</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p><strong>多对一：</strong><code>信号</code>与处理函数是<code>多对一</code>的关系</p>
<ul>
<li>可以对多种信号绑定同一个处理函数，处理函数可以根据传入的参数（信号类型）决定进行哪种操作</li>
<li>也可以对同一个信号注册多个处理程序，但前面注册的会被后面注册的处理函数覆盖。</li>
</ul>
<p><strong>同步性：</strong>发出信号的行为是异步的，但处理函数处理的过程是同步的。也就是说，注册了处理函数的信号出现后，程序会暂停并执行信号处理函数，返回后暂停的程序从信号发生点恢复并继续执行。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>处理函数返回后程序行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>终止</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>处理函数返回后的程序行为未定义</td>
</tr>
<tr>
<td>其它</td>
<td>暂停的程序从信号发生点恢复并继续执行</td>
</tr>
</tbody>
</table>
<blockquote>
<blockquote>
<p><strong>一次性：</strong>信号处理完之后，除非处理函数被重新注册，否则该信号不回被同一个函数处理两遍。<br><strong>无限递归问题：</strong>如果信号是由处理这个信号的函数引发的，如果没有其它机制将会发生无限递归。所以，C语言要求，除了<code>SIGTLL</code>，当一个信号的处理函数被调用时，该信号对应的处理函数要么要被重置为<code>SIG_DFL</code>或以其它方式加以封锁。</p>
</blockquote>
<p><strong>限制：</strong>处理函数和普通函数相比多了一些限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>可以</th>
<th>不可以</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以忽略该信号</td>
<td>自由调用库函数</td>
</tr>
<tr>
<td>执行一些错误修复</td>
<td>访问静态存储期限的变量</td>
</tr>
<tr>
<td>终止程序</td>
<td></td>
</tr>
<tr>
<td>可以调用<code>signal</code>，只要第一个参数为正被处理的信号</td>
<td></td>
</tr>
<tr>
<td>调用库函数，只要信号处理函数是由raise或abort调用的</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @param &#123;func *&#125; func 处理函数</span><br><span class="line">* @return &#123;func *&#125; 指向注册过同样信号的上一个处理函数的指针：成功；SIG_ERR：注册失败（同时会在errno中存储一个正值）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> *(*signal)(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(int));<span class="comment">// 书上写法是：void (*signal(int sig, void (*func)(int)))(int);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为中断注册处理函数，并将之前的处理函数存储下来</span></span><br><span class="line">orig_handler = signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orig_handler == SIG_ERR) &#123;</span><br><span class="line">	<span class="comment">// 注册处理函数失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成原来的处理函数</span></span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-3-预定义的信号处理函数"><a href="#24-3-3-预定义的信号处理函数" class="headerlink" title="24.3.3    预定义的信号处理函数"></a>24.3.3    预定义的信号处理函数</h3><blockquote>
<p><strong>说明：</strong>出了编写我们自己的信号处理函数，我们还可以选择使用<code>signal.h</code>提供的预定义的处理函数。<br><strong>预定义的信号处理函数命名规则：</strong></p>
<blockquote>
<p><code>SIG_</code>大写字母</p>
</blockquote>
</blockquote>
<h4 id="SIG-DFL宏（函数）"><a href="#SIG-DFL宏（函数）" class="headerlink" title="SIG_DFL宏（函数）"></a>SIG_DFL宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>按“默认”的方式处理<br><strong>描述：</strong>行为由实现定义，大多数情况下会导致程序终止。<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_DFL</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN); <span class="comment">// 使用默认行为响应“中断”信号</span></span><br></pre></td></tr></table></figure>
<h4 id="SIG-IGN宏（函数）"><a href="#SIG-IGN宏（函数）" class="headerlink" title="SIG_IGN宏（函数）"></a>SIG_IGN宏（函数）</h4><hr>
<blockquote>
<p><strong>描述：</strong>什么都不做，忽略信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_IGN</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="24-3-4-raise函数"><a href="#24-3-4-raise函数" class="headerlink" title="24.3.4    raise函数"></a>24.3.4    raise函数</h3><hr>
<blockquote>
<p><strong>说明：</strong>触发信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发SIGABORT</span></span><br><span class="line">raise(SIGABOUT);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-5-程序：测试信号"><a href="#24-3-5-程序：测试信号" class="headerlink" title="24.3.5    程序：测试信号"></a>24.3.5    程序：测试信号</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests signals</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明函数指针</span></span><br><span class="line">	<span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1. 第一次实验*/</span></span><br><span class="line">	<span class="comment">// 注册处理函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---first--- %d\n"</span>, SIGILL);</span><br><span class="line">	signal(SIGILL, handler);</span><br><span class="line">	<span class="comment">// 触发信号</span></span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2. 第二次实验*/</span></span><br><span class="line">	<span class="comment">// 再次注册,忽略相应信号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---second---\n"</span>);</span><br><span class="line">	orig_handler = signal(SIGILL, SIG_IGN);</span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3. 第三次实验*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---third---\n"</span>);</span><br><span class="line">	<span class="comment">// 更改为第一次实验使用的处理函数</span></span><br><span class="line">	signal(SIGILL, orig_handler);</span><br><span class="line">	raise_sig();</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Handler called for signal %d\n"</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	raise(SIGILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./tsignal</span><br><span class="line"> ---first--- 4</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br><span class="line"> ---second---</span><br><span class="line"> ---third---</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br></pre></td></tr></table></figure>
<h2 id="24-4-setjmp-h：非局部跳转"><a href="#24-4-setjmp-h：非局部跳转" class="headerlink" title="24.4    setjmp.h：非局部跳转"></a>24.4    setjmp.h：非局部跳转</h2><blockquote>
<p><strong>说明：</strong>通常情况下，函数调用后会回到它被调用的位置。但<code>setjmp.h</code>提供了使一个函数直接跳转到另一个函数（而且不需要返回）的方式。<br><strong>goto：</strong>只能配合标记实现<code>局部跳转</code>，也就是在同一个函数内部跳转。</p>
</blockquote>
<h3 id="setjmp宏（函数）"><a href="#setjmp宏（函数）" class="headerlink" title="setjmp宏（函数）"></a>setjmp宏（函数）</h3><blockquote>
<p><strong>描述：</strong>标记程序中的一个“位置”<br><strong>应用：</strong>生成标记位置，稍后提供给<code>longjmp函数</code><br><strong>限制：</strong>按照<code>标准C</code>，只有两种使用setjmp的方式是合法的(否则不具备可移植性)</p>
<ul>
<li>作为表达式语句（可能会前置转换成void）</li>
<li>作为<code>if、switch、while、do、for</code>语句中控制表达式的一部分(<code>constexp</code>：计算结果为整数的<em>常量表达式</em>；<code>op</code>：<em>关系</em>或<em>判等</em>运算符)</li>
</ul>
<ol>
<li>setjmp(…)</li>
<li>!setjmp(…)</li>
<li><code>constexp</code> <code>op</code> <code>constexp</code></li>
<li>setjmp(…) <code>op</code> <code>constexp</code></li>
</ol>
<p><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env 用来保存生成的被调用时所处的“位置”(数组)</span><br><span class="line">* @return &#123;int&#125; 0：第一次调用时返回；非0：longjmp将控制权重新转给最初的setjmp宏调用，后者这次的返回值非零</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a>longjmp函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>首先根据参数env的值恢复当前环境，然后从<code>setjmp宏</code>调用中返回<br><strong>注意：</strong>一定要确保参数env已经被<code>setjmp宏</code>初始化了，否则程序可能会崩溃。<br><strong>应用：</strong>可以由多种潜在的用途，但主要被用于错误处理。<br><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env</span><br><span class="line">* @param &#123;int&#125; val</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试setjmp和longjmp"><a href="#程序：测试setjmp和longjmp" class="headerlink" title="程序：测试setjmp和longjmp"></a>程序：测试setjmp和longjmp</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests setjmp/longjmp</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @type &#123;jmp_buf&#125; env 存储位置数据的全局变量</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">// 获得存储位置</span></span><br><span class="line">	ret = setjmp(env);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"setjmp returned %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次执行到这里的时候值不为0</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Program terminates: longjmp called\n"</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f1();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这句不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Program terminates normally\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 begins\n"</span>);</span><br><span class="line">	f2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 returns\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 begins\n"</span>);</span><br><span class="line">	<span class="comment">// 按照env的值跳转到指定的环境</span></span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 returns\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ ./tsetjmp               </span><br><span class="line"> setjmp returned <span class="number">0</span></span><br><span class="line"> f1 begins</span><br><span class="line"> f2 begins</span><br><span class="line"> setjmp returned <span class="number">1</span></span><br><span class="line"> Program terminates: longjmp called</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/23 库对数值和字符数据的支持/" itemprop="url">
                  23 库对数值和字符数据的支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:31:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="23-1-float-h-浮点型的特性"><a href="#23-1-float-h-浮点型的特性" class="headerlink" title="23.1    float.h:浮点型的特性"></a>23.1    <code>float.h</code>:浮点型的特性</h2><p><strong>说明：</strong>提供了用来定义浮点型的范围和精度的宏（没有类型和函数的定义）。<br><strong>应用：</strong>由于只有进行数值分析的专家才会对上述<code>float.h</code>中定义的宏感兴趣，这可能是标砖哭中最不常用的宏。</p>
<h3 id="23-1-1-对浮点数通用的宏"><a href="#23-1-1-对浮点数通用的宏" class="headerlink" title="23.1.1    对浮点数通用的宏"></a>23.1.1    对浮点数通用的宏</h3><h4 id="FLT-ROUND宏"><a href="#FLT-ROUND宏" class="headerlink" title="FLT_ROUND宏"></a>FLT_ROUND宏</h4><p><strong>说明：</strong>浮点加法的舍入模式，存在5中可能<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.12.40.png" alt="Alt text"></p>
<h4 id="FLT-RADIX宏"><a href="#FLT-RADIX宏" class="headerlink" title="FLT_RADIX宏"></a>FLT_RADIX宏</h4><p><strong>说明：</strong>指定了基数的形式，最小值是2（二进制）</p>
<h3 id="23-1-2-其它宏"><a href="#23-1-2-其它宏" class="headerlink" title="23.1.2    其它宏"></a>23.1.2    其它宏</h3><p><strong>说明：</strong>其他宏用来描述特定类型的特性。<br><strong>宏命名：</strong>根据宏是针对的浮点类型有不同的前缀</p>
<table>
<thead>
<tr>
<th>宏前缀</th>
<th>针对的浮点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT</td>
<td>float</td>
</tr>
<tr>
<td>DBL</td>
<td>double</td>
</tr>
<tr>
<td>LDBL</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h4 id="与有效数字个数相关的宏"><a href="#与有效数字个数相关的宏" class="headerlink" title="与有效数字个数相关的宏"></a>与有效数字个数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.19.57.png" alt="Alt text"></p>
<h4 id="与指数相关的宏"><a href="#与指数相关的宏" class="headerlink" title="与指数相关的宏"></a>与指数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="Alt text"></p>
<h4 id="其它宏"><a href="#其它宏" class="headerlink" title="其它宏"></a>其它宏</h4><p><strong>说明：</strong>描述了最大值、最接近0的值（最小正数），两个数之间的最小差值。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.22.22.png" alt="Alt text"></p>
<h2 id="23-2-limit-h：整值类型的大小"><a href="#23-2-limit-h：整值类型的大小" class="headerlink" title="23.2    limit.h：整值类型的大小"></a>23.2    <code>limit.h</code>：整值类型的大小</h2><p><strong>说明：</strong>提供了用于定义每种整型和字符型取值范围的宏（没有类型或函数）。</p>
<h3 id="23-2-1-用于字符型的宏"><a href="#23-2-1-用于字符型的宏" class="headerlink" title="23.2.1    用于字符型的宏"></a>23.2.1    用于字符型的宏</h3><p><strong>说明：</strong><code>char、signed char、unsigned char</code><br><strong>注意：</strong>char类型在有些机器上默认为unsigned char，有些默认为signed char。CHAR_MIN和CHAR_MAX的值因不同情况有所不同。<br>①</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MIN</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MIN</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MAX</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MAX</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR_MAX</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.08.05.png" alt="Alt text"></p>
<h3 id="23-2-2-用于整型的宏"><a href="#23-2-2-用于整型的宏" class="headerlink" title="23.2.2    用于整型的宏"></a>23.2.2    用于整型的宏</h3><p><strong>说明：</strong><code>[{signed|unsigned}] [{short|long}] int</code><br><strong>用途：</strong>在查看编译器是否支持特定大小的整数时十分方便<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.27.34.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用预处理指令判断int型是否可以用来存储100 000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small<span class="comment">// 终止编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择正确的类型定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &gt;= 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="23-3-math-h：数学计算"><a href="#23-3-math-h：数学计算" class="headerlink" title="23.3    math.h：数学计算"></a>23.3    <code>math.h</code>：数学计算</h2><p><strong>说明：</strong>包含5中类型</p>
<ol>
<li>三角函数</li>
<li>双曲函数</li>
<li>指数和对数函数</li>
<li>幂函数</li>
<li>就近取整函数绝对值函数和取余函数</li>
</ol>
<h3 id="23-3-1-错误"><a href="#23-3-1-错误" class="headerlink" title="23.3.1    错误"></a>23.3.1    错误</h3><p><strong>相关库：</strong><code>errno.h</code><br><strong>特点：</strong><code>math.h</code>中，大多数函数会将一个错误代码存储到一个名字为<code>errno</code>（<code>math.h</code>）的特定变量中（这一点不同于其他库）。<br><strong>相关宏：</strong><code>HUGE_VAL</code>(<code>math.h</code>， IEEE标准)</p>
<blockquote>
<p><strong>说明：</strong>在<code>math.h</code>中定义，double类型，不一定是一个普通的数，代表无穷大（<a href="">7.2</a>）。<br><strong>用途：</strong>当函数的返回值大于double类型的最大值时，会返回<code>HUGE_VAL</code>。<br><strong>更多错误：</strong><a href="">附录D</a></p>
</blockquote>
<h4 id="参数超出定义域"><a href="#参数超出定义域" class="headerlink" title="参数超出定义域"></a>参数超出定义域</h4><p><strong>描述：</strong>函数的是惨超出了函数的定义域。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>EDOM</code>(定义域错误)<br><strong>返回值：</strong><code>NAN</code>(<code>math.h</code>， IEEE标准)</p>
<h4 id="返回值超出取值范围"><a href="#返回值超出取值范围" class="headerlink" title="返回值超出取值范围"></a>返回值超出取值范围</h4><p><strong>描述：</strong>函数的返回值超出了double类型的取值范围。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>ERANGE</code>(取值范围错误)，绝对值过小（下溢出）的情况又可能不存储<code>ERANGE</code><br><strong>返回值：</strong>分两种情况</p>
<ol>
<li><strong>绝对值过大：</strong>根据返回值的正负返回正或负的<code>HIGE_VAL</code></li>
<li><strong>绝对值过小：</strong>返回0</li>
</ol>
<h3 id="23-3-2-三角函数"><a href="#23-3-2-三角函数" class="headerlink" title="23.3.2    三角函数"></a>23.3.2    三角函数</h3><h4 id="cos函数"><a href="#cos函数" class="headerlink" title="cos函数"></a>cos函数</h4><p><strong>说明：</strong>余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sin函数"><a href="#sin函数" class="headerlink" title="sin函数"></a>sin函数</h4><p><strong>说明：</strong>正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tan函数"><a href="#tan函数" class="headerlink" title="tan函数"></a>tan函数</h4><p><strong>说明：</strong>正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="acos函数"><a href="#acos函数" class="headerlink" title="acos函数"></a>acos函数</h4><p><strong>说明：</strong>反余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 余弦值</span><br><span class="line">* @return &#123;double&#125; 余弦值对应的弧度（0~π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asin函数"><a href="#asin函数" class="headerlink" title="asin函数"></a>asin函数</h4><p><strong>说明：</strong>反正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正弦值</span><br><span class="line">* @return &#123;double&#125; 正弦值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan函数"><a href="#atan函数" class="headerlink" title="atan函数"></a>atan函数</h4><p><strong>说明：</strong>反正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正切值</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan2函数"><a href="#atan2函数" class="headerlink" title="atan2函数"></a>atan2函数</h4><p><strong>说明：</strong>反正切，<code>atan(x)&lt;==&gt;atan2(x, 1.0)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; y y</span><br><span class="line">* @param &#123;double&#125; x x</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π～π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cos</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(PI/<span class="number">4</span>);<span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">1.0</span>);<span class="comment">// 0.0</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">1.0</span>);<span class="comment">// 1.5708</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1.0</span>);<span class="comment">// 0.785398</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-4-双曲函数"><a href="#23-3-4-双曲函数" class="headerlink" title="23.3.4    双曲函数"></a>23.3.4    双曲函数</h3><h4 id="cosh函数"><a href="#cosh函数" class="headerlink" title="cosh函数"></a>cosh函数</h4><p><strong>说明：</strong>计算双曲余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cosh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sinh函数"><a href="#sinh函数" class="headerlink" title="sinh函数"></a>sinh函数</h4><p><strong>说明：</strong>计算双曲正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sinh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p><strong>说明：</strong>计算双曲正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tanh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cosh</span>(<span class="number">0.5</span>);<span class="comment">// 1.12763</span></span><br><span class="line"><span class="built_in">sinh</span>(<span class="number">0.5</span>);<span class="comment">// 0.521095</span></span><br><span class="line"><span class="built_in">tanh</span>(<span class="number">0.5</span>);<span class="comment">// 0.462117</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-指数函数和对数函数"><a href="#22-3-4-指数函数和对数函数" class="headerlink" title="22.3.4 指数函数和对数函数"></a>22.3.4 指数函数和对数函数</h3><h4 id="exp函数"><a href="#exp函数" class="headerlink" title="exp函数"></a>exp函数</h4><p><strong>说明：</strong>返回e的幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 指数</span><br><span class="line">* @return &#123;double&#125; e的x次幂</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e的3次幂</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">3.0</span>);<span class="comment">// 20.0855</span></span><br></pre></td></tr></table></figure>
<h4 id="log函数"><a href="#log函数" class="headerlink" title="log函数"></a>log函数</h4><p><strong>说明：</strong>以e为底的对数（exp函数的逆运算）<br><strong>原型：</strong>math.h``</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return double 以e为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">20.0855</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="log10函数"><a href="#log10函数" class="headerlink" title="log10函数"></a>log10函数</h4><p><strong>说明：</strong>计算常用对数（以10为底的对数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return &#123;double&#125; 以10为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log10</span>(<span class="number">1000</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 对任意的x和b，计算以b为底x的对数</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @param &#123;double&#125; b 底数</span><br><span class="line">* @return &#123;double&#125; 以b为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">logb</span><span class="params">(<span class="keyword">double</span> x. <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">log</span>(x) / <span class="built_in">log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="frexp函数"><a href="#frexp函数" class="headerlink" title="frexp函数"></a>frexp函数</h4><p><strong>说明：</strong>将浮点数拆成小数部分f和指数部分n，使得原始值等于<code>f x 2^n</code>。<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 浮点数原始值</span><br><span class="line">* @param &#123;double *&#125; iptr 存储n的地址</span><br><span class="line">* @return &#123;double&#125; f（0.5&lt;=f&lt;=1）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lfexp</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">frexp</span>(<span class="number">12.0</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// .75, exp: 4</span></span><br><span class="line"><span class="built_in">frexp</span>(<span class="number">0.25</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// 0.5, exp: -1</span></span><br></pre></td></tr></table></figure>
<h4 id="ldexp函数"><a href="#ldexp函数" class="headerlink" title="ldexp函数"></a>ldexp函数</h4><p><strong>说明：</strong>将小数部分f和整数部分exp组合为，一般而言为<code>f x 2^exp</code>(frexp函数的逆函数)<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; f 小数部分</span><br><span class="line">* @param &#123;int&#125; exp 整数部分</span><br><span class="line">* @return &#123;double&#125; f x 2^exp</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ldexp</span><span class="params">(<span class="keyword">double</span> f <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ldexp</span>(<span class="number">.75</span>, <span class="number">4</span>);<span class="comment">// 12.0</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.5</span>, <span class="number">-1</span>);<span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>
<h4 id="modf函数"><a href="#modf函数" class="headerlink" title="modf函数"></a>modf函数</h4><p><strong>说明：</strong>将一个浮点数的整数部分和小数部分拆解开，返回小数部分，并将整数部分存入第二个参数所指向的变量中<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 原始浮点数</span><br><span class="line">* @param &#123;double *&#125; iptr 存储整数部分的地址</span><br><span class="line">* @return &#123;double&#125; 小数部分 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-3-5-幂函数"><a href="#23-3-5-幂函数" class="headerlink" title="23.3.5    幂函数"></a>23.3.5    幂函数</h3><h4 id="pow函数"><a href="#pow函数" class="headerlink" title="pow函数"></a>pow函数</h4><p><strong>说明：</strong>计算x的y次幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 底数</span><br><span class="line">* @param &#123;double&#125; y 指数</span><br><span class="line">* @param &#123;double&#125; x^y</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);<span class="comment">// 9.0</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">0.5</span>);<span class="comment">// 1.73205</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">-3.0</span>);<span class="comment">// 0.037037</span></span><br></pre></td></tr></table></figure>
<h4 id="sqrt函数"><a href="#sqrt函数" class="headerlink" title="sqrt函数"></a>sqrt函数</h4><p><strong>说明：</strong>计算平方根（算数平方根），<code>sqrt(x)</code>相当于<code>pow(x, 0.5)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 开放数</span><br><span class="line">* @return &#123;double&#125; 平方根</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(<span class="number">3.0</span>);<span class="comment">// 1.73205</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-6-就近取整函数、绝对值函数和取余函数"><a href="#23-3-6-就近取整函数、绝对值函数和取余函数" class="headerlink" title="23.3.6    就近取整函数、绝对值函数和取余函数"></a>23.3.6    就近取整函数、绝对值函数和取余函数</h3><h4 id="ceil函数"><a href="#ceil函数" class="headerlink" title="ceil函数"></a>ceil函数</h4><p><strong>说明：</strong>向上舍入（计算大于或等于其参数的最小整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="floor函数"><a href="#floor函数" class="headerlink" title="floor函数"></a>floor函数</h4><p><strong>说明：</strong>向下舍入（计算小于或等于其参数的最大整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.1</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.8</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.1</span>);<span class="comment">// -7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.1</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.8</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.1</span>);<span class="comment">// -8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 实现“四舍五入”（标准库没实现）</span><br><span class="line">* @param &#123;double&#125; x 原始的浮点数</span><br><span class="line">* @return &#123;double&#125; 四舍五入后的</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	return x &lt; <span class="number">0.07</span> ? <span class="built_in">ceil</span>(x - <span class="number">0.5</span>) : <span class="built_in">floor</span>(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fabs函数"><a href="#fabs函数" class="headerlink" title="fabs函数"></a>fabs函数</h4><p><strong>说明：</strong>计算参数的绝对值<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 原始浮点数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="number">7.1</span>);<span class="comment">// 7.1</span></span><br><span class="line"><span class="built_in">fabs</span>(<span class="number">-7.1</span>);<span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<h4 id="fmod函数"><a href="#fmod函数" class="headerlink" title="fmod函数"></a>fmod函数</h4><p><strong>说明：</strong>取余（第一个参数除以第二个参数所得的余数）<br><strong>注意：</strong><code>%</code>只能用于整数，不能用于浮点数<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;double&#125; x 被除数</span><br><span class="line">* @param &#123;double&#125; y 除数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(<span class="number">5.5</span>, <span class="number">2.2</span>);<span class="comment">// 1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="23-4-ctype-h：字符处理"><a href="#23-4-ctype-h：字符处理" class="headerlink" title="23.4    ctype.h：字符处理"></a>23.4    <code>ctype.h</code>：字符处理</h2><p><strong>说明：</strong><code>ctype.h</code>提供了两类函数</p>
<ol>
<li><p>字符测试函数</p>
<blockquote>
<p><strong>举例</strong><br><code>isdigit函数</code>：用来检测一个字符是否是数字</p>
</blockquote>
</li>
<li><p>字符大小写转换函数</p>
<blockquote>
<p><strong>举例</strong><br><code>toupper函数</code>：用来将一个小写字母转换成大写字母</p>
</blockquote>
</li>
</ol>
<p><strong>技巧：</strong>建议使用<code>ctype.h</code>中提供的函数而不是用其他手段测试字符或进行大小写转换</p>
<ol>
<li>性能更好（大多数是用宏实现的）</li>
<li>可移植性更好（可以在任何字符集上运行）</li>
<li>国际化（可以正确运行在世界上不同地点）</li>
</ol>
<p><strong>特点（参数和返回值类型）</strong><code>ctype.h</code>中的函数都以<code>int</code>类型作为参数，并返回一个<code>int</code>类型的值（C语言可以自动将<code>char</code>类型的参数转换为<code>int</code>类型，或将<code>int</code>类型的返回值转换成<code>char</code>类型）。</p>
<h3 id="23-4-1-字符测试函数"><a href="#23-4-1-字符测试函数" class="headerlink" title="23.4.1    字符测试函数"></a>23.4.1    字符测试函数</h3><p><strong>说明：</strong>这些函数具有一样的<code>参数类型</code>和<code>返回值类型</code>。<br><strong>原型：</strong><code>ctype.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 要测试的字符</span><br><span class="line">* @param &#123;int&#125; 1:测试符合期待；0:测试不符合期待</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> 函数名(<span class="keyword">int</span> c);</span><br></pre></td></tr></table></figure>
<h4 id="字符测试函数列表"><a href="#字符测试函数列表" class="headerlink" title="字符测试函数列表"></a>字符测试函数列表</h4><table>
<thead>
<tr>
<th>字符测试函数</th>
<th>测试类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum</code></td>
<td>字母或数字</td>
</tr>
<tr>
<td><code>isalpha</code></td>
<td>字母</td>
</tr>
<tr>
<td><code>iscntrl</code></td>
<td>控制字符</td>
<td>包括<code>\0x00~\0x1f</code>、<code>\0x7f</code></td>
</tr>
<tr>
<td><code>isdigit</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>isgraph</code></td>
<td>可显示字符（除空格外）</td>
</tr>
<tr>
<td><code>islower</code></td>
<td>小写字母</td>
</tr>
<tr>
<td><code>isprint</code></td>
<td>可显示字符（包括空格）</td>
</tr>
<tr>
<td><code>ispunct</code></td>
<td>标点符号</td>
<td>空格、字母、数字以外的可显示字符</td>
</tr>
<tr>
<td><code>isspace</code></td>
<td>空白字符</td>
<td>空格、换页符(<code>\f</code>)、换行符(<code>\n</code>)、回车符(<code>\r</code>)、横向制表符(<code>\t</code>)、纵向制表符(<code>\v</code>)</td>
</tr>
<tr>
<td><code>isupper</code></td>
<td>大写字母</td>
</tr>
<tr>
<td><code>isxdigit</code></td>
<td>十六进制数字</td>
</tr>
</tbody>
</table>
<h3 id="23-4-2-程序：测试字符测试函数"><a href="#23-4-2-程序：测试字符测试函数" class="headerlink" title="23.4.2    程序：测试字符测试函数"></a>23.4.2    程序：测试字符测试函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(f) printf(<span class="string">"%6c"</span>, f(*p) ? <span class="string">'x'</span> : <span class="string">' '</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   alnum cntrl graph print space xdigit alpha digit lower punc       upper\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"azAZ0	!\t"</span>; *p != <span class="string">'0'</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(*p)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\\x%02x:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%5c:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		TEST(<span class="built_in">isalnum</span>);</span><br><span class="line">		TEST(<span class="built_in">iscntrl</span>);</span><br><span class="line">		TEST(<span class="built_in">isgraph</span>);</span><br><span class="line">		TEST(<span class="built_in">isprint</span>);</span><br><span class="line">		TEST(<span class="built_in">isspace</span>);</span><br><span class="line">		TEST(<span class="built_in">isxdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">isalpha</span>);</span><br><span class="line">		TEST(<span class="built_in">isdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">islower</span>);</span><br><span class="line">		TEST(<span class="built_in">ispunct</span>);</span><br><span class="line">		TEST(<span class="built_in">isupper</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.01.33.png" alt="Alt text"></p>
<h3 id="23-4-3-字符大小写转换函数"><a href="#23-4-3-字符大小写转换函数" class="headerlink" title="23.4.3    字符大小写转换函数"></a>23.4.3    字符大小写转换函数</h3><h4 id="tolower函数"><a href="#tolower函数" class="headerlink" title="tolower函数"></a>tolower函数</h4><p><strong>说明：</strong>返回与作为参数的字母相对应的小写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的小写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="toupper函数"><a href="#toupper函数" class="headerlink" title="toupper函数"></a>toupper函数</h4><hr>
<p><strong>说明：</strong>返回与作为参数的字母相对应的大写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的大写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-4-4-程序：测试大小写转换函数"><a href="#23-4-4-程序：测试大小写转换函数" class="headerlink" title="23.4.4    程序：测试大小写转换函数"></a>23.4.4    程序：测试大小写转换函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"aA0!"</span>; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tolower('%c') is '%c';\n"</span>, *p, <span class="built_in">tolower</span>(*p));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"toupper('%c') is '%c'\n"</span>, *p, <span class="built_in">toupper</span>(*p));</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.39.11.png" alt="Alt text"></p>
<h2 id="23-5-string-h：字符串处理"><a href="#23-5-string-h：字符串处理" class="headerlink" title="23.5    string.h：字符串处理"></a>23.5    <code>string.h</code>：字符串处理</h2><p><strong>相关章节：</strong><a href="">13.5</a><br><strong>函数分类：</strong>可以分为5类</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复制函数</td>
<td style="text-align:center">将字符从内存中的一处复制到另一处</td>
</tr>
<tr>
<td style="text-align:center">拼接函数</td>
<td style="text-align:center">向字符串末尾追加字符</td>
</tr>
<tr>
<td style="text-align:center">比较函数</td>
<td style="text-align:center">比较字符数组的函数</td>
</tr>
<tr>
<td style="text-align:center">搜索函数</td>
<td style="text-align:center">在字符数组中搜索特定字符、字符组或字符串</td>
</tr>
<tr>
<td style="text-align:center">其他函数</td>
<td style="text-align:center">初始化字符数组或计算字符串的长度</td>
</tr>
</tbody>
</table>
<h3 id="23-5-1-复制函数"><a href="#23-5-1-复制函数" class="headerlink" title="23.5.1    复制函数"></a>23.5.1    复制函数</h3><p><strong>说明：</strong>共4个函数，用于将字符（字节）将内存的一处（源）移动到另一处（目的）。要求第一个参数指向目的，第二个参数指向源，并返回第一个参数（即指向目的的指针）。</p>
<h4 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时无法正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>限制：</strong>当从一块内存区域复制到另一块可能重叠的内存区域时，不能保证正常工作。<br><strong>性能：</strong>比<code>memmove函数</code>快一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">4</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">7</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时仍然可以正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>性能：</strong>比<code>memcpy函数</code>性能差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，会持续肤质字符，知道遇到一个空字符为止。<br><strong>对源的要求：</strong>要求字符串以空字符结尾。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(dest, souce);<span class="comment">// h, o, t, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncpy函数"><a href="#strncpy函数" class="headerlink" title="strncpy函数"></a>strncpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，<code>strcpy函数</code>的增强版<br><strong>对源的要求：</strong>不要求字符串以空字符串结尾，对任意内存块正常工作。<br><strong>安全：</strong>比<code>strcpy函数</code>更安全<br><strong>性能：</strong>比<code>strcpy</code>差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符（如果）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, \0, \0, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-2-拼接函数"><a href="#23-5-2-拼接函数" class="headerlink" title="23.5.2    拼接函数"></a>23.5.2    拼接函数</h3><h4 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h4><hr>
<p><strong>说明：</strong>将第一个参数追加到第一个参数的末尾</p>
<ul>
<li><strong>参数：</strong>要求两个参数都是以<code>\0</code>结尾的字符串</li>
<li><strong>返回值：</strong>返回的字符串会自动在末尾添加<code>\0</code>。</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">"bag"</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncat函数"><a href="#strncat函数" class="headerlink" title="strncat函数"></a>strncat函数</h4><hr>
<p><strong>说明：</strong><code>strcat</code>的增强版，第3个参数会限制复制的字符的个数。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @param &#123;size_t&#125; n 限制复制的字符的个数</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">2</span>);<span class="comment">// t, e, a, b, a, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">3</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">4</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-3-比较函数"><a href="#23-5-3-比较函数" class="headerlink" title="23.5.3    比较函数"></a>23.5.3    比较函数</h3><p><strong>注意：</strong>下面5个函数可以分为两类</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>比较依据</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memcmp函数</code> 、<code>strcmp函数</code>、<code>strncmp函数</code></td>
<td>计算机自身的排序顺序（通常是ACILL）</td>
<td>好</td>
</tr>
<tr>
<td><code>strcoll函数</code>、<code>strxfrm函数</code></td>
<td>依赖当前的本地化设置</td>
<td>差</td>
</tr>
</tbody>
</table>
<h4 id="memcpm函数"><a href="#memcpm函数" class="headerlink" title="memcpm函数"></a>memcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串的大小(具有限制参与比较的字符个数的参数)<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;void *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<h4 id="strcpm函数"><a href="#strcpm函数" class="headerlink" title="strcpm函数"></a>strcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串（不能设置参与比较的字符数上限），在其中一个字符数组遇到<code>\0</code>时停止比较。</p>
<ul>
<li><strong>参数：</strong>必须是以<code>\0</code>结尾的字符串</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strncmp函数"><a href="#strncmp函数" class="headerlink" title="strncmp函数"></a>strncmp函数</h4><hr>
<p><strong>说明：</strong>结合<code>memcmp</code>和<code>strcmp</code>，当比较的字符数达到字符数上限或任意一个字符数组中遇到<code>\0</code>时停止比较。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="strcoll函数"><a href="#strcoll函数" class="headerlink" title="strcoll函数"></a>strcoll函数</h4><hr>
<p><strong>说明：</strong>类似<code>strcmp</code>，不同点在于比较结果依赖本地化设置（通过调用<code>setlocale函数</code><a href="">25.1.2</a>）。<br><strong>缺点：</strong>性能差。<br><strong>应用：</strong>适用于那些根据程序运行的地点不同而可能按不同方式比较的程序。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strxfrm函数"><a href="#strxfrm函数" class="headerlink" title="strxfrm函数"></a>strxfrm函数</h4><hr>
<p><strong>说明：</strong>按照本地化设置转换字符串。<br><strong>技巧：</strong>需要考虑本地化时可以配合<code>strcmp</code>来取代<code>strcoll</code>。因为对两个转化后的参数调用<code>strcmp</code>等价直接调用<code>strcoll</code>。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 转换后的字符串存储到s1</span><br><span class="line">* @return &#123;char *&#125; s2 需要转换的字符串</span><br><span class="line">* @param &#123;char *&#125; size_t 转换的字符数量上限</span><br><span class="line">* @return &#123;size_t&#125; 转换后字符串的长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strxfrm(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * restict s2, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> *transformed;</span><br><span class="line"><span class="comment">// 获取转换后字符串的长度</span></span><br><span class="line">len = strxfrm(NULL, original, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">transformed = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将转换后的字符串存储到分配的内存中</span></span><br><span class="line">strxfrm(transformed, original, len);</span><br></pre></td></tr></table></figure>
<h3 id="23-5-4-搜索函数"><a href="#23-5-4-搜索函数" class="headerlink" title="23.5.4    搜索函数"></a>23.5.4    搜索函数</h3><h4 id="strchr函数"><a href="#strchr函数" class="headerlink" title="strchr函数"></a>strchr函数</h4><hr>
<p><strong>说明：</strong>在字符串中搜索指定字符。<br><strong>停止搜索时机：</strong>遇到首个<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;char *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,  <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">'f'</span>);<span class="comment">// 找到第一个'f'</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">strchr</span>(p + <span class="number">1</span>, <span class="string">'f'</span>);<span class="comment">// 找到第二个'f'</span></span><br></pre></td></tr></table></figure>
<h4 id="memchr函数"><a href="#memchr函数" class="headerlink" title="memchr函数"></a>memchr函数</h4><hr>
<p><strong>说明：</strong>类似<code>strchr</code>，在字符串中搜索指定字符<br><strong>停止搜索时机：</strong>搜索了指定数量的字符后<br><strong>用途：</strong>适用于不希望对整个字符串进行搜索或搜索的内存块不是以<code>\0</code>结尾时<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @param &#123;size_t&#125; n 要搜索的字符数量上限</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strrhrc函数"><a href="#strrhrc函数" class="headerlink" title="strrhrc函数"></a>strrhrc函数</h4><hr>
<p><strong>说明：</strong>函数会首先找到字符串末尾的空字符，然后反向查找字符。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s1, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[<span class="number">22</span>] = <span class="string">"Form follows function"</span>;</span><br><span class="line"><span class="comment">// 反向搜索字符'f'</span></span><br><span class="line">p = <span class="built_in">memchr</span>(strr, <span class="string">'f'</span>, sizeof(str));</span><br></pre></td></tr></table></figure>
<h4 id="strpbrk函数"><a href="#strpbrk函数" class="headerlink" title="strpbrk函数"></a>strpbrk函数</h4><hr>
<p><strong>说明：</strong>返回指向第一个实际参数中与第二个实参中任意一个字符匹配的最左边一个字符的指针。<br><strong>更通用：</strong><code>strchr</code>相当于<code>strpbrk</code>的第二个参数字符串中只给一个字符的情况。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 匹配字符集</span><br><span class="line">* @return &#123;char *&#125; 指向匹配到的字符：匹配到；指针：没有匹配到</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索第一个'm'或'n'</span></span><br><span class="line">p = <span class="built_in">strpbrk</span>(str, <span class="string">"mm"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strspn函数"><a href="#strspn函数" class="headerlink" title="strspn函数"></a>strspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个不属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<h4 id="strcspn函数"><a href="#strcspn函数" class="headerlink" title="strcspn函数"></a>strcspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strcspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">" \t\n"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h4><hr>
<p><strong>说明：</strong>在第一个参数（字符串）中搜索能匹配第二个参数（字符串）的子串，并返回找到的第一处匹配子串的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在str中搜索"fun"</span></span><br><span class="line">p = <span class="built_in">strstr</span>(str, <span class="string">"fun"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><hr>
<p><strong>说明：</strong>分割出一段子字符串。<br><strong>原理：</strong>在s1中搜索，按照s2指定的分隔符找出一系列非空字符（不包含s2中指定的字符）。<code>strtok函数</code>会写入一个<code>\0</code>来标记字符序列的末尾，并返回指向这个序列的首字符的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串（要作为分割字符的字符集合）</span><br><span class="line">* @return &#123;char *&#125; 指向新分割出来的子字符串的指针（指向首字符）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>原始字符串状态</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">" Apri1  28,1990"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th><code> </code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>月</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分割出第一个序列，使用" \t"中的字符作为分隔符</span></span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">p = strtok(str, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th><code>A</code></th>
<th><code>p</code></th>
<th><code>r</code></th>
<th><code>i</code></th>
<th><code>1</code></th>
<th><code>\0</code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>日</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th><code>2</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>年</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>\0</th>
<th><code>1</code></th>
<th><code>9</code></th>
<th><code>9</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="23-5-5-其他函数"><a href="#23-5-5-其他函数" class="headerlink" title="23.5.5    其他函数"></a>23.5.5    其他函数</h3><h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><hr>
<p><strong>说明：</strong>将一个字符的多个副本存储到指定区域。<br><strong>应用：</strong>将数组元素全部初始化为0<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 指向用来存储字符副本的空间</span><br><span class="line">* @param &#123;int&#125; c 用于填充的字符</span><br><span class="line">* @param &#123;size_t&#125; n 从s指向的地址往后填充空间大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 第一个参数（空间地址）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为p指向的内存的N哥字节存储空格</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="string">' '</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组a初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>
<h4 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h4><hr>
<p><strong>说明：</strong>返回字符串的长度，不计算字符串末尾的<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @return &#123;size_t&#125; 字符串的常速</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p><strong>说明：</strong><a href="">24.2</a><br><strong>原型：</strong><code>errno.h</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/22 输入／输出/" itemprop="url">
                  22 输入/输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:01:02+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="22-1-流"><a href="#22-1-流" class="headerlink" title="22.1    流"></a>22.1    流</h2><blockquote>
<p><strong>说明：</strong>在C语言中，术语流意味着任意输入的源或人意输出的目的地。<code>stdio.h</code>中的许多函数不仅可以处理表示成文件的流，还可以处理所有其它形式的流。<br><strong>流：</strong>流常常表示为磁盘上的文件，但却可以和其它类型的设备相关联：调制解调器、网络端口、打印机、光盘驱动器等。</p>
</blockquote>
<h3 id="22-1-1-文件指针"><a href="#22-1-1-文件指针" class="headerlink" title="22.1.1    文件指针"></a>22.1.1    文件指针</h3><blockquote>
<p><strong>文件指针（file pointer）：</strong><code>File *</code>(<code>File</code>定义在<code>stdio.h</code>中)<br><strong>用途：</strong>C程序中流的访问是通过<code>文件指针</code>实现的<br><strong>限制：</strong>操作系统通常会限制在任意某时刻可以打开的流的数量（但是一个程序中可以声明任意数量的<code>File *</code>型变量）。</p>
</blockquote>
<h3 id="22-1-2-标准流和重定向"><a href="#22-1-2-标准流和重定向" class="headerlink" title="22.1.2    标准流和重定向"></a>22.1.2    标准流和重定向</h3><h4 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h4><blockquote>
<p><strong>说明：</strong>由<code>stdio.h</code>提供，一共3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件指针</th>
<th>流</th>
<th>默认的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输出</td>
<td>屏幕</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关的函数：</strong><code>printf</code>、<code>scanf</code>、<code>putchar</code>、<code>getchar</code>、<code>puts</code>、<code>gets</code></p>
</blockquote>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><blockquote>
<p><strong>说明：</strong>某些操作系统（比如UNIX/Linux/DOS）允许通过所谓的<code>重定向（redirextion）</code>机制来改变标准流默认的含义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入重定向(input redirection)</td>
<td>使<code>stdin流</code>表示为文件(而非键盘)</td>
<td>程序不回意识到正在从文件读取数据</td>
</tr>
<tr>
<td>输出重定向(output redirection)</td>
<td>使<code>stdout流</code>和<code>stderr流</code>表示为文件（而飞屏幕）</td>
<td>程序不会意识到正在向文件中写数据</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入重定向</span></span><br><span class="line">demo &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出重定向</span></span><br><span class="line">demo &gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">demo &lt; in.dat &gt;out.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-1-3-文本文件与二进制文件"><a href="#22-1-3-文本文件与二进制文件" class="headerlink" title="22.1.3    文本文件与二进制文件"></a>22.1.3    文本文件与二进制文件</h3><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>支持两种类型的文件（文本文件和二进制文件）<br><strong>存储方式：</strong>文本文件和二进制文件都是字节的序列，不同点在于存储的数据类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>数据类型（假设字符集为ASCII，16位机器）</th>
<th>空间利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本文件(text file)</td>
<td>字符（占一个字节）</td>
<td>低</td>
</tr>
<tr>
<td>二进制文件(binary file)</td>
<td>字符（占一个字节）、整数（两个字节）、浮点数（四个字节）等</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>结束符：</strong></p>
<ul>
<li><strong>DOS系统：</strong>文本文件和二进制文件不同</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>文本文件</th>
<th>二进制文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>回行符＋回车符</td>
<td>回行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>Ctrl+Z(\x1a)，但不是必需的（有的编辑器会加上</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>UNIX系统：</strong>对文本文件和二进制文件不进行区分</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>换行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>在屏幕上显示文件内容的程序会假设文件为文本文件</li>
<li>复制文件时如果设定文件为文本文件，只会复制到出现文件末尾符出现的地方</li>
</ol>
<p><strong>技巧：</strong>在无法确定文件是文本文件还是二进制文件时，安全的做法是把文件假设为二进制文件。</p>
</blockquote>
<h2 id="22-2-文件操作"><a href="#22-2-文件操作" class="headerlink" title="22.2    文件操作"></a>22.2    文件操作</h2><h3 id="22-2-1-打开文件"><a href="#22-2-1-打开文件" class="headerlink" title="22.2.1    打开文件"></a>22.2.1    打开文件</h3><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><blockquote>
<p><strong>说明：</strong>用流的方式打开文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 含有要大开文件名的字符串（可能包含文件位置的信息，例如驱动号或路径）</span><br><span class="line">* @param &#123;char *&#125; mode 模式字符串，例如"r"代表只读方式</span><br><span class="line">* @return &#123;FILE *&#125; 文件指针（如果文件不存在或未获得打开文件的许可则返回空指针）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>在DOS中的文件名中含有”\”字符要用”\替代”<br><strong>注意：</strong>永远不能假设可以打开文件，为了确保不回返回空指针，需要测试<code>fopen</code>函数的返回值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"c:\\project\\test1.dat"</span>, r); <span class="comment">// 以只读方式打开</span></span><br></pre></td></tr></table></figure>
<h3 id="22-2-2-模式"><a href="#22-2-2-模式" class="headerlink" title="22.2.2    模式"></a>22.2.2    模式</h3><blockquote>
<p><strong>说明：</strong>模式字符串依据文件是文本文件还是二进制文件分为两大类。<br><strong>注意：</strong>可读且可写的模式（包含<code>+</code>）存在如下限制</p>
<ul>
<li>调用<code>文件定位函数</code>后，可读才能转换为可写</li>
<li>调用<code>文件定位函数</code>或<code>fflush函数</code>后，可写才能转换为可读</li>
</ul>
</blockquote>
<h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>rb</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>wb</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>ab</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h3 id="22-2-3-关闭文件"><a href="#22-2-3-关闭文件" class="headerlink" title="22.2.3    关闭文件"></a>22.2.3    关闭文件</h3><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><blockquote>
<p><strong>说明：</strong>关闭不再使用的文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针（来自fopen函数或freopen函数）</span><br><span class="line">* @return 0:关闭成功；EOF(stdio.h宏)：关闭失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="string">"example.dat"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.大开文件</span></span><br><span class="line">	fp = fopen(FILE_NAME, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Cant't open %s\n"</span>, FILE_NAME);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Opened!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.操作文件</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 3.关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-4-为流附加文件"><a href="#22-2-4-为流附加文件" class="headerlink" title="22.2.4    为流附加文件"></a>22.2.4    为流附加文件</h3><h4 id="freopen函数"><a href="#freopen函数" class="headerlink" title="freopen函数"></a>freopen函数</h4><blockquote>
<p><strong>说明：</strong>为已经打开的流附加一个不同的文件<br><strong>应用：</strong>把文件和一个标准流相关联<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;char *&#125; mode 打开模式</span><br><span class="line">* @param &#123;FILE *&#125; stream 标准流（stdin或stdout或stderr）</span><br><span class="line">* @return &#123;FILE *&#125; 附加成功：文件指针；NULL：打开失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,  FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.如果stdout通过命令行重定向或者freopen函数已经和其它文件关联，则先关闭与stdout相关联的文件</span></span><br><span class="line"><span class="comment">// fclose(frp); // fp指向是和stdout关联的流（文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开foo文件，并使此文件和stdout相关联</span></span><br><span class="line"><span class="comment">// 如果无法关闭旧的文件，那么freopen函数会忽略掉错误</span></span><br><span class="line">frp = freopen(<span class="string">"foo"</span>, <span class="string">"w"</span>, stdout)</span><br><span class="line"><span class="keyword">if</span> (frp == NULL) &#123;</span><br><span class="line">	<span class="comment">// 打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-5-从命令行获取文件名"><a href="#22-2-5-从命令行获取文件名" class="headerlink" title="22.2.5    从命令行获取文件名"></a>22.2.5    从命令行获取文件名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*</span><br><span class="line">* @param &#123;int&#125; argc 实际参数的数量</span><br><span class="line">* @param &#123;[].(char *)&#125;  一个指针数组，argv[0]指向程序的名字，其余指向实际参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argv[0]: demo</span></span><br><span class="line"><span class="comment"># argv[1]: name.dat</span></span><br><span class="line"><span class="comment"># argv[2]: dates.dat.dat</span></span><br><span class="line">$ demo name.dat dates.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-6-程序：检查文件是否可以打开"><a href="#22-2-6-程序：检查文件是否可以打开" class="headerlink" title="22.2.6    程序：检查文件是否可以打开"></a>22.2.6    程序：检查文件是否可以打开</h3><blockquote>
<p><strong>说明：</strong>若文件存在就可以打开进行读入，在运行程序时，用户将给出要检测的文件的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks whether a file can be opened for reading</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="comment">// 如果没有正确调用，给出使用提示</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: canopen filanem\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不能以只读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s can't be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果能以只读的方式打开 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s can be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ canopen f1.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-7-临时文件"><a href="#22-2-7-临时文件" class="headerlink" title="22.2.7    临时文件"></a>22.2.7    临时文件</h3><blockquote>
<p><strong>说明：</strong>只在程序运行时存在的文件。<code>stdio.h</code>提供了两个函数用来处理临时文件，即<code>tmpfile</code>和<code>tmpname</code></p>
</blockquote>
<h4 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>产生临时文件，这些临时文件将存到文件关闭时或程序终止时。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @ return &#123;FILE *&#125; 指向临时文件的文件指针(如果创建失败则为NULL)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *tmpptr;</span><br><span class="line">Tempptr = tmpfile(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h4 id="tmpfile函数-1"><a href="#tmpfile函数-1" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>为临时文件产生名字。<br><strong>用途：</strong>解决<code>tmpfile函数</code>无法知道临时文件的名字的问题。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  如果实际参数为NULL，那么tmpnam函数会把文件名存储到静态变量中，并且返回指向此变量的指针；</span><br><span class="line">*  否则，如果提供了字符数组作为参数，函数会把文件名复制到程序员提供的字符数组中。</span><br><span class="line">*</span><br><span class="line">* @param &#123;char *&#125; NULL或者一个字符数组（字符串）</span><br><span class="line">* @return &#123;char *&#125; 指向静态变量（存储着临时文件名）的指针：如果参数为NULL；指向临时文件名的指针（非静态）：如果提供了有效的参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>参数为NULL</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line">filename = tmpnam(NULL); <span class="comment">// 创建临时文件名</span></span><br></pre></td></tr></table></figure>
<p><em>参数为字符数组</em></p>
<blockquote>
<p><strong>说明：</strong><code>tmpnam函数</code>会把声称的临时文件名复制到程序员提供的字符数组中，而且仍然会返回指向临时文件名的指针。<br><strong>注意：</strong>作为参数的字符数组长度至少为<code>L_tmpnam</code>,产生的临时文件名的最大数量不能超过<code>TMP_MAX</code>。</p>
<ul>
<li><code>L_tmpnam</code>：在<code>stdio.h</code>中定义的一个宏，保存着临时文件名的字符数组的长度。</li>
<li><code>TMP_MAX</code>：在<code>stdio.h</code>中定义的一个宏，保存着程序执行期间<code>tmpnam函数</code>产生的临时文件名的最大数量。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> filename[L_tmpnam];</span><br><span class="line">tmpnam(filename);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-8-文件缓冲"><a href="#22-2-8-文件缓冲" class="headerlink" title="22.2.8    文件缓冲"></a>22.2.8    文件缓冲</h3><blockquote>
<p><strong>说明：</strong>缓冲发生在屏幕的后台，而且通常不用担心它的操作。然而，极少的情况下可能需要我们承担更主动的作用，需要使用<code>fflush函数</code>、<code>setbuf函数</code>和<code>setbuf函数</code>。<br><strong>输入流缓存：</strong>从硬盘或磁盘读取，包含来自输入设备（键盘或磁盘）的数据<br><strong>写入（输出）流缓存：</strong>向输出设备（屏幕或磁盘）写入，包含来自</p>
</blockquote>
<h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><blockquote>
<p><strong>说明：</strong>针对输出（写入）流，把缓冲区的内容传递给磁盘（当缓冲区满了或者关闭文件时，缓冲区会自动“清洗”）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 把缓冲区的内容传递给磁盘</span><br><span class="line">* 当参数为NULL时，“清洗”所有缓冲区；否则，只清洗和参数指向的文件相关的缓冲区</span><br><span class="line">*</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 0：成功；EOF：发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fflush(fp); <span class="comment">// 为fp指向的文件</span></span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">// 清洗全部输出流</span></span><br></pre></td></tr></table></figure>
<h4 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h4><blockquote>
<p><strong>说明：</strong>改变缓冲流的方式，控制缓冲区的大小和位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; buf 期望缓冲区的地址</span><br><span class="line">* @param &#123;int&#125; 期望缓冲区的类型&#123;_IOFBF|_IOLBF|IONBF&#125;</span><br><span class="line">* @param &#123;size_t&#125; 缓冲区内字节的数量</span><br><span class="line">* @return &#123;int&#125; 0：成功；非零：要求的缓冲区模式无效或无法提供</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数要点：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>第N个参数</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>缓冲区的地址</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>缓冲区的类型</td>
<td>值为定义在<code>stdio.h</code>中的宏</td>
</tr>
<tr>
<td>4</td>
<td>缓冲区的大小</td>
<td>较大的缓冲区可以提供更好的性能，而较小的缓冲区可以节约时间。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的类型（宏）</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_IOFBF</td>
<td>满缓冲</td>
<td>当缓冲区为空时，从流读入数据；活着当缓冲区满时，向流写入数据</td>
</tr>
<tr>
<td>_IONLF</td>
<td>行缓冲</td>
<td>每次从流读入数据活着直接向流写入数据</td>
</tr>
<tr>
<td>_IOLBF</td>
<td>无缓冲</td>
<td>每次从流读入数据活着直接向流卸乳数据，而没有缓冲区</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的存储特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>存在于程序运行的整个过程中</td>
</tr>
<tr>
<td>自动存储期限</td>
<td>允许在它的空间在块退出时被自动重声明（?）</td>
</tr>
<tr>
<td>动态分配</td>
<td>在不需要时可以释放缓冲区</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>限制：</strong>必需在打开stream之后，在stream上执行任何操作之前调用<code>setvbuf</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建缓冲区</span></span><br><span class="line"><span class="keyword">char</span> buffer[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对缓冲区进行设置（必需在打开stream之后，在stream上执行任何操作之前调用setvbuf）</span></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, N);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-9-其他文件操作"><a href="#22-2-9-其他文件操作" class="headerlink" title="22.2.9    其他文件操作"></a>22.2.9    其他文件操作</h3><h4 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h4><blockquote>
<p><strong>说明：</strong>根据文件名删除文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remove(<span class="string">"foo"</span>); <span class="comment">// 删除名为foo的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h4><blockquote>
<p><strong>说明：</strong>文件重命名<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; old 旧文件名</span><br><span class="line">* @param &#123;char *&#125; new 新文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *old, <span class="keyword">const</span> <span class="keyword">char</span> *new)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>一定要确保在调用<code>rename函数</code>之前文件是关闭的，否则无法对文件重命名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rename(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="22-3-格式化的输入／输出"><a href="#22-3-格式化的输入／输出" class="headerlink" title="22.3    格式化的输入／输出"></a>22.3    格式化的输入／输出</h2><h3 id="22-3-1-…printf类函数"><a href="#22-3-1-…printf类函数" class="headerlink" title="22.3.1    …printf类函数"></a>22.3.1    …printf类函数</h3><h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><blockquote>
<p><strong>说明：</strong>向<code>stdout</code>输出，利用格式串控制输出的形式<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Total: %d\n"</span>, total);</span><br></pre></td></tr></table></figure>
<h4 id="fprintf函数"><a href="#fprintf函数" class="headerlink" title="fprintf函数"></a>fprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>和<code>printf函数</code>唯一的不同就是，<code>printf函数</code>始终向标准输出流<code>stdout</code>向中写入，而<code>fprintf函数</code>则向第一个参数说明的流（任何输出流）中写输出。<br><strong>应用：</strong>向标准错误<code>stderr</code>写出错信息。<br><strong>扩展：</strong><code>stdio.h</code>中还有其他两种函数也可以向流写入格式化的输出，分别是<code>vfprintf函数</code>和<code>vprintf函数</code>,而且它们都还依赖<code>stdarg.h</code>(<a href="">26.1</a>)。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向磁盘中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"Total:%d\n"</span>, total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向stderr中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: data file can't be opened.\n"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="22-3-2-…printf类函数的转换说明"><a href="#22-3-2-…printf类函数的转换说明" class="headerlink" title="22.3.2    …printf类函数的转换说明"></a>22.3.2    …printf类函数的转换说明</h3><blockquote>
<p><strong>说明：</strong>对已知的转换说明内容进行回顾，并把剩余的内容补充完整。<br><strong>注意：</strong>格式串必需遵守规则编写，许多看似可能的转换说明（<code>%le、%lf、%lg</code>等）实际上是无效的。</p>
</blockquote>
<h4 id="转换说明：-012-5Lg"><a href="#转换说明：-012-5Lg" class="headerlink" title="转换说明：%# 012.5Lg"></a><strong>转换说明：</strong><code>%# 012.5Lg</code></h4><table>
<thead>
<tr>
<th>%</th>
<th># 0</th>
<th>12</th>
<th>.5</th>
<th>L</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊标志</td>
<td>➋最小字段宽度</td>
<td>➌精度</td>
<td>➍长度修饰符</td>
<td>➎转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选（可多于一个）</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>转换说明提示符：</strong>标记格式串的开始<br><strong>➊标志：</strong>设置对齐方式、前缀、进制、填充</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>+</code></td>
<td>用<code>+</code>作为正数的前缀</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>用<code>空格</code>作为正数的前缀</td>
</tr>
<tr>
<td><code># 0</code>、<code># 0x(X)</code></td>
<td><code># 0</code>（8进制）、<code># 0x(X)</code>(16进制)，转换说明<code>g(G)</code>转换出的尾部0不能删除</td>
</tr>
<tr>
<td><code>0</code></td>
<td>除非转换说明为<code>d、i、o、u、x(X)</code>且制定了精度，否则用前导0在字段宽度内进行填充</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➋最小字段宽度：</strong>值为<code>有效整数</code>或<code>*</code></p>
<ul>
<li><code>有效整数</code>：**字符数少于最小字段宽度时对字符填充，默认右对齐（在左侧填充<code>空格</code>）；大于最小字段宽度则完整显示。</li>
<li><code>*</code>：格式串中的n个<code>*</code>对应<code>参数2</code>~<code>参数n-1</code>，可以是宏</li>
</ul>
<p><strong>➌精度：</strong>值为<code>.整数</code>或<code>.*</code>(精度的含义即依赖于转换说明符，也依赖于自身的值)</p>
</blockquote>
<table>
<thead>
<tr>
<th>说明符</th>
<th>精度值：<code>.整数</code></th>
<th>精度值：<code>.*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i、o、u、x(X)</code></td>
<td>最小数字位数（如果数字位数少于精度值，则添加前导0）</td>
<td>同<code>最小字段宽度</code>❷中<code>*</code>的含义</td>
</tr>
<tr>
<td><code>e(E)、f</code></td>
<td>小数点后的数字位数</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>最大有效数字位</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>最大字符数</td>
<td>（同上）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➍长度修饰符：</strong>共3个，只能和一些转换说明符搭配</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➎转换说明符：</strong>当对带有可变实参的函数（比如<code>printf</code>）传参时，会发生默认的实际参数的提升。<code>float</code>会转换为<code>double</code>，<code>char</code>会转换为<code>int</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参类型</th>
<th>格式化后的形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i</code></td>
<td>signed int</td>
<td>十进制形式</td>
</tr>
<tr>
<td><code>o、u、x(X)</code></td>
<td>unsigned int</td>
<td><code>o</code>(8进制)、<code>u</code>(10进制)、<code>x</code>(16进制，a-f来显示)、<code>X</code>(16进制，A-F来显示)</td>
</tr>
<tr>
<td><code>f</code></td>
<td>double</td>
<td>十进制形式（默认的精度为小数点后显示6位）</td>
</tr>
<tr>
<td><code>e(E)</code></td>
<td>double</td>
<td>科学计数法表示的double，默认精度为小数点后显示6位（<code>e</code>表示指数前为e，<code>E</code>表示指数前为E)</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>double</td>
<td><code>-4 &gt;= 指数部分 &lt; 精度值</code>则相当于<code>e</code>（对应<code>g</code>）或者<code>E</code>（对应<code>G</code>）；否则相当于<code>f</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>unsigned int</td>
<td>无符号整数</td>
</tr>
<tr>
<td><code>s</code></td>
<td>指向字符串的指针</td>
<td>按照<code>void *</code>型显示，达到精度值（如果存在）或空字符(<code>\0</code>)时停止写操作</td>
</tr>
<tr>
<td><code>p</code></td>
<td>*</td>
<td>转化为可显示格式的<code>void *</code>型值</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>int *</code>(指向int型数的指针)</td>
<td><code>...printf类函数</code>返回值（不会输出到屏幕，而是存储到所指向的int型数中）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>无对应参数</td>
<td>字符串”%”</td>
</tr>
</tbody>
</table>
<h3 id="22-3-3-…printf类函数的转换说明示例"><a href="#22-3-3-…printf类函数的转换说明示例" class="headerlink" title="22.3.3    …printf类函数的转换说明示例"></a>22.3.3    …printf类函数的转换说明示例</h3><h4 id="标志➊"><a href="#标志➊" class="headerlink" title="标志➊"></a>标志➊</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.07.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.22.png" alt="Alt text"></p>
<h4 id="最小字段宽度➋-精度➌"><a href="#最小字段宽度➋-精度➌" class="headerlink" title="最小字段宽度➋ + 精度➌"></a>最小字段宽度➋ + 精度➌</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.29.png" alt="Alt text"></p>
<h4 id="转换说明➎"><a href="#转换说明➎" class="headerlink" title="转换说明➎"></a>转换说明➎</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.08.42.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.45.png" alt="Alt text"></p>
<h4 id="最小字符宽度❷和精度❸中"><a href="#最小字符宽度❷和精度❸中" class="headerlink" title="最小字符宽度❷和精度❸中*"></a>最小字符宽度❷和精度❸中*</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小字符宽度❷和精度❸中*的用法示例</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.4d"</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.4d"</span>, <span class="number">6</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.*d"</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, <span class="number">6</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, WIDTH, I, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, page_width/num_cols, I, i); <span class="comment">// ..1234</span></span><br></pre></td></tr></table></figure>
<h4 id="转换说明p和n"><a href="#转换说明p和n" class="headerlink" title="转换说明p和n"></a>转换说明<code>p</code>和<code>n</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (void *)ptr); <span class="comment">// 显示指针ptr的值（可能会以8进制或16进制形式显示）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%n"</span>, <span class="number">123</span>, &amp;len); <span class="comment">// 将printf函数显示的字符数存储到len</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-…scanf类函数"><a href="#22-3-4-…scanf类函数" class="headerlink" title="22.3.4    …scanf类函数"></a>22.3.4    …scanf类函数</h3><h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><blockquote>
<p><strong>说明：</strong>从<code>stdin</code>（键盘）读入内容，根据格式串中的转换说明进行转换并存储在指针指定的位置上。<br><strong>原型：</strong><code>stdio.h</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;char *&#125; format 格式串</span><br><span class="line">&gt;* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">&gt;* return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> chat *format, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环读取一串整数，在首个"?"处停止</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;I) == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fscanf函数"><a href="#fscanf函数" class="headerlink" title="fscanf函数"></a>fscanf函数</h4><blockquote>
<p><strong>说明：</strong><code>scanf函数</code>从<code>stdin</code>读入数据，而<code>fscanf函数</code>则从它自己的第一个实参所指定的流中妇孺内容。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 指定的流</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="22-3-5-…scanf类函数的格式化字符串"><a href="#22-3-5-…scanf类函数的格式化字符串" class="headerlink" title="22.3.5    …scanf类函数的格式化字符串"></a>22.3.5    …scanf类函数的格式化字符串</h3><table>
<thead>
<tr>
<th>比较</th>
<th><code>...printf类函数</code></th>
<th><code>...scanf类函数</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>格式串的作用</td>
<td>转换数据形式并拼接</td>
<td>模式匹配和数据类型转换</td>
</tr>
<tr>
<td>数据源</td>
<td>指定的实参（不定参数部分）的值</td>
<td><code>stdin</code>（键盘输入）</td>
</tr>
<tr>
<td>数据源类型</td>
<td>多种类型</td>
<td>字符</td>
</tr>
</tbody>
</table>
<h4 id="格式串"><a href="#格式串" class="headerlink" title="格式串"></a>格式串</h4><blockquote>
<p><strong>例子：</strong><code>ISBN %d-%d-%ld-%d</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>ISBN</th>
<th>空格</th>
<th>%d</th>
<th>-</th>
<th>%d</th>
<th>-</th>
<th>%ld</th>
<th>-</th>
<th>%d</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISBN</td>
<td>空白字符（0或多个）</td>
<td>一个整数</td>
<td>-</td>
<td>一个整数</td>
<td>-</td>
<td>一个长整数</td>
<td>-</td>
<td>一个整数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
</tr>
</tbody>
</table>
<h5 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h5><blockquote>
<p><strong>说明：</strong>类似<code>...printf函数</code>格式串中中的转换说明。<br><strong>特点：</strong></p>
<ul>
<li>大多数转换说明会在输入项的开始出跳过空白字符（<code>%[、%c、%n</code>除外）</li>
<li>转换说明从来不回跳过尾部的空白字符（遇到换行符时，不会读区之并停止匹配返回）</li>
</ul>
</blockquote>
<h5 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h5><blockquote>
<p><strong>说明：</strong>格式串中的一个（或多个）空白字符匹配0个或多个输入流中的空白字符。</p>
</blockquote>
<h5 id="非空白字符"><a href="#非空白字符" class="headerlink" title="非空白字符"></a>非空白字符</h5><blockquote>
<p><strong>说明：</strong>非空白字符和输入流中相同字符进行匹配（<code>%</code>除外）</p>
</blockquote>
<h3 id="22-3-6-…scanf类函数的转换说明"><a href="#22-3-6-…scanf类函数的转换说明" class="headerlink" title="22.3.6    …scanf类函数的转换说明"></a>22.3.6    …scanf类函数的转换说明</h3><h4 id="转换说明：-12Ld"><a href="#转换说明：-12Ld" class="headerlink" title="转换说明：%*12Ld"></a><strong>转换说明：</strong><code>%*12Ld</code></h4><table>
<thead>
<tr>
<th>%</th>
<th>＊</th>
<th>12</th>
<th>L</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊赋值屏蔽</td>
<td>➋最小字段宽度</td>
<td>➌长度修饰符</td>
<td>❹转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❶赋值屏蔽（assignment suppression）：</strong>使用符号<code>*</code>，匹配空白符之外的连续字符，直到遇到空白符为止。</p>
<ul>
<li>匹配的数据项会被读入，但不会被赋值给变量</li>
<li>用*匹配到的数据相不回包含在<code>...scanf类函数</code>返回的计数中</li>
</ul>
<p><strong>❷最大字段宽度：</strong>限制转换说明匹配的输入项的字符数量（不计算跳过的空白符），达到限制的字符数量后便停止当前输入项的转换。<br><strong>❸长度修饰符：</strong>共3个，只能和一些转换说明符搭配，同时长度修饰符的选择取决于要存储为相匹配实参所指向的变量类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>对应实参（指针）的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>double</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❹转换说明符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参指针应当指向类型</th>
<th>匹配的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数</td>
<td>十进制整数</td>
</tr>
<tr>
<td>i</td>
<td>整数</td>
<td>自动判断进制（0打头：8进制；0x(X)打头：16进制；否则十进制）</td>
</tr>
<tr>
<td>o</td>
<td>unsigned int</td>
<td>八进制整数</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>十进制整数</td>
</tr>
<tr>
<td>x(X)</td>
<td>unsigned int</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>float</td>
<td>float型小数</td>
</tr>
<tr>
<td>s</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>一系列非空白字符</td>
</tr>
<tr>
<td>[</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>来自<code>扫描集合</code>的非空字符序列。<code>扫描集合</code>可以包含任何字符集，特别的是如果<code>扫描集合</code>中包含<code>]</code>，则要放在首位，例如<code>[]abc]</code>（<code>[abc]</code>：表示匹配只含有字母<code>a、b、c</code>的字符序列；<code>[^abc]</code>：表示匹配<code>a、b、c</code>都不存在的字符序列）</td>
</tr>
<tr>
<td>c</td>
<td>char *(指定<code>❷最大字段宽度</code>n，则在末尾添加<code>\0</code>，否则不添加)</td>
<td>指定<code>❷最大字段宽度</code>n，则匹配n个字符，否则旧就匹配一个字符</td>
</tr>
<tr>
<td>p</td>
<td>void *</td>
<td><code>...printf类函数</code>可以打印出的指针值（地址）</td>
</tr>
<tr>
<td>n</td>
<td>int(不指定<code>❸长度修饰符</code>)、short int(<code>❸长度修饰符</code>为<code>h</code>)、long int(<code>❸长度修饰符</code>为<code>l</code>)</td>
<td>不匹配任何字符，因而也不回影响<code>...scanf类函数</code>的放回值（对应的变量存储的是到目前为止已经读入的字符数）</td>
</tr>
<tr>
<td>%</td>
<td>char</td>
<td>匹配字符%</td>
</tr>
</tbody>
</table>
<h4 id="strtol函数-26-2-1"><a href="#strtol函数-26-2-1" class="headerlink" title="strtol函数(26.2.1)"></a>strtol函数(<a href="">26.2.1</a>)</h4><blockquote>
<p><strong>说明：</strong>将字符串根据参数base来转换成长整型数<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; nptr 要转换的字符串</span><br><span class="line">* @param &#123;int&#125; base 基数（0或2~36）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr,<span class="keyword">char</span> **endptr,<span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>和<code>...scanf类函数</code>转换说明符之间的对应关系</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>strol的参数base的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>10</td>
</tr>
<tr>
<td>i</td>
<td>0</td>
</tr>
<tr>
<td>o</td>
<td>8</td>
</tr>
<tr>
<td>u</td>
<td>10</td>
</tr>
<tr>
<td>x(X)</td>
<td>16</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="22-3-7-…scanf函数的示例"><a href="#22-3-7-…scanf函数的示例" class="headerlink" title="22.3.7    …scanf函数的示例"></a>22.3.7    …scanf函数的示例</h3><h4 id="转换说明、空白字符、非空白字符组合效果"><a href="#转换说明、空白字符、非空白字符组合效果" class="headerlink" title="转换说明、空白字符、非空白字符组合效果"></a>转换说明、空白字符、非空白字符组合效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.10.png" alt="Alt text"></p>
<h4 id="赋值屏蔽和指定字段宽度效果"><a href="#赋值屏蔽和指定字段宽度效果" class="headerlink" title="赋值屏蔽和指定字段宽度效果"></a>赋值屏蔽和指定字段宽度效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.25.png" alt="Alt text"></p>
<h4 id="难懂的转换说明：i、-、n"><a href="#难懂的转换说明：i、-、n" class="headerlink" title="难懂的转换说明：i、[、n"></a>难懂的转换说明：<code>i、[、n</code></h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.38.png" alt="Alt text"></p>
<h3 id="22-3-8-检测文件末尾和错误条件"><a href="#22-3-8-检测文件末尾和错误条件" class="headerlink" title="22.3.8    检测文件末尾和错误条件"></a>22.3.8    检测文件末尾和错误条件</h3><blockquote>
<p><strong>错误指示器（error indicator）：</strong>打开流时被清除，遇到错误时会被设置。<br><strong>文件末尾指示器（end of file indicator）：</strong>打开流时被清除，遇到文件末尾时被设置。<br><strong><code>...scanf类函数</code>出错分类：</strong>当<code>...scanf类函数</code>的返回值小于不定参数（要匹配）的数量时，由3中可能</p>
<ol>
<li><strong>提前遇到文件末尾：</strong>函数在完全匹配格式串之前遇到了文件末尾</li>
<li><strong>匹配失败：</strong>数据相的格式错误（比如函数在搜索整数的第一个数字期间遇到了一个字母）</li>
<li><strong>错误：</strong>错误的发生超出了函数控制的范围</li>
</ol>
</blockquote>
<h4 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h4><blockquote>
<p><strong>说明：</strong>清除文件末尾指示器和错误指示器<br><strong>注意：</strong><code>Q&amp;A</code>某些其他库函数因为副作用可以清除某种指示器或两种都可以清除，所以不回需要经常使用该函数。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>末尾指示器</code>，判断是否已经到达输入流（文件或<code>stdin</code>）末尾。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入文件的末尾</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ferror函数"><a href="#ferror函数" class="headerlink" title="ferror函数"></a>ferror函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>错误指示器</code>，判断输入过程是否发生错误<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入过程发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 搜索文件中以某个整数起始的行并返回行号</span><br><span class="line">* </span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;int *&#125; ptr 指向要将找到的整数存储到变量的指针</span><br><span class="line">* @return &#123;int&#125; 以整数起始的行的行号</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	<span class="function">FILE *fp <span class="title">fopen</span> <span class="params">(filename, <span class="string">"r"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, ptr) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果是输入错误</span></span><br><span class="line">		<span class="keyword">if</span> (ferror (fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是到达文件末尾</span></span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-3</span>; <span class="comment">// 整数没找到</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">"%*[^\n]"</span>); <span class="comment">// 跳过一行的其余部分</span></span><br><span class="line">		line++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">n = find_int(<span class="string">"foo"</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<h2 id="22-4-字符的输入／输出"><a href="#22-4-字符的输入／输出" class="headerlink" title="22.4    字符的输入／输出"></a>22.4    字符的输入／输出</h2><blockquote>
<p><strong>说明：</strong>本节的所有函数用于文本流和二进制流是等效的。</p>
</blockquote>
<h3 id="22-4-1-输出函数"><a href="#22-4-1-输出函数" class="headerlink" title="22.4.1    输出函数"></a>22.4.1    输出函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...scanf类函数</code>一样，<code>fputc、putc、putchar</code>出现错误都会为流设置<code>错误指示器</code>并返回<code>EOF</code>。</p>
</blockquote>
<h4 id="fputc函数"><a href="#fputc函数" class="headerlink" title="fputc函数"></a>fputc函数</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符（<code>putc</code>和<code>putchar</code>更通用的版本）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE * stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putc宏"><a href="#putc宏" class="headerlink" title="putc宏"></a>putc宏</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符(宏实现)<br><strong>优点和缺点：</strong><a href="">14.3</a><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putchar宏"><a href="#putchar宏" class="headerlink" title="putchar宏"></a>putchar宏</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>（屏幕）写一个字符，通常作为宏来实现（底层是<code>fputc</code>，因此性能不如<code>putc</code>）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> putchat(c) putc((c), stdout);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @return &#123;int&#125; </span><br><span class="line">int putchar(int c);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-2-输入函数"><a href="#22-4-2-输入函数" class="headerlink" title="22.4.2    输入函数"></a>22.4.2    输入函数</h3><blockquote>
<p><strong>注意：</strong><code>Q&amp;A</code>把char型变量与<code>EOF</code>比较可能会产生错误的结果。</p>
</blockquote>
<h4 id="getc宏"><a href="#getc宏" class="headerlink" title="getc宏"></a>getc宏</h4><blockquote>
<p><strong>说明：</strong>从指定流中读入一个字符（宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件读入字符直到遇到文件末尾</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fgetc函数"><a href="#fgetc函数" class="headerlink" title="fgetc函数"></a>fgetc函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读如一个字符。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = fgetc(fp); <span class="comment">// 从fp中读取一个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="getchar（宏）"><a href="#getchar（宏）" class="headerlink" title="getchar（宏）"></a>getchar（宏）</h4><blockquote>
<p><strong>说明：</strong>从标准输出流<code>stdout</code>（键盘）中获得一个字符（通常是用宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar getc(stdin);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-3-程序：复制文件"><a href="#22-4-3-程序：复制文件" class="headerlink" title="22.4.3    程序：复制文件"></a>22.4.3    程序：复制文件</h3><blockquote>
<p><strong>说明：</strong>采用”rb”和”wb”作为文件的模式使<code>fcopy</code>程序既可以复制文本文件也可以复制二进制文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Copy a file(既可以是文本文件，也可以是二进制文件)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *source_fp, *dest_fp;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有给出正确的参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: fcopy source dest\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开原始文件</span></span><br><span class="line">	<span class="keyword">if</span> ((source_fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开目标文件</span></span><br><span class="line">	<span class="keyword">if</span> ((dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">"wb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制内容(一个字符一个字符地)</span></span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(source_fp)) != EOF) &#123;</span><br><span class="line">		putc(ch, dest_fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(source_fp);</span><br><span class="line">	fclose(dest_fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./fcopy source.dat dest.dat</span><br></pre></td></tr></table></figure>
<h2 id="22-5-行的输入／输出"><a href="#22-5-行的输入／输出" class="headerlink" title="22.5    行的输入／输出"></a>22.5    行的输入／输出</h2><blockquote>
<p><strong>说明：</strong>读和写行的苦函数（虽然也可以有效地用于二进制文件流，但多数用于文本流）。</p>
</blockquote>
<h3 id="22-5-1-输出函数"><a href="#22-5-1-输出函数" class="headerlink" title="22.5.1    输出函数"></a>22.5.1    输出函数</h3><h4 id="puts函数-13-3"><a href="#puts函数-13-3" class="headerlink" title="puts函数(13.3)"></a>puts函数(<a href="">13.3</a>)</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>写入一串字符（总会在后面添加一个换行符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">puts</span><span class="params">(chat *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Hi, there!"</span>); <span class="comment">// 向stdout(屏幕)输出"Hi, there!"</span></span><br></pre></td></tr></table></figure>
<h4 id="fputs函数"><a href="#fputs函数" class="headerlink" title="fputs函数"></a>fputs函数</h4><blockquote>
<p><strong>说明：</strong>向指定的流输出一串字符（不会在后面自动添加换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fput</span><span class="params">(chat *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">"Hi, there!"</span>, fp); <span class="comment">// 向fp输出"Hi. there!"</span></span><br></pre></td></tr></table></figure>
<h3 id="22-5-2-输入函数"><a href="#22-5-2-输入函数" class="headerlink" title="22.5.2    输入函数"></a>22.5.2    输入函数</h3><blockquote>
<p><strong>返回值：</strong>无论<code>gets</code>还是<code>fgets</code>，如果出现了错误，活着使在存储人和字符之前大道了输入流的末尾，都会返回空指针<code>NULL</code>;否则，返回指向读入字符串的指针。<br><strong>末尾空字符：</strong>两个函数都会在字符串的末尾存储空字符。<br><strong>技巧：</strong>大多数情况下用<code>fgets</code>而不是<code>gets</code>（只有在确保读入的字符正好适合数组大小时才使用），因为后者会超出接收数组范围的可能</p>
</blockquote>
<h4 id="gets函数（13-3）"><a href="#gets函数（13-3）" class="headerlink" title="gets函数（13.3）"></a>gets函数（<a href="">13.3</a>）</h4><blockquote>
<p><strong>说明：</strong>从标准输入流<code>stdin</code>中读取一串字符（逐个读取字符，并且把它们存储在字符串中，直到读取到换行符为止，因此不存储换行符）<br><strong>注意：</strong>只有在确保读入的字符正好适合数组大小时才使用，因为会有超出接收数组范围的可能。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储位置（首地址）</span><br><span class="line">* @return &#123;char *&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">chat *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读取一串字符（有时会存储换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;char *&#125; s  存储位置（首地址）</span><br><span class="line">* @param &#123;int&#125; n 限制读取字符的数量(保证不回超过s的存储能力)</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件字符（要读取的目标流）</span><br><span class="line">* @return &#123;char *&#125; 读取到的字符串</span><br><span class="line">*/</span><br><span class="line">char *fget(char *s, int n, FILE *stream));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>可以从任意流中读取信息</li>
<li>比<code>gets</code>更加安全，因为可以限制要存储的字符的数量</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逐个读入字符，在遇到首个换行符时或已经读入sizeof(str)-1个字符时结束操作</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-6-块的输入／输出"><a href="#22-6-块的输入／输出" class="headerlink" title="22.6    块的输入／输出"></a>22.6    块的输入／输出</h2><blockquote>
<p><strong>说明：</strong><code>fread</code>和<code>fwrite</code>允许程序在一次读和写大的数据块（任意数据类型）。<br><strong>用途：</strong>当程序在终止之前使用<code>fwrite函数</code>把数据存储到文件中，稍后，程序可以把数据从文件读入到内存。<br><strong>注意：</strong><code>Q&amp;A</code>小心使用<code>fread</code>函数和<code>fwrite</code>函数可以用于文本流，但它们主要还是用于二进制的流。</p>
</blockquote>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><blockquote>
<p><strong>说明：</strong>从流读入数据块。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 读入后数据块存储位置的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块的数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要读的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际读入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line">fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从fp指向的流位置读出数组并存储到数组a中</span></span><br><span class="line">n = fread(a, sizeof(a[<span class="number">0</span>], sizeof(a)/sizeof(a[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure>
<h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><blockquote>
<p><strong>说明：</strong>把内存中的数据块复制到流。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 存储数据块的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要写入的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际写入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream );</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将内存中数组a复制到fp指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(a, <span class="keyword">sizeof</span>(a[<span class="number">0</span>], sizeof(a)/sizof(a[<span class="number">0</span>]), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存中的结构体（实例）存储到指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(&amp;s, sizeof(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-7-文件的定位"><a href="#22-7-文件的定位" class="headerlink" title="22.7    文件的定位"></a>22.7    文件的定位</h2><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>提供了5个函数允许程序确定当前的文件位置或者改变文件位置，通过这些函数可以实现文件的随机访问（任意访问）。<br><strong>注意：</strong>文件定为函数最适合二进制文件，处理文本流可能出现操作系统差异。<br><strong>文件位置（file position）：</strong>每个流都由文件位置，可以看作当前访问到的位置。在执行读或者写操作时，文件位置会自动推进。</p>
</blockquote>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><blockquote>
<p><strong>说明：</strong>改变指定流的文件位置，相关的宏有3个</p>
<ul>
<li>SEEK_SET：文件的起始处</li>
<li>SEEK_CUR：文件的当前位置</li>
<li>SEEK_END：文件的末尾处</li>
</ul>
<p><strong>注意：</strong>fseek函数对流是<code>文本型</code>还是<code>二进制型</code>非常敏感</p>
<ul>
<li><strong>文本型：</strong>参数必须是以下两种情景之一</li>
</ul>
<ol>
<li>offset必须为0（即只能移动到文件的起始处或末尾）</li>
<li>whence必须是<code>SEEK_SET</code>，且offset是通过<code>ftell函数</code>获取的（即返回前一次访问到的位置）</li>
</ol>
<ul>
<li><strong>二进制型：</strong>不要求支持whience是SEEK_END<br><strong>原型：</strong><code>stdio.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;long int&#125; offset 目标位置距离whence的距离，可以是负值</span><br><span class="line">* @param &#123;int&#125; whence 参照位置，值为SEEK_SET或SEEK_CUR或SEEK_END</span><br><span class="line">* @return &#123;int&#125; 0:成功；非0:产生错误（比如位置不存在）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置移动到文件起始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置移动到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置基于当前位置向后移动10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10</span>L, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><blockquote>
<p><strong>说明：</strong>以长整型返回当前文件位置<br><strong>注意：</strong><code>二进制文件</code>和<code>文本文件</code>的返回值情况有所不同</p>
<ul>
<li><strong>二进制文件：</strong>以字节计算返回当前位置</li>
<li><strong>文本文件：</strong>不一定按照字节计数</li>
</ul>
<p><strong>用途：</strong>可能会存储返回的值并且稍后将其提供给<code>fseek函数</code><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @patam &#123;long int&#125; 当前文件位置：成功；－1L：发生错误（同时会把错误码存储到errno中）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> file_pos;</span><br><span class="line">...</span><br><span class="line">file_pos = ftell(fp); <span class="comment">// 获取当前文件位置</span></span><br><span class="line">...</span><br><span class="line">fseek(fp, file_pos, SEEK_SET); <span class="comment">// 返回到之前存储下的文件位置处</span></span><br></pre></td></tr></table></figure>
<h4 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h4><blockquote>
<p><strong>说明：</strong>把文件位置设置到文件起始处，几乎等价于<code>fseek(fp, 0L, SEEK_SET)</code>,差异是该函数没有返回值，但会为fp清除掉<code>错误指示器</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgetpos函数"><a href="#fgetpos函数" class="headerlink" title="fgetpos函数"></a>fgetpos函数</h4><blockquote>
<p><strong>说明：</strong>将指定流的文件位置存储到fpos_t型变量中<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE * restrict&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t * restrict&#125; fpos_t型变量</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> stream, fpos_t * <span class="keyword">restrict</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsetpos函数"><a href="#fsetpos函数" class="headerlink" title="fsetpos函数"></a>fsetpos函数</h4><blockquote>
<p><strong>说明：</strong>为指定流设置文件fpos_t型位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t&#125; pos 文件位置</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream,  <span class="keyword">const</span> fpos_t *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fpos_t</span> file_pos;</span><br><span class="line">...</span><br><span class="line">fgetpos(fp, &amp;file_pos); <span class="comment">// 获取当前文件位置并保存</span></span><br><span class="line">...</span><br><span class="line">fsetpos(fp, &amp;file_pos); <span class="comment">// 设置文件位置到之前保存的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="程序：修改零件记录文件"><a href="#程序：修改零件记录文件" class="headerlink" title="程序：修改零件记录文件"></a>程序：修改零件记录文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * modify a file of part records by setting the quantity</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NAME_LEN 25	</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"><span class="keyword">struct</span> part &#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_parts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开清单</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"invent.dat"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open inventory file\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取零件(元素为结构体的数组)</span></span><br><span class="line">	num_parts = fread(inventory, sizeof(struct part), MAX_PARTS, fp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line">		inventory[i].on_hand = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动到文件开始处</span></span><br><span class="line">	rewind(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将修改后的清单数据存储到文件中</span></span><br><span class="line">	fwrite(inventory, <span class="keyword">sizeof</span>(struct part), num_parts, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-8-字符串的输入／输出"><a href="#22-8-字符串的输入／输出" class="headerlink" title="22.8    字符串的输入／输出"></a>22.8    字符串的输入／输出</h2><blockquote>
<p><strong>扩展：</strong>还有一个依赖<code>stdarg.h</code>定义<code>va_list</code>的<code>vsprintf函数</code>（<a href="">26.1.2</a>）</p>
</blockquote>
<h4 id="sprintf函数"><a href="#sprintf函数" class="headerlink" title="sprintf函数"></a>sprintf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>printf函数</code>和<code>fprintf函数</code>，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d/%d/%d"</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">94</span>); <span class="comment">// str: 9/20/94</span></span><br></pre></td></tr></table></figure>
<h4 id="sscanf函数"><a href="#sscanf函数" class="headerlink" title="sscanf函数"></a>sscanf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>scanf函数</code>和<code>fscanf函数</code>，唯一的不同是该函数是从字符数组而不是流中读取数据。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败(找到第一个数据项之前到达)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用fgets函数来获取一行输入，然后把此行数据传递给scanf函数进一步处理</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d%d"</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字符串中读取日期</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str, <span class="string">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sscanf(str, <span class="string">"%d-%d-%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/21 标准库/" itemprop="url">
                  21	标准库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:33:07+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="21-1-标准库的使用"><a href="#21-1-标准库的使用" class="headerlink" title="21.1    标准库的使用"></a>21.1    标准库的使用</h2><blockquote>
<p><strong>标准头：</strong>依据C标准，一个“标准头”不需要一定是文件，有可能内置在编译器自身中。<br><strong>标准库：</strong>C语言的标准库总共划分成<code>15</code>个部分，每个部分用一个头描述。<br><strong>扩展：</strong>许多编译器会使用扩展后的库，这类库（头文件）通常提供一些针对特定畸形或特定操作系统的函数（比如更多对屏幕或键盘操作的函数，用于支持图形或窗口界面的头等）</p>
</blockquote>
<h3 id="21-1-1-包含标准头的程序中使用的名字的一些限制"><a href="#21-1-1-包含标准头的程序中使用的名字的一些限制" class="headerlink" title="21.1.1    包含标准头的程序中使用的名字的一些限制"></a>21.1.1    包含标准头的程序中使用的名字的一些限制</h3><blockquote>
<p><strong>意义：</strong>虽然这些规则并不总是强制性的，但不遵守这些规则可能会导致程序的可移植性下降。</p>
</blockquote>
<h4 id="必需遵守"><a href="#必需遵守" class="headerlink" title="必需遵守"></a>必需遵守</h4><ul>
<li><strong>宏的名字：</strong>不能再使用在头文件中定义过的宏的名字</li>
<li><strong>类型名（<code>typedef</code>）：</strong>具有文件作用域的库名（包括类型名）不可以在文件层次重新定义</li>
</ul>
<h4 id="建议遵守（避开保留字）"><a href="#建议遵守（避开保留字）" class="headerlink" title="建议遵守（避开保留字）"></a>建议遵守（避开保留字）</h4><ul>
<li>由<code>_大写字母</code>或<code>__</code>开头的标识符</li>
<li>由<code>_</code>开头的标识符（除非仅声明在函数内部）</li>
<li>标准库中所有具备外部链接的标识符，特别是所有标准库中的函数</li>
</ul>
<h3 id="21-1-2-使用宏隐藏函数"><a href="#21-1-2-使用宏隐藏函数" class="headerlink" title="21.1.2    使用宏隐藏函数"></a>21.1.2    使用宏隐藏函数</h3><blockquote>
<p><strong>说明：</strong>标准库中经常会为小的实际函数定义同名的宏函数，这是允许的，目的是提高程序的运行速度。<br><strong>取消隐藏：</strong>如果需要尽量缩小可执行代码的大小，或者需要一个指向这个库函数的指针，可以使用<code>undef</code>取消相应的红定义即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> isprint <span class="comment">// 即使isprint没定义过，也不会有负面影响</span></span></span><br></pre></td></tr></table></figure>
<p><strong>绕过宏调用：</strong>可以通过为函数名加圆括号来屏蔽个别宏调用<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(isptint)(); <span class="comment">// 预处理器无法分辨出带圆括号的宏，而编译器仍可认出isprint函数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-2-标准库概述"><a href="#21-2-标准库概述" class="headerlink" title="21.2    标准库概述"></a>21.2    标准库概述</h2><table>
<thead>
<tr>
<th>概述</th>
<th>标准头（15个）</th>
<th>提供的功能</th>
<th>相关章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>诊断</td>
<td>assert.h</td>
<td>仅包含<code>assert</code>宏，检查程序的状态，一旦任何检查失败，程序终止</td>
<td><a href="">24.1</a></td>
</tr>
<tr>
<td>字符处理</td>
<td>ctype.h</td>
<td>包括用于字符分类及大小写转换的函数</td>
<td><a href="">23.4</a></td>
</tr>
<tr>
<td>错误</td>
<td>errno.h</td>
<td>提供了<code>errno(&quot;errno number&quot;)</code>，errno是一个左值，可以在调用特定苦函数后进行监测，来判断调用过程中是否有错误发生</td>
<td><a href="">24.2</a></td>
</tr>
<tr>
<td>浮点型的特点</td>
<td>float.h</td>
<td>提供了用于描述浮点型特点的宏，包括值的范围及精度</td>
<td><a href="">23.1</a></td>
</tr>
<tr>
<td>整型的大小</td>
<td>limits.h</td>
<td>提供了用于描述整数类型和字符类型的宏，包括它们的最大值和最小值</td>
<td><a href="">23.2</a></td>
</tr>
<tr>
<td>本地化</td>
<td>locale.h</td>
<td>与本地化相关的行为，包括小数点的字符、货币的格式、字符集一集日期和时间的显示</td>
<td><a href="">25.1</a></td>
</tr>
<tr>
<td>数学计算</td>
<td>math.h</td>
<td>大量用于数据计算的函数，大部分使用double类型的实参，并返回一个double类型的值</td>
<td><a href="">23.3</a></td>
</tr>
<tr>
<td>非本地条转</td>
<td>setjmp.h</td>
<td>setjmp函数和longjmp函数<a href="**setjmp函数和long函数：**会“标记”程序中的一个位置，随后可以用`longjmp`返回被标记的位置，这些函数可以用来从一个函数跳转到另一个（仍然活动中的）函数中绕过正常的函数返回机制。`setjmp`函数和`longjmp`函数主要用来处理程序执行过程中的重大问题。">^21-2-7</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>信号处理</td>
<td>signal.h</td>
<td>用于异常情况（信号）处理的函数，包括终端和运行时错误<a href="**sinal函数：**可以设置一个函数，使系统会在给定信号发生后自动调用改函数；`raise函数`用来产生一个信号。">^21-2-8-signal</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>可变实际参数</td>
<td>stdarg.h</td>
<td>提供给函数可以处理不定个参数的的工具，就像<code>printf</code>和<code>scanf</code>函数</td>
<td><a href="">26.1</a></td>
</tr>
<tr>
<td>常用定义</td>
<td>stddef.h</td>
<td>提供了经常使用的类型和宏的定义</td>
<td><a href="">21.3</a></td>
</tr>
<tr>
<td>输入／输出</td>
<td>stdio.h</td>
<td>提供了大量用于输入／输出的函数，包括对顺序读写和随机读写文件的操作</td>
<td><a href="">22.1</a></td>
<td></td>
</tr>
<tr>
<td>常用实用程序</td>
<td>stdlib.h</td>
<td>包含了大量无法华贵其它头的函数[^stdlib]</td>
<td><a href="">26.2</a></td>
</tr>
<tr>
<td>字符串处理</td>
<td>string.h</td>
<td>提供了用于进行字符串操作的函数，包括肤质、拼接、比较以及搜索</td>
<td><a href="">23.5</a></td>
</tr>
<tr>
<td>日期与时间</td>
<td>time.h</td>
<td>提供相应的函数来获取日期和时间、操作时间和以多种方式显示时间等。</td>
<td><a href="">26.3</a></td>
</tr>
</tbody>
</table>
<h2 id="21-3-：常用定义"><a href="#21-3-：常用定义" class="headerlink" title="21.3    ：常用定义"></a>21.3    <stddef.h>：常用定义</stddef.h></h2><blockquote>
<p><strong>说明：</strong><code>stddef.h</code>提供了常用的类型和宏的定义，但没有声明任何函数。</p>
</blockquote>
<h3 id="21-3-1-定义的类型"><a href="#21-3-1-定义的类型" class="headerlink" title="21.3.1    定义的类型"></a>21.3.1    定义的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>原始类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptrdiff_t</td>
<td>当记性指针相减运算时，其结果的类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>size_t</td>
<td>运算符<code>sizeof</code>的返回值类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>wchar_t</td>
<td>一种足够大的、可以用于表示所有支持的地区的所有字符的类型</td>
<td>整数类型</td>
</tr>
</tbody>
</table>
<h3 id="21-3-2-定义的宏"><a href="#21-3-2-定义的宏" class="headerlink" title="21.3.2    定义的宏"></a>21.3.2    定义的宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>空指针</td>
</tr>
<tr>
<td>offsetof</td>
<td>计算结构的起点到指定成员间的字节数</td>
</tr>
</tbody>
</table>
<h4 id="21-3-2-1-offsetof"><a href="#21-3-2-1-offsetof" class="headerlink" title="21.3.2.1    offsetof"></a>21.3.2.1    offsetof</h4><blockquote>
<p><strong>说明：</strong>计算结构成员的偏移量（距结构起点的距离）<br><strong>用途：</strong>对人和编译器都会返回正确的偏移量，使我们可以编写一致性更好的程序。<br><strong>结构体成员的偏移量：</strong>一些编译器会在结构中留下一些空洞（无效字节），从而影响到<code>offsetof</code>产生的值。</p>
</blockquote>
<p><code>@param {struct}</code> 结构类型本身（不是实例）<br><code>@param {*}</code> 结构的成员<br><code>@return {int}</code> 结构的起点到指定成员的字节数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> s &#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">offsetof(<span class="keyword">struct</span> s, a); <span class="comment">// 0，C语言确保结构的第一个成员的地址与结构自身地址相同</span></span><br><span class="line"></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, b); <span class="comment">// 1（或2）</span></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, c); <span class="comment">// 5（或6）</span></span><br></pre></td></tr></table></figure>
<hr>
<p>[^stdlib]:  包含在<code>&lt;stdlib.h&gt;</code>中的函数可以将字符串转换成数、产生随机值、执行内存管理任务、域操作系统通信、执行搜索与排序以及对多字节字符及字符串进行操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/20 低级程序设计/" itemprop="url">
                  20 低级程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:05:58+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>位操作和其他一些低级运算在编写系统程序（包括编译器和操作系统）、加密程序、图形程序以及其他一些需要高执行速度或高效地使用空间的程序时非常有用。</p>
</blockquote>
<h2 id="20-1-按位运算符"><a href="#20-1-按位运算符" class="headerlink" title="20.1    按位运算符"></a>20.1    按位运算符</h2><blockquote>
<p><strong>说明：</strong>C语言一共提供了6个按位运算符。</p>
</blockquote>
<h3 id="20-1-1-移位运算符"><a href="#20-1-1-移位运算符" class="headerlink" title="20.1.1    移位运算符"></a>20.1.1    移位运算符</h3><blockquote>
<p><strong>说明：</strong>移位运算符可以改变数的二进制形式，将它的位向左或向右移动。<br><strong>优先级：</strong>低于算数运算符<code>i&lt;&lt;2+1 &lt;==&gt; i&lt;&lt;(2+1)</code><br><strong>操作数类型要求：</strong>可以是任意整型或字符型的<br><strong>副作用：</strong>不存在（不会改变操作数本身）<br>|运算符|名称|示例|返回值|复合移位运算符|<br>|-|-|-|-|-|<br>|<code>&lt;&lt;</code>|左位移|<code>i&lt;&lt;j</code>|<code>i</code>中的位左移<code>j</code>位的结果（左端溢出，右端补0）|<code>&lt;&lt;=</code>|<br>|<code>&gt;&gt;</code>|右位移|<code>i&gt;&gt;j</code>|<code>i</code>中的位右移<code>j</code>位的结果（右端溢出，左端补0或保存符号位而补1）|<code>&gt;&gt;=</code>|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">13</span>; <span class="comment">// 0000000000001101(16位)</span></span><br><span class="line">j = i &lt;&lt; <span class="number">2</span>; <span class="comment">// 0000000000110100(16位)</span></span><br><span class="line">j = i &gt;&gt; <span class="number">2</span>; <span class="comment">// 0000000000000011(16位)</span></span><br></pre></td></tr></table></figure>
<h3 id="20-1-2-按位求反、按位与、按位亦或、按位或"><a href="#20-1-2-按位求反、按位与、按位亦或、按位或" class="headerlink" title="20.1.2    按位求反、按位与、按位亦或、按位或"></a>20.1.2    按位求反、按位与、按位亦或、按位或</h3><blockquote>
<p><strong>优先级：</strong><code>~</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code>，都比<code>关系运算符</code>和<code>判等运算符</code>低。<br><strong>技巧：</strong>使用<code>~</code>创建在位一级具备可移植性的程序（例子）</p>
<ol>
<li>~0：所有位都为1的整数（否则就要最大的整数，但不同位的机器不同）</li>
<li>~0x001f：除了最后5位其它为都为1<br>|符号|名称|返回值|复合运算符|<br>|-|-|-|-|<br>|<code>~</code>|按位求反|将每一个0替换成1，每一个1替换成0|<code>~=</code>|<br>|<code>&amp;</code>|按位与|对两个操作数相应的位执行逻辑与运算|<code>&amp;=</code>|<br>|<code>^</code>|按位亦或|对两个操作数相应的位执行逻辑或操作，都是1时产生0|<code>^=</code>|<br>|<code>\</code>|按位或|对两个操作数相应的位执行逻辑或操作，都是1时产生1|<code>\=</code>|</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设unsigned int类型的值占16位</span></span><br><span class="line">i = <span class="number">21</span>; <span class="comment">//    0000000000010101</span></span><br><span class="line">j = <span class="number">56</span>; <span class="comment">//    0000000000111000</span></span><br><span class="line">k = ~i; <span class="comment">//    1111111111101010</span></span><br><span class="line">k = i &amp; j; <span class="comment">// 0000000000010000</span></span><br><span class="line">k = i ^ j; <span class="comment">// 0000000000101101</span></span><br><span class="line">k = i | j; <span class="comment">// 0000000000111101</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">21</span>;</span><br><span class="line">j = <span class="number">56</span>;</span><br><span class="line">i &amp;= j;</span><br><span class="line">i ^= j;</span><br><span class="line">i |= j;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-3-用按位运算符访问位"><a href="#20-1-3-用按位运算符访问位" class="headerlink" title="20.1.3    用按位运算符访问位"></a>20.1.3    用按位运算符访问位</h3><blockquote>
<p><strong>说明：</strong>通过按位运算，可以提取或修改存储在少数几个位中的数据。<br><strong>用途：</strong>比如，在编写图形程序时，可能会需要讲两个或更多的像素挤在一个字节中，从而降低空间复杂度和时间复杂度。<br><strong>方式：</strong>构造“掩码”，通过按位复合运算修改位</p>
<h4 id="设置位（为1）"><a href="#设置位（为1）" class="headerlink" title="设置位（为1）"></a>设置位（为1）</h4><p><strong>说明：</strong> 通过与“掩码”进行<code>按位或运算</code>设置某一位为1<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>0000000000001000</code>）。<br><strong>相关按位运算：</strong><code>按位或运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0x0000</span>;</span><br><span class="line"><span class="comment">// 将第4位设置为1</span></span><br><span class="line"><span class="comment">// 0000000000000000 (i)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (按位或运算结果)</span></span><br><span class="line">i |= <span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算灵活构造掩码</span></span><br><span class="line">i |= <span class="number">1</span> &lt;&lt; j; <span class="comment">// 使用移位运算构造掩码</span></span><br></pre></td></tr></table></figure>
<h4 id="将位清零"><a href="#将位清零" class="headerlink" title="将位清零"></a>将位清零</h4><blockquote>
<p><strong>说明：</strong>通过与“掩码”进行<code>按位且运算</code>设置某一位为0<br><strong>掩码：</strong>除要清零的位外都为1的掩码（可以通过<code>移位运算</code>和<code>按位非运算</code>）构造（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0x00ff</span>;  <span class="comment">// 0000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000000011111111（i）</span></span><br><span class="line"><span class="comment">// 1111111111110111 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000011110111 (按位且运算结果)</span></span><br><span class="line">i &amp;= ~<span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算和按位非灵活构造掩码</span></span><br><span class="line">i &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br></pre></td></tr></table></figure>
<h4 id="检测位"><a href="#检测位" class="headerlink" title="检测位"></a>检测位</h4><blockquote>
<p><strong>说明：</strong>检测某一位是否被设置过（设置为1）。<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置需要的掩码(假设在16位机器上)</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BLUE = <span class="number">1</span>, <span class="comment">// 0000000000000001</span></span><br><span class="line">	GREN = <span class="number">2</span>, <span class="comment">// 0000000000000010</span></span><br><span class="line">	RED = <span class="number">4</span>   <span class="comment">// 0000000000000100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i |= BULE; <span class="comment">// 设置BLUE bit(最后一位为1)</span></span><br><span class="line">i &amp;= ~BLUE; <span class="comment">// 抹掉BLUE bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测BLUE bit是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; BULUE) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测BLUE bit和GREEN bit是否都被设置了</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (BLUE | GREEN)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-4-用按位运算符访问位域"><a href="#20-1-4-用按位运算符访问位域" class="headerlink" title="20.1.4    用按位运算符访问位域"></a>20.1.4    用按位运算符访问位域</h3><blockquote>
<p><strong>位域：</strong>连续的几个位<br><strong>位域下标记法：</strong>最右边是最低位，记为0位</p>
<h4 id="修改位域"><a href="#修改位域" class="headerlink" title="修改位域"></a>修改位域</h4><p><strong>说明：</strong>不同于修改位，修改位域并不单纯的只是设置位或清除位，目标值中1和0可以并存，因此多了清除先清除位域的操作。<br><strong>相关按位运算：</strong><code>按位与</code>（用来清除位域）；<code>按位或</code>（用来将新的位存入域）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将二进制的值101存入变量i的第4-6位*/</span></span><br><span class="line"><span class="comment">// 0000000000000000，i的值可以使任意的16位整数</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将i的4-6位清零，然后用构造的掩码设置4-6位</span></span><br><span class="line"><span class="comment">// 0000000001110000 (0x0070)</span></span><br><span class="line"><span class="comment">// 1111111110001111 (~0x0070，掩码)</span></span><br><span class="line"><span class="comment">// 0000000001010000 (0x0050，4-6位上为要存储的二进制)</span></span><br><span class="line">i = i &amp; ~<span class="number">0x0070</span> | <span class="number">0x0050</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*让上名的例子更加通用*/</span></span><br><span class="line"><span class="comment">// 0000000000000101, 包含需要存储的值</span></span><br><span class="line">j = <span class="number">5</span>;</span><br><span class="line">i = (i &amp; ~<span class="number">0x0070</span>) | (j &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取位域"><a href="#获取位域" class="headerlink" title="获取位域"></a>获取位域</h4><blockquote>
<p><strong>说明：</strong>获得指定位域上的值。<br><strong>相关按位运算：</strong><code>按位与</code><br><strong>技巧：</strong>当位域处在数的末尾区间时，获取值更加方便。如果要获取的位域不在末尾，可以先通过位移移至末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0000000000000111 (0x0007)</span></span><br><span class="line">j = i &amp; <span class="number">0x0007</span>; <span class="comment">// 获取0-2位上的位并放在j的末端</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">j = (i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0007</span>;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-5-程序：XOR加密"><a href="#20-1-5-程序：XOR加密" class="headerlink" title="20.1.5    程序：XOR加密"></a>20.1.5    程序：XOR加密</h3><blockquote>
<p><strong>说明：</strong>将每一个字符与一个密匙进行亦或（XOR）运算；要将信息解码，只需要再次加密，即可得到原来的字符。<br><strong>注意：</strong>读或写包含控制字符的文件时会在一些操作系统中引发错误，应当避免。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-------------加密---------------</span><br><span class="line">		<span class="number">01111010</span> (z， 加密前)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 密匙)</span><br><span class="line">		<span class="number">01011100</span> (\, 加密后)</span><br><span class="line">-------------解密---------------</span><br><span class="line">		<span class="number">01011100</span> (\, 解密)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 同样的密匙)</span><br><span class="line">		<span class="number">01111010</span> (z, 解密后)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 以文件作为输入，使用XOR加密(或解密)。并将加密(或解密)后的文本输出</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> KEY <span class="string">'&amp;'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> orig_char, new_char;</span><br><span class="line">	<span class="comment">// 遍历输入流中的每一个字符，加密后输出，直到文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> ((orig_char = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="comment">// 加密</span></span><br><span class="line">		new_char = orig_char ^ KEY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果加密（或解密）后的字符是控制字符则不加密（或解密）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(orig_char) || <span class="built_in">iscntrl</span>(new_char)) &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(orig_char);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(new_char);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./xor &lt; msg.txt</span><br></pre></td></tr></table></figure>
<h2 id="20-2-结构中的位域"><a href="#20-2-结构中的位域" class="headerlink" title="20.2    结构中的位域"></a>20.2    结构中的位域</h2><blockquote>
<p><strong>说明：</strong>C语言提供了可以在结构中声明存储在位域中的成员。<br><strong>语法：</strong>位域的类型必需是<code>int</code>、<code>unsigned int</code>或<code>signed int</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构名 &#123;</span><br><span class="line">	&#123;<span class="keyword">int</span>|<span class="keyword">unsigned</span> <span class="keyword">int</span>|<span class="keyword">signed</span> <span class="keyword">int</span>&#125; [成员名]: 位数;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>使用<code>按位运算</code>可以达到同样的效果，而且可能更快些，当可读性不如<code>结构中的位域</code>。<br><strong>局限性：</strong>通常位域没有地址，因此C语言不允许将<code>&amp;运算符</code>或<code>scanf函数</code>用于位域。<br><strong>可移植性技巧：</strong>将所有的位域声明为<code>unsigned int</code>或<code>signed int</code>而不是<code>int</code>，因为一些编译器将位域的最高位作为符号位，而其它一些编译器则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="位域是如何存储的"><a href="#位域是如何存储的" class="headerlink" title="位域是如何存储的"></a>位域是如何存储的</h3><blockquote>
<p><strong>存储单元：</strong>一个存储单元的大小是由实现定义的，通常是8位、16位或32位。<br><strong>未命名为域：</strong>将无法被赋值和使用，但正常占据空间。经常用来作为成员间的填充，以保证其它位域存储在适当的位置。<br><strong>长度为0的位域：</strong>告诉编译器将下一个位域放在一个存储单元的起始位置，即如果当前存储单元还有空间剩余，无论能否放下长度为0的成员的后面的成员，都会将其放在下一个存储单元中。</p>
</blockquote>
<ul>
<li><strong>存储顺序：</strong>当编译器处理结构实例时，会将位域逐个存入存储单元（从左向右或从右向左）</li>
<li><strong>位域型成员之间的间隙：</strong>位域之间没有间隙，直到剩下的空间不够放下一个位域（这时会跳到下一个存储单元继续存放，即<code>存在间隙</code>或跨存储单元存放，即<code>没有间隙</code>）。</li>
</ul>
<p><strong>案例</strong></p>
<blockquote>
<p><strong>说明：</strong>假设位域是<code>从右至左</code>存储，且当一个存储单元剩余的空间无法存储下一个位域成员时会<code>跨存储单元存储</code>。这时DOS系统上编译常用的方式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明结构实例</span></span><br><span class="line"><span class="keyword">struct</span> file_date fd;</span><br><span class="line">fd.day = <span class="number">28</span>;</span><br><span class="line">fd.month = <span class="number">12</span>;</span><br><span class="line">fd.year = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>*</th>
<th>year</th>
<th>month</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>0001000</td>
<td>1100</td>
<td>11100</td>
</tr>
<tr>
<td>大小（bit）</td>
<td>7</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>区间</td>
<td>15-9</td>
<td>8-5</td>
<td>4-0</td>
</tr>
</tbody>
</table>
<h2 id="20-3-其他低级技术"><a href="#20-3-其他低级技术" class="headerlink" title="20.3    其他低级技术"></a>20.3    其他低级技术</h2><h3 id="20-3-1-定义依赖机器的类型"><a href="#20-3-1-定义依赖机器的类型" class="headerlink" title="20.3.1    定义依赖机器的类型"></a>20.3.1    定义依赖机器的类型</h3><blockquote>
<p><strong>说明：</strong>可以将<code>char</code>作为一个字节（不一定存储字符）来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-2-用联合从多个视角看待数据"><a href="#20-3-2-用联合从多个视角看待数据" class="headerlink" title="20.3.2    用联合从多个视角看待数据"></a>20.3.2    用联合从多个视角看待数据</h3><h4 id="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"><a href="#案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。" class="headerlink" title="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"></a>案例一：使用<code>联合</code>结合<code>结构体（位域成员）</code>实现文件日期和整数的转换。</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>获取：可以通过成员<code>i</code>以两个字节的形式获得日期的整数形式</li>
<li>设置：可以通过成员<code>fd</code>以结构体的方式设置文件日期（以两个字节的方式存储）</li>
</ul>
</blockquote>
<p><em>文件日期定义</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>封装一个方便读取和设置数据结构</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> int_date &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ;</span><br><span class="line">	<span class="keyword">struct</span> file_date fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>实践</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将整数形式（两个字节）的日期以作为文件日期数据结构打印</span><br><span class="line">* @param &#123;undesigned int&#125; n 存储这日期信息的整数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_date</span> <span class="params">(undesigned <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> int_date u;</span><br><span class="line">	u.i = n;</span><br><span class="line">	<span class="comment">// 年只显示后两位（比如1990年简称90年）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d/%d/%.2d\n"</span>, u.fd.month, u.fd.day, (u.fd.year + <span class="number">1980</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="案例二：模拟对寄存器的访问（Intel-80x86）"><a href="#案例二：模拟对寄存器的访问（Intel-80x86）" class="headerlink" title="案例二：模拟对寄存器的访问（Intel 80x86）"></a>案例二：模拟对寄存器的访问（Intel 80x86）</h4><blockquote>
<p><strong>说明：</strong>需要对16位寄存器和8位寄存器进行访问，同时保留它们之间的关系。<br><strong>寄存器：</strong>Intel 80x86处理器包涵4个16位的寄存器（<code>AX(AH|AL)</code>、<code>BX(BH|BL)</code>、<code>CX(CH|CL)</code>、<code>DX(DH|DL)</code>），其中每个16位寄存器都包含2个8位寄存器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="comment">// 16位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		WORD ax, bx, cx. dx;</span><br><span class="line">	&#125; word;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 8位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		BYTE al, ah, bl, bh, cl, ch, dl, dh;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; regs;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照8位寄存器的方式修改</span></span><br><span class="line">regs.byte.ah = <span class="number">0x12</span>;</span><br><span class="line">regs.byte.al = <span class="number">0x34</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照16位寄存器的方式观察</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AX: %x\n"</span>, regs.word.ax);</span><br></pre></td></tr></table></figure>
<h3 id="20-3-3-将指针作为地址使用（将地址转换为指针使用）"><a href="#20-3-3-将指针作为地址使用（将地址转换为指针使用）" class="headerlink" title="20.3.3    将指针作为地址使用（将地址转换为指针使用）"></a>20.3.3    将指针作为地址使用（将地址转换为指针使用）</h3><blockquote>
<p><strong>说明：</strong>指针按照其自身的构造方式可以分为两类（以16位机器为例）<br>|分类|组成|大小(bit)|地址转换为指针|情景|<br>|-|-|-|-|<br>|近指针|偏移量||16|将整数强制转换为指针|在一些计算机中|<br>|远指针|段地址＋偏移量|32|<code>far(关键字，非标准c)</code>+<code>MK_FP</code>(dos.h中的宏)|Intel CPU的实时模式（DOS使用的模式）|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近指针</span></span><br><span class="line">BYTE *p;</span><br><span class="line">p = (BYTE *) <span class="number">0x1000</span>; <span class="comment">// 将16位整数地址直接转换为指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 远指针</span></span><br><span class="line">BYTE far *p; <span class="comment">// 使用far声明一个远指针</span></span><br><span class="line">p = MKFP(segment, offset); <span class="comment">// 段地址， 偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="20-3-4-程序：设置Num-Lock-键"><a href="#20-3-4-程序：设置Num-Lock-键" class="headerlink" title="20.3.4    程序：设置Num Lock 键"></a>20.3.4    程序：设置Num Lock 键</h3><blockquote>
<p><strong>说明：</strong>在<code>IBM PC</code>机极其兼容机上，<code>Num Lock</code>切换涌来确定数字键盘上的按键是作为数字键使用，还是作为移动光标的方向键。<br><strong>原理：</strong><code>Num Lock</code>的状态保存在地址位地址段为40（16进制）、偏移量为17（16进制）的字节中。该字节的第5位（最低位为0位）用来控制<code>Num Lock</code>的状态。</p>
</blockquote>
<p><strong>开启Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 开启num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0000000000100000 (掩码)</span></span><br><span class="line">	*p |= <span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1111111111011111 (掩码)</span></span><br><span class="line">	*p &amp;= ～<span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-5-volatile类型限定符"><a href="#20-3-5-volatile类型限定符" class="headerlink" title="20.3.5    volatile类型限定符"></a>20.3.5    volatile类型限定符</h3><blockquote>
<p><strong>关键字：</strong><code>volatile</code><br><strong>说明：</strong>通常使用在用于指向易变内存空间的指针的声明中。用来防止编译器优化过程中错误地将易变内容缓存在了寄存器中，而不再读取内存中易变内容。</p>
</blockquote>
<p><em>优化前的逻辑</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前的逻辑</span></span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入; <span class="comment">// 将输入存储到*p</span></span><br><span class="line">	buffer[i] = *p;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>优化后的逻辑</em></p>
<blockquote>
<p><strong>说明：</strong>注意到这个循环中既没有改变p，也没有改变<em>p，因此对程序进行优化，使</em>p只被读取一次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在寄存器中存储*p;</span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入;</span><br><span class="line">	buffer[i] = 存储在寄存器中的值;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/19 程序设计/" itemprop="url">
                  19 程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:00:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="19-1-模块"><a href="#19-1-模块" class="headerlink" title="19.1    模块"></a>19.1    模块</h2><blockquote>
<p><strong>说明：</strong><code>模块</code>是一组功能（服务）的集合，其中一些功能可以被程序的其它部分（<code>客户</code>）使用。每个模块都有一个<code>接口</code>来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的<code>实现</code>中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td><code>模块名.h</code>(头文件)</td>
</tr>
<tr>
<td>实现</td>
<td>对应头文件<code>模块名.c</code>文件</td>
</tr>
<tr>
<td>客户</td>
<td>通过<code>#include</code>引入模块的文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>优点：</strong>将程序分割成模块有一系列好处</p>
<ul>
<li>抽象：不必了解功能的实现细节，只需对模块的接口达成一致</li>
<li>可复用：每个模块都可以在另一个程序中复用</li>
<li>可维护性（最重要）：当程序出现错误或需要升级时，通常只会影响一个模块</li>
</ul>
<p><strong>扩展：</strong><a href="">Fundamental of SoftWare Engineer</a></p>
</blockquote>
<h3 id="19-1-1-内聚性与耦合性"><a href="#19-1-1-内聚性与耦合性" class="headerlink" title="19.1.1    内聚性与耦合性"></a>19.1.1    内聚性与耦合性</h3><blockquote>
<p><strong>说明：</strong>一个好的模块接口并不是随意的一组声明，应具有下面两个性质</p>
<ul>
<li>高内聚：模块中的元素应该紧密相关</li>
<li>低耦合：模块之间应该尽可能相互独立</li>
</ul>
</blockquote>
<h3 id="19-1-2-模块的类型"><a href="#19-1-2-模块的类型" class="headerlink" title="19.1.2    模块的类型"></a>19.1.2    模块的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据池</td>
<td>一些相关的变量或常量的集合</td>
<td><code>&lt;float.h&gt;</code>(<a href="">23.1</a>)、 <code>&lt;limits.h&gt;</code>(<a href="">23.2</a>)</td>
<td>通常不建议将变量放在头文件</td>
</tr>
<tr>
<td>库</td>
<td>一组相关函数的集合</td>
<td><code>&lt;string.h&gt;</code></td>
<td></td>
</tr>
<tr>
<td>抽象对象</td>
<td>对隐藏的数据结构进行操作的一组函数的集合</td>
<td></td>
<td>如果数据是隐藏起来的，那么这个对象那个就是“抽象的”</td>
</tr>
<tr>
<td>抽象数据类型</td>
<td>将具体数据实现方式隐藏起来的数据类型称为抽象数据类型</td>
<td></td>
<td>抽象数据类型在当今的程序设计中起着非常重要的作用</td>
</tr>
</tbody>
</table>
<h2 id="19-2-信息隐藏"><a href="#19-2-信息隐藏" class="headerlink" title="19.2    信息隐藏"></a>19.2    信息隐藏</h2><blockquote>
<p><strong>说明：</strong>一个设计良好的模块经常会对它的客户隐藏一些信息。谨慎的对客户隐藏信息的方法称为信息隐藏。<br><strong>优点：</strong></p>
<ul>
<li>安全性：<code>客户</code>只能通过<code>模块</code>自身的函数进行参数</li>
<li>灵活性：修改模块通常不必修改接口，对<code>客户</code>没有影响</li>
</ul>
<p><strong>原理：</strong>使用<code>static</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰</th>
<th>链接情况</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数</td>
<td>内部链接</td>
<td>只能在只能被同一文件中被调用</td>
</tr>
<tr>
<td>变量（文件作用域）</td>
<td>内部链接</td>
<td>只能被同一文件中的其它函数访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>使用宏定义“公有”和“私有”可以使程序含义更加清晰（尤其是<code>static</code>，因为它在c语言中有许多用法）</p>
<h3 id="栈模块-实现部分"><a href="#栈模块-实现部分" class="headerlink" title="栈模块(实现部分)"></a>栈模块(实现部分)</h3></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC  <span class="comment">// 定义为空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIVATE static</span></span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> contents[STACK_SIZE] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PRIVATE <span class="keyword">int</span> <span class="title">is_full</span> <span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">pop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-3-抽象数据类型"><a href="#19-3-抽象数据类型" class="headerlink" title="19.3    抽象数据类型"></a>19.3    抽象数据类型</h2><blockquote>
<p><strong>说明：</strong>c语言没有设计专门用于封装类型的特性（<code>class</code>），即无法定义真正的抽象数据类型。<br><strong>案例缺陷：</strong>之前定义的栈模块提供的栈不基于一种抽象数据类型，而是仅仅提供了一个相当于“栈的实例”的数据结构。当需要多个栈实例时就无能为力了。</p>
</blockquote>
<p><em>stack.h</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 下面定义的Stack不是抽象数据类型，因为stack.h暴露了Stack的具体实现方式（结构体实例的成员是暴露的)</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empyt</span> <span class="params">(Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">const</span> Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(Stack *s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span> <span class="params">(Stack *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>客户</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 理想的使用方式</span></span><br><span class="line">	Stack s1, s2;</span><br><span class="line">	make_empty(&amp;s1);</span><br><span class="line">	make_empty(&amp;s2);</span><br><span class="line">	push(&amp;s1, <span class="number">1</span>);</span><br><span class="line">	push(&amp;s2, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!is_empty(&amp;s1)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(&amp;s1)); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不理想的方式</span></span><br><span class="line">	Stack s3;</span><br><span class="line">	s3.top = <span class="number">0</span>; <span class="comment">//直接访问了暴露出来的成员</span></span><br><span class="line">	s3.contents[top++] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-4-C-语言"><a href="#19-4-C-语言" class="headerlink" title="19.4    C++语言"></a>19.4    C++语言</h2><blockquote>
<p><strong>说明：</strong>C++语言是由<code>AT&amp;T</code>贝尔实验室的Bjqrne Stroustrup在20世纪80年代开发出来的C语言的扩展版。<br><strong>新特性（相对C）：</strong></p>
<ul>
<li>面向对象：允许从已经存在的类“派生”（继承）出新的类</li>
<li>运算符重载：为传统的C语言的运算符赋予新的含义</li>
<li>模版：可以使我们写出通用的、高度可复用的类和函数</li>
<li>异常处理：一种同一的方式用来检测并响应错误</li>
</ul>
<p><strong>兼容C：</strong>C++语言包含了标准C的全部特性，然而不是所有C语言都可以在C++的环境下编译，因为C++语言增加了更多强制限制，比C语言更加安全。</p>
</blockquote>
<h3 id="19-4-1-C语言与C-语言之间的差异"><a href="#19-4-1-C语言与C-语言之间的差异" class="headerlink" title="19.4.1    C语言与C++语言之间的差异"></a>19.4.1    C语言与C++语言之间的差异</h3><h4 id="19-4-1-1-注释"><a href="#19-4-1-1-注释" class="headerlink" title="19.4.1.1    注释"></a>19.4.1.1    注释</h4><blockquote>
<p><strong>新特性：</strong>C++语言支持单行注释</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a Comment</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-2-标记与类型名"><a href="#19-4-1-2-标记与类型名" class="headerlink" title="19.4.1.2    标记与类型名"></a>19.4.1.2    标记与类型名</h4><blockquote>
<p><strong>新特性：</strong>标记（结构、联合或枚举的名字）会自动被认为是类型名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">	<span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 相当于下列形式的c语言</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">typedef struct Complex &#123;</span><br><span class="line">	double re, im;</span><br><span class="line">&#125; Complex;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-3-不带参数的函数"><a href="#19-4-1-3-不带参数的函数" class="headerlink" title="19.4.1.3    不带参数的函数"></a>19.4.1.3    不带参数的函数</h4><blockquote>
<p><strong>新特性：</strong>在声明或定义一个不带参数的<code>C++</code>函数时，可以不使用<code>void</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">()</span></span>; <span class="comment">// 和void相同</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-4-默认实际参数"><a href="#19-4-1-4-默认实际参数" class="headerlink" title="19.4.1.4    默认实际参数"></a>19.4.1.4    默认实际参数</h4><blockquote>
<p><strong>新特性：</strong>C++语言允许函数的实际参数有默认值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示任意数量的换行符，如果没有提供参数，默认为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_line</span> <span class="params">(<span class="keyword">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_line(<span class="number">3</span>); <span class="comment">// 三个换行</span></span><br><span class="line">new_line(); <span class="comment">//一个换行</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-5-引用参数"><a href="#19-4-1-5-引用参数" class="headerlink" title="19.4.1.5    引用参数"></a>19.4.1.5    引用参数</h4><blockquote>
<p><strong>新特性：</strong>允许实际参数被声明为<code>引用</code>，而不是<code>指针</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c语言的方式</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">void swap (int *a, int *b) &#123;</span><br><span class="line">	int temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;i, &amp;j);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(i, j); <span class="comment">// 不需要再参数前加&amp;运算符</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-6-动态存储分配"><a href="#19-4-1-6-动态存储分配" class="headerlink" title="19.4.1.6    动态存储分配"></a>19.4.1.6    动态存储分配</h4><blockquote>
<p><strong>新特性：</strong>使用运算符<code>new</code>（分配空间）、 <code>delete</code>（释放空间）<br><strong>语法：</strong></p>
<ul>
<li>分配内存：<code>new 类型说明符</code></li>
<li>释放内存： <code>delete 指针</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> *int_ptr, *int_array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">int_ptr = new <span class="keyword">int</span>; <span class="comment">// 为整数分配存储空间</span></span><br><span class="line">int_array = new <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 为数组分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="keyword">delete</span> int_ptr; <span class="comment">// 为整数空间释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] int_array; <span class="comment">// 为数组释放空间</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-2-类"><a href="#19-4-2-类" class="headerlink" title="19.4.2    类"></a>19.4.2    类</h3><blockquote>
<p><strong>类：</strong>一个类从根本上说就是一个<code>抽象数据类型</code>：一组数据以及操作这些数据的函数<br><strong>说明：</strong>这个新数据类型的功能可以同基本数据类型同样强大。<br><strong>类的不足：</strong>类的设计和实现比较复杂，这是易用性必须付出的代价，而这也是计算机领域近几年内的妥协。</p>
</blockquote>
<h3 id="19-4-3-类定义"><a href="#19-4-3-类定义" class="headerlink" title="19.4.3    类定义"></a>19.4.3    类定义</h3><blockquote>
<p><strong>类标记（class tag）：</strong>可以直接作为类型名使用，不要求类名以大写开始，但许多C++程序员尊循首字母大写的规范。<br><strong>数据成员（data memeber）：</strong>类似结构的成员（但是默认是隐藏的，即“私有的”）<br><strong>类的实例（instance）：</strong>任何类的实例就是<code>对象</code>（object）<br><strong>访问成员：</strong>使用运算符<code>.</code>或<code>-&gt;</code>来访问公有的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 默认是私有的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 公有成员</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> numeratitor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-4-成员函数"><a href="#19-4-4-成员函数" class="headerlink" title="19.4.4    成员函数"></a>19.4.4    成员函数</h3><blockquote>
<p><strong>成员函数（member function）：</strong>属于类的函数称为成员函数，特别的，那些需要访问类的私有数据成员的函数必须声明在类里面。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 将函数的定义放在类的定义之中</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> denom)</span> </span>&#123;</span><br><span class="line">			numertor = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 只声明不定义（定义部分放在类外部）</span></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		* 乘法函数</span><br><span class="line">		* @param &#123;Fraction f&#125; </span><br><span class="line">		*/</span></span><br><span class="line">		<span class="function">Fraction <span class="title">mul</span><span class="params">(Fraction f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 乘法函数的定义</span><br><span class="line">* Fraction::前缀是必需的，否则C++编译器会将mul作为一个普通函数</span><br><span class="line">* @param &#123;Fraction f&#125; 分数</span><br><span class="line">*/</span></span><br><span class="line">Fraction Fraction::mul(Fraction f) &#123;</span><br><span class="line">	Fraction result;</span><br><span class="line">	result.numerator = numerator * f.numerator;</span><br><span class="line">	result.denominator = denominator * f.denominator;</span><br><span class="line">	result.reduce();</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Fraction f1;</span><br><span class="line">f1.create(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Fraction f2 = f1.mul(f1);</span><br></pre></td></tr></table></figure>
<h3 id="19-4-5-构造函数"><a href="#19-4-5-构造函数" class="headerlink" title="19.4.5    构造函数"></a>19.4.5    构造函数</h3><blockquote>
<p><strong>构造函数（controctor）：</strong></p>
<ul>
<li>通常时自动调用的（编译器安排在合适的时机自动调用）</li>
<li>定义在public成员部分，不需要指定返回值类型</li>
<li>命名和类名相同</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		Fraction(<span class="keyword">int</span> num = <span class="number">0</span>, <span class="keyword">int</span> denom = <span class="number">1</span>) &#123;</span><br><span class="line">			numerator = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 通过构造函数声明并初始化实例</span></span><br><span class="line"><span class="function">Fraction <span class="title">f2</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 等同于Fraction f2(3, 1);</span></span><br><span class="line">Fraction f3; <span class="comment">// 等同于 f3(0, 1);</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-6-构造函数和动态存储分配"><a href="#19-4-6-构造函数和动态存储分配" class="headerlink" title="19.4.6    构造函数和动态存储分配"></a>19.4.6    构造函数和动态存储分配</h3><blockquote>
<p><strong>说明：</strong>构造函数和析构函数为那些内存分配和回收函数提供了比较合适的时机。<br><strong>举例：</strong>创建自己的<code>String</code>类型<br>|比较|C++的<code>String</code>（自定义）|C语言实现方式（<code>char</code>数组）|<br>|-|-|-|<br>|字符串长度|任意长度|受限于数组的长度|<br>|获取字符串长度|O(1)|O(n)|<br>|扩展性|需要时可给String类添加操作|无法修改（就算引入<string.h>，但无法扩展）|</string.h></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">	<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="comment">// 分配足够大的空间</span></span><br><span class="line">	text = new Char[len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">	<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-7-析构函数"><a href="#19-4-7-析构函数" class="headerlink" title="19.4.7    析构函数"></a>19.4.7    析构函数</h3><blockquote>
<p><strong>析构函数（destructor）：</strong></p>
<ul>
<li>名字：<code>~类名</code></li>
<li>返回值：没有返回值</li>
<li>参数：没有</li>
</ul>
<p><strong>用途：</strong>自动存储期限的类的实例，当其生存期结束后，普通成员的内存会被释放，但在构造函数中分配内存的成员指向的内存不会被释放（内存泄漏）。所以需要析构函数在对象释放时自动调用，清理构造函数动态分配的内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明并定义构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">			<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">			len = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="comment">// 分配足够大的空间</span></span><br><span class="line">			text = new Char[len + <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">			<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 声明并定义析构函数</span></span><br><span class="line">		~String() &#123;</span><br><span class="line">			<span class="keyword">delete</span> [] text;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-8-重载"><a href="#19-4-8-重载" class="headerlink" title="19.4.8    重载"></a>19.4.8    重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p><strong>说明：</strong>在同一作用域下存在两个或以上同名但参数不同的函数(包括构造函数)叫做函数的重载。<br><strong>用途：</strong>需要记住更少的函数名，编译器会根据实际参数的情况自动判断调用哪一个函数。<br><strong>默认构造函数：</strong>不带时机参数的构造函数，会在声明对象而没有制定初始值时被调用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Sring &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	* 重载构造函数（默认）</span><br><span class="line">	* @overload</span><br><span class="line">	*/</span></span><br><span class="line">	String() &#123;</span><br><span class="line">		text = <span class="number">0</span>;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~String() &#123;</span><br><span class="line">		<span class="keyword">delete</span> [] text;</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *text;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">String s; <span class="comment">// 不带实际参数，会调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p><strong>说明：</strong>重载运算符后，根据操作数类型的不同，同样的运算符号可以代表不同的操作。<br><strong>用途：</strong>更易读，更自然（不需要定义一些难以记住的函数名）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 声明重载操作符：*</span></span><br><span class="line">	Fraction <span class="keyword">operator</span>*(Fraction f);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载操作符：*</span></span><br><span class="line">Fraction Fraction::operation*(Fraction f) &#123;</span><br><span class="line">	<span class="comment">//代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">f3 = f1 * f2; <span class="comment">// 定义的*是一个二元运算符(相当于f3 = f1.operator*(f2);)</span></span><br></pre></td></tr></table></figure>
<h4 id="C-语言的输入／输出（）"><a href="#C-语言的输入／输出（）" class="headerlink" title="C++语言的输入／输出（）"></a>C++语言的输入／输出（<stdio.h>）</stdio.h></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/18 声明/" itemprop="url">
                  18 声明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T20:29:30+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>通过声明变量和函数，可以再检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。</p>
</blockquote>
<h2 id="18-1-声明的语法"><a href="#18-1-声明的语法" class="headerlink" title="18.1    声明的语法"></a>18.1    声明的语法</h2><blockquote>
<p><strong>语法：</strong><code>声明说明符 声明符;</code></p>
</blockquote>
<h3 id="18-1-1-声明说明符"><a href="#18-1-1-声明说明符" class="headerlink" title="18.1.1    声明说明符"></a>18.1.1    声明说明符</h3><blockquote>
<p><strong>分类：</strong>分3类（可组合）</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>包括</th>
<th>位置</th>
<th>可多个</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>auto static extern register</td>
<td>声明中的首要位置</td>
<td>否</td>
</tr>
<tr>
<td>类型限定符</td>
<td>const volatile</td>
<td>存储类型的后边</td>
<td>是</td>
</tr>
<tr>
<td>类型说明符</td>
<td>void char short int long float double signed unsigned 结构 联合 枚举 typedef创建的类型名</td>
<td>存储类型的后边</td>
<td>是，出现顺序无限制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>类型限定符和类型说明符的顺序没有限制，习惯上前者在前。</p>
</blockquote>
<h3 id="18-1-2-声明符"><a href="#18-1-2-声明符" class="headerlink" title="18.1.2    声明符"></a>18.1.2    声明符</h3><blockquote>
<p><strong>说明：</strong>一次可以声明多个声明符，彼此用<code>,</code>隔开。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>是否可跟初始化式</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单变量名</td>
<td>标识符</td>
<td>是</td>
</tr>
<tr>
<td>数组名</td>
<td>后边跟随[]的标识符</td>
<td>是</td>
</tr>
<tr>
<td>指针名</td>
<td>前放置*的标识符</td>
<td>是</td>
</tr>
<tr>
<td>函数名</td>
<td>后边跟随()的标识符</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="18-1-3-举例"><a href="#18-1-3-举例" class="headerlink" title="18.1.3    举例"></a>18.1.3    举例</h3><p><em>同时声明多个声明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.19.png" alt="Alt text"></p>
<p><em>带有初始化式</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.31.png" alt="Alt text"></p>
<p><em>同时使用多种类型说明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.57.png" alt="Alt text"></p>
<p><em>函数声明</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.09.05.png" alt="Alt text"></p>
<h2 id="18-2-存储类型"><a href="#18-2-存储类型" class="headerlink" title="18.2    存储类型"></a>18.2    存储类型</h2><blockquote>
<p><strong>说明：</strong>可以用于变量、较小范围的函数和形式参数的说明。根据声明位置的不同，在不用存储类型修饰的情况下，变量具有默认的存储类型，当默认的性质无法满足要求时，可以通过指定明确的存储类型来改变变量的性质。<br><strong>关键字：</strong><code>auto</code> <code>static</code> <code>extern</code> <code>register</code><br><strong>块（block）：</strong>表示函数体（大括号闭合的部分）或块语句（包含生命的复合语句）。</p>
</blockquote>
<h3 id="18-2-1-变量的特性"><a href="#18-2-1-变量的特性" class="headerlink" title="18.2.1    变量的特性"></a>18.2.1    变量的特性</h3><blockquote>
<p><strong>说明：</strong>变量的3个性质</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
<th>说明</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储期限</td>
<td>为变量预留和释放内存的时间</td>
<td>自动存储期限、静态存储期限</td>
</tr>
<tr>
<td>作用域</td>
<td>指引用变量的那部分程序文件</td>
<td>块作用域、文件作用域</td>
</tr>
<tr>
<td>链接</td>
<td>程序的不同部分可以共享此变量的范围</td>
<td>外部链接、内部链接、无链接</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>声明位置决定的存储特性：</strong>对许多变量而言，默认的存储期限、作用域和链接是可以符合要求的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>声明位置</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>块内部</td>
<td>自动存储期限、块作用域、无链接</td>
</tr>
<tr>
<td>程序的最外层</td>
<td>静态存储期限、文件作用域、外部链接</td>
</tr>
</tbody>
</table>
<h4 id="1-存储期限"><a href="#1-存储期限" class="headerlink" title="1. 存储期限"></a>1. 存储期限</h4><table>
<thead>
<tr>
<th>存储期限</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
<td>在所属块被执行时获得内存单元，并在块终止时释放内存单元（变量失去值）</td>
<td></td>
</tr>
<tr>
<td>静态存储期限</td>
<td>在程序运行期间占有同样的存储单元</td>
<td>可以允许变量无限期地保留它的值</td>
</tr>
</tbody>
</table>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>块作用域</td>
<td>变量从声明的地方一直到闭合块的末尾都是可见的</td>
<td></td>
</tr>
<tr>
<td>文件作用域</td>
<td>从声明的地方一直到闭合文件的末尾都时可见的</td>
</tr>
</tbody>
</table>
<h4 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h4><table>
<thead>
<tr>
<th>链接</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部链接</td>
<td>可以被程序中的几个（或者全部）文件共享</td>
<td></td>
</tr>
<tr>
<td>内部链接</td>
<td>只能属于单独一个文件</td>
<td></td>
</tr>
<tr>
<td>无链接</td>
<td>属于单独一个函数，而且根本不能被共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 静态存储期限</span><br><span class="line">* 文件作用域</span><br><span class="line">* 外部链接</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	* 自动存储期限</span><br><span class="line">	* 块作用域</span><br><span class="line">	* 无链接</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-2-auto存储类型"><a href="#18-2-2-auto存储类型" class="headerlink" title="18.2.2    auto存储类型"></a>18.2.2    auto存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>auto</code><br>注意：auto存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h3 id="18-2-3-static存储类型"><a href="#18-2-3-static存储类型" class="headerlink" title="18.2.3    static存储类型"></a>18.2.3    static存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>static</code><br><strong>可以修饰：</strong>全部变量<br><strong>特性：</strong>修饰快外部声明的变量和块内部声明的变量会有不同的效果</p>
<ul>
<li><strong>块外部</strong>：static使变量由外部链接变为内部链接（即<code>信息隐藏</code>，因为本质上隐藏了它所在声明文件内的变量，只有出现在同一文件中的函数可以看到此变量）</li>
<li><strong>块内部</strong>：static使变量的存储期限从自动变成静态的(无限期保留值)</li>
</ul>
<ol>
<li>块内的<code>static</code> 型变量只在程序执行前进行一次初始化，而<code>auto</code>型变量则会在每次变成有效时进行初始化</li>
<li>每次函数进行递归调用时，它都会获得一组新的<code>auto</code>型变量的集合。<code>static</code>修饰的变量则会被共用</li>
<li>函数不能返回<code>auto</code>型变量的指针，但可以返回指向<code>static</code>型变量的指针</li>
</ol>
<p><strong>用途：</strong></p>
<ol>
<li><strong>提升性能：</strong>修饰块内部变量，避免函数每次调用都对变量进行初始化</li>
<li><strong>信息隐藏：</strong>修饰块外部变量，用于在“隐藏”区域内的调用之间保留信息</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 内部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 无链接</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 将10进制的数字转换为16进制的</span><br><span class="line">* param &#123;int&#125; digit 10进制数字（16以内）</span><br><span class="line">* return &#123;char&#125; 表示响应16进制数字的字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">digit_to_hex_char</span> <span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 无论函数呗调用多少次，只会初始化一次</span></span><br><span class="line">	<span class="keyword">const</span> chat hex_chars[<span class="number">16</span>] = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">	return hex_chars[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-4-extern存储类型"><a href="#18-2-4-extern存储类型" class="headerlink" title="18.2.4    extern存储类型"></a>18.2.4    extern存储类型</h3><blockquote>
<p><strong>说明：</strong>只声明变量（不初始化）<br><strong>关键字：</strong><code>extern</code><br><strong>用途：</strong>多文件共享同一个变量<br><strong>性质：</strong></p>
<ul>
<li><strong>存储期限：</strong>使变量具有<code>静态存储期限</code>（即使在块中声明的变量）</li>
<li><strong>作用域：</strong><code>extern</code>不影响变量作用域（块内声明为块作用域，否则是文件作用域）</li>
<li><strong>链接：</strong>通常情况为<code>外部链接</code>；当同时被<code>static</code>修饰且声明位置为任何函数外部时为<code>内部链接</code></li>
</ul>
<p><strong>注意：</strong>用<code>extern</code>修饰的变量仍然可以同时初始化（但就没有了用<code>extern</code>的意义）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//等价于int i = 0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 链接？</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 链接？</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-5-register存储类型"><a href="#18-2-5-register存储类型" class="headerlink" title="18.2.5    register存储类型"></a>18.2.5    register存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>register</code><br><strong>用途：</strong>使变量存储在寄存器而不是内存中，提高访问和更新速度。<br><strong>寄存器：</strong>使驻留在计算机CPU中的存储单元。在传统计算机架构中，存储在寄存器中的数据会比存储在普通内存中的数据访问和更新速度更快。<br><strong>特点：</strong></p>
<ul>
<li>具有和<code>auto</code>型变量一样的俄存储期限、作用域和链接</li>
<li>对<code>register</code>型变量使用取地址运动符<code>&amp;</code>使非法的（因为寄存器没有地址）</li>
</ul>
<p><strong>注意：</strong>随着编译器变得更加复杂和高效，一些编译器可以自动决定变量保存在寄存器中还是内存中来达到最优性能。因此<code>register</code>的使用不再流行了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for语句的循环控制变量应用`register`是一个很好的选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-6-函数的存储类型"><a href="#18-2-6-函数的存储类型" class="headerlink" title="18.2.6    函数的存储类型"></a>18.2.6    函数的存储类型</h3><blockquote>
<p><strong>说明：</strong>函数只能用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<table>
<thead>
<tr>
<th>不修饰或<code>extern</code></th>
<th><code>static</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>静态存储期限</td>
</tr>
<tr>
<td>文件作用域</td>
<td>文件作用域</td>
</tr>
<tr>
<td><code>外部链接</code></td>
<td><code>内部链接</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong> 当声明不打算被其他文件调用的任意函数时，建议使用<code>static</code>修饰</p>
<ol>
<li><strong>更容易维护：</strong>稍后修改文件的人可以知道对被<code>static</code>修饰的函数的修改一般不会影响其他文件中的函数（即便该函数所在文件中其它函数将指向该函数的指针传递了出去，也可以在当前文件发现）</li>
<li><strong>减少“命名空间污染”：</strong>可以在其它文件中使用相同的名字命名函数而不会发生冲突<br><strong>注意：</strong>使用<code>extern</code>画蛇添足，不必使用但也无害。</li>
</ol>
<p><strong>扩展：</strong>函数行参的存储类型（只能用<code>register</code>修饰）</p>
</blockquote>
<table>
<thead>
<tr>
<th>默认（等同于块中的<code>auto</code>型变量）</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h2 id="18-3-类型限定符"><a href="#18-3-类型限定符" class="headerlink" title="18.3    类型限定符"></a>18.3    类型限定符</h2><table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const</code></td>
<td>声明只读类型（也称为常量）</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td><a href="">20.3节</a></td>
</tr>
</tbody>
</table>
<h3 id="const介绍"><a href="#const介绍" class="headerlink" title="const介绍"></a><code>const</code>介绍</h3><p><strong>用途：</strong>定义常量</p>
<blockquote>
<ol>
<li>提示阅读程序的人，对象的值不能改变</li>
<li>让编译器检查防止程序改变对象的值</li>
<li>可能的话（特别是嵌入式系统），编译器可以用让<code>const</code>修饰的变量存储到<code>ROM</code>(只读内存)中</li>
</ol>
</blockquote>
<p><code>只读（const）</code>和<code>宏（#define）</code>：如何恰当使用两者？</p>
<blockquote>
<p><strong>技巧：</strong>建议对表示数字（比如数组维数）或字符的常量使用<code>#define</code>;<code>const</code>常用于保护存储在数组中的常量数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>只读（const）</th>
<th>宏(#define)</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>数字常量、字符常量、字符串常量</td>
<td>任何类型（包括常量数组、常量指针、常量结构、常量联合）</td>
</tr>
<tr>
<td>作用域</td>
<td>遵守作用域规则</td>
<td>不遵守，不能产生具有块作用域的常量</td>
</tr>
<tr>
<td>能否在调试器观察</td>
<td>能</td>
<td>不能</td>
</tr>
<tr>
<td>能否用于常量表达式</td>
<td>不能，比如数组大小（常量表达式）不能用<code>const</code>定义的常量</td>
<td>能</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">// 使用错误，只读类型不能用于常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="18-4-声明符"><a href="#18-4-声明符" class="headerlink" title="18.4    声明符"></a>18.4    声明符</h2><h3 id="声明符组成"><a href="#声明符组成" class="headerlink" title="声明符组成"></a>声明符组成</h3><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>标识符</code></td>
<td>声明的变量或函数的名字</td>
<td>是</td>
</tr>
<tr>
<td><code>*</code></td>
<td>声明指针或对指针进行索引</td>
<td>否</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>声明数组</td>
<td>否</td>
</tr>
<tr>
<td><code>()</code></td>
<td>声明函数或提高优先级</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="简单的声明规则"><a href="#简单的声明规则" class="headerlink" title="简单的声明规则"></a>简单的声明规则</h3><table>
<thead>
<tr>
<th>符号(用于声明)</th>
<th>简单规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>用*开头的声明符表示指针</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>用[]结尾的声明符表示数组</td>
</tr>
<tr>
<td><code>()</code></td>
<td>用()结尾的声明符表示函数</td>
</tr>
</tbody>
</table>
<h3 id="不合法的声明符"><a href="#不合法的声明符" class="headerlink" title="不合法的声明符"></a>不合法的声明符</h3><blockquote>
<ol>
<li>函数不能返回数组</li>
<li>函数不能返回函数</li>
<li>数组不能是函数型的</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的情况：标识符就是声明符</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; <span class="comment">//extern int a[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">()</span></span>; <span class="comment">// 空括号形式使得编译器不检查函数调用的参数情况，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 明确告诉编译器没有参数，编译器会检查参数情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>; <span class="comment">// 允许在函数声明中忽略形式参数的名字</span></span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-解释复杂声明"><a href="#18-4-1-解释复杂声明" class="headerlink" title="18.4.1    解释复杂声明"></a>18.4.1    解释复杂声明</h3><blockquote>
<p><strong>规则：</strong>无论多么复杂的声明都可以被下面的两条规则解释</p>
<ol>
<li>从标识符开始，由内往外解读</li>
<li>当符号位于同一层级(一左一右)时，确定声明的是什么东西的优先级是：<code>[] &gt; () &gt; *</code>(数组 &gt; 函数 &gt; 指针)</li>
</ol>
<p><strong>技巧：</strong>作为上面规则的补充，符号<code>()</code>和<code>*</code>有存在歧义的时候，下面是甄别的依据</p>
<ol>
<li><code>()</code>：当位于声明符最右端时代表“函数”；否则是用来进行指针索引的，像这样：<code>(*其它部分)</code></li>
<li><code>*</code>：<code>(*其它部分)</code>代表指针索引，否则是定义函数的返回值类型为指针（如果是函数）或者是指针类型的定义。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据规则2，ap是数组（元素是int *型的指针）</span></span><br><span class="line"><span class="keyword">int</span> *ap[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，fp是函数（返回值类型为float *）</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> *<span class="title">fp</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过技巧1，(*pf)是函数，所以pf是指向函数的指针（函数的返回值为void）</span></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，(*x[10])是函数（返回值为int *, 参数为void），则x[10]为函数指针，所以x是存储函数指针的数组。</span></span><br><span class="line"><span class="keyword">int</span> *(*x[<span class="number">10</span>])(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-使用类型定义来简化声明"><a href="#18-4-2-使用类型定义来简化声明" class="headerlink" title="18.4.2    使用类型定义来简化声明"></a>18.4.2    使用类型定义来简化声明</h3><blockquote>
<p><strong>说明：</strong>利用一组类型定义拆分复杂的声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价：int *(*x[10])(void);</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">Fcn</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> Fcn *Fcn_ptr;</span><br><span class="line"><span class="keyword">typedef</span> Fcn_ptr Fcn_ptr_array[<span class="number">10</span>];</span><br><span class="line">Fcn_ptr_array x;</span><br></pre></td></tr></table></figure>
<h2 id="18-5-初始化式"><a href="#18-5-初始化式" class="headerlink" title="18.5    初始化式"></a>18.5    初始化式</h2><blockquote>
<p><strong>说明：</strong>可以在声明符的后边书写=, 后边再跟上初始化式（不同于赋值，赋值只要是合法的右值即可，而初始化式存在诸多限制）。<br><strong>变量的默认值（声明时不给初始化式）：</strong>变量的初始化值依赖于变量的存储期限</p>
<ul>
<li><em>自动存储期限</em>：没有默认的初始值，不能预测初始值</li>
<li><em>静态存储期限</em>：基于类型初始化为“零”（整型初始化为0，浮点数初始化为0.0，指针初始化为空指针）</li>
</ul>
<p><strong>技巧：</strong>推荐为静态类型的变量提供初始化式，便于阅读者确定变量的值，也便于查看初始化赋值的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单变量的初始化：一个变量，与变量类型一样的表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型不匹配，采用和赋值运算相同的规则进行自动类型转换（7.5节）</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量的初始化：必须是具有和变量相同类型或void *类型的指针表达式</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组、结构或联合的初始化式通常是遗传封闭在大括号内的值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="额外规则"><a href="#额外规则" class="headerlink" title="额外规则"></a>额外规则</h3><ul>
<li>具有静态存储期限的变量：初始化式必须是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 100</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = LAST - FIRST + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>具有自动存储期限的变量：初始化式不必要是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用大括号闭合的数组、结构或联合的初始化式必须只能包含常量表达式，不允许有变量或函数调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="keyword">int</span> powers[<span class="number">3</span>] = &#123;<span class="number">1</span>, N, N*N, N*N*N&#125;; <span class="comment">// N是常量，所以合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自动类型的结构或联合：初始化式可以是另外一个结构或联合</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">struct</span> <span class="keyword">complex</span> c1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">complex</span> c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/17 指针的高级应用/" itemprop="url">
                  17 指针的高级应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T19:38:12+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-动态存储分配"><a href="#17-1-动态存储分配" class="headerlink" title="17.1    动态存储分配"></a>17.1    动态存储分配</h2><blockquote>
<p><strong>背景：</strong>c语言的数据结构通常是固定大小的，为了扩大数据结构的容量，必须修改程序并且再次编译。<br><strong>说明（行为）：</strong>在程序执行期间分配内存单元<br><strong>用途：</strong>可以根据需要设计可以扩大（和缩小）的数据结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>适用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>数组</td>
<td></td>
</tr>
<tr>
<td>结构</td>
<td>可以链接成表、树和其它数据结构</td>
</tr>
</tbody>
</table>
<h3 id="17-1-1-内存分配函数"><a href="#17-1-1-内存分配函数" class="headerlink" title="17.1.1    内存分配函数"></a>17.1.1    内存分配函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>库</th>
<th>备注</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>malloc</code></td>
<td>分配内存快，但是不对内存块进行初始化</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>最常用，不需要对分配的内存块进行清除，所以它比<code>calloc</code>更高效</td>
<td><code>void *</code>(通用指针，本质上只是内存地址)</td>
</tr>
<tr>
<td><code>calloc</code></td>
<td>分配内存块，并且对内存块进行清除</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
<td></td>
</tr>
<tr>
<td><code>realloc</code></td>
<td>调整先前分配的内存块</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
</tr>
</tbody>
</table>
<h3 id="17-1-2-空指针"><a href="#17-1-2-空指针" class="headerlink" title="17.1.2    空指针"></a>17.1.2    空指针</h3><p><strong>说明：</strong>“指向为空的指针”，这是一个区别于所有有效指针的特殊值。<code>Q&amp;A</code>用<code>NULL</code>（宏）来表示空指针。<br><strong>相关场景：</strong>当调用内存分配函数时，如果无法定位满足我们需要的足够大的内存块，函数会返回空指针（<code>null pointer</code>）。</p>
<p><strong>定义了<code>NULL</code>的库文件：</strong></p>
<ol>
<li><locale.h></locale.h></li>
<li><stddef.h></stddef.h></li>
<li><stdio.h></stdio.h></li>
<li><stdlib.h></stdlib.h></li>
<li><string.h></string.h></li>
<li><time.h></time.h></li>
</ol>
<blockquote>
<p><strong>真假：</strong>所有非空指针都为真，而只有空指针为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) ... </span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (!p) ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != NULL) ...</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (p) ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>更酷的方式</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = malloc(<span class="number">10000</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-2-动态分配字符串"><a href="#17-2-动态分配字符串" class="headerlink" title="17.2    动态分配字符串"></a>17.2    动态分配字符串</h2><h3 id="17-2-1-使用malloc函数为字符串分配内存"><a href="#17-2-1-使用malloc函数为字符串分配内存" class="headerlink" title="17.2.1    使用malloc函数为字符串分配内存"></a>17.2.1    使用malloc函数为字符串分配内存</h3><blockquote>
<p><strong>注意：</strong>为字符串分配内存空间时不要忘记包含空字符串的空间。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">char</span> *p = (char *) <span class="built_in">malloc</span>(n + <span class="number">1</span>);<span class="comment">// malloc返回的通用指针会自动转化为char*型变量，因此强制类型转换的部分可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="17-2-2-在字符串函数中使用动态存储分配"><a href="#17-2-2-在字符串函数中使用动态存储分配" class="headerlink" title="17.2.2    在字符串函数中使用动态存储分配"></a>17.2.2    在字符串函数中使用动态存储分配</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 拼接两个字符串并返回一个“新字符串”（不改变原有的两个字符串）</span><br><span class="line"> * @param  s1 要拼接的字符串的第一部分</span><br><span class="line"> * @param  s2 要拼接的字符串的第二部分</span><br><span class="line"> * @return    新字符串地址</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, concat(<span class="string">"abc"</span>, <span class="string">"def"</span>)); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义指向新字符串的临时指针变量</span></span><br><span class="line">	<span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新字符串分配空间</span></span><br><span class="line">	result = <span class="built_in">malloc</span>(strlen(s1) + strlen(s2) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存失败</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in concat \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一部分复制到新字符串的空间中（会有剩余）</span></span><br><span class="line">	<span class="built_in">strcpy</span>(result, s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二部分拼接到后面</span></span><br><span class="line">	<span class="built_in">strcat</span>(result, s2);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-3-动态分配字符串的数组"><a href="#17-2-3-动态分配字符串的数组" class="headerlink" title="17.2.3    动态分配字符串的数组"></a>17.2.3    动态分配字符串的数组</h3><blockquote>
<p><strong>说明：</strong>在数组中存储字符串有两种方式。二维字符数组或者字符串字面量指针数组，相比之下，前者可能会浪费空间。</p>
</blockquote>
<h3 id="17-2-4-程序：显示一个月的提示列表（改进版）"><a href="#17-2-4-程序：显示一个月的提示列表（改进版）" class="headerlink" title="17.2.4    程序：显示一个月的提示列表（改进版）"></a>17.2.4    程序：显示一个月的提示列表（改进版）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> *reminders[MAX_REMIND];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			reminders[j], reminders[j<span class="number">-1</span>];</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line">		reminders[i] = <span class="built_in">malloc</span>(<span class="number">2</span> + strlen(msg_str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (reminders[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-动态分配数组"><a href="#17-3-动态分配数组" class="headerlink" title="17.3    动态分配数组"></a>17.3    动态分配数组</h2><blockquote>
<p><strong>原理：</strong>在程序执行期间为数组分配空间，然后通过指向数组第一个元素的指针访问数组。由于c语言中数组和指针的紧密关系，指向动态分配的内存块的指针可以当作数组的名字使用。<br><strong>注意：</strong>计算数组所需的空间要使用sizeof运算符，如果分配空间不足，稍后网数组中存储时程序会出现异常。</p>
</blockquote>
<h3 id="17-3-1-使用malloc函数为数组分配存储空间"><a href="#17-3-1-使用malloc函数为数组分配存储空间" class="headerlink" title="17.3.1    使用malloc函数为数组分配存储空间"></a>17.3.1    使用malloc函数为数组分配存储空间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个含n个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">a = <span class="built_in">malloc</span>(n * sizeof(int)); <span class="comment">// 计算数组所需的空间要使用sizeof运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作数组使用</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-3-2-calloc函数"><a href="#17-3-2-calloc函数" class="headerlink" title="17.3.2    calloc函数"></a>17.3.2    calloc函数</h3><blockquote>
<p><strong>函数原型（<code>stdlib.h</code>）：</strong>如果要求的空间无效，那么此函数返回空指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 分配内存空间并初始化</span><br><span class="line">* @param &#123;size_t&#125; numeb 数组的长度</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 数组第一个元素的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmeb, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当第一个参数为1时，可以为任何类型的数据项（不仅仅是数组）分配空间</li>
<li>calloc函数会清除分配的空间中的数据</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为n的int型数组，并将所有项初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(n, sizeof(int));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向结构体的指针</span></span><br><span class="line"><span class="keyword">struct</span> point &#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125; *p;</span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1</span>, sizeof(struct point)); <span class="comment">//p将指向新创建的结构体，且结构体的成员x、y都为0</span></span><br></pre></td></tr></table></figure>
<h3 id="17-3-3-realloc函数"><a href="#17-3-3-realloc函数" class="headerlink" title="17.3.3    realloc函数"></a>17.3.3    realloc函数</h3><blockquote>
<p><strong>原型(<code>stdlib.h</code>)：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 调整分配的内存的大小</span><br><span class="line">* @param &#123;void *&#125; ptr 指向内存块（通常是数组）的指针</span><br><span class="line">* @param &#123;size_t&#125; size 内存块的新尺寸</span><br><span class="line">* @return &#123;void *&#125; 新的内存块的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用途：</strong>一旦为数组分配完内存，稍后可能会返现数组过大或过小。relloc函数可以调整数组的大小以使它更适合需要。<br><strong>局限：</strong>要确定传递给<code>realloc函数</code>的指针来自于先前<code>malloc函数</code>、<code>calloc函数</code>或<code>realloc函数</code>的调用获得的。否则程序会出现异常。<br><strong>规则：</strong></p>
<ul>
<li>如果无法扩大内存（后边内存被占用），会在别处分配新的内存，然后把旧块中的内容复制过去</li>
<li>当扩展内存块时，    <code>realloc函数</code>不会对添加进内存块的字节进行初始化</li>
<li>如果<code>realloc函数</code>不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。</li>
<li>如果<code>realloc函数</code>调用时以空指针作为第一个实际参数，那么它的行为就将像<code>malloc函数</code>一样</li>
<li>如果<code>realloc函数</code>调用时以0作为第二个实际参数，那么它会释放掉内存块    </li>
</ul>
<p><strong>注意：</strong>一旦<code>realloc函数</code>返回，一定要对指向内存块的所有指针进行更新（将新的地址赋值给指针），因为可能realloc函数移动到了其地方的内存块。</p>
</blockquote>
<h2 id="17-4-释放存储"><a href="#17-4-释放存储" class="headerlink" title="17.4    释放存储"></a>17.4    释放存储</h2><blockquote>
<p><strong>堆（heap）：</strong><code>malloc函数</code>和其他内存分配函数所获得的内存块都来自一个称为堆的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也会耗尽堆，这会导致函数返回空指针。<br><strong>垃圾（garbage）：</strong>对程序而言不再访问到的内存块被称为垃圾。<br><strong>内存泄漏（memroy leak）：</strong>运行中留有垃圾被称为内存泄漏。<br><strong>垃圾收集器（garbage collector）：</strong>用于垃圾的自动定位和回收，但c语言不提供。相反，每个c程序负责回收各自的垃圾（调用<code>free函数</code>）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*模拟内存泄漏*/</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...)</span><br><span class="line">q = <span class="built_in">malloc</span>(...)</span><br><span class="line">p = q; <span class="comment">// p原本指向的内存块变成垃圾</span></span><br></pre></td></tr></table></figure>
<h3 id="17-4-1-free函数"><a href="#17-4-1-free函数" class="headerlink" title="17.4.1    free函数"></a>17.4.1    free函数</h3><blockquote>
<p><strong>用途：</strong>调用<code>free函数</code>将内存块释放返回堆。<br><strong>原型：</strong><code>stdlib.h</code><br><strong>限制：</strong><code>free函数</code>的世纪参数必须是指针，而且一定是先前<code>内存分配函数</code>返回的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 释放内存</span><br><span class="line">* @param &#123;void *&#125; ptr 指向需要释放的内存块的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-4-2-“悬空指针”问题"><a href="#17-4-2-“悬空指针”问题" class="headerlink" title="17.4.2    “悬空指针”问题"></a>17.4.2    “悬空指针”问题</h3><blockquote>
<p><strong>悬空指针（dangling pointer）：</strong>指向被<code>free</code>掉的内存块的指针。<br><strong>注意：</strong>悬空指针很难被发现，而且试图通过“悬空指针”修改被释放掉的内存块会导致程序异常。</p>
</blockquote>
<h2 id="17-5-链表"><a href="#17-5-链表" class="headerlink" title="17.5    链表"></a>17.5    链表</h2><blockquote>
<p><strong>链表（linked list）：</strong>时由一连串的结构（节点）组成的，其中每个节点都包含指向下一个链中节点的指针。<br><strong>优点：</strong>更灵活，方便扩大和缩小（插入和删除）。<br><strong>缺点：</strong>没有“随机访问”的能力</p>
</blockquote>
<h3 id="17-5-1-声明节点类型"><a href="#17-5-1-声明节点类型" class="headerlink" title="17.5.1    声明节点类型"></a>17.5.1    声明节点类型</h3><blockquote>
<p><strong>注意：</strong>结点类型只能使用标记而不能使用<code>typedef</code>定义结构，因为后者无法在节点内声明指向另一个结点的成员。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的单个节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node *first = <span class="literal">NULL</span>; <span class="comment">//链表初始为空</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-2-创建节点"><a href="#17-5-2-创建节点" class="headerlink" title="17.5.2    创建节点"></a>17.5.2    创建节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点分配内存</span></span><br><span class="line">new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点初始化值</span></span><br><span class="line">(*new_node).value = <span class="number">0</span>; <span class="comment">// .的优先级高于间接寻址运算符*，所以使用()提升后者优先级</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-3-gt-运算符"><a href="#17-5-3-gt-运算符" class="headerlink" title="17.5.3    -&gt;运算符"></a>17.5.3    -&gt;运算符</h3><blockquote>
<p><strong>右箭头选择（right arrow selection）：</strong>通过指针访问结构中的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;value); <span class="comment">//scanf("%d", &amp;(*new_node).value)</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-4-在链表的开始处插入节点"><a href="#17-5-4-在链表的开始处插入节点" class="headerlink" title="17.5.4    在链表的开始处插入节点"></a>17.5.4    在链表的开始处插入节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>为节点分配内存单元</li>
<li>把数据存储在节点中</li>
<li>把节点插入到链表中</li>
</ol>
<p><strong>伏笔：</strong>在17.6节中对<code>add_to_list</code>有进一步优化。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FALURE 0</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 节点</span><br><span class="line"> * @struct</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加节点到链表头部</span><br><span class="line"> * 需要注意的是，该函数执行后还需要将头部指向该函数返回的新的节点才能完成插入到链表头部的工作</span><br><span class="line"> * @param  list 要插入的链表（指向头部节点的指针）</span><br><span class="line"> * @param  n    要插入的节点存储的值</span><br><span class="line"> * @return      新的链表（指向新的头节点的指针）</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明新节点</span></span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配内存</span></span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_ro list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FALURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	new_node-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	return new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行完成链表的创建</span><br><span class="line"> * @return  链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">read_numbers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *first = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a series of intergers (0 to terminate):\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			return first;</span><br><span class="line">		&#125;</span><br><span class="line">		first = add_to_list(first, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个含有用户录入的数字的链表</span></span><br><span class="line">	<span class="keyword">struct</span> node *num_list;</span><br><span class="line">	num_list = read_numbers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-5-搜索链表"><a href="#17-5-5-搜索链表" class="headerlink" title="17.5.5    搜索链表"></a>17.5.5    搜索链表</h3><blockquote>
<p><strong>惯用法：</strong><code>for (p = first; p != NULL; p = p-&gt;next)</code><br><em>形式一：惯用法</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;value == n) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式二：省略中间变量</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span>; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;value == n) &#123;</span><br><span class="line">			return <span class="built_in">list</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式三：链表到末尾和找到目标判定合并</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式四：使用while</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	wile (<span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-6-从链表中删除节点"><a href="#17-5-6-从链表中删除节点" class="headerlink" title="17.5.6    从链表中删除节点"></a>17.5.6    从链表中删除节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定位要删除的节点</li>
<li>改变前一个节点，从而使它“绕过”删除节点</li>
<li>调用<code>free函数</code>从而收回删除节点占用的内存空间</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据节点的值找到节点并删除之</span><br><span class="line">* @param &#123;struct node*&#125; list 所在的链表</span><br><span class="line">* @param &#123;int&#125; n 要删除的节点存储的值</span><br><span class="line">* @return &#123;struct node*&#125; 链表的头节点</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">delete_from_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *cur, *prev;</span><br><span class="line">	<span class="comment">// 定位要删除的节点</span></span><br><span class="line">	<span class="keyword">for</span> (cur = <span class="built_in">list</span>, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;value != n; prev = cur, cur = cur-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	<span class="comment">// 没有找到要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了，要删除的节点是第一个节点</span></span><br><span class="line">	<span class="keyword">if</span> (prev == NUL) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了， 要删除的节点不是第一个几点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		prev-&gt;next = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cur);</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-8-程序：维护零件数据库（改进版）"><a href="#17-5-8-程序：维护零件数据库（改进版）" class="headerlink" title="17.5.8    程序：维护零件数据库（改进版）"></a>17.5.8    程序：维护零件数据库（改进版）</h3><blockquote>
<p><strong>说明：</strong>使用链表代替数组有两个主要的好处</p>
<ol>
<li>不需要事先限制数据库的大小，数据库可以扩大到没有更多内存空间存储零件为止</li>
<li>可以很容易保持用零件编号排序的数据库，当往数据库中添加新零件时，只是简单把它插入链表中的适当位置就可以了</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ tree -L 2</span><br><span class="line"> .</span><br><span class="line"> ├── invent2</span><br><span class="line"> ├── invent2.c</span><br><span class="line"> ├── invent2.o</span><br><span class="line"> ├── makefile</span><br><span class="line"> ├── readline.c</span><br><span class="line"> ├── readline.h</span><br><span class="line"> └── readline.o   └── readline.o</span><br></pre></td></tr></table></figure>
<h4 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invent2-c"><a href="#invent2-c" class="headerlink" title="invent2.c"></a>invent2.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (linked list version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * 定义零件</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number; <span class="comment">// 编号</span></span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>]; <span class="comment">// 名字长度</span></span><br><span class="line"> 	<span class="keyword">int</span> on_hand; <span class="comment">// 当前库存</span></span><br><span class="line"> 	<span class="keyword">struct</span> part *next; <span class="comment">// 指向下一个零件</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表（头节点）</span></span><br><span class="line"> <span class="keyword">struct</span> part *inventory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"> 		<span class="comment">// 跳过换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>: insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>: search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>: update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>: print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>: return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索零件</span><br><span class="line"> * @param  number 零件包含的值</span><br><span class="line"> * @return        对应零件节点的地址（没找到返回NULL）</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span> &amp;&amp; number &gt; p-&gt;number; p = p -&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; number == p-&gt;number) &#123;</span><br><span class="line"> 		return p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入一种零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *cur, *prev, *new_node;</span><br><span class="line"> 	<span class="comment">// 为新节点分配空间</span></span><br><span class="line"> 	new_node = <span class="built_in">malloc</span>(sizeof(struct part));</span><br><span class="line"> 	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Database is full; can't add more parts.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 零件编号</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;number);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 根据编号寻找插入位置(按从小到大的顺序排列)</span></span><br><span class="line"> 	<span class="keyword">for</span> (cur = inventory, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number &gt; cur-&gt;number; prev = cur, cur = cur-&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 发现编号相同的节点</span></span><br><span class="line"> 	<span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number == cur-&gt;number) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exits.\n"</span>);</span><br><span class="line"> 		<span class="built_in">free</span>(new_node);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name:"</span>);</span><br><span class="line"> 	read_line(new_node-&gt;name, NAME_LEN);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件数量</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;on_hand);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 插入进去</span></span><br><span class="line"> 	new_node-&gt;next = cur;</span><br><span class="line"> 	<span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		inventory = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		prev-&gt;next = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 以交互的方式根据编号搜索并显示目标零件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">struct</span> part *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">	p = find_part(number);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p-&gt;name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, p-&gt;on_hand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 修改零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> number, change;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	p = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		p-&gt;on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印所有零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part number    Part Name   Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d      %-25s%11d\n"</span>, p-&gt;number, p-&gt;name, p-&gt;on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-6-指向指针的指针"><a href="#17-6-指向指针的指针" class="headerlink" title="17.6    指向指针的指针"></a>17.6    指向指针的指针</h2><blockquote>
<p><strong>说明：</strong>对17.5.4中的<code>add_to_list</code>进行优化，优化后插入链表的功能将完全由该函数提供。<br><strong>原理：</strong>通过指针的指针的副本，达到修改指针指向的目的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 向链表中插入节点</span><br><span class="line">* @param &#123;struct node **&#125; node 指向链表的头节点的指针的指针</span><br><span class="line">* @param &#123;int&#125; n 节点存储的值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node **<span class="built_in">list</span>,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_to_list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURES);</span><br><span class="line">	&#125;</span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	<span class="comment">// 新节点的下一个节点指向链表头节点</span></span><br><span class="line">	new_node-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原本指向头节点的指针指向新节点</span></span><br><span class="line">	<span class="comment">// 详解：list的值是first这个指针本身的地址，通过*list便可以访问到first这个指针</span></span><br><span class="line">	*<span class="built_in">list</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">add_to_list(&amp;first, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="17-7-指向函数的指针"><a href="#17-7-指向函数的指针" class="headerlink" title="17.7    指向函数的指针"></a>17.7    指向函数的指针</h2><blockquote>
<p><strong>说明：</strong>毕竟函数占用内存单元，所以每个函数都有地址，就像每个变量都有地址一样。</p>
</blockquote>
<h3 id="17-7-1-函数指针作为实际参数"><a href="#17-7-1-函数指针作为实际参数" class="headerlink" title="17.7.1    函数指针作为实际参数"></a>17.7.1    函数指针作为实际参数</h3><blockquote>
<p><strong>声明：</strong>声明为指向函数的指针有两种方式，从编译器的角度看是完全一样的。</p>
<blockquote>
<p>方式一：<strong>返回值 函数名(<code>返回值 (*函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">double integrate (double (*f)(double), double a, double b)  &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x); // 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式二：<strong>返回值 函数名(<code>返回值 (函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">double integrate (double f(double), double a, double b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x);// 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-7-2-qsort函数"><a href="#17-7-2-qsort函数" class="headerlink" title="17.7.2    qsort函数"></a>17.7.2    qsort函数</h3><blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 为数组排序</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;int (*)&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size,  int (*compar) (const void *, const void *));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较函数（提供给qsort函数排序规则）</span><br><span class="line"> * @param &#123;void *&#125; p 第一个零件</span><br><span class="line"> * @param &#123;void *&#125; q 第二个零件</span><br><span class="line"> * @return   正数（1）：*p &gt; *q;负数（-1）：*p &lt; *q;零（0）：*p = *q</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_parts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">const</span> <span class="keyword">void</span> *q)</span> </span>&#123;</span><br><span class="line">	return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比较函数进行排序</span></span><br><span class="line">qsort(inventory, num_parts, <span class="keyword">sizeof</span>(struct part), compare_parts);</span><br></pre></td></tr></table></figure>
<h3 id="17-7-3-函数指针的其他用途"><a href="#17-7-3-函数指针的其他用途" class="headerlink" title="17.7.3    函数指针的其他用途"></a>17.7.3    函数指针的其他用途</h3><blockquote>
<p><strong>说明：</strong>c语言对待指向函数的指针就像对待指向数据的指针一样。我们可以把函数存储在变量中，或者用做数组的元素，再或者用做结构或联合的成员，甚至可以编写返回函数指针的函数，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*存储函数的变量*/</span></span><br><span class="line"><span class="keyword">void</span> (*pf) (<span class="keyword">int</span>); <span class="comment">//声明一个可以存储指向函数的指针的变量（pf可以指向任何带有int型实际参数，且返回值为void的函数）</span></span><br><span class="line"></span><br><span class="line">pf = f; <span class="comment">// 指向函数f</span></span><br><span class="line"></span><br><span class="line">(*pf)(i); <span class="comment">// pf(i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储函数的数组*/</span></span><br><span class="line"><span class="keyword">void</span> (*file_cmd[])(<span class="keyword">void</span>) = &#123;</span><br><span class="line">	new_cmd,</span><br><span class="line">	open_cmd,</span><br><span class="line">	close_cmd,</span><br><span class="line">	close_all_cmd,</span><br><span class="line">	save_cmd,</span><br><span class="line">	ext_cmd</span><br><span class="line">&#125;;</span><br><span class="line">(*file_cmd[n])(); <span class="comment">// 或者file_cmd[n]();</span></span><br></pre></td></tr></table></figure>
<h3 id="17-7-4-程序：列三角函数表"><a href="#17-7-4-程序：列三角函数表" class="headerlink" title="17.7.4    程序：列三角函数表"></a>17.7.4    程序：列三角函数表</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tabulates values of trigonometric functions</span><br><span class="line"> */</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)double, double first, double last, double incr);</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">	double final, increament, initial;</span><br><span class="line">	printf("Enter initial value: ");</span><br><span class="line">	scanf("%lf", &amp;initial);</span><br><span class="line"></span><br><span class="line">	printf("Enter final value:");</span><br><span class="line">	scanf("%lf", &amp;final);</span><br><span class="line"></span><br><span class="line">	printf("Enter increament:");</span><br><span class="line">	scanf("%lf", &amp;increament);</span><br><span class="line"></span><br><span class="line">	printf("\n     x     cos(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(cos, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     sin(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(sin, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     tan(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(tan, initial, final, increament);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)(double), double first, double last, double incr) &#123;</span><br><span class="line">	double x;</span><br><span class="line">	int i, num_intervals;</span><br><span class="line">	num_intervals = cell((last - first) / incr);</span><br><span class="line">	for (i = 0; i &lt;= num_intervals; i++) &#123;</span><br><span class="line">		x = first + i * incr;</span><br><span class="line">		printf("%10.5f %10.5f\n", x, (*f)[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/16 结构、联合和枚举/" itemprop="url">
                  16 结构、联合和枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:49:46+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="16-1-结构变量"><a href="#16-1-结构变量" class="headerlink" title="16.1    结构变量"></a>16.1    结构变量</h2><blockquote>
<p><strong>结构：</strong>结构的特性与数组很不相同。</p>
<ul>
<li>结构的元素（成员）可能具有不同的类型</li>
<li>每个结构成员都有名字</li>
<li>为了选择特殊的结构成员需要知名结构成员的名字而不是它的位置</li>
</ul>
<p><strong>扩展：</strong>大多数语言都提供类似的特性，所以结构可能听起来很舒需。再其它语言中，经常把结构称为纪录（record），把结构的成员称为字段（field）。</p>
</blockquote>
<h3 id="16-1-1-结构变量的声明"><a href="#16-1-1-结构变量的声明" class="headerlink" title="16.1.1    结构变量的声明"></a>16.1.1    结构变量的声明</h3><p><strong>语法：</strong>只声明不初始化（会非配内存但成员不会初始化）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span>, 实例变量<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong>结构实例化的变量具备以下特点</p>
<ul>
<li>成员在内存中是按照顺序存储的</li>
<li>内部成员拥有单独的名字空间（name space）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//零件</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//零件编号</span></span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//零件名称</span></span><br><span class="line">	<span class="keyword">int</span> on_hand;<span class="comment">//零件现有数量</span></span><br><span class="line">&#125;part1, part2;<span class="comment">//同时用这种结构实例化了两个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//工号</span></span><br><span class="line">	<span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line">&#125;employee1, employee2;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-2-结构变量的初始化"><a href="#16-1-2-结构变量的初始化" class="headerlink" title="16.1.2    结构变量的初始化"></a>16.1.2    结构变量的初始化</h3><blockquote>
<p><strong>语法：</strong>声明的同时初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">    成员<span class="number">2</span>类型 成员<span class="number">2</span>名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;,   </span><br><span class="line">  实例变量<span class="number">2</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;, </span><br><span class="line">  ...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则：</strong>类似数组</p>
<ol>
<li>用于结构初始化式的表达式必须是常量</li>
<li>初始化式可以短于它所初始化的结构，任何剩余的成员都用0作为它的初始值</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> on, hand;</span><br><span class="line">&#125;part1 = &#123;<span class="number">528</span>, <span class="string">"Disk drive"</span>, <span class="number">10</span>&#125;,</span><br><span class="line"> part2 = &#123;<span class="number">914</span>, <span class="string">"Printer cable"</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-3-对结构的操作"><a href="#16-1-3-对结构的操作" class="headerlink" title="16.1.3    对结构的操作"></a>16.1.3    对结构的操作</h3><blockquote>
<p><strong>限制：</strong>不能用<code>==</code>或<code>!=</code>判定两个结构是否相等或不等。</p>
</blockquote>
<h4 id="16-1-3-1-访问成员"><a href="#16-1-3-1-访问成员" class="headerlink" title="16.1.3.1    访问成员"></a>16.1.3.1    访问成员</h4><blockquote>
<p><strong>左值：</strong>结构成员的值是左值</p>
<ul>
<li>可以出现在赋值运算的左侧</li>
<li>作为自增或自减表达式的操作数</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Part number %d:"</span>, part1.number);</span><br><span class="line">part1.number = <span class="number">228</span>;<span class="comment">//可以出现在赋值运算的左侧</span></span><br><span class="line">part1.on_hand++;<span class="comment">//作为自增或自减表达式的操作数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>逗号运算符：</strong><code>结构变量.成员名</code></p>
<ul>
<li>优先级和后缀++和后缀–相同（几乎高于所有其他运算符）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part1.on_hand);<span class="comment">//.运算符优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-2-赋值运算"><a href="#16-1-3-2-赋值运算" class="headerlink" title="16.1.3.2    赋值运算"></a>16.1.3.2    赋值运算</h4><blockquote>
<p><strong>说明：</strong>数组不能用=运算符实现变量间数组内容的复制，但结构变量可以。<br><strong>注意：</strong>只能用于同一个结构类型声明的的变量之间。<br><strong>技巧：</strong>把需要复制的数组嵌在结构体内（作为成员）进行复制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;a1, a2;</span><br><span class="line"></span><br><span class="line">a1 = a2;<span class="comment">//a1的存储空间中数据和a2相同，实现了复制</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-结构类型"><a href="#16-2-结构类型" class="headerlink" title="16.2    结构类型"></a>16.2    结构类型</h2><blockquote>
<p><strong>说明：</strong>上一小结重点放在结构变量而不是结构类型本身上，这一节将重点观察结构类型。<br><strong>命名结构类型：</strong>如果需要在程序的不同位置声明结构变量，上一节的“匿名结构”就行不通了。c语言提供了两种命名结构的方法</p>
<ol>
<li>声明“结构标记”(结构用语链表时，只能声明“结构标记”)</li>
<li>使用<code>typedef</code>定义类型名</li>
</ol>
</blockquote>
<h3 id="16-2-1-结构标记的声明"><a href="#16-2-1-结构标记的声明" class="headerlink" title="16.2.1    结构标记的声明"></a>16.2.1    结构标记的声明</h3><blockquote>
<p><strong>结构标记(structure tag)：</strong>结构标记用于标记某种特定结构类型的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>  结构类型名&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125;[结构变量<span class="number">1</span>, ...];<span class="comment">//分号表示声明的结束，不能省略</span></span><br><span class="line"><span class="keyword">struct</span> 结构类型名 结构变量<span class="number">2</span>, ...;<span class="comment">//struct关键字不能省略，因为结构类型名不是有效的c语言类型名(原生的和typedef定义的才是)。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不仅声明了标记part，而且声明了变量</span></span><br><span class="line"><span class="keyword">struct</span> part&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> part  part1 = &#123;<span class="number">528</span>, <span class="string">"disk drive"</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> part part2;</span><br><span class="line">part2 = part1;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-2-结构类型的定义"><a href="#16-2-2-结构类型的定义" class="headerlink" title="16.2.2    结构类型的定义"></a>16.2.2    结构类型的定义</h3><blockquote>
<p><strong>说明：</strong>用typedef来定义真正的类型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125; 结构类型名;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; Part;<span class="comment">//类型名的名字必须出现在定义的末尾，而不是在单词struct的后边</span></span><br><span class="line">Part part1, part2;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-3-结构类型的实际参数和返回值"><a href="#16-2-3-结构类型的实际参数和返回值" class="headerlink" title="16.2.3    结构类型的实际参数和返回值"></a>16.2.3    结构类型的实际参数和返回值</h3><blockquote>
<p><strong>缺点：</strong>带来一定系统开销，尤其是结构题很大的时候</p>
<blockquote>
<p>给函数传递结构和从函数返回结构都要求使用结构中所有成员的副本。</p>
</blockquote>
<p><strong>技巧：</strong>有时用指向结构的指针来代替传递给函数（或函数返回）的结构本身是很明智的做法。</p>
</blockquote>
<h4 id="16-2-3-1-用作参数"><a href="#16-2-3-1-用作参数" class="headerlink" title="16.2.3.1    用作参数"></a>16.2.3.1    用作参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_part</span> <span class="params">(<span class="keyword">struct</span> part p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"part number: %d\n"</span>, p.number);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Quality on hand: %d \n"</span>, p.on_hand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line">print_part(part1);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-2-用作返回值"><a href="#16-2-3-2-用作返回值" class="headerlink" title="16.2.3.2    用作返回值"></a>16.2.3.2    用作返回值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> part <span class="title">build_part</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> on_hand)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> part p;</span><br><span class="line">	p.number = number;</span><br><span class="line">	<span class="built_in">strcpy</span>(p.name, name);</span><br><span class="line">	p.on_hand = on_hand;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-3-数组和结构的嵌套"><a href="#16-3-数组和结构的嵌套" class="headerlink" title="16.3    数组和结构的嵌套"></a>16.3    数组和结构的嵌套</h2><h3 id="16-3-1-嵌套的结构"><a href="#16-3-1-嵌套的结构" class="headerlink" title="16.3.1    嵌套的结构"></a>16.3.1    嵌套的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义姓名</span></span><br><span class="line"><span class="keyword">struct</span> person_name &#123;</span><br><span class="line">	<span class="keyword">char</span> first[FIRST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> middle_initial;</span><br><span class="line">	<span class="keyword">char</span> last[LAST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">struct</span> student &#123;</span><br><span class="line">	<span class="keyword">struct</span> person_name name; <span class="comment">// 结构的成员可以是另一种结构体</span></span><br><span class="line">	int_id, age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; student1, student2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">"Fred"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-结构数组"><a href="#16-3-2-结构数组" class="headerlink" title="16.3.2    结构数组"></a>16.3.2    结构数组</h3><blockquote>
<p><strong>说明：</strong>结构可以作为数组的元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="comment">// 声明结构数组</span></span><br><span class="line"><span class="keyword">struct</span> part inventory[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问*/</span></span><br><span class="line"><span class="comment">// 访问结构数组中的结构</span></span><br><span class="line">print_part(inventory[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*操作*/</span></span><br><span class="line"><span class="comment">// 为数组中的结构的成员赋值</span></span><br><span class="line">inventory[i].number = <span class="number">883</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组中的结构的成员（字符串）置空</span></span><br><span class="line"> inventory[i].name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-3-结构数组的初始化"><a href="#16-3-3-结构数组的初始化" class="headerlink" title="16.3.3    结构数组的初始化"></a>16.3.3    结构数组的初始化</h3><blockquote>
<p><strong>语法：</strong>类似二维数组的初始化，每个结构都拥有自己的大括号。<br><strong>注意：</strong>每个结构值的内层大括号是可选项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结构：国家代码</span></span><br><span class="line"><span class="keyword">struct</span> dialog_code &#123;</span><br><span class="line">	<span class="keyword">char</span> *country;</span><br><span class="line">	<span class="keyword">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> dialog_code country_codes[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Argentina"</span>, <span class="number">54</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Bangladesh"</span>, <span class="number">66</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-4-程序：维护零件数据库"><a href="#16-3-4-程序：维护零件数据库" class="headerlink" title="16.3.4    程序：维护零件数据库"></a>16.3.4    程序：维护零件数据库</h3><h4 id="16-3-4-1-编写"><a href="#16-3-4-1-编写" class="headerlink" title="16.3.4.1    编写"></a>16.3.4.1    编写</h4><h5 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invent-c"><a href="#invent-c" class="headerlink" title="invent.c"></a>invent.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (array version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line"> 	<span class="keyword">int</span> on_hand;</span><br><span class="line"> &#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> num_parts = <span class="number">0</span>; <span class="comment">// 当前零件的数量</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待用户操作</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 跳过所有的换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line"> 				insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line"> 				search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line"> 				update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line"> 				print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line"> 				return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 				<span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 按照零件的编号查找零件在清单数组中的下标</span><br><span class="line"> * @param  number 零件的编号</span><br><span class="line"> * @return        零件在清单中的下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (inventory[i].number == number) &#123;</span><br><span class="line"> 			return i;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行插入零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 输入零件号</span></span><br><span class="line"> 	<span class="keyword">int</span> part_number;</span><br><span class="line"> 	<span class="keyword">if</span> (num_parts == MAX_PARTS) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Datebase is full, can't add more parts .\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter partnumber: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part_number);</span><br><span class="line"> 	<span class="keyword">if</span> (find_part(part_number) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exists.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	inventory[num_parts].number = part_number;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 输入零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name: "</span>);</span><br><span class="line"> 	read_line(inventory[num_parts].name, NAME_LEN);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inventory[num_parts].on_hand);</span><br><span class="line"> 	num_parts++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 在命令行根据零件编号搜索零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, inventory[i].name);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新清单中某种零件的数量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number, change;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number : "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand: "</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		inventory[i].on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印当前零件清单中所有种类零件的信息</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part Number   Part Name             "</span></span><br><span class="line"> 		   <span class="string">"Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d     %-25s%11d\n"</span>, inventory[i].number, inventory[i].name, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-3-4-2-编译"><a href="#16-3-4-2-编译" class="headerlink" title="16.3.4.2    编译"></a>16.3.4.2    编译</h4><p>$ vim makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">invent:invent.o readline.o</span><br><span class="line">	gcc -o invent invent.o readline.o</span><br><span class="line">invent.o:invent.c readline.h</span><br><span class="line">	gcc -c invent.c</span><br><span class="line">readline.o:readline.c readline.h</span><br><span class="line">	gcc -c readline.c</span><br></pre></td></tr></table></figure>
<p>$ make</p>
<h4 id="16-3-4-3-运行"><a href="#16-3-4-3-运行" class="headerlink" title="16.3.4.3    运行"></a>16.3.4.3    运行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./invent </span><br><span class="line"> Enter operation code:i</span><br><span class="line"> Enter partnumber: 01</span><br><span class="line"> Enter part name: screen</span><br><span class="line"> Enter quantity on hand: 1 </span><br><span class="line"></span><br><span class="line"> Enter operation code:p</span><br><span class="line"> Part Number   Part Name             Quantity on hand</span><br><span class="line">       1     screen</span><br></pre></td></tr></table></figure>
<h2 id="16-4-联合"><a href="#16-4-联合" class="headerlink" title="16.4    联合"></a>16.4    联合</h2><h3 id="特点（和结构相比）"><a href="#特点（和结构相比）" class="headerlink" title="特点（和结构相比）"></a>特点（和结构相比）</h3><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>包含一个或多个成员</li>
<li>成员可以是不同的类型</li>
<li>声明标记和类型的方式</li>
<li>访问成员的方式</li>
<li>可以使用<code>=</code>进行复制操作</li>
<li>可以在函数间传递或作为函数的返回值</li>
<li>初始化方式</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>联合的实例所有成员共享相同的存储空间</li>
<li>联合的实例大小由最大的成员的类型决定</li>
<li>联合初始化实例时初始化的是按照第一个成员的类型来初始化值的</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; u = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0会按照i的类型初始化存储空间</span></span><br><span class="line"></span><br><span class="line">u.f = <span class="number">78.4</span>; <span class="comment">// 为联合赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="16-4-1-使用联合来节省空间"><a href="#16-4-1-使用联合来节省空间" class="headerlink" title="16.4.1    使用联合来节省空间"></a>16.4.1    使用联合来节省空间</h3><blockquote>
<p><strong>原理：</strong>在<code>struct</code>中使用<code>union</code>作为成员，后者使用<code>struct</code>作为成员。这种混合的结构可以实现一种数据结构应用于多种情境的效果。<br><strong>扩展：</strong>在<code>c++</code>中，<code>struct</code>中的<code>union</code>可以匿名，在<code>c</code>中则不得不指定<code>union</code>的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_LEN 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTHOR_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESIGN_LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 礼品册上的商品</span><br><span class="line"> * 可以存储3种类型的商品：书籍、杯子、衬衫</span><br><span class="line"> *</span><br><span class="line"> * @type &#123;struct&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> catalog_item &#123;</span><br><span class="line">	<span class="keyword">int</span> stock_number; <span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">int</span> item_type; <span class="comment">// 分类</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 可能是书</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> title[TITLE_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">char</span> author[AUTHOR_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> num_pages;</span><br><span class="line">		&#125; book;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是杯子</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">		&#125; mug;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是衬衫</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> colors;</span><br><span class="line">			<span class="keyword">int</span> sizes;</span><br><span class="line">	 	&#125; shirt;</span><br><span class="line">	&#125; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构体实例</span></span><br><span class="line">	<span class="keyword">struct</span> catalog_item bookItem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为结构体中的联合的成员赋值</span></span><br><span class="line">	<span class="built_in">strcpy</span>(bookItem.item.book.title, <span class="string">"three body"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问结构题中的联合的成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, bookItem.item.book.title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-2-使用联合来构造混合的数据结构"><a href="#16-4-2-使用联合来构造混合的数据结构" class="headerlink" title="16.4.2    使用联合来构造混合的数据结构"></a>16.4.2    使用联合来构造混合的数据结构</h3><blockquote>
<p><strong>说明：</strong>创建含有不同数据类型的混合数据结构（比如数组）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 混合数据类型，包含整型和浮点型</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;union&#125; Number</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明混合型数组</span></span><br><span class="line">	Number number_array[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	number_array[<span class="number">0</span>].i = <span class="number">5</span>; <span class="comment">// 第一个值为整型</span></span><br><span class="line">	number_array[<span class="number">1</span>].f = <span class="number">3.14</span>; <span class="comment">// 第二个值为浮点型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number_array[<span class="number">0</span>].i); <span class="comment">// 5</span></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-3-为联合添加“标记字段”"><a href="#16-4-3-为联合添加“标记字段”" class="headerlink" title="16.4.3    为联合添加“标记字段”"></a>16.4.3    为联合添加“标记字段”</h3><blockquote>
<p><strong>用途：</strong>为联合提供额外的当前类型信息，防止获取到无意义的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_KIND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_KIND 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;struct&#125; </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> kind; <span class="comment">// 标记字段</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据数据结构的类型以不同的方式打印值</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;struct&#125; n 要打印的数据结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构实例</span></span><br><span class="line">	Number n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记字段</span></span><br><span class="line">	n.kind = INT_KIND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	n.u.i = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印出来</span></span><br><span class="line">	print_number(n); <span class="comment">// 82</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n.u.i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%g\n"</span>, n.u.f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-5-枚举"><a href="#16-5-枚举" class="headerlink" title="16.5    枚举"></a>16.5    枚举</h2><blockquote>
<p><strong>说明：</strong><code>enum</code>是一种由程序员列出值的类型，而且程序员必须为每种值（枚举常量）命名。<br><strong>特点：</strong></p>
<ul>
<li>遵循到c语言的作用域规则（如果枚举声明在函数体内，那么它的常量对外部函数是不可见的）</li>
<li>声明的方式类似结构和联合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的声明方式：定义枚举类型的同时声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-1-枚举标记和枚举类型"><a href="#16-5-1-枚举标记和枚举类型" class="headerlink" title="16.5.1    枚举标记和枚举类型"></a>16.5.1    枚举标记和枚举类型</h3><blockquote>
<p><strong>说明：</strong>类似结构和联合的标记，有两种方式。</p>
</blockquote>
<h5 id="方式1：enum-标记名-可能值"><a href="#方式1：enum-标记名-可能值" class="headerlink" title="方式1：enum 标记名 {可能值}"></a>方式1：<code>enum 标记名 {可能值}</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> suit s1, s2;</span><br></pre></td></tr></table></figure>
<h5 id="方式2：typedef-enum-可能值-类型名"><a href="#方式2：typedef-enum-可能值-类型名" class="headerlink" title="方式2：typedef enum {可能值} 类型名"></a>方式2：<code>typedef enum {可能值} 类型名</code></h5><blockquote>
<p><strong>技巧：</strong>利用<code>typedef</code>来创建布尔类型是非常好的一种方法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; Suit;</span><br><span class="line">Suit s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-2-枚举作为整数"><a href="#16-5-2-枚举作为整数" class="headerlink" title="16.5.2    枚举作为整数"></a>16.5.2    枚举作为整数</h3><blockquote>
<p><strong>说明：</strong>在系统内部，c语言会把枚举变量和常量作为整数处理。</p>
<ul>
<li>当没有为枚举常量指定值时，它的值时一个大于前一个常量的值（默认第一个枚举常量的值为0）</li>
<li>可以为枚举常量自由选择不同的值</li>
<li>当为枚举常量指定值时，对大小顺序没有要求</li>
<li>两个或多个枚举常量具有相同的值也是合法的</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS = <span class="number">20</span>, DIAMONDS = <span class="number">10</span>, HEARTS, SPADES&#125;; <span class="comment">// 20, 10, 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>把整数用作枚举的值是非常危险的，<code>c++</code>不允许整数用作枚举的值来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s;</span><br><span class="line">i = DIAMONDS;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">s++;</span><br><span class="line">i = s + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-3-用枚举声明“标记字段”"><a href="#16-5-3-用枚举声明“标记字段”" class="headerlink" title="16.5.3    用枚举声明“标记字段”"></a>16.5.3    用枚举声明“标记字段”</h3><blockquote>
<p><strong>说明：</strong><code>enum</code>和<code>union</code>配合实现<code>union</code>的“标记字段”。<br><strong>优点：</strong></p>
<ul>
<li>不需要额外定义宏</li>
<li>明确类型的可能值范围</li>
<li>含义更明确</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedeg <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">enum</span> &#123;INT_KIND, FLOAT_KIND&#125; kind;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/15 编写大规模程序/" itemprop="url">
                  15 编写大规模程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:39:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="15-1-源文件"><a href="#15-1-源文件" class="headerlink" title="15.1    源文件"></a>15.1    源文件</h2><blockquote>
<p><strong>说明：</strong>可以把程序分割成一定数量的源文件(.c文件和.h文件)。</p>
<ul>
<li>原文件的扩展名为.c，每个原文件包含程序的部分内容，主要是函数的定义和变量</li>
<li>一个原文件必须包含名为main的函数，次函数作为程序的起始点</li>
</ul>
<p><strong>优点：</strong>把程序分裂成多个源文件有许多显著的优点。</p>
<ul>
<li>（易读）把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构</li>
<li>（易维护）可以单独对每一个文件进行编译。</li>
<li>（易复用）当把函数集合在单独的源文件中时，会更容易在其他程序中重新使用这些函数。</li>
</ul>
</blockquote>
<h3 id="案例－计算器："><a href="#案例－计算器：" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h3><blockquote>
<p><strong>逆波兰符号（Reverse Polish Notation, RPN）：</strong>指运算符都跟在操作数的后边。例如：<code>30 5 - 7 *</code>。<br><strong>思路：</strong>程序逐个读入操作数和运算符，那么利用栈跟踪中间结果这样的方式计算逆波兰表达式是很容易的。</p>
<ol>
<li>读取“记号”（数或运算符）</li>
<li>如果程序读取数，就将此数压入栈</li>
<li>如果程序读取运算符，那么将从栈顶弹出两个数进行相应的计算。</li>
</ol>
</blockquote>
<h2 id="15-2-头文件"><a href="#15-2-头文件" class="headerlink" title="15.2    头文件"></a>15.2    头文件</h2><blockquote>
<p><strong>说明：</strong>如果打算几个源文件可以访问相同的信息，那么将把此信息放在文件中，扩展名为<code>.h</code>，然后利用<code>#include</code>指令把文件的内容带进每个源文件中。这样的<code>.h</code>文件就是头文件（或包含文件）。</p>
</blockquote>
<h3 id="15-2-1-include指令"><a href="#15-2-1-include指令" class="headerlink" title="15.2.1    #include指令"></a>15.2.1    #include指令</h3><p><strong>语法：</strong>有两种格式，其中的<code>文件名</code>可以包含路径或驱动器号。而且预处理器不会讲<code>&quot;文件名&quot;</code>当作字符串处理了，不然DOS路径中的某些字符有可能被当作转义字符。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>搜索目标</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>#include &lt;文件名&gt;</td>
<td>系统头文件所在的目录</td>
<td>有可能是多个，通常是/usr/include</td>
</tr>
<tr>
<td>#include “文件名”</td>
<td>搜索当前目录，然后搜索系统头文件所在的目录</td>
<td>可以通过诸如-I选项修改搜索目录</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"c:\cprogs\utils.h"</span>/*DOS path*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"/cprogs/utils.h"</span>/*UNIX path*/</span></span><br></pre></td></tr></table></figure>
<p><strong>可移植性技巧：</strong>不要在<code>#include</code>指令中包含路径或驱动器信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys\stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;..\include\utils.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-共享宏定义和类型定义"><a href="#15-2-2-共享宏定义和类型定义" class="headerlink" title="15.2.2    共享宏定义和类型定义"></a>15.2.2    共享宏定义和类型定义</h3><blockquote>
<p><strong>说明：</strong>将通用的宏定义和类型定义放在头文件中有许多明显的好处。</p>
<ul>
<li>不用频繁复制代码</li>
<li>易于修改和维护</li>
<li>避免犹豫原文件包含相同宏或类型的不同定义而导致的矛盾</li>
</ul>
</blockquote>
<p><em>boolean.h</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-共享函数原型"><a href="#15-2-3-共享函数原型" class="headerlink" title="15.2.3    共享函数原型"></a>15.2.3    共享函数原型</h3><blockquote>
<p><strong>说明：</strong>为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。<br><strong>技巧：</strong>为了保证函数原型声明一致，声明部分单独放在一个头文件中。然后在定义和调用的源文件中都引入该头文件。<br><strong>注意：</strong>在调用在其他文件中的函数时，要始终确保编译器在调用之前看到函数的原型。</p>
</blockquote>
<h4 id="案例－计算器：-1"><a href="#案例－计算器：-1" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h4><p><em>1. 头文件：<code>stack.h</code></em></p>
<blockquote>
<p><strong>说明：</strong>包含共享的函数的原型声明。<br><strong>注意：</strong>只在<code>calc.c</code>中使用的的函数不应该定义在该头文件中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>2. 函数定义：<code>stack.c</code></em></p>
<blockquote>
<p><strong>说明：</strong>实现stack.c中声明的所有函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>3. 入口文件：<code>calc.c</code></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//编译器会通过stack.h中make_empty的原型找到对应的定义，从而正确调用</span></span><br><span class="line">	make_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>编译运行</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o calc calc.c stack.c</span><br><span class="line">$ ./calc </span><br><span class="line"> what</span><br></pre></td></tr></table></figure>
<h3 id="15-2-4-共享变量声明"><a href="#15-2-4-共享变量声明" class="headerlink" title="15.2.4    共享变量声明"></a>15.2.4    共享变量声明</h3><blockquote>
<p><strong>说明：</strong>为了共享变量<code>i</code>，首先把变量i的定义（和初始化）放置在一个文件中，而在其他文件中包含变量<code>i</code>的声明（使用关键字<code>extern</code>）。<br><strong>变量声明：</strong><code>extern</code></p>
<ul>
<li>类似函数的声明，仅声明变量名和类型（内存不会为其分配空间）</li>
<li>通常情况下我们不使用<code>extern</code>，这种情况下变量声明和定义同时完成</li>
<li>可以用于所有类型的变量</li>
<li>在数组的声明中使用<code>extern</code>时可以忽略数组的长度<code>extern int a[];</code></li>
<li>编译器无法检查<code>变量声明</code>是否和<code>变量定义</code>严格匹配，因此有可能出现和声明类型不一致的定义，这会导致程序的异常行为</li>
</ul>
<p><strong>技巧：</strong>通常把共享的变量的声明放置在头文件中，需要访问该共享变量的源文件中引入该头文件。同时如果变量的定义在其它源文件（而不是入口文件中），则也需要引入该头文件。<br><strong>扩展：</strong>虽然在文件中共享变量是<code>c</code>语言界的长期惯例，但是它有重大缺陷。<code>19.2</code>节有如何设计不需要共享变量的程序的知识。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern提示编译器变量i是在程序的其它位置定义的（同一文件或不同文件）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-5-嵌套包含"><a href="#15-2-5-嵌套包含" class="headerlink" title="15.2.5    嵌套包含"></a>15.2.5    嵌套包含</h3><blockquote>
<p><strong>说明：</strong>头文件自身可以包含<code>#include</code>指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"boolean.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-6-保护头文件"><a href="#15-2-6-保护头文件" class="headerlink" title="15.2.6    保护头文件"></a>15.2.6    保护头文件</h3><blockquote>
<p><strong>为什么保护：</strong>如果源文件包含同一个文件两次（直接或间接），那么可能（如果包含类型定义）会产生编译错误。</p>
<ul>
<li>避免由重复的类型定义导致的编译错误</li>
<li>节约编译时间</li>
</ul>
<p><strong>如何保护：</strong>为了防止头文件多次包含导致的多次编译，将用<code>#ifndef</code>和<code>#endif</code>两个指令把文件闭合起来。在预编译阶段去重复掉引入的头文件的代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BOOLEAN_H是按照所在头文件名(BOOLEAN.h)进行命名的，目的是避免和其它头文件中的宏冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-7-头文件中的-error指令"><a href="#15-2-7-头文件中的-error指令" class="headerlink" title="15.2.7    头文件中的#error指令"></a>15.2.7    头文件中的#error指令</h3><blockquote>
<p><strong>用途：</strong>放在头文件中用来检查不应该包含头文件的条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有在DOS程序中才能正常使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOS</span></span><br><span class="line">	<span class="comment">//如果非DOS程序试图包含此头文件，那么编译将在#error指令处停止</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">error</span> Grapphics supported only under DOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="15-3-把程序划分成多个文件（程序：文本格式化）"><a href="#15-3-把程序划分成多个文件（程序：文本格式化）" class="headerlink" title="15.3    把程序划分成多个文件（程序：文本格式化）"></a>15.3    把程序划分成多个文件（程序：文本格式化）</h2><blockquote>
<p><strong>功能分析：</strong>能够将输入的文本格式化的命令行工具。</p>
<ul>
<li>“删除空行、制表符”</li>
<li>“填充”：添加单词直到再多一个单词就会导致溢出时才停止</li>
<li>“调整”：除最后一行外，在单词间添加额外的空格以便每行有精确的相同长度（60个字符）</li>
</ul>
</blockquote>
<h2 id="15-4-构建多文件程序"><a href="#15-4-构建多文件程序" class="headerlink" title="15.4    构建多文件程序"></a>15.4    构建多文件程序</h2><blockquote>
<p><strong>原理：</strong>大多数编译器允许一步完成编译和链接的过程。</p>
<ol>
<li><strong>编译：</strong>对每个源文件（不包括头文件）分别进行编译</li>
<li><strong>链接：</strong>把上一步产生的目标文件和库函数的代码结合在一起生成可执行的程序。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-o告诉编译器最终的可执行文件的名字</span></span><br><span class="line">$ gcc -o fmt fmt.c line.c word.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-1-makefile"><a href="#15-4-1-makefile" class="headerlink" title="15.4.1    makefile"></a>15.4.1    makefile</h3><p><strong>命令行编译的缺点：</strong></p>
<ul>
<li>枯燥乏味（敲没有营养的编译命令）</li>
<li>浪费时间，所有源文件每次都会被重新编译</li>
<li>构建大规模程序费时费力易出错</li>
</ul>
<p><strong>说明：</strong>Unix系统发明了makefile的概念，这个文件包含构建程序的必要信息。</p>
<ol>
<li>列出了作为程序部分的文件</li>
<li>描述了文件之间的依赖性</li>
</ol>
<p><strong>基本语法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">目标文件名:依赖的文件</span><br><span class="line">[tab]命令</span><br></pre></td></tr></table></figure>
<p><strong>扩展：</strong>不是每个人都使用makefile，其它程序维护工具正变得流行，包括一些集成开发环境支持的“工程文件”。</p>
<h4 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">fmt:fmt.o word.o line.o</span><br><span class="line">	gcc -o fmt fmt.o word.o line.o</span><br><span class="line">fmt.o:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.o:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.o:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h4 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">fmt.exe:fmt.obj word.obj line.obj</span><br><span class="line">	gcc -o fmt fmt.obj word.obj line.obj</span><br><span class="line">fmt.obj:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.obj:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.obj:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-2-链接期间的错误"><a href="#15-4-2-链接期间的错误" class="headerlink" title="15.4.2    链接期间的错误"></a>15.4.2    链接期间的错误</h3><blockquote>
<p><strong>常见错误：</strong></p>
<ol>
<li>Undefined symbol</li>
<li>Unresollved external reference</li>
</ol>
<p><strong>起因：</strong>程序中丢失了函数定义或变量定义，那么链接器将无法解决外部引用。</p>
<ol>
<li>拼写错误</li>
<li>丢失文件</li>
<li>丢失库</li>
</ol>
</blockquote>
<h3 id="15-4-3-重新构建程序"><a href="#15-4-3-重新构建程序" class="headerlink" title="15.4.3    重新构建程序"></a>15.4.3    重新构建程序</h3><blockquote>
<p><strong>两种情况：</strong>无论哪个文件发生变化，重新编译后都需要重新链接整个程序。</p>
<ol>
<li>变化影响单独一个源文件：只对此文件进行重新编译</li>
<li>变化影响头文件：重新编译所有包含此头文件的源文件</li>
</ol>
<p><strong>使用makefile重新构建：</strong>通过检查每个文件的日期，makex可以确定从程序最后一次构建后哪些文件发生了变化。然后根据依赖关系判断如何重新编译。</p>
</blockquote>
<h3 id="15-4-4-在程序外定义宏"><a href="#15-4-4-在程序外定义宏" class="headerlink" title="15.4.4    在程序外定义宏"></a>15.4.4    在程序外定义宏</h3><blockquote>
<p><strong>意义：</strong>不需要编辑任何程序文件就对宏的值进行改变。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D</td>
<td>在命令行指定宏的值</td>
<td>大多数UNIX编译器和某些非UNIX编译器</td>
</tr>
<tr>
<td>-U</td>
<td>取消指定宏的定义</td>
<td>一些编译器</td>
</tr>
</tbody>
</table>
<p><em>foo.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br></pre></td></tr></table></figure>
<p><em>命令行</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -DDEBUG=1 foo.c</span><br><span class="line"># gcc -UDEBUG foo.c</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/14 预处理器/" itemprop="url">
                  14 预处理器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:28:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>预处理器是一个小软件，它可以在编译前编辑c程序<br><strong>弊端：</strong></p>
<ul>
<li>造成那一发现的错误的根源</li>
<li>经常被错误地用来编写一些几乎不可能读懂的程序</li>
</ul>
<p><strong>技巧：</strong>适度使用预处理功能，减少对于处理器的依赖。<br><strong>扩展：</strong>c++中可以进一步限制预处理器的使用。</p>
</blockquote>
<h2 id="14-1-预处理器的工作方式"><a href="#14-1-预处理器的工作方式" class="headerlink" title="14.1    预处理器的工作方式"></a>14.1    预处理器的工作方式</h2><blockquote>
<p><strong>说明：</strong>预处理器的输入是一个c语言程序，程序中可能会包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8B%E5%8D%884.28.36.png" alt="Alt text"></p>
<blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>不检查错误</li>
<li>不删除包含指令的行，而是简单地将它们替换为空</li>
<li>将每一处注视替换为空格字符（有些与编译器会进一步删除不必要的空白字符，并在每一行开始使用缩进的空格符和制表符）</li>
</ul>
<p><strong>注意：</strong>预处理器仅知道少量的c语言规则，因此，它在执行指令时非常有可能产生非法的程序。</p>
</blockquote>
<h2 id="14-2-预处理指令"><a href="#14-2-预处理指令" class="headerlink" title="14.2    预处理指令"></a>14.2    预处理指令</h2><p><strong>分类：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>包括</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义</td>
<td><code>#define</code> <code>#undef</code></td>
</tr>
<tr>
<td>文件包含</td>
<td><code>#include</code></td>
</tr>
<tr>
<td>条件编译</td>
<td><code>#if</code> <code>ifdef</code> <code>ifindef</code> <code>elif</code> <code>#else</code> <code>#endif</code></td>
</tr>
<tr>
<td>其他</td>
<td><code>#error</code> <code>#line</code> <code>#pragma</code></td>
</tr>
</tbody>
</table>
<p><strong>语法：</strong></p>
<ul>
<li>指令都以<code>#</code>开始：<code>空白符 #指令名 指令所需要的其他信息</code></li>
<li>在指令的符号之间可以插入任意树龄的空格或横向制表符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#		<span class="meta-keyword">define</span>		N 		100<span class="comment">// 这样写也是合法的</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>指令总是在第一个换行符处结束，除非明确地指明要继续（通过在行末尾使用<code>\</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISK_CAPACITY (SIDES *  \</span><br><span class="line">                        TRACK_PER_SIDE * \)</span></span><br><span class="line">				    	  SECTORS_PER_TRACK * \</span><br><span class="line">						  BYTES_PER_SECTOR)</span><br></pre></td></tr></table></figure>
<ul>
<li>指令可以出现在程序种任何地方（<code>#define</code>和<code>#include</code>通常放在文件开始）</li>
<li>注释可以和指令放在同一行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREEZING_PT 32.0	<span class="comment">/* Freezing point of water */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-3-宏定义"><a href="#14-3-宏定义" class="headerlink" title="14.3    宏定义"></a>14.3    宏定义</h2><blockquote>
<p><strong>说明：</strong>除了简单的宏，与编译器也支持带参数的宏。</p>
</blockquote>
<h3 id="14-3-1-简单的宏"><a href="#14-3-1-简单的宏" class="headerlink" title="14.3.1    简单的宏"></a>14.3.1    简单的宏</h3><p><strong>语法：</strong><code>#define 表示符 替换列表</code><br><strong>替换列表：</strong>一系列c语言记号，包括表示符、关键字、数、字符常量、字符串字面量、运算符和标点符号。<br><strong>原理：</strong>当预处理器遇到一个宏定义时，会做一个<code>标识符</code>代表<code>替换列表</code>的记录。再文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。<br><strong>注意（常见错误）：</strong></p>
<ol>
<li>不要在宏定义中放置任何额外的符号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N = 1000<span class="comment">//不能使用=</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会成为int a[= 100]，导致错误</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不能在宏定义的末尾添加分号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;<span class="comment">//这里添加的分号会被作为替换列表的一部分</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会变成int a[100;]</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>简单的宏主要用来定义那些被<code>Kernighan</code>和<code>Ritchie</code>称为明示常量（<code>manifest constant</code>）的东西。优点如下</p>
<ol>
<li>程序更易读</li>
<li>易于修改</li>
<li>帮助避免前后不一致或键盘输入错误</li>
<li>可以对c语法做小的修改</li>
<li>对类型重命名</li>
<li>控制条件编译</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE_LEN 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR <span class="string">'R'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOS <span class="string">'\0'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-带参数的宏"><a href="#14-3-2-带参数的宏" class="headerlink" title="14.3.2    带参数的宏"></a>14.3.2    带参数的宏</h3><blockquote>
<p><strong>语法：</strong><code>#define 标识符(x1, x2, ..., xn) 替换列表</code></p>
<ul>
<li>宏的<code>(</code>和<code>标识符</code>之间必须没有空格（否则会被当作简单宏处理）</li>
</ul>
<p><strong>原理：</strong>当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，宏调用<code>标识符(y1,y2,...,yn)</code>会被<code>替换列表</code>替换，且参数也会依据<code>宏定义</code>对应到替换列表中。<br><strong>用途：</strong></p>
<ul>
<li>经常被用来作为一些简单的函数使用（模拟函数调用）</li>
<li>经常被作为模版，替换经常重复书写的代码段（替换语句）<br><strong>优点：</strong>相比实际的函数</li>
<li>程序可能会稍快些（没有存储上下文、复制参数等的开销）</li>
<li>宏会更“通用”（没有对参数类型的限制）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>编译后的代码通常会变大</li>
<li>宏参数没有类型检查</li>
<li>无法用一个指针指向一个宏</li>
<li>宏可能会不止一次地计算它的参数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果宏使用带有副作用的参数，多次进行宏调用带来的副作用可能导致不易察觉的错误。</li>
</ul>
<p><strong>技巧：</strong>避免使用带有副作用的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y)	((x) &gt; (y) ? (x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EVEN(n) ((n)%2 == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTINT_INT(x) printf(<span class="string">"%d\n"</span>, x)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">i = MAX(j+k, m-n);<span class="comment">//会被修改为i = ((j+k) &gt; (m-n) ? (j+k):(m-n));</span></span><br><span class="line"><span class="keyword">if</span>(IS_EVEN(i)) i++;<span class="comment">//if(((i)%2 == 0)) i++;</span></span><br><span class="line"></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("%d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-运算符"><a href="#14-3-3-运算符" class="headerlink" title="14.3.3    #运算符"></a>14.3.3    <code>#</code>运算符</h3><blockquote>
<p><strong>说明：</strong>将带参数的宏的参数转换为字符串字面量<br><strong>语法：</strong><code>#define 标识符(x1...) 替换列表</code></p>
<ul>
<li><code>#参数</code>仅允许出现在带参数的宏的替换列表中</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(x) printf(#x <span class="string">" = %%d"</span>, x)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//c语言中相邻的字符串字面量会被合并</span></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("i/j = %d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-4-运算符"><a href="#14-3-4-运算符" class="headerlink" title="14.3.4    ##运算符"></a>14.3.4    <code>##</code>运算符</h3><blockquote>
<p><strong>说明：</strong>可以将两个记号（例如标识符）“粘”在一起，成为一个记号。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#define MK_ID(n) i##n</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">//int i1, i2, i3;</span><br><span class="line">int MK_ID(1), MK_ID(2), MK_ID(3);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>求最大值的函数模版（针对不同类型）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERIC_MAX(type)		\</span><br><span class="line">type type##_max(type x, type y)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return x &gt; y ? x : y;		\</span><br><span class="line">&#125;	</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* float float_max(float x, float y)&#123;</span><br><span class="line">*	return x &gt; y ? x : y;</span><br><span class="line">* &#125;</span><br><span class="line">*/</span></span><br><span class="line">GENERIC_MAX(<span class="keyword">float</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-5-宏的通用属性"><a href="#14-3-5-宏的通用属性" class="headerlink" title="14.3.5    宏的通用属性"></a>14.3.5    宏的通用属性</h3><ul>
<li>宏的替换列表可以包含对另一个宏的调用</li>
<li>预处理器智慧替换完整的记号，而不会替换记号的片段</li>
<li>一个宏定义的作用范围通常到出现这个宏的文件末尾</li>
<li>宏不可以被定义两遍，除非新的定义和旧的定义是一样的</li>
<li>宏可以使用<code>#undef</code>指令取消定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N<span class="comment">//取消对N的定义以便给出新的定义</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-6-宏定义中的圆括号"><a href="#14-3-6-宏定义中的圆括号" class="headerlink" title="14.3.6    宏定义中的圆括号"></a>14.3.6    宏定义中的圆括号</h3><blockquote>
<p><strong>说明：</strong>在宏定义中缺少圆括号会导致c语言最让人讨厌的错误（比如优先级问题）。<br><strong>哪里要添加圆括号：</strong></p>
<ol>
<li>如果宏的替换列表中又运算符，那么始终要讲替换列表放在括号中</li>
<li>当宏有参数时，仅给替换列表添加圆括号是不够的，参数的每一次出现都要添加圆括号</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE(x) (x*10)<span class="comment">//需要给x添加括号</span></span></span><br><span class="line">...</span><br><span class="line">j = SCALE(i+<span class="number">1</span>);<span class="comment">//j = ((i+1)*10);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-7-创建较长的宏"><a href="#14-3-7-创建较长的宏" class="headerlink" title="14.3.7    创建较长的宏"></a>14.3.7    创建较长的宏</h3><h4 id="14-3-7-1-逗号运算符"><a href="#14-3-7-1-逗号运算符" class="headerlink" title="14.3.7.1    逗号运算符"></a>14.3.7.1    逗号运算符</h4><blockquote>
<p><strong>说明：</strong>创建较长的宏的一个办法是使用<code>逗号运算符</code>，特别是可以使用逗号运算符来使替换列表包含一系列表达式。<br><strong>限制：</strong><code>逗号运算符</code>只能连接<code>表达式</code>，不能连接<code>语句</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-2-复合语句"><a href="#14-4-7-2-复合语句" class="headerlink" title="14.4.7.2        复合语句"></a>14.4.7.2        复合语句</h4><blockquote>
<p><strong>说明：</strong>除了使用逗号表达式，还可以将<code>语句</code>或<code>表达式</code>放在<code>{}</code>内形成复合语句。<br><strong>缺点：</strong>不能在<code>替换列表</code>为复合语句的宏调用的末尾使用分号结尾，因为在<code>if</code>语句中会调用会导致错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-3-在只循环一次的do-while中包含语句和表达式"><a href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式" class="headerlink" title="14.4.7.3    在只循环一次的do-while中包含语句和表达式"></a>14.4.7.3    在只循环一次的do-while中包含语句和表达式</h4><blockquote>
<p><strong>说明：</strong>加入一个宏需要包含一系列的语句，而不仅仅是一些列的表达式，可以将语句放在<code>do</code>循环中，并将条件设置为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s)		\</span><br><span class="line">	do&#123;				\</span><br><span class="line">		gets(s); 	\</span><br><span class="line">		puts(s);	\</span><br><span class="line">	&#125;while(0)		</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//do&#123;gets(s); puts(s);&#125;while(0)</span></span><br><span class="line">ECHO(str);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-8-预定义宏"><a href="#14-3-8-预定义宏" class="headerlink" title="14.3.8    预定义宏"></a>14.3.8    预定义宏</h3><blockquote>
<p><strong>说明：</strong>在c语言中预定义了一些有用的宏，这些宏主要是提供当前编译的信息。<br><strong>扩展：</strong>c语言提供了一个通用的、用于错误检测的宏—assert宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>LINE</em></td>
<td>被编译的文件的行数</td>
</tr>
<tr>
<td><em>FILE</em></td>
<td>被编译的文件的名字</td>
</tr>
<tr>
<td><em>DATE</em></td>
<td>编译的日期（格式”Mmm dd yyyy”）</td>
</tr>
<tr>
<td><em>TIME</em></td>
<td>编译的时间（格式”hh:mm:ss”）</td>
</tr>
<tr>
<td><em>STDC</em></td>
<td>如果编译器接受标准c，那么值为1</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测被零除的错误</span></span><br><span class="line"><span class="comment">//该宏应该在除法之前被调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ZERO(divisor)	\</span><br><span class="line">	<span class="meta-keyword">if</span>(divisor == 0)&#123;		\</span><br><span class="line">		printf(<span class="string">"**** Attempt to divide by zero on line %d "</span> \</span><br><span class="line">				<span class="string">"of file $s ***\n"</span>, _LINE_, _FILE_);		\\</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">CHECK_ZERO(j);</span><br><span class="line">k = i / j;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="14-4-条件编译"><a href="#14-4-条件编译" class="headerlink" title="14.4    条件编译"></a>14.4    条件编译</h2><blockquote>
<p><strong>说明：</strong>条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段。</p>
</blockquote>
<h3 id="14-4-1-if指令和-endif指令"><a href="#14-4-1-if指令和-endif指令" class="headerlink" title="14.4.1    #if指令和#endif指令"></a>14.4.1    #if指令和#endif指令</h3><blockquote>
<p><strong>语法：</strong>当预处理器遇到<code>if</code>指令时，会计算常量表达式。如果表达式的值为0，那么<code>#if</code>与<code>#endif</code>之间的行将在预处理过程中删除。<br><strong>注意：</strong>对于没有定义过的标识符，<code>#if</code>指令会把它当作是值为0的宏对待。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">&gt;	语句</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of i: %d\n"</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of j: %d\n"</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-defined运算符"><a href="#14-4-2-defined运算符" class="headerlink" title="14.4.2    defined运算符"></a>14.4.2    defined运算符</h3><blockquote>
<p><strong>说明：</strong>如果标识符是一个定义过的宏返回1，否则返回0。<br><strong>用途：</strong>判断宏某个标识符是否被定义的宏，通常和<code>#if</code>指令结合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-3-ifdef指令和-ifndef指令"><a href="#14-4-3-ifdef指令和-ifndef指令" class="headerlink" title="14.4.3    #ifdef指令和#ifndef指令"></a>14.4.3    #ifdef指令和#ifndef指令</h3><blockquote>
<p><strong>说明：</strong>严格说来，这里要介绍的两种指令都不是必须的，因为都可以用其他指令模拟。</p>
</blockquote>
<h4 id="14-4-3-1-ifdef指令"><a href="#14-4-3-1-ifdef指令" class="headerlink" title="14.4.3.1    #ifdef指令"></a>14.4.3.1    #ifdef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>if defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="14-4-3-2-ifndef指令"><a href="#14-4-3-2-ifndef指令" class="headerlink" title="14.4.3.2    #ifndef指令"></a>14.4.3.2    #ifndef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>#if !defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="14-4-4-elif指令和-else指令"><a href="#14-4-4-elif指令和-else指令" class="headerlink" title="14.4.4    #elif指令和#else指令"></a>14.4.4    #elif指令和#else指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 表达式1</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 表达式2</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<h3 id="14-4-5-使用条件编译"><a href="#14-4-5-使用条件编译" class="headerlink" title="14.4.5    使用条件编译"></a>14.4.5    使用条件编译</h3><p><strong>常见应用：</strong></p>
<ul>
<li>编写在多台机器或多种操作系统之间可移植的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WINDOWS)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(DOS)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS2)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写可以使用不同的编译器进行编译的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC__</span></span><br><span class="line">标准c函数原型</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">经典c函数声明</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>为宏提供默认定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUFFER_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时屏蔽包含注释的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">包含注释的代码行</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-5-其他指令"><a href="#14-5-其他指令" class="headerlink" title="14.5    其他指令"></a>14.5    其他指令</h2><h3 id="14-5-1-error指令"><a href="#14-5-1-error指令" class="headerlink" title="14.5.1    #error指令"></a>14.5.1    #error指令</h3><blockquote>
<p><strong>语法：</strong><code>#error 消息</code><br><strong>说明：</strong>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，这个消息一定会包含<code>消息</code>，然后大多数编译器会立即终止编译而不去找出其他错误。<br><strong>用途：</strong>通常与条件编译指令一起用于检测正常编译过程中不应出现的情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if INT_MAX &lt; 1000000</span><br><span class="line">#error int type is too small//Error directive:int type is too small</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="14-5-2-line指令"><a href="#14-5-2-line指令" class="headerlink" title="14.5.2    #line指令"></a>14.5.2    #line指令</h3><blockquote>
<p><strong>说明：</strong>用来改变程序行编号的方式以及使编译器认为所在文件是另一个文件。<br><strong>语法：</strong><code>#line 行号 [文件名]</code></p>
<ul>
<li><code>行号</code>是大小介于1-32767之间的整数</li>
<li><code>行号</code>会影响<code>__LINE__</code>宏的值，<code>文件名</code>影响<code>__FILE__</code>的值</li>
</ul>
<p><strong>用途：</strong>主要用于那些产生c代码作为输入的程序，因为出错信息都指向程序员编写的文件，而不是（更复杂）由一些工具生成的文件。</p>
</blockquote>
<h3 id="14-5-3-pragma指令"><a href="#14-5-3-pragma指令" class="headerlink" title="14.5.3    #pragma指令"></a>14.5.3    #pragma指令</h3><blockquote>
<p><strong>语法：</strong><code>#pragma 记号</code></p>
<ul>
<li>＃pragma指令通常只跟着一个记号，这个记号表示了一条编译器需要服从的命令</li>
<li>一些编译器允许#pragma指令所包含的不仅是简单的命令（特别是有些编译器允许#pragma指令带参数）</li>
<li>如果#pragma指令包含了无法识别的命令，编译器必须忽略这些#pragma指令，不允许产生出错信息</li>
</ul>
<p><strong>注意：</strong>#pragma指令中出现的命令集在不同的编译器上是不一样的，需要查阅相关编译器的文档。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/13 字符串/" itemprop="url">
                  13 字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:11:36+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="13-1-字符串字面量"><a href="#13-1-字符串字面量" class="headerlink" title="13.1    字符串字面量"></a>13.1    字符串字面量</h2><blockquote>
<p><strong>说明：</strong>用一对双括号括起来的字符序列。</p>
<h3 id="13-1-1-字符串字面量中的转义序列"><a href="#13-1-1-字符串字面量中的转义序列" class="headerlink" title="13.1.1    字符串字面量中的转义序列"></a>13.1.1    字符串字面量中的转义序列</h3><p><strong>说明：</strong><code>char</code>型字面量中能够使用的转义字符字符串字面量中都可以使用。<br><strong>注意：</strong>数字转义字符并不常用，但使用时会需要注意一些<code>char</code>中不会遇到的问题</p>
</blockquote>
<table>
<thead>
<tr>
<th>数字转义字符</th>
<th>格式</th>
<th>字符串字面量额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制转义字符</td>
<td><code>\最多含有3位数字的八进制数字</code></td>
<td>在3个数字之后结束，或者在第一个非八进制数字符处结束。</td>
</tr>
<tr>
<td>十六进制转义字符</td>
<td><code>\x十六进制数</code></td>
<td>没有字数限制，直到第一个非十六机制数字符截止（通常还限制十六进制数大小为<code>\x0~\x7f</code>或<code>\x0~\xff</code>）</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串字面量中使用8进制转义字符</span></span><br><span class="line"><span class="string">"\1234"</span><span class="comment">//2个字符（\123和4）</span></span><br><span class="line"><span class="string">"\189"</span><span class="comment">//3个字符（\1，8，9）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字面量中使用16进制转义字符</span></span><br><span class="line"><span class="string">"Z\x81rich"</span><span class="comment">//6个字符（Z, \81, r, i, c, h）</span></span><br><span class="line"><span class="string">"\x81ber"</span><span class="comment">//2个字符（\x81be和r）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-延续字符串字面量"><a href="#13-1-2-延续字符串字面量" class="headerlink" title="13.1.2    延续字符串字面量"></a>13.1.2    延续字符串字面量</h3><h4 id="方式一：用字符-结尾"><a href="#方式一：用字符-结尾" class="headerlink" title="方式一：用字符\结尾"></a>方式一：用字符<code>\</code>结尾</h4><blockquote>
<p><strong>说明：</strong>只要在一行用字符<code>\</code>结尾，那么c语言就允许在下一行延续字符串字面量。<br><strong>注意：</strong>除了（看不见）的末尾的换行符，在同一行不可以有其他字符跟在<code>\</code>后面。<br><strong>扩展：</strong>不只字符串，字符<code>\</code>还可以用来分隔任何长的符号。<br><strong>缺点：</strong>字符字面量必须从下一行的起始位置继续，破坏了程序的缩紧结构。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A,then \</span><br><span class="line">press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="方式二：字面量自动合并（c标准）"><a href="#方式二：字面量自动合并（c标准）" class="headerlink" title="方式二：字面量自动合并（c标准）"></a>方式二：字面量自动合并（c标准）</h4><blockquote>
<p><strong>说明：</strong>当两条或更多条字符串字面量相连时（仅用空白字符分割），编译器必须把他们合并成单独一条字符串。<br><strong>优点：</strong>不必破坏缩紧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Put a disk in drive A, then"</span></span><br><span class="line">	   <span class="string">"press any key to continue\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-如何存储字符串字面量"><a href="#13-1-3-如何存储字符串字面量" class="headerlink" title="13.1.3    如何存储字符串字面量"></a>13.1.3    如何存储字符串字面量</h3><blockquote>
<p><strong>存储形式：</strong>c语言把字符串字面量作为字符数组来处理，相当于<code>char *</code>。<br><strong>空字符（<code>\0</code>）：</strong><code>ASCII</code>字符集中的第一个字符。<br><strong>内存分配：</strong>当c语言编译器在程序中遇到长度为<code>n</code>的字符串字面量时，它会为字符串字面量分配长度为<code>n+1</code>的内存空间，用来存储字符串子民啊量中的字符，以及额外的一个字符——<code>空字符</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc"</span>);<span class="comment">//当调用printf时，会传递"abc"的地址（即指向字母`a`存储单元的指针）</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-4-字符串字面量的操作"><a href="#13-1-4-字符串字面量的操作" class="headerlink" title="13.1.4    字符串字面量的操作"></a>13.1.4    字符串字面量的操作</h3><blockquote>
<p><strong>说明：</strong>可以将字符串字面量赋值给<code>char *</code>指针。<br><strong>特点：</strong></p>
<ul>
<li><p>c语言允许指针添加下标，因此可以给字符串字面量添加下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = <span class="string">"abc"</span>[<span class="number">1</span>];<span class="comment">//b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>允许改变字符串字面量的字符（不推荐）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//一些编译器可能会出现异常</span></span><br><span class="line">&gt;<span class="keyword">char</span> *p = <span class="string">"abc"</span>;</span><br><span class="line">&gt;*p = <span class="string">'b'</span>;<span class="comment">//字符串字面量被修改为"bbc"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = <span class="string">"abc"</span>;<span class="comment">//这个赋值操作不是复制"abc"中的字符，而仅仅是使用p指向字符串的第一个字符。</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-5-字符串字面量与字符常量"><a href="#13-1-5-字符串字面量与字符常量" class="headerlink" title="13.1.5    字符串字面量与字符常量"></a>13.1.5    字符串字面量与字符常量</h3><blockquote>
<p><strong>说明：</strong>只包含一个字符的字符串字面量不同于字符常量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>例子</th>
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;a&quot;</code></td>
<td>字符串字面量</td>
<td>用指针来表示</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>字符常量</td>
<td>用整数（字符的ASCII码）来表示</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//合法，相当于传递`char *`指针作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">'\n'</span>);<span class="comment">//会报错，传递的不是指针而是整数</span></span><br></pre></td></tr></table></figure>
<h2 id="13-2-字符串变量"><a href="#13-2-字符串变量" class="headerlink" title="13.2    字符串变量"></a>13.2    字符串变量</h2><blockquote>
<p><strong>存储方式：</strong><code>char str[STR_LEN+1]</code></p>
<ul>
<li>载体为一维的字符数组</li>
<li>以空字符串结尾（数组的长度比字符串的长度多一个字符）</li>
</ul>
<p><strong>注意：</strong>如果没有给空字符预留位置，可能导致程序运行时出现不可预知的结果，因为c函数库中的函数假设字符串都以空字符串结束。<br><strong>技巧：</strong>字符串的长度取决于空字符的位置，而不是取决于存放字符串的字符数组的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="keyword">char</span> str[STR_LEN+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="13-2-1-初始化字符串变量"><a href="#13-2-1-初始化字符串变量" class="headerlink" title="13.2.1    初始化字符串变量"></a>13.2.1    初始化字符串变量</h3><blockquote>
<p><strong>两种字面量：</strong><code>字符串字面量</code>和<code>数组字初始化式</code></p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p><strong>底层：</strong>c编译器会把它看成是数组初始化式的缩写形式。<br><strong>规则：</strong></p>
<ul>
<li>如果初始化式太短以至于不能填满字符串变量时，c编译器会讲多出的部分都赋值为<code>\0</code></li>
<li>如果没有空间给空字符串，将使数组无法作为字符串使用</li>
</ul>
<p><strong>注意：</strong>一定要确保数组的长度要长于初始化式的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器将把字符床"June 14"中的字符复制到数组date1中，然后追加一个空字符串从而使date1可以作为字符串使用</span></span><br><span class="line"><span class="keyword">char</span> date[<span class="number">8</span>] = <span class="string">"June 14"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>J</th>
<th>u</th>
<th>n</th>
<th>e</th>
<th></th>
<th>1</th>
<th>4</th>
<th>\0</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p><strong>规则：</strong>如果初始化式比本身短，会把余下的字符数组元素初始化为<code>\0</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组长度可以省略由编译器自己计算，手工计算很容易出错</span></span><br><span class="line"><span class="keyword">char</span> date1[<span class="number">8</span>] = &#123;<span class="string">'J'</span>, <span class="string">'u'</span>, <span class="string">'n'</span>, <span class="string">'e'</span>, <span class="string">' '</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-2-字符数组和字符指针"><a href="#13-2-2-字符数组和字符指针" class="headerlink" title="13.2.2    字符数组和字符指针"></a>13.2.2    字符数组和字符指针</h3><blockquote>
<p><strong>说明：</strong>数组变量有两种</p>
</blockquote>
<table>
<thead>
<tr>
<th>＊</th>
<th>字符数组</th>
<th>字符指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>声明</strong></td>
<td><code>char varStr[]</code></td>
<td><code>char *varStr</code></td>
</tr>
<tr>
<td><strong>元素是否可修改</strong></td>
<td>是</td>
<td>否（因为指针指向的是不可修改的字符串）</td>
</tr>
<tr>
<td><strong>变量本身是否可改变指向</strong></td>
<td>否（数组名和数组绑定在一起且无法改变指向）</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>声明字符指针必需指向字符数组后才能使用，无论是字面量（两种形式的字面量）还是已经声明好的字符数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[STR_LEN+<span class="number">1</span>];</span><br><span class="line">p = srt;<span class="comment">//p指向了str的第一个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="13-3-字符串的读／写"><a href="#13-3-字符串的读／写" class="headerlink" title="13.3    字符串的读／写"></a>13.3    字符串的读／写</h2><h3 id="13-3-1-用printf函数和puts函数写字符串"><a href="#13-3-1-用printf函数和puts函数写字符串" class="headerlink" title="13.3.1    用printf函数和puts函数写字符串"></a>13.3.1    用printf函数和puts函数写字符串</h3><h4 id="13-3-1-1-printf函数"><a href="#13-3-1-1-printf函数" class="headerlink" title="13.3.1.1    printf函数"></a>13.3.1.1    <code>printf</code>函数</h4><blockquote>
<p><strong>说明：</strong>转换说明为<code>%[m][.p]s</code>，下面分3中情景讨论。</p>
</blockquote>
<hr>
<p><em>情景1:<code>%s</code>（不限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>情景</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>末尾提供了<code>空字符</code></td>
<td>逐个写字符<code>直到遇到空字符</code></td>
</tr>
<tr>
<td>末尾没有<code>空字符</code></td>
<td>会越过字符串的末尾继续写，直到最终在<code>内存的某个地方找到空字符</code>为止</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景2:<code>%ms</code>（限制宽度，不截断）</em></p>
<table>
<thead>
<tr>
<th>m大小</th>
<th>表现</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>>字符串长度</td>
<td>多出部分显示空格，字符串右对齐</td>
<td>在<code>m</code>前使用<code>-</code>强制左对齐</td>
</tr>
<tr>
<td>&lt;字符串长度</td>
<td>忽略设置的m，显示整个字符串</td>
<td>不会截断</td>
</tr>
</tbody>
</table>
<hr>
<p><em>情景3:<code>%m.ps</code>（限制宽度，截断）</em><br>会使字符串的前p个字符在大小为m的区域内显示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Are we having fun yet?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value of str:%s\n"</span>, str);<span class="comment">//Are we having fun yet?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(str);<span class="comment">////Are we having fun yet?(\n)</span></span><br></pre></td></tr></table></figure>
<h4 id="13-3-1-2-put函数"><a href="#13-3-1-2-put函数" class="headerlink" title="13.3.1.2    put函数"></a>13.3.1.2    put函数</h4><blockquote>
<p><strong>参数：</strong>需要显示的字符串<br><strong>说明：</strong></p>
<ul>
<li>不使用转换说明和格式串</li>
<li>在写完字符串后，puts函数总会添加一个额外的换行符</li>
</ul>
</blockquote>
<h3 id="13-3-2-用scanf函数和gets函数读字符串"><a href="#13-3-2-用scanf函数和gets函数读字符串" class="headerlink" title="13.3.2    用scanf函数和gets函数读字符串"></a>13.3.2    用scanf函数和gets函数读字符串</h3><h4 id="13-3-2-1-scanf函数"><a href="#13-3-2-1-scanf函数" class="headerlink" title="13.3.2.1    scanf函数"></a>13.3.2.1    scanf函数</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>不需要在str前添加运算符<code>&amp;</code>，因为str是数组名，编译器会自动把它当作指针来处理</li>
<li>空白符（换行符、空格符、制表符）会使scanf函数停止读入，因此用scanf输入的字符串永远不会包含空白符</li>
<li>scanf函数始终会在字符串末尾存储一个<code>空字符</code>（否则无法当作正常字符串使用）</li>
</ul>
<p><strong>注意：</strong>scanf不会检测何时填满数组，可能会越过数组边界，导致异常。<br><strong>技巧：</strong>使用<code>%ns</code>代替<code>%s</code>可以使scanf函数更安全（<code>n</code> 指可以存储的最大字符的数量）</p>
<p><strong>限制：</strong>通常不用于读入一整行输入。</p>
</blockquote>
<h4 id="13-3-2-2-gets函数"><a href="#13-3-2-2-gets函数" class="headerlink" title="13.3.2.2    gets函数"></a>13.3.2.2    gets函数</h4><blockquote>
<p><strong>说明：</strong>类似scanf函数，把读入的字符放在数组中，然后存储一个<code>空字符</code>。</p>
<ul>
<li>不会在开始读字符串之前跳过空白字符（scanf函数会跳过）</li>
<li>会持续读入直到找到换行符（不是任意空白符）</li>
</ul>
<p><strong>扩展：</strong>gets函数天生就是不安全的，fgets函数是更加安全的选择。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> sentence[STR_LEN+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a sentence:\n"</span>);<span class="comment">//To , or not to c</span></span><br><span class="line">gets(sentence);<span class="comment">//sentence的值为"To , or not to c"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-3-3-逐个字符读字符串"><a href="#13-3-3-逐个字符读字符串" class="headerlink" title="13.3.3    逐个字符读字符串"></a>13.3.3    逐个字符读字符串</h3><p><strong>说明：</strong>利用<code>getchar</code>自定义更加灵活的输入函数<br><strong>编程思路：</strong></p>
<ol>
<li>在开始存储字符串之前，函数应该跳过空白字符吗？</li>
<li>什么字符会导致函数停止读取：换行符、任意空白字符、还是其他一些字符？需要存储这类字符还是忽略掉？</li>
<li>如果输入的字符串太长以致无法存储，那么程序应该做些什么：胡咧额外的字符，还是把它们留给下一次的操作输入？</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 不会跳过空白符，在第一个换行符处（不把换行符存储到字符串中）停止读取，</span><br><span class="line">* 并且忽略额外的字符。</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-访问字符串中的字符"><a href="#13-4-访问字符串中的字符" class="headerlink" title="13.4    访问字符串中的字符"></a>13.4    访问字符串中的字符</h2><p><strong>说明：</strong>访问字符串中的字符存在两种方式</p>
<ol>
<li>数组下标</li>
<li>指针</li>
</ol>
<h3 id="13-4-1-用数组下标"><a href="#13-4-1-用数组下标" class="headerlink" title="13.4.1    用数组下标"></a>13.4.1    用数组下标</h3><p><strong>说明：</strong>既然字符串是以数组的方式存储的，那么可以使用下标来访问字符串中的字符。<br><strong><code>const</code>：</strong>形式参数使用<code>const</code>修饰可以防止数组被修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用数组下标遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-2-用指针"><a href="#13-4-2-用指针" class="headerlink" title="13.4.2    用指针"></a>13.4.2    用指针</h3><blockquote>
<p><strong>说明：</strong>使用指针代替数组下标访问字符串中的字符会更加便捷。<br><code>const</code>：用<code>const</code>修饰字符串指针可以避免传进来的实参的指向被改变，即便如此，因为传进来的指针的副本，所以可以可以自增。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 使用指针遍历数组计算数组中空格的数量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_spaces</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; s != <span class="string">'\0'</span>; s++)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">' '</span>)&#123;</span><br><span class="line">			coun++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-使用c语言的字符串库"><a href="#13-5-使用c语言的字符串库" class="headerlink" title="13.5    使用c语言的字符串库"></a>13.5    使用c语言的字符串库</h2><blockquote>
<p><strong>说明：</strong>c语言的函数库为字符串的操作提供了丰富的函数集，包含在<code>string.h</code>中。<br><strong>参数：</strong></p>
<ul>
<li>每个函数至少需要一个字符串作为实际参数</li>
<li>字符串形式参数类型可以是<code>char *</code></li>
<li>合法的实际参数类型：字符数组、<code>char *</code>类型变量、字符串字面量</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>形式参数没有声明为const的函数会在调用函数时修改形式参数，因此对应的实际参数不能为字符串字面量（字符串字面量的特点在于不可修改）。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-1-strcpy函数"><a href="#13-5-1-strcpy函数" class="headerlink" title="13.5.1    strcpy函数"></a>13.5.1    strcpy函数</h3><p><strong>背景：</strong>不能使用赋值运算符将字符串字面量赋值给字符数组（但字符串指针可以）。因为数组名在c语言中是不能作为左值使用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<p><strong>原型：</strong><code>char *strcpy(char *s1, const char *s2)</code><br><strong>用途：</strong>将<code>s2</code>指向的字符串复制到<code>s1</code>指向的数组中。<br><strong>返回值：</strong>被赋值的字符串的首地址，可以被用来实现多重赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcpy</span>(s2, <span class="string">"abc"</span>));<span class="comment">//将abc复制给s1和s2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>函数会将<code>s2</code>指向的字符串逐个复制过去直到遇到一个空字符为止，因此假设<code>s2</code>长度为<code>n</code>，如果<code>s1</code>长度小于<code>n</code>包含（<code>\0</code>），<code>s1</code>后面的内存也会被覆盖</li>
<li>因为不会修改<code>s2</code>指向的字符串，因此s2被声明为<code>const</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符数组形式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> strArr[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//指针方式声明的字符串</span></span><br><span class="line"><span class="keyword">char</span> *strPointer = <span class="string">"def"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strArr = "aaa";//这种方式会报错</span></span><br><span class="line">strPointer = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strPointer);</span><br></pre></td></tr></table></figure>
<h3 id="13-5-2-strcat函数"><a href="#13-5-2-strcat函数" class="headerlink" title="13.5.2    strcat函数"></a>13.5.2    strcat函数</h3><p><strong>原型：</strong><code>char *strcats(char *s1, const char *s2)</code><br><strong>说明：</strong>将<code>s2</code>指向的字符串追加到<code>s1</code>指向的字符串的后面<br><strong>返回值：</strong><code>s1</code>指向的字符串（指针）<br><strong>注意：</strong>如果<code>s1</code>指向的数组的大小不足以容纳所有的字符，将会多余的字符复制到数组后面的内存，到处错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, <span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2, <span class="string">"def"</span>);<span class="comment">//"abcdefhgi"</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, <span class="built_in">strcat</span>(s2, <span class="string">"ghi"</span>));<span class="comment">//"defhgi"</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-3-strcmp函数"><a href="#13-5-3-strcmp函数" class="headerlink" title="13.5.3    strcmp函数"></a>13.5.3    strcmp函数</h3><p><strong>原型：</strong><code>int strcmp(const char *s1, const chat *s2)</code><br><strong>说明：</strong>比较两个字符串的大小</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于0</td>
<td>s1 &lt; s2</td>
</tr>
<tr>
<td>0</td>
<td>s1 == s2</td>
</tr>
<tr>
<td>大于0</td>
<td>s1 &gt; s2</td>
</tr>
</tbody>
</table>
<p><strong>底层：</strong>依据对应ASCII字符集的大小</p>
<ul>
<li>字典顺序</li>
<li>前<code>i</code>个字符相同，第<code>i+1</code>个字符大的大（若其中一个没有第<code>i+1</code>个字符，则字符数多的大）</li>
<li>所有大写字母（65～90）都小于所有小写字符（97～122 ）</li>
<li>数字（48～57）小于字母</li>
<li>空格符（32）小于所有打印字符</li>
</ul>
<h3 id="13-5-4-strlen函数"><a href="#13-5-4-strlen函数" class="headerlink" title="13.5.4    strlen函数"></a>13.5.4    strlen函数</h3><p><strong>原型：</strong><code>size_t strlen(const char *s)</code><br><strong>说明：</strong>求字符串的长度，即字符串中第一个空字符串前的字符的个数（不包括空字符）。</p>
<blockquote>
<p><strong>size_ t</strong>：无符号整数类型（unsigned int 或 unsigned long int ），在c函数库定义的。</p>
</blockquote>
<p><strong>注意：</strong>当用数组作为函数的实际参数时，strlen函数不会测量数组本身的长度，而是返回存储在数组中的字符串的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">fen = <span class="built_in">strlen</span>(<span class="string">"abc"</span>);<span class="comment">//3</span></span><br><span class="line">len = <span class="built_in">strlen</span>(<span class="string">" "</span>);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, <span class="string">"abc"</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(str1);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="13-5-5-程序：显示一个月的提示列表"><a href="#13-5-5-程序：显示一个月的提示列表" class="headerlink" title="13.5.5    程序：显示一个月的提示列表"></a>13.5.5    程序：显示一个月的提示列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./remind</span><br><span class="line"> Enter day and reminder:1 dd</span><br><span class="line"> Enter day and reminder:2 ff</span><br><span class="line"> Enter day and reminder:3 ff</span><br><span class="line"> Enter day and reminder:0</span><br><span class="line"></span><br><span class="line"> Day Reminder</span><br><span class="line">  1 dd</span><br><span class="line">  2 ff</span><br><span class="line">  3 ff</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合(记录备忘列表)，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> reminders[MAX_REMIND][MSG_LEN + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(reminders[j], reminders[j<span class="number">-1</span>]);</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-6-字符串惯用法"><a href="#13-6-字符串惯用法" class="headerlink" title="13.6    字符串惯用法"></a>13.6    字符串惯用法</h2><h3 id="13-6-1-搜索字符串的结尾"><a href="#13-6-1-搜索字符串的结尾" class="headerlink" title="13.6.1    搜索字符串的结尾"></a>13.6.1    搜索字符串的结尾</h3><p><strong>相关惯用法：</strong></p>
<ol>
<li><code>while(*s){s++;}</code></li>
<li><code>while(*s++){...}
 ;</code></li>
</ol>
<h4 id="13-6-1-1-原始版本"><a href="#13-6-1-1-原始版本" class="headerlink" title="13.6.1.1    原始版本"></a>13.6.1.1    原始版本</h4><blockquote>
<p><strong>思路：</strong>从左到右扫描字符串，n自增。当s最终指向一个空字符串时，n的长度就是字符串的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">for</span>(n = <span class="number">0</span>; *s != <span class="string">'\0'</span>; s++)&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-1-2-优化版本"><a href="#13-6-1-2-优化版本" class="headerlink" title="13.6.1.2    优化版本"></a>13.6.1.2    优化版本</h4><blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>空字符的ASCII码值为0，而0在c语言中可以代表“假”</li>
<li>字符串是被当作字符数组来处理的，而数组不同元素的存储地址之差和下标之差相同，因此可以通过地址之差计算数组长度，避免了频繁的自增操作，从而提高速度</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> chat *s)&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">	<span class="keyword">while</span>(*s)&#123;</span><br><span class="line">		*s++;</span><br><span class="line">	&#125;</span><br><span class="line">	return s - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-6-2-复制字符串"><a href="#13-6-2-复制字符串" class="headerlink" title="13.6.2    复制字符串"></a>13.6.2    复制字符串</h3><blockquote>
<p><strong>惯用法：</strong>字符串复制惯用法<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span>(*p++ = *s2++)</span><br><span class="line">&gt; ;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="13-6-2-1-原版"><a href="#13-6-2-1-原版" class="headerlink" title="13.6.2.1    原版"></a>13.6.2.1    原版</h4><blockquote>
<p><strong>说明：</strong>自定义实现<code>strcat</code>函数<br><strong>思路：</strong></p>
<ol>
<li>查找字符串s1末尾空字符串的位置，并使指针p指向它</li>
<li>把字符串s2中的字符逐个复制到p所指向的位置</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> chat *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*s2 != <span class="string">'\0'</span>)&#123;</span><br><span class="line">		*p = *s2;</span><br><span class="line">		p++;</span><br><span class="line">		s2++;</span><br><span class="line">	&#125;</span><br><span class="line">	*p = <span class="string">'\0'</span>;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-6-2-2-优化版"><a href="#13-6-2-2-优化版" class="headerlink" title="13.6.2.2    优化版"></a>13.6.2.2    优化版</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = s1;</span><br><span class="line">	<span class="comment">//1. 查找字符串s1末尾空字符串的位置，并使指针p指向它</span></span><br><span class="line">	<span class="keyword">while</span>(*p)&#123;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 把字符串s2中的字符逐个复制到p所指向的位置</span></span><br><span class="line">	<span class="keyword">while</span>(*p++ = s2++)</span><br><span class="line">		;</span><br><span class="line">	return s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-7-字符串数组"><a href="#13-7-字符串数组" class="headerlink" title="13.7    字符串数组"></a>13.7    字符串数组</h2><blockquote>
<p><strong>两种方式：</strong><code>二维字符数组</code>和<code>一维指针数组</code><br><strong>技巧：</strong>得益于指针和数组之间的紧密联系，访问一维指针数组中的元素的方式和访问而为字符数组中元素的方式相同。</p>
</blockquote>
<h4 id="二维字符数组"><a href="#二维字符数组" class="headerlink" title="二维字符数组"></a>二维字符数组</h4><blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>需要知道所有字符串的长度，以最长的字符串的长度来确定二位数组每一行的长度。</li>
<li>不能填满数组的一整行的字符会用空字符填补，浪费空间。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> planets[][<span class="number">8</span>] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Earth"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>, <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Neptune"</span>, <span class="string">"Pluto"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.16.44.png" alt="Alt text"></p>
<h4 id="一维字符指针数组"><a href="#一维字符指针数组" class="headerlink" title="一维字符指针数组"></a>一维字符指针数组</h4><blockquote>
<p><strong>说明：</strong>大部分字符串集都是长短字符串的混合，c语言本身不提供“参次不齐的数组”，但可以通过字符数组指针的数组模拟。<br><strong>参次不齐的数组(ragged array)：</strong>数组的每一行有不同的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">m</span><br><span class="line"></span><br><span class="line"><span class="title">for</span><span class="params">(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(planets[i][<span class="number">0</span>] == <span class="string">'M'</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s begins with M\n"</span>, planets[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.23.02.png" alt="Alt text"></p>
<h3 id="13-7-1-命令行参数"><a href="#13-7-1-命令行参数" class="headerlink" title="13.7.1    命令行参数"></a>13.7.1    命令行参数</h3><p><strong>程序参数（command-line atgument）：</strong>不仅是操作系统命令，所有程序都有命令行信息。<code>Q&amp;A</code>为了能够访问这些命令行参数，必须为<code>main</code>函数定义为含有两个参数的函数，这两个参数通常命名为<code>argc</code>和<code>argv</code>。<br><strong>空指针：</strong>是一种不指向任何内容的特殊指针。宏<code>NULL</code>代表空指针。<br><strong>参数向量（argv）和参数计数（argc）：</strong></p>
<ul>
<li>argv[0]：指向程序名的字符串</li>
<li>argv[1]~argv[argc-1]：余下的命令行参数</li>
<li>argv[argc]：指向空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*argc：参数计数，命令行参数的数量（包括程序名本身）</span><br><span class="line">*argv: 参数向量，指向命令行参数的指针数组（以字符串的行书存储）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8A%E5%8D%888.56.34.png" alt="Alt text"></p>
<p><em>命令行输入参数案例</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l remind.c</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用数组）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;argc; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>获取参数代码（利用指针）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> **p;<span class="comment">//p用来指向argv中的字符串，因为argv本身作为数组就是指针，而其中的字符串（字符数组）也是指针，所以声明p为指针的指针</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;argv[<span class="number">1</span>]; *p != <span class="literal">NULL</span>; p++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-7-2-程序：核对行星的名字"><a href="#13-7-2-程序：核对行星的名字" class="headerlink" title="13.7.2    程序：核对行星的名字"></a>13.7.2    程序：核对行星的名字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_PLANETS 9<span class="comment">//行星的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//9大行星</span></span><br><span class="line">	<span class="keyword">char</span> *planets[] = &#123;<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Eath"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>,  <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Nepture"</span>, <span class="string">"Pluto"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以此访问每个参数，并遍历9大行星寻找匹配的目标</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NUM_PLANETS; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[i], planets[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is planets %d\n"</span>, argv[i], j+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j == NUM_PLANETS)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s is not a planet\n"</span>, argv[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./planet Pluto  </span><br><span class="line"> Pluto is planets 9</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/12 指针和数组/" itemprop="url">
                  12 指针和数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:24:07+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="12-1-指针的算术运算"><a href="#12-1-指针的算术运算" class="headerlink" title="12.1    指针的算术运算"></a>12.1    指针的算术运算</h2><blockquote>
<p><strong>说明：</strong>指针不仅可以指向普通变量，还可以指向数组元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">//a[0]值变为5</span></span><br></pre></td></tr></table></figure>
<p><strong>3种格式：</strong></p>
<ol>
<li>指针加上整数</li>
<li>指针减去整数</li>
<li>两个指针相减</li>
</ol>
<h3 id="12-1-1-指针加上整数"><a href="#12-1-1-指针加上整数" class="headerlink" title="12.1.1    指针加上整数"></a>12.1.1    指针加上整数</h3><blockquote>
<p><strong>说明：</strong>指针<code>p</code>加上整数<code>j</code>产生指向<code>p</code>元素后<code>j</code>个位置的指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line">q = p + <span class="number">3</span>;<span class="comment">//p指向了数组下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-2-指针减去整数"><a href="#12-1-2-指针减去整数" class="headerlink" title="12.1.2    指针减去整数"></a>12.1.2    指针减去整数</h3><blockquote>
<p><strong>说明：</strong>如果<code>p</code>指向数组元素<code>a[i]</code>，那么<code>p-j</code>指向<code>a[i-j]</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a[<span class="number">8</span>];</span><br><span class="line">q = p<span class="number">-3</span>;<span class="comment">//指向数组a下标为5的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-指针相减"><a href="#12-1-3-指针相减" class="headerlink" title="12.1.3    指针相减"></a>12.1.3    指针相减</h3><blockquote>
<p><strong>说明：</strong>当两个指针相减时，结果为指针之间的距离。<br><strong>用途：</strong>用来计算数组种元素的个数。如果<code>p</code>指向<code>a[i]</code>且<code>q</code>指向<code>a[j]</code>，那么<code>p-q</code>就等于<code>i-j</code>。<br><strong>限制：</strong></p>
<ul>
<li>只有在<code>p</code>指向数组元素时，指针<code>p</code>上的算数运算才会获得意义的结果</li>
<li>只有在两个指针指向同一个数组时，指针相减才有意义</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">i = p - q;<span class="comment">//4</span></span><br><span class="line">i = q - p;<span class="comment">//-4</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-指针比较"><a href="#12-1-4-指针比较" class="headerlink" title="12.1.4    指针比较"></a>12.1.4    指针比较</h3><blockquote>
<p><strong>说明：</strong>可以用关系运算符（<code>&lt;</code> <code>&lt;=</code>  <code>&lt;</code>  <code>&gt;=</code>）和判等运算符（<code>==</code>和<code>!=</code>）。<br><strong>限制：</strong>只有在两个指针指向同一个数组时，用关系运算符进行的指针比较才有意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p &lt;= q;<span class="comment">//0</span></span><br><span class="line">q &gt; p;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h2 id="12-2-指针用于数组处理"><a href="#12-2-指针用于数组处理" class="headerlink" title="12.2    指针用于数组处理"></a>12.2    指针用于数组处理</h2><blockquote>
<p><strong>说明：</strong>指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。<br><strong>注意：</strong>数组<code>a</code>的下标是<code>0到N-1</code>,但<code>&amp;a[N]</code>是合法的，只要不尝试对该地址存储空间进行读取活写入，就是安全的。<br><strong>性能：</strong>一些编译器依赖下标而不是指针产生的循环代码性会更好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N], sum, *p;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符和-运算符的组合"><a href="#运算符和-运算符的组合" class="headerlink" title="*运算符和++运算符的组合"></a><code>*</code>运算符和<code>++</code>运算符的组合</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*p++</code>或<code>*(p++)</code></td>
<td>表达式的值是<code>*p</code>，然后<code>p</code>自增1</td>
</tr>
<tr>
<td><code>(*p)++</code></td>
<td>表达式的值为<code>*p</code>，然后<code>*p</code>自增1</td>
</tr>
<tr>
<td><code>*++p</code></td>
<td>先自增<code>p</code>，在自增后的指针对应的值</td>
</tr>
<tr>
<td><code>++*p</code>或<code>++(*p)</code></td>
<td>表达式的值是<code>*p</code>自增后的值</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(p &lt; &amp;a[N])&#123;</span><br><span class="line">	sum += *p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程序-栈"><a href="#程序-栈" class="headerlink" title="程序:栈"></a>程序:栈</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> *top = contents[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = &amp;contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return *top == contents[STACK_SIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		*top++ = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return *--top;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-用数组名作为指针"><a href="#12-3-用数组名作为指针" class="headerlink" title="12.3    用数组名作为指针"></a>12.3    用数组名作为指针</h2><blockquote>
<p><strong>说明：</strong>可以用数组的名字作为指向数组第一个元素的指针。<br><strong>意义：</strong>简化了指针的算术运算，而且使得数组和指针都更加通用。<br><strong>局限：</strong>虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其它地方是错误的。所以当需要的时候，可以先将数组指针复制给其它变量，然后改变该指针变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">*a = <span class="number">7</span>;<span class="comment">//a[0]=7</span></span><br><span class="line">*(a+<span class="number">1</span>); = <span class="number">12</span>;<span class="comment">//a[1]=12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数组元素的和</span></span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line">	sum += *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-1-程序：数列反向（改进版）"><a href="#12-3-1-程序：数列反向（改进版）" class="headerlink" title="12.3.1    程序：数列反向（改进版）"></a>12.3.1    程序：数列反向（改进版）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reverses a series of numbers (pointer version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//输入N个数组存储到数组中</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers\n"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a; p &lt; a + N; p++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//逆向打印所有数组元素</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In reverse order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(p = a + N <span class="number">-1</span>; p &gt;= a; p--)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">" %d"</span>, *p);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./reverse2                             </span><br><span class="line"> Enter 10 numbers</span><br><span class="line"> 1 2 3 4 5 6 7 8 9 0</span><br><span class="line"> In reverse order: 0 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<h3 id="12-3-2-数组型实际参数（改进版）"><a href="#12-3-2-数组型实际参数（改进版）" class="headerlink" title="12.3.2    数组型实际参数（改进版）"></a>12.3.2    数组型实际参数（改进版）</h3><blockquote>
<p><strong>说明：</strong>数组作为实参传递给函数是是作为指针传递的（传引用），而不会复制数组。</p>
</blockquote>
<ul>
<li><p>因为没有对数组进行复制，所以数组作为实际参数不会防止原数组被修改<br><strong>防改变：</strong>为了指明数组形式参数不会改变，可以在它的声明中包含单词<code>const</code></p>
</li>
<li><p>给函数传递数组所需的时间不依赖于数组的大小</p>
</li>
<li>声明形参时，数组型式和指针形式等价，编译器处理这两类声明就好像它们是完全一样的<br><strong>局限：</strong>不适用于普通变量的声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];<span class="comment">//会导致编译器为10个证书预留空间</span></span><br><span class="line"><span class="keyword">int</span> *a;<span class="comment">//会导致编译器为指针变量分配空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以给形式参数为数组的函数传递数组的“片段”</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, max;</span><br><span class="line">	max = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; max)&#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">4</span>, b = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> larget = find_largest(b, N);<span class="comment">//会把数组b的第一个元素的地址赋给a，数组本身并没有复制</span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-3-用指针作为数组名"><a href="#12-3-3-用指针作为数组名" class="headerlink" title="12.3.3    用指针作为数组名"></a>12.3.3    用指针作为数组名</h3><blockquote>
<p><strong>说明：</strong>指向数组的指针除了可以通过指针的方式操作数组外，还可以将该指针当作数组来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> a[N], i, sum = <span class="number">0</span>, *p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	sum += p[i];<span class="comment">//*(p+i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-4-指针和多维数组"><a href="#12-4-指针和多维数组" class="headerlink" title="12.4    指针和多维数组"></a>12.4    指针和多维数组</h2><h3 id="12-4-1-处理多维数组的元素"><a href="#12-4-1-处理多维数组的元素" class="headerlink" title="12.4.1    处理多维数组的元素"></a>12.4.1    处理多维数组的元素</h3><blockquote>
<p><strong>说明：</strong>可以通过指针递增的方式访问到多维数组的每一个元素，因为c语言始终按照顺序存储多维数组的元素。</p>
</blockquote>
<p><em>数组遍历（数组下标的方式）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="comment">//将数组元素初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">0</span>; row &lt; NUM_ROWS; row++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(col = <span class="number">0</span>; col &lt; NUM_COLS; col++)&#123;</span><br><span class="line">		a[row][col] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>数组遍历（指针的方式）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>][<span class="number">0</span>]; p &lt;= &amp;a[NUMROWS<span class="number">-1</span>][NUM_COLS<span class="number">-1</span>]; P++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-2-处理多维数组的行"><a href="#12-4-2-处理多维数组的行" class="headerlink" title="12.4.2    处理多维数组的行"></a>12.4.2    处理多维数组的行</h3><blockquote>
<p><strong>说明：</strong>二维数组第<code>i</code>(从0开始)行第一个元素的地址<br><code>a[i]</code> == <code>*(a + i)</code> ==<code>&amp;a[i][0]</code> == <code>&amp;(*(a[i] + 0))</code> == <code>&amp;*a[i]</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[NUM_ROWS][NUM_COLS], *p, i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//初始化a的第i行元素为0</span></span><br><span class="line"><span class="keyword">for</span>(p = a[i]; p &lt; a[i] + NUM_COLS; p++)&#123;</span><br><span class="line">	*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-4-3-用多维数组名作为指针"><a href="#12-4-3-用多维数组名作为指针" class="headerlink" title="12.4.3    用多维数组名作为指针"></a>12.4.3    用多维数组名作为指针</h3><p><strong>指针的指针：</strong><code>int a[10], b[10][10];</code></p>
<blockquote>
<p><code>a</code>可以看作是<code>int *</code>型的指针，而<code>b</code>用作指针时则是<code>int **</code>型的（指针某个整数的指针的指针）。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/11 指针/" itemprop="url">
                  11 指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T23:05:35+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>字节(byte)：</strong>大多数现代计算机用字节来分割内存，每个字节可以存储8位信息。每个字节都有唯一的地址，用来和内存中的其他字节进行区别。<br><strong>变量在内存中的地址：</strong>程序中的每个变量占有一个或多个内存字节，把第一个字节的地址称为变量的地址。<br><strong>指针变量：（pointer variable）</strong>虽然可以用整数表示地址，但是其取值单位可能不同于整数的范围，所以一定不能用普通整型变量存储地址。但是，可以用热熟的指针变量存储地址。<br><strong>指针：</strong>在用指针变量p存储变量i的地址时，我们说成是p“指向”i。换句话说，指针就是地址，而且指针变量是只存储地址的变量。</p>
<h2 id="11-1声明指针变量"><a href="#11-1声明指针变量" class="headerlink" title="11.1声明指针变量"></a>11.1声明指针变量</h2><p><strong>语法：</strong><code>int *p</code></p>
<ul>
<li>必须在指针变量名字前放置<code>*</code></li>
<li>可以和其他变量一起出现在声明中</li>
<li>每个指针变量唯一指向特定类型（引用类型）的对象</li>
<li>对指针可以指向的引用类型没有限制，甚至可以指向另一个指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, i, a[<span class="number">10</span>], *p;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-取地址运算符和间接寻址运算符"><a href="#11-2-取地址运算符和间接寻址运算符" class="headerlink" title="11.2    取地址运算符和间接寻址运算符"></a>11.2    取地址运算符和间接寻址运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;变量</code></td>
<td>取地址运算符</td>
<td>找到变量的地址</td>
</tr>
<tr>
<td><code>*指针变量</code></td>
<td>间接寻址运算符</td>
<td>找到指针指向的对象</td>
</tr>
</tbody>
</table>
<h3 id="11-2-1-取地址运算符"><a href="#11-2-1-取地址运算符" class="headerlink" title="11.2.1    取地址运算符"></a>11.2.1    取地址运算符</h3><p><strong>先声明后赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p;</span><br><span class="line">p = &amp;i;</span><br></pre></td></tr></table></figure>
<p><strong>声明的同时赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-间接寻址运算符"><a href="#11-2-2-间接寻址运算符" class="headerlink" title="11.2.2    间接寻址运算符"></a>11.2.2    间接寻址运算符</h3><blockquote>
<p><strong>说明：</strong>一旦指针变量指向指向了对象，就可以使用<code>*</code>运算符访问存储在对象中的内容。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);<span class="comment">//*p等价于i</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>不要把间接寻址运算符用于未初始化的指针变量。否则一旦改变未知的内存单元可能会导致不规律的行为或操作系统的崩溃。</p>
<h2 id="11-3-指针赋值"><a href="#11-3-指针赋值" class="headerlink" title="11.3    指针赋值"></a>11.3    指针赋值</h2><blockquote>
<p><strong>前提：</strong>两个指针具有相同的类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, *p, *q;</span><br><span class="line">p = &amp;i;</span><br><span class="line">q = p;<span class="comment">//把i的地址右赋值给了p，此时右两个指针同时指向i</span></span><br></pre></td></tr></table></figure>
<h2 id="11-4-指针作为实际参数"><a href="#11-4-指针作为实际参数" class="headerlink" title="11.4    指针作为实际参数"></a>11.4    指针作为实际参数</h2><blockquote>
<p><strong>背景：</strong>c语言的参数传递机制为“值传递”，参数传递进来的是变量的副本。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_part;</span><br><span class="line"><span class="keyword">float</span> frace_part;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *frac_part)</span></span>;</span><br><span class="line"><span class="comment">//或void decompose(float x, int *, float *);</span></span><br><span class="line">decompose(<span class="number">3.1415926</span>, &amp;i, &amp;f);</span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义*/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 取出一个浮点数的整数部分和小数部并分别赋值给两个外部变量</span><br><span class="line">* @param x 目标浮点数</span><br><span class="line">* @param *int_part 存储整数部分的地址</span><br><span class="line">* @param *fract_part 存储小数部分的变量</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> *int_part, <span class="keyword">float</span> *fract_part)</span></span>&#123;</span><br><span class="line">	*int_part = (int) x;</span><br><span class="line">	*fract_part = x - *int_part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-1-程序：找出数组中的最大元素和最小元素"><a href="#11-4-1-程序：找出数组中的最大元素和最小元素" class="headerlink" title="11.4.1    程序：找出数组中的最大元素和最小元素"></a>11.4.1    程序：找出数组中的最大元素和最小元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Finds the largest and smallest elements in an array</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> b[N], i, big, small;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers:"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	max_min(b, N, &amp;big, &amp;small);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Largest: %d\n"</span>, big);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"smallest: %d\n"</span>, small);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 找出最大值和最小值并将结果赋给响应指针对应的变量</span><br><span class="line"> * @param a   数组</span><br><span class="line"> * @param n   数组大小</span><br><span class="line"> * @param max 存储最大值的变量</span><br><span class="line"> * @param min 存储最小值的变量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	*max = *min = a[<span class="number">0</span>];</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line"> 			*max = a[i];</span><br><span class="line"> 		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line"> 			*min = a[i];</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./maxmin </span><br><span class="line"> Enter 10 numbers:1 2 3 4 5 6 7 8 9 10</span><br><span class="line"> Largest: 10</span><br><span class="line"> smallest: 1</span><br></pre></td></tr></table></figure>
<h3 id="11-4-2-用const保护实际参数"><a href="#11-4-2-用const保护实际参数" class="headerlink" title="11.4.2    用const保护实际参数"></a>11.4.2    用const保护实际参数</h3><p><strong>使用指针替代变量副本：</strong>如果需要大量的存储空间，那么传递变量的值可能浪费时间和空间。<br><strong>const：</strong>放在形式参数的类型说明之前，证明函数不会改变传递给函数的指针所指向的对象。试图改变用<code>const</code>修饰的形参对应的实参会引发编译器发出特定消息。</p>
<h2 id="11-5-指针作为返回值"><a href="#11-5-指针作为返回值" class="headerlink" title="11.5    指针作为返回值"></a>11.5    指针作为返回值</h2><p><strong>用途：</strong>函数返回结果的内存位置而不是返回值。<br><strong>场景：</strong></p>
<ol>
<li>返回指向外部变量的指针</li>
<li>返回声明为<code>static</code>的局部变量的指针</li>
<li><strong>限制：</strong>永远不会返回指向自动局部变量的指针，因为函数返回后局部变量的存储空间就不存在了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">max</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*a &gt; *b)&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p, x, y;</span><br><span class="line">p = max(*x, &amp;y);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/10 程序结构/" itemprop="url">
                  10 程序结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T22:53:52+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="10-1-局部变量"><a href="#10-1-局部变量" class="headerlink" title="10.1    局部变量"></a>10.1    局部变量</h2><p><strong>局部：</strong>在函数体内声明的变量称为相对于函数的局部。<br><strong>存储期限（storage duration）：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。<br><strong>特点：</strong></p>
<ul>
<li><strong>自动存储期限：</strong>调用闭合函数时“自动”分配局部变量的存储单元，函数返回时收回分配。在闭合函数返回时收回分配。</li>
<li><strong>程序快作用域：</strong>变量的作用域是可以参考变量的程序文本的部分。从变量声明的点开始一直到闭合函数的末尾。局部变量拥有程序块作用域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">log</span> = <span class="number">0</span>;<span class="comment">/*局部变量*/</span></span><br><span class="line">   <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">     n /= <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">log</span>++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-1-静态存储期限：static"><a href="#10-1-1-静态存储期限：static" class="headerlink" title="10.1.1 静态存储期限：static"></a>10.1.1 静态存储期限：<code>static</code></h3><p><strong>特点：</strong>具有静态存储期限的变量拥有永久的存储单元，所以会在整个程序执行期间会保留变量的值。</p>
<ol>
<li>静态局部变量始终有程序块作用域，它对其他函数而言是不可见的</li>
<li>静态变量是隐藏来自其他函数的数据的地方，但是它会为将来同一个函数的调用保留这些数据。</li>
</ol>
<p><strong>声明方式：</strong>在局部变量声明中放置单词<code>static</code>可以使用变量从自动存储期限变为静态存储期限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*因为局部变量i已经声明为static，所以在程序执行期间它占有同样的存储单元。在f返回时，变量i不会丢失自身的值。*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-形式参数"><a href="#10-1-2-形式参数" class="headerlink" title="10.1.2 形式参数"></a>10.1.2 形式参数</h3><p><strong>和局部变量比较</strong></p>
<ul>
<li><strong>相同点：</strong>自动存储期限、块级作用域</li>
<li><strong>不同点：</strong>在每次函数调用时对形式参数自动进行初始化（调用中通过赋值获得实际参数的值）</li>
</ul>
<h2 id="10-2-外部变量"><a href="#10-2-外部变量" class="headerlink" title="10.2    外部变量"></a>10.2    外部变量</h2><blockquote>
<p><strong>又名：</strong>全局变量<br><strong>声明位置：</strong>外部变量是声明在任何函数体外的。<br><strong>性质：</strong></p>
<ul>
<li>静态存储期限：同声明的static的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。</li>
<li>文件作用域：从变量声明的点开始一直到闭合文件的末尾。跟随在外部变量声明后的所有函数都可以访问它。</li>
</ul>
</blockquote>
<h3 id="10-2-1-程序：用外部变量实现栈"><a href="#10-2-1-程序：用外部变量实现栈" class="headerlink" title="10.2.1    程序：用外部变量实现栈"></a>10.2.1    程序：用外部变量实现栈</h3><blockquote>
<p><strong>栈（stack）：</strong>像数组一样，栈可以存储具有相同数据类型的多个数据项。<br><strong>操作方式：</strong>LIFO(后进先出)，占中数据项的操作是十分受限制的，可以忘栈中压入数据，或者从栈中弹出数据项。禁止测试或修改不在栈顶的数据项。<br><strong>c语言实现：</strong>把元素存储在数组中，称为<code>constents</code>,命名为top的一个整型变量用来标记栈栈顶的位置。栈为空时，top值为0。为了往栈中压入数据项，可以把数据项简单存储在contents中标记为top的位置上，然后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>中标记为top的位置上，谈后自增top。弹出数据项则要求自减top，然后用它作为<code>contents</code>的索引取回弹出的数据项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈</span><br><span class="line"> * 将top指针指向数组的第一项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否为空</span><br><span class="line"> * @return  true:空；false:非空</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查栈是否已满</span><br><span class="line"> * @return  true:已满；false:未满</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	return top == STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向栈中压入数据</span><br><span class="line"> * @param i 要压入的数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_full())&#123;</span><br><span class="line">		stace_overflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		contents[top++] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 从栈中弹出数据项</span><br><span class="line"> * @return  数据项</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_empty())&#123;</span><br><span class="line">		stack_underflow();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return contents[--top];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-外部变量的利与弊"><a href="#10-2-2-外部变量的利与弊" class="headerlink" title="10.2.2 外部变量的利与弊"></a>10.2.2 外部变量的利与弊</h3><blockquote>
<p><strong>利：</strong>有利于多个函数必须共享一个变量或者上述几个函数共享大量变量。<br><strong>蔽：</strong></p>
<ol>
<li>可维护性差：如果改变外部变量，那么需要检查同一个文件中的每个函数，确认该改变对函数的影响。</li>
<li>可读性差：如果外部变量出现问题，难以确定导致这个值发生错误的函数。</li>
<li>可复用性差：很难再其他城程序中复用依赖于外部变量的函数。因为以来外部变量的函数不是“独立的”。</li>
</ol>
<p><strong>技巧：</strong>为了提高可阅读性和可能的错误，使用外部变量时，确保它们都拥有有意义的名字。</p>
</blockquote>
<h3 id="10-2-3-程序：猜数（略）"><a href="#10-2-3-程序：猜数（略）" class="headerlink" title="10.2.3 程序：猜数（略）"></a>10.2.3 程序：猜数（略）</h3><h2 id="10-3-程序块"><a href="#10-3-程序块" class="headerlink" title="10.3    程序块"></a>10.3    程序块</h2><blockquote>
<p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    多条声明</span><br><span class="line">    多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>作用域：</strong>程序块中的变量具有进入程序块时为存储变量分配单元，而在退出程序块时解除分配。<br><strong>函数体（也是程序块）放置临时变量的优点：</strong></p>
<ol>
<li>避免函数体起始位置的声明与只是临时使用的变量相混淆</li>
<li>减少了名字冲突</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = i;</span><br><span class="line">	i = j;</span><br><span class="line">	j = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-作用域"><a href="#10-4-作用域" class="headerlink" title="10.4    作用域"></a>10.4    作用域</h2><blockquote>
<p><strong>规则：</strong></p>
<ol>
<li>标识符拥有文件作用域，即在所声明的闭合程序块内有效</li>
<li>新的声明临时会“隐藏”旧的声明</li>
<li>在程序块结束后后面，被“隐藏”的标识符重新获得旧的含义</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*第1个*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第2个*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*第3个*/</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/*第4个*/</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		i = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-5-构建c-程序"><a href="#10-5-构建c-程序" class="headerlink" title="10.5    构建c 程序"></a>10.5    构建c 程序</h2><p><strong>程序构成要素：</strong></p>
<ul>
<li>预处理指令：诸如<code>#include</code>和<code>#define</code></li>
<li>类型定义</li>
<li>函数声明和外部变量声明</li>
<li>函数定义</li>
</ul>
<p><strong>建议编排顺序：</strong></p>
<ol>
<li>#include指令</li>
<li>define指令</li>
<li>类型定义（typedef）</li>
<li>外部变量声明</li>
<li>除main函数之外的函数原型</li>
<li>main函数的定义</li>
<li>其他函数的定义</li>
</ol>
<p><strong>建议函数注释：</strong>盒形注释</p>
<ul>
<li>函数名</li>
<li>描述函数的目的</li>
<li>讨论每个参数的含义</li>
<li>描述返回值</li>
<li>罗列任何的副作用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/9 函数/" itemprop="url">
                  9 函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T19:06:38+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="9-1-函数的定义和调用"><a href="#9-1-函数的定义和调用" class="headerlink" title="9.1    函数的定义和调用"></a>9.1    函数的定义和调用</h2><blockquote>
<p><strong>语法</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>简析</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回类型（return type）</td>
<td>每次调用函数返回数据的类型，当不需要返回值时使用<code>void</code></td>
</tr>
<tr>
<td>形式参数（parameter）</td>
<td>每一个参数都必须有类型，没有行参使用<code>void</code></td>
</tr>
<tr>
<td>函数体（body）</td>
<td>用<code>{}</code>括起来的执行部分</td>
</tr>
<tr>
<td>实际参数（argument）</td>
<td>为了激活（即调用（call））函数，需要写出函数名及跟随其后的实际参数列表</td>
</tr>
</tbody>
</table>
<h3 id="9-1-1-程序：计算平均值"><a href="#9-1-1-程序：计算平均值" class="headerlink" title="9.1.1    程序：计算平均值"></a>9.1.1    程序：计算平均值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes pairwise averages of three numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>&#123;</span><br><span class="line"> 	return (a+b) / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter three numbers:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f%f%f"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, y, average(x,y));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, y, z, average(y,z));</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Average of %g and %g: %g\n"</span>, x, z, average(x,z));</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./average</span><br><span class="line"> Enter three numbers:1 2 3</span><br><span class="line"> Average of 1 and 2: 1.5</span><br><span class="line"> Average of 2 and 3: 2.5</span><br><span class="line"> Average of 1 and 3: 2</span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-程序：显示倒数计时"><a href="#9-1-2-程序：显示倒数计时" class="headerlink" title="9.1.2    程序：显示倒数计时"></a>9.1.2    程序：显示倒数计时</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a countdown</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, n);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">10</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line"> 		print_count(i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./countdwn </span><br><span class="line">T minus 10 and counting</span><br><span class="line">T minus 9 and counting</span><br><span class="line">T minus 8 and counting</span><br><span class="line">T minus 7 and counting</span><br><span class="line">T minus 6 and counting</span><br><span class="line">T minus 5 and counting</span><br><span class="line">T minus 4 and counting</span><br><span class="line">T minus 3 and counting</span><br><span class="line">T minus 2 and counting</span><br><span class="line">T minus 1 and counting</span><br></pre></td></tr></table></figure>
<h3 id="9-1-3-程序：显示双关语"><a href="#9-1-3-程序：显示双关语" class="headerlink" title="9.1.3    程序：显示双关语"></a>9.1.3    程序：显示双关语</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a bad pun</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	print_pun();</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pun2</span><br><span class="line"> To c, or not to c:that is the question.</span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-函数定义"><a href="#9-1-4-函数定义" class="headerlink" title="9.1.4    函数定义"></a>9.1.4    函数定义</h3><blockquote>
<p><strong>函数定义：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名(形式参数)&#123;</span><br><span class="line">  声明</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数无法返回数组，但是没有其它关于返回类型的限制</li>
<li>如果忽略返回类型，那么会假定函数返回值的类型时<code>int</code>型</li>
<li>制定返回类型是<code>void</code>型说明函数没有返回值</li>
</ul>
<p><strong>技巧：</strong></p>
<ul>
<li>为每个函数指定一个明显的返回类型是一个很好的方法（<code>void</code>也可以省略，毕竟经典c没有<code>void</code>概念，但不推荐这样）</li>
<li>如果返回值很冗长，比如<code>unsigned long int</code>，那么把返回类型单独放一行是非常有用的</li>
</ul>
</blockquote>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>需要在每个形式参数的前面说明其类型</li>
<li>形式参数间用逗号进行分隔</li>
<li>如果函数没有形式参数，那么在圆口哈没应该出现<code>void</code></li>
<li>即使有些行参具有相同数据类型，也必须对每个形式参数分别进行类型说明</li>
</ul>
</blockquote>
<h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><blockquote>
<p><strong>规则：</strong></p>
<ul>
<li>函数体内声明的变量专属于此函数，其它函数不能对这些变量进行检查或修改</li>
<li>函数体可以为空，以后可以回来编写它的函数体</li>
</ul>
</blockquote>
<h3 id="9-1-5-函数调用"><a href="#9-1-5-函数调用" class="headerlink" title="9.1.5    函数调用"></a>9.1.5    函数调用</h3><blockquote>
<p><strong>语法：</strong><code>[强制转换返回类型] 函数名(实参1, 实参2 ...);</code><br><strong>有无返回值的函数调用的区别：</strong>void型的函数调用是语句，所以调用后边始终跟着分号；非void型的函数调用是表达式。<br><strong>注意：</strong>丢掉圆括号仍然是合法的表达式，但不起任何作用，有些编译器会给出警告。</p>
</blockquote>
<h4 id="强制转换返回类型"><a href="#强制转换返回类型" class="headerlink" title="[强制转换返回类型]"></a>[强制转换返回类型]</h4><blockquote>
<p><strong>说明：</strong>很少用到，可以省略<br><strong>技巧：</strong>可以将返回值强制类型转换成<code>void</code>，使别人清楚编写者使故意扔掉返回值的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"Hi, Mom!\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-程序：判定素数"><a href="#9-1-6-程序：判定素数" class="headerlink" title="9.1.6    程序：判定素数"></a>9.1.6    程序：判定素数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests whether a number is prime</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"> <span class="function">Bool <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> divisor;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"> 		return FALSE;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">for</span>(divisor = <span class="number">2</span>; divisor * divisor &lt;= n; divisor++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(n % divisor == <span class="number">0</span>)&#123;</span><br><span class="line"> 			return FALSE;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return TRUE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> 	<span class="keyword">if</span>(is_prime(n))&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"'Prime'\n"</span>);</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Not prime\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./prime </span><br><span class="line"> Enter a number:34</span><br><span class="line"> Not prime</span><br></pre></td></tr></table></figure>
<h2 id="9-2-函数声明"><a href="#9-2-函数声明" class="headerlink" title="9.2    函数声明"></a>9.2    函数声明</h2><blockquote>
<p><strong>背景：</strong>c语言没有要求函数的定义必须放置在<code>main</code>函数的定义之后。如果函数的定义在调用之后，那么编译器会为被调用的函数的函数做一些假设。如果假设错误，则程序无法正常工作。<br><strong>说明：</strong>在调用前声明（declare）每个函数，函数声明是的编译器对函数进行概要浏览，而函数的完整定义稍后再出现。</p>
<blockquote>
<p><strong>函数原型（function prototype）：</strong><code>Q&amp;A</code>中将这种函数声明称为函数原型。原型为如何调用函数提供了一个完整的描述：提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型。<br><strong>行参规则：</strong>可以不写形式参数的名字，只要显示类型就可以，<code>float average(float float)</code>，但不建议，为了代码的可阅读性和可维护性。</p>
</blockquote>
<p><strong>语法：</strong><code>返回类型 函数名（形式参数）;</code><br><strong>注意：</strong>函数的声明必须和函数的定义一致。</p>
</blockquote>
<h2 id="9-3-实际参数"><a href="#9-3-实际参数" class="headerlink" title="9.3    实际参数"></a>9.3    实际参数</h2><blockquote>
<p><strong>实参和形参：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式参数(parameter)</td>
<td>出现在函数定义中，它们以假名字来表示函数调用时提供的值</td>
</tr>
<tr>
<td>实际参数(argument)</td>
<td>出现在函数调用中的表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>通过值传递：</strong>调用函数时，计算出每个实际参数的值并且把它赋值给相应的形式参数。</p>
<blockquote>
<p><strong>特点：</strong>在函数的执行过程中，对形式参数的改变不会影响实际参数的值。</p>
</blockquote>
</blockquote>
<h3 id="9-3-1-实际参数的转换"><a href="#9-3-1-实际参数的转换" class="headerlink" title="9.3.1    实际参数的转换"></a>9.3.1    实际参数的转换</h3><blockquote>
<p><strong>说明：</strong>c语言允许在实际参数的类型和形式参数的类型不匹配的情况下进行函数调用。<br><strong>实参转换规则：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>编译器在调用前是否遇到原型</th>
<th>转换方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>实参的值被隐式转换成相应形式参数的类型。</td>
</tr>
<tr>
<td>否</td>
<td>编译器执行默认的实际参数提升</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>默认的实际参数提升</strong></p>
<ol>
<li>把<code>float</code>型的实际参数转换成<code>double</code>类型</li>
<li>执行整数的提升（即把<code>char</code>型和<code>short</code>型的实际参数转换成<code>int</code>型）<br><strong>注意：</strong>默认的实际参数提升不总会获得期望的效果<br><strong>技巧：</strong>始终在调用函数前声明函数非常必要。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter number to be squard:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">	<span class="comment">//把变量i强制转换为正确的类型的方法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The answer if %g\n"</span>, square((double)i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-数组型实际参数"><a href="#9-3-2-数组型实际参数" class="headerlink" title="9.3.2    数组型实际参数"></a>9.3.2    数组型实际参数</h3><p><strong>语法：</strong><code>数组类型 数组实参名[数组长度]</code><br><strong>特点：</strong></p>
<ul>
<li>其中<code>数组长度</code>通常省略不写。即便写了在函数中仍然无法判断数组的长度。</li>
<li>多维数组形式参数只能忽略第一位的长度</li>
</ul>
<p><strong>获取实参数组长度：</strong>c语言没有提供任何简便的方法来确定传递给它的数组的长度。但是如果函数需要，必须把长度作为额外的实际参数提供给函数。<br><strong>注意：</strong>在函数内部通过<code>sizeof(a) / sizeof(a[0])</code>的方式并不能正确计算出传递进来的数组的长度。<br><strong>技巧：</strong>通过传递比数组实际长度小的整数参数，来部分操作数组。<br><strong>延伸：</strong>不能传递令人困扰的具有任意列数的多维数组。幸运的是，我们经常可以通过使用指针数组的方式处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数原型*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//如果愿意可以省略形式参数的名字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b[LEN], total;</span><br><span class="line">	total = sun_array(b, LEN);<span class="comment">//在数组名传递给函数时，不要在数组名的后边放置方括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* params&#123;int Array&#125; a 数组</span><br><span class="line">* params&#123;int&#125; n 数组长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, sun = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		sun += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-return语句"><a href="#9-4-return语句" class="headerlink" title="9.4    return语句"></a>9.4    return语句</h2><blockquote>
<p><strong>return语句：</strong><code>return 表达式;</code><br><strong>隐式转换：</strong>如果<code>return</code>语句中表达式的类型和函数的返回类型不匹配，那么系统将会把表达式的类型隐式转换为返回类型<br><strong>立即返回：</strong>在返回类型为<code>void</code>的函数中可以使用<code>return;</code>，会导致函数立即返回，后面不能包含表达式</p>
</blockquote>
<p><strong><code>void</code>和非<code>void</code></strong></p>
<table>
<thead>
<tr>
<th>返回值类型是否为<code>void</code></th>
<th>是否必须<code>return</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td>是</td>
<td>必须使用<code>return 表达式</code>返回值，否则某些编译器会报错</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td><code>return</code>并不是必须的，因为在执行最后一条语句后函数将会自动跳转。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to C :that is the qyestion.\n"</span>)</span><br><span class="line">	return;<span class="comment">/*可以省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-5-程序终止"><a href="#9-5-程序终止" class="headerlink" title="9.5    程序终止"></a>9.5    程序终止</h2><blockquote>
<p><strong>状态码：</strong>即<code>main</code>函数的返回值，默认为<code>int</code>类型；或者<code>exit</code>函数的实参。</p>
<blockquote>
<p><strong>用途：</strong>在某些操作系统中程序终止时可以检测到状态码。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常终止</td>
<td>0</td>
</tr>
<tr>
<td>异常终止</td>
<td>非0</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>即使不打算用状态码，确信每个c程序都返回状态码也是一个很好的实践，因为某些运行程序的人可能稍后再决定测试状态码。</p>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><p><strong>功能：</strong>终止程序，相当于在<code>main</code>函数中使用<code>return</code>。<br><strong>实参：</strong>传递给<code>exit</code>函数的实际参数和<code>main</code>函数的返回值具有相同的含义，两者都说明程序终止时的状态。<br><strong>所在库：</strong><code>&lt;stdlib.h&gt;</code><br><strong>相关宏定义：</strong><code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>,值由实现定义，典型的值是0和1<br><strong>区别于<code>return</code>：</strong><code>return</code>和<code>exit</code>都可以在任何函数中调用，但<code>return</code>只有在<code>main</code>函数中调用才会终止程序；<code>exit</code>在任何函数中调用都会终止程序。<br><strong>技巧：</strong>一些程序员专门使用<code>exit</code>函数以便于模式匹配程序可以很容易地定位程序中全部的退出点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<h2 id="9-6-递归函数"><a href="#9-6-递归函数" class="headerlink" title="9.6    递归函数"></a>9.6    递归函数</h2><blockquote>
<p><strong>说明：</strong>如果函数调用它本身，那么此函数就是递归的（recursice）。<br><strong>技巧：</strong>为了防止无限递归，所有递归函数都需要某些类型的终止条件。<br><strong>注意：</strong>c语言允许递归，但大多数c程序员并不经常使用递归。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 计算n的阶乘</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">face</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		return n * fact(n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 计算x^n</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	return n == <span class="number">0</span> ? <span class="number">1</span> : x * power(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-1-快速排序算法"><a href="#9-6-1-快速排序算法" class="headerlink" title="9.6.1    快速排序算法"></a>9.6.1    快速排序算法</h3><blockquote>
<p><strong>分治法(divide-and-conquer)：</strong>把一个大问题划分成多个较小的问题，然后采用相同的算法分别解决这些小问题。比如排序算法。<br><strong>算法操作：</strong></p>
<ol>
<li>选择数组元素e（作为“分割元素”），然后重新排列数组使得元素从1一直到i-1都是小雨或等于元素e的，元素i包含e，而元素从i-1一直到n都是大于或等于e的。</li>
<li>通过递归地采用快速排序算法，对从1到i-1的元素进行排序。</li>
<li>通过递归地采用快速排序方法，对从i+1到n的元素进行排序。</li>
</ol>
</blockquote>
<h4 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of integers using Quicksort algorthm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 12</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>&#125;;</span><br><span class="line"> 			  </span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line"> 	printArr(a, <span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印数组</span><br><span class="line"> * @param &#123;int&#125; a 需要打印的数组</span><br><span class="line"> * @param &#123;int&#125; flag 表示打印时排序处在的状态</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 自己实现的快排程序：快速排序</span><br><span class="line"> * @param &#123;int&#125; a[] 被排序的数组</span><br><span class="line"> * @param &#123;int&#125; low 起点</span><br><span class="line"> * @param &#123;int&#125; high 终点</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">myquicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"%d****%d\n"</span>, low, high);</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return ;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> middleValue = a[low];</span><br><span class="line"> 		<span class="keyword">int</span> emptyPoint = low;</span><br><span class="line"> 		<span class="keyword">int</span> newLow = low, </span><br><span class="line"> 			newHigh = high;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">/**</span><br><span class="line"> 		 * 只要low指针和high指针没有最后相遇，就交替往中间靠拢。并在在这个过程中完成位置的交换。</span><br><span class="line"> 		 * 原理是：有点像拆东墙补西墙，把中间数字两边的数字看作东墙和西墙的话，</span><br><span class="line"> 		 * 其实就是在东墙上找西墙上的砖补到西墙上，东墙被拿走砖的位置且只能是这个位置需要西墙去补。一来二去就完成了砖的交换过程。</span><br><span class="line"> 		 */</span></span><br><span class="line"> 		<span class="keyword">while</span>(newLow &lt; newHigh)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(newLow == emptyPoint)&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为低位：高位指针向左移动寻找比中间值小的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newHigh] &gt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newHigh--;	</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newHigh];</span><br><span class="line"> 				emptyPoint = newHigh;</span><br><span class="line"> 			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 				<span class="comment">//待定的位置为高位：低位指针向右移动寻找比中间值大的数</span></span><br><span class="line"> 				<span class="keyword">while</span>(a[newLow] &lt;= middleValue)&#123;</span><br><span class="line"> 					<span class="keyword">if</span>(newHigh &gt; newLow)&#123;</span><br><span class="line"> 						newLow++;</span><br><span class="line"> 					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 						<span class="keyword">goto</span> done;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				a[emptyPoint] = a[newLow];</span><br><span class="line"> 				emptyPoint = newLow;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			printArr(a, <span class="number">1</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//标记</span></span><br><span class="line"> 		done:</span><br><span class="line"> 		a[emptyPoint] = middleValue;</span><br><span class="line"> 		printArr(a, <span class="number">0</span>);</span><br><span class="line"> 		<span class="keyword">if</span>(newLow &gt; low)&#123;</span><br><span class="line"> 			quicksort(a, low, newLow - <span class="number">1</span>);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span>(newHigh &lt; high)&#123;</span><br><span class="line"> 			quicksort(a, newHigh + <span class="number">1</span>, high);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-2-程序：快速排序"><a href="#9-6-2-程序：快速排序" class="headerlink" title="9.6.2 程序：快速排序"></a>9.6.2 程序：快速排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sorts an array of intergers using Quicksort algorithm</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="comment">/*声明函数*/</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], i;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*输入需要排队的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers to be sorted :"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*调用排序函数进行排序*/</span></span><br><span class="line"> 	quicksort(a, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/*打印排序好的数组*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In sorted order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 快排程序</span><br><span class="line"> * @param &#123;Array&#125; a 数组</span><br><span class="line"> * @param &#123;int&#125; low 开始下标 </span><br><span class="line"> * @param &#123;int&#125; high 结束下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> middle;</span><br><span class="line"> 	<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//获得分段的中间位置</span></span><br><span class="line"> 	middle = split(a, low, high);</span><br><span class="line"> 	quicksort(a, low, middle <span class="number">-1</span>);</span><br><span class="line"> 	quicksort(a, middle + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> part_element = a[low];</span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">/*high指针向左移动寻找比part_element小的数，直到找到或low和high指针重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; part_element &lt;= a[high])&#123;</span><br><span class="line"> 			high--;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果重合了，说明没有找到</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果找到了，将找到的比中间值小的数放到当前low指针指向的位置，并将指针向右移动</span></span><br><span class="line"> 		a[low++] = a[high];</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">/*low指针向右移动，寻找比part_element大的数，直到找到一个或low和high重合*/</span></span><br><span class="line"> 		<span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= part_element)&#123;</span><br><span class="line"> 			low++;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//重合了就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果没重合，就讲找到的数移动到high指针指向的位置，并将high的指针向左移动一下</span></span><br><span class="line"> 		a[high--] = a[low];</span><br><span class="line"> 		return high;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-3-改进"><a href="#9-6-3-改进" class="headerlink" title="9.6.3    改进"></a>9.6.3    改进</h3><ol>
<li><p>改进分割算法</p>
<blockquote>
<p>上面介绍的方法不是最有效的。我们不再选择数组中的第一个元素作为分割元素，较好的方法是取第一个元素、中间元素和最后一个元素的中间值。分个过程本身也可以加速。特别是，在两个while循环中避免测试low&lt;high是可能的。</p>
</blockquote>
</li>
<li><p>采用不同的方法进行小数组排序</p>
</li>
<li><p>使得快速排序非递归</p>
<blockquote>
<p>虽然快速排序本质上是使用递归算法，并且递归格式的快速排序是最容易理解的，但是实际上若去掉递归会更有效率。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/8 数组/" itemprop="url">
                  8 数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:48:30+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>变量：</strong>变量分为两种</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>标量（scalar）</td>
<td>标亮具有保存单一数据项的能力</td>
</tr>
<tr>
<td>聚合（aggregate）</td>
<td>存储数值的集合（数组(array)和结构(structure)）</td>
</tr>
</tbody>
</table>
<h2 id="8-1-一维数组"><a href="#8-1-一维数组" class="headerlink" title="8.1    一维数组"></a>8.1    一维数组</h2><blockquote>
<p><strong>说明：</strong>数组是含有多个数据值的数据结构，并且每个数据之具有相同的数据类型。这些数据类型的值被称为元素（element）。<br><strong>声明数组：</strong>需要说明数组元素的<code>类型</code>(任何类型)和<code>数量</code>（任何整数常量表达式）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>因为程序后面变化时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br></pre></td></tr></table></figure>
<h3 id="8-1-1-数组下标"><a href="#8-1-1-数组下标" class="headerlink" title="8.1.1    数组下标"></a>8.1.1    数组下标</h3><blockquote>
<p><strong>说明：</strong>为了存取特定的数组元素，可以在写数组名的同时在后迷呐加上一个用方括号围绕的整数值（称这是对数组进行下标（subsvripting）或索引（indexing））。<br><strong>注意：</strong></p>
<ul>
<li><code>a[i]</code>的表达式格式是左值，所以数组元素可以和普通变量一样使用</li>
<li>在调用scanf函数读取数组元素时，就像对待普通变量一样，必须使用取地址符号<code>&amp;</code>。</li>
<li>c语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="comment">//对某些编译器来说，这个表面上正确的for语句却产生了一个无限循环</span></span><br><span class="line"><span class="comment">//如果i在内存中的位置在a[9]后面，那么修改a[10]其实是修改了i，使i变为0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		a[i] = <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>避免数组下标的副作用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不确定的做法</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; N)&#123;</span><br><span class="line">	a[i] = b[i++];<span class="comment">//i有可能会在复制发生之前就进行自增，导致两个数组错位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安全的做法</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	a[i] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">5</span>]);</span><br><span class="line">++a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空数组</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数组元素</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	sun += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-程序：数列反向"><a href="#8-1-2-程序：数列反向" class="headerlink" title="8.1.2    程序：数列反向"></a>8.1.2    程序：数列反向</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reverse a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> a[N], i;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter %d numbers:"</span>, N);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"In reverse order:"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">" %d"</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./reverse</span><br><span class="line"> Enter 10 numbers:10</span><br><span class="line"> 9</span><br><span class="line"> 8</span><br><span class="line"> 7</span><br><span class="line"> 6</span><br><span class="line"> 5</span><br><span class="line"> 4</span><br><span class="line"> 3</span><br><span class="line"> 2</span><br><span class="line"> 1</span><br><span class="line"> In reverse order: 1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>
<h3 id="8-1-3-数组初始化"><a href="#8-1-3-数组初始化" class="headerlink" title="8.1.3    数组初始化"></a>8.1.3    数组初始化</h3><blockquote>
<p><strong>常量表达式列表规则：</strong></p>
<ul>
<li>列表用<code>{}</code>括起来，内部数值用<code>,</code>分隔</li>
<li>初始化式完全为空或比数组长度长是非法的，但可以比数组短，此时数组中生育的元素赋值为0</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完整的格式</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略数组的长度，此时编译器会利用初始化式的长度确定数组的大小</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化式比数组长度短</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//&#123;1,2,3,4,5,6,0,0,0,0&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部数组元素初始化为0</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//&#123;0,0,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-1-4-程序：检查数中重复出现的数字"><a href="#8-1-4-程序：检查数中重复出现的数字" class="headerlink" title="8.1.4    程序：检查数中重复出现的数字"></a>8.1.4    程序：检查数中重复出现的数字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks numbers for repeated digits</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	Bool digit_seen[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> 	<span class="keyword">int</span> digit;</span><br><span class="line"> 	<span class="keyword">long</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> 		<span class="comment">//取个位数</span></span><br><span class="line"> 		digit  = n % <span class="number">10</span>;</span><br><span class="line"> 		<span class="comment">//检查个位数是不是已经有过一个了，是的话终止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(digit_seen[digit])&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//以当前个位数作为索引将对应数字元素的值改为TRUE</span></span><br><span class="line"> 		digit_seen[digit] = TRUE;</span><br><span class="line"> 		n /= <span class="number">10</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> 		<span class="comment">//n&gt;0说明至少有一个数字发生了重复</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Repeated digit\n\n"</span>);</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"No repeated digit\n\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./repdigit </span><br><span class="line">Enter a number:12345677</span><br><span class="line">Repeated digit</span><br></pre></td></tr></table></figure>
<h3 id="8-1-5-对数组使用sizeof运算符"><a href="#8-1-5-对数组使用sizeof运算符" class="headerlink" title="8.1.5    对数组使用sizeof运算符"></a>8.1.5    对数组使用sizeof运算符</h3><blockquote>
<p><strong>用途：</strong></p>
<ul>
<li>计算数组的字节数</li>
<li>计算数组中每个元素的字节数</li>
<li>利用上面的结果计算数组的长度</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">10</span>]); i++)&#123;</span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>利用宏：</strong>简化用sizeof计算数组长度。更加有效的方式是使用带参数的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE (sizeof(a) / sizeof(a[0]))</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-6-程序：计算利息"><a href="#8-1-6-程序：计算利息" class="headerlink" title="8.1.6    程序：计算利息"></a>8.1.6    程序：计算利息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of compound interest</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NUM_RATES (sizeof(value) / sizeof(value[0]))</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> INITIAL_BALANCE 100.00</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, low_rate, num_years, year;</span><br><span class="line"> 	<span class="keyword">float</span> value[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter interest rate:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;low_rate);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of years:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num_years);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//表格标题行</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nYears"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM_RATES; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%6d%%"</span>, low_rate + i);<span class="comment">//两个%%代表要显示%字符串</span></span><br><span class="line"> 		value[i] = INITIAL_BALANCE;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	<span class="comment">//各个利率下逐年100美金的价值</span></span><br><span class="line"> 	<span class="keyword">for</span>(year = <span class="number">1</span>; year &lt;= num_years; year++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%3d    "</span>, year);</span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM_RATES; i++)&#123;</span><br><span class="line"> 			value[i] += (low_rate+i) / <span class="number">100.0</span> * value[i];</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"%7.2f"</span>, value[i]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);	</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./interest                            </span><br><span class="line"> Enter interest rate:5</span><br><span class="line"> Enter number of years:6</span><br><span class="line"></span><br><span class="line"> Years     5%     6%     7%     8%     9%</span><br><span class="line">  1     105.00 106.00 107.00 108.00 109.00</span><br><span class="line">  2     110.25 112.36 114.49 116.64 118.81</span><br><span class="line">  3     115.76 119.10 122.50 125.97 129.50</span><br><span class="line">  4     121.55 126.25 131.08 136.05 141.16</span><br><span class="line">  5     127.63 133.82 140.26 146.93 153.86</span><br><span class="line">  6     134.01 141.85 150.07 158.69 167.71</span><br></pre></td></tr></table></figure>
<h2 id="8-2-多维数组"><a href="#8-2-多维数组" class="headerlink" title="8.2    多维数组"></a>8.2    多维数组</h2><blockquote>
<p><strong>语法：</strong><code>m[i][j]</code><br><strong>注意：</strong>不能把<code>m[i][j]</code>写为<code>m[i, j]</code>。c语言把逗号看成是逗号运算符，所以<code>m[i,j]</code>等同于<code>m[j]</code>。<br><strong>地位：</strong>和其它编程语言中的多位数组相比， c语言中的多位数组扮演的角色相对较弱，这主要是因为c语言为存储多维数组提供了更加灵活的方法：指针数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">float</span> ident[N][N];</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">0</span>; row &lt; N; row++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(col = <span class="number">0</span>; col &lt; N; col++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(row == col)&#123;</span><br><span class="line">			ident[row][col] = <span class="number">1.0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ident[row][col] = <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-1-多为数组的初始化"><a href="#8-2-1-多为数组的初始化" class="headerlink" title="8.2.1    多为数组的初始化"></a>8.2.1    多为数组的初始化</h3><blockquote>
<p><strong>说明：</strong>通过嵌套一维初始化式的方式可以产生二维数组的初始化式。<br><strong>规则：</strong>c 语言提供了多种方法来缩写初始化式。</p>
<ul>
<li>如果初始化式不大到足以填满整个多位数组，那么数组中剩余的元素会被赋值为0。</li>
<li>如果内层的列表不大到足以填满数组的一行，那么慈航的剩余元素会被初始化为0。</li>
<li>可以忽略掉内层的大括号<br><strong>注意：</strong>在多维数组中忽略掉内层的大括号可能很危险，此外省略括号会引起某些编译器产生警告信息。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行数不足</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//列数不足</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//忽略内层的大括号</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">			   <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-2-常量数组"><a href="#8-2-2-常量数组" class="headerlink" title="8.2.2    常量数组"></a>8.2.2    常量数组</h3><blockquote>
<p><strong>语法：</strong><code>const 类型 数组名[]</code><br><strong>说明：</strong>程序不应对声明为<code>const</code>的数组进行修改。</p>
<ul>
<li>表明程序不会修改数组</li>
<li>告知不打算修改数组对编译器发现错误是很有帮助的</li>
</ul>
</blockquote>
<h3 id="8-2-3-发牌"><a href="#8-2-3-发牌" class="headerlink" title="8.2.3    发牌"></a>8.2.3    发牌</h3><blockquote>
<p><strong>相关函数：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>所属库</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>time</td>
<td>time.h</td>
<td>返回当前的时间，且这个时间是被编码成单独的数。</td>
</tr>
<tr>
<td>srand</td>
<td>stdlib.h</td>
<td>初始化c语言的随机数生成器</td>
</tr>
<tr>
<td>rand</td>
<td>stdlib.h</td>
<td>在每次调用时会产生一个显然随机的数</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Deals a random hand of cards</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SUITS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_RANKS 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Bool in_hand[NUM_SUITS][NUM_RANKS] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> num_cards, rank, suit;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> rank_code[] = &#123;<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'t'</span>,<span class="string">'j'</span>,<span class="string">'q'</span>,<span class="string">'k'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> suit_code[] = &#123;<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'s'</span>, <span class="string">'h'</span>&#125;;</span><br><span class="line">	srand((unsigned)time(NULL));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter number of cards in hand:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num_cards);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your hand:"</span>);</span><br><span class="line">	<span class="keyword">while</span>(num_cards &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		suit = rand() % NUM_SUITS;<span class="comment">//检出随机的花面</span></span><br><span class="line">		rank = rand() % NUM_RANKS;<span class="comment">//检出随机的纸牌等级</span></span><br><span class="line">		<span class="comment">//如果某张牌已经发出去过，则不能再发同样的牌，应当重新发</span></span><br><span class="line">		<span class="keyword">if</span>(!in_hand[suit][rank] == TRUE)&#123;</span><br><span class="line">			in_hand[suit][rank] = TRUE;</span><br><span class="line">			num_cards--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %c%c"</span>, rank_code[rank], suit_code[suit]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./deal                        </span><br><span class="line"> Enter number of cards <span class="keyword">in</span> hand:10</span><br><span class="line"> Your hand: 5s 6d th 9c 6s qs 7c 9d kh 2d</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/7 基本类型/" itemprop="url">
                  7 基本类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:39:48+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="7-1-整型"><a href="#7-1-整型" class="headerlink" title="7.1    整型"></a>7.1    整型</h2><blockquote>
<p><strong>可移植性技巧：</strong>对不超过32767的整数采用int或shaort int，其它情况下使用long int。<br><strong>注意：</strong>不要部分差别地使用长整型，因为长整型操作比较耗时。</p>
</blockquote>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>说明</th>
<th>bit（16位机器）</th>
<th>bit(32位机器)</th>
<th>数值范围(16位机器)</th>
<th>数值范围(32位机器)</th>
<th>有无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short [signed] int</code></td>
<td>短整型</td>
<td>16</td>
<td>16</td>
<td>-2^15~2^15-1</td>
<td>-2^15~2^15-1</td>
<td>有</td>
</tr>
<tr>
<td><code>short usigned int</code></td>
<td>无符号短整型</td>
<td>16</td>
<td>16</td>
<td>0~2^16-1</td>
<td>0~2^16-1</td>
<td>无</td>
</tr>
<tr>
<td><code>int [signed]</code></td>
<td>整型</td>
<td>16</td>
<td>32</td>
<td>-2^15~2^15-1</td>
<td>-2^31~2^31-1</td>
<td>有</td>
</tr>
<tr>
<td><code>int unsigned</code></td>
<td>无符号整型</td>
<td>16</td>
<td>32</td>
<td>0~2^16-1</td>
<td>0~2^32-1</td>
<td>无</td>
</tr>
<tr>
<td><code>long [signed]</code></td>
<td>长整型</td>
<td>32</td>
<td>32</td>
<td>-2^31~2^31-1</td>
<td>-2^31~2^31-1</td>
<td>有</td>
</tr>
<tr>
<td><code>long unsigned int</code></td>
<td>无符号长整型</td>
<td>32</td>
<td>32</td>
<td>0~2^32-1</td>
<td>0~2^32-1</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="7-1-1-整型常量"><a href="#7-1-1-整型常量" class="headerlink" title="7.1.1    整型常量"></a>7.1.1    整型常量</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>整数都是以二进制形式存储的，不会考虑实际的书写方式</li>
<li>任何时候都可以从一种书写方式切换到另一种，甚至可以混合使用</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>包含数字</th>
<th>写法</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td>0~9</td>
<td>不能以0开头</td>
<td>15 255</td>
<td></td>
</tr>
<tr>
<td>八进制</td>
<td>0~7</td>
<td>必须以0开头</td>
<td>017 0377</td>
<td></td>
</tr>
<tr>
<td>十六进制</td>
<td>0~9和字母a~f</td>
<td>字母部分大小写均可</td>
<td>0xf</td>
</tr>
</tbody>
</table>
<h4 id="长整型和无符号整型"><a href="#长整型和无符号整型" class="headerlink" title="长整型和无符号整型"></a>长整型和无符号整型</h4><blockquote>
<p><strong>注意：</strong>默认情况下编译器对处于int类型取值范围内的整数使用int类型，否则使用long int。</p>
</blockquote>
<table>
<thead>
<tr>
<th>后缀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>U(u)</td>
<td>指定常量为无符号整型</td>
</tr>
<tr>
<td>L(l)</td>
<td>指定常量为长整型</td>
</tr>
</tbody>
</table>
<h3 id="7-1-2-读／写整数"><a href="#7-1-2-读／写整数" class="headerlink" title="7.1.2    读／写整数"></a>7.1.2    读／写整数</h3><blockquote>
<p><strong>溢出：</strong>当程序付给变量的值太大以至于无法存储在int类型中时，这时值会被处理为不符合预期的值。</p>
</blockquote>
<h4 id="printf函数和scanf函数"><a href="#printf函数和scanf函数" class="headerlink" title="printf函数和scanf函数"></a><code>printf</code>函数和<code>scanf</code>函数</h4><p><strong>有符号整数</strong></p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>类型</th>
<th>进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>int</td>
<td>十进制</td>
</tr>
<tr>
<td>%hd</td>
<td>short signed int</td>
<td>十进制</td>
</tr>
<tr>
<td>%ld</td>
<td>long signed int</td>
<td>十进制</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%hd"</span>, &amp;s);<span class="comment">//写：短整型</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;l);<span class="comment">//写：长整型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%hd"</span>, s);<span class="comment">//读：短整型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld"</span>, l);<span class="comment">//读：长整型</span></span><br></pre></td></tr></table></figure>
<p><strong>无符号整数</strong></p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>类型</th>
<th>进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>十进制数字</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>八进制</td>
</tr>
<tr>
<td>%x</td>
<td>unsigned int</td>
<td>十六进制</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>, %u);<span class="comment">//写：无符号十进制</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>, u);<span class="comment">//读：无符号十进制</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-程序：数列求和（改进版）"><a href="#7-1-3-程序：数列求和（改进版）" class="headerlink" title="7.1.3    程序：数列求和（改进版）"></a>7.1.3    程序：数列求和（改进版）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sums a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program sums a series of intergers.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter intergers (0 to terminate:)"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		sum += n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The sun is:%d\n"</span>, sum);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-浮点数"><a href="#7-2-浮点数" class="headerlink" title="7.2    浮点数"></a>7.2    浮点数</h2><blockquote>
<p><strong>IEEE浮点标准：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>bit</th>
<th>最小正数</th>
<th>最大值</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32</td>
<td>1.17x10^-38</td>
<td>3.40x10^38</td>
<td>6个数字</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>2.22x0^-308</td>
<td>1.79x10^308</td>
<td>15个数字</td>
</tr>
<tr>
<td>long float</td>
<td>>=43</td>
<td>未说明</td>
<td>未说明</td>
<td>未说明</td>
</tr>
<tr>
<td>long double</td>
<td>>=79</td>
<td>未说明</td>
<td>未说明</td>
<td>未说明</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>c语言浮点数：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>浮点数</th>
<th>说明</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>当精度要求不严格时，float类型是很适合的类型</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>提供更高的精度，适合绝大多数</td>
</tr>
<tr>
<td>long double</td>
<td>扩展双精度浮点数</td>
<td>支持极高精度的要求，很少会用到</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>long double类型没有出现在IEEE标准中，其长度随机器的不同而变化，最常通用的尺寸是80位和128位</li>
</ol>
</blockquote>
<h3 id="7-2-1-浮点常量"><a href="#7-2-1-浮点常量" class="headerlink" title="7.2.1    浮点常量"></a>7.2.1    浮点常量</h3><blockquote>
<p><strong>语法：</strong>必须包含小数点或指数<br><strong>举个栗子：</strong>57.0的多种写法</p>
</blockquote>
<p><code>57.0</code> <code>57.</code> <code>57.0e0</code> <code>57E0</code> <code>5.7e1</code> <code>5.7e+1</code> <code>.57e2</code> <code>570.e-1</code></p>
<blockquote>
<p><strong>存储方式：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>情景</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认情况</td>
<td><code>double</code></td>
</tr>
<tr>
<td><code>浮点常量F(f)</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>浮点常量L(l)</code></td>
<td><code>long double</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong><code>double</code>类型的值在使用时，如果需要会自动转换为<code>float</code>类型的值。</p>
</blockquote>
<h3 id="7-2-2-读-些浮点数"><a href="#7-2-2-读-些浮点数" class="headerlink" title="7.2.2    读/些浮点数"></a>7.2.2    读/些浮点数</h3><table>
<thead>
<tr>
<th>浮点类型</th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
</tr>
<tr>
<td>double</td>
<td><code>%e</code> <code>%f</code> <code>%g</code></td>
<td><code>%le</code> <code>%lf</code> <code>%lg</code></td>
</tr>
<tr>
<td>long double</td>
<td><code>%Le</code> <code>%Lf</code> <code>%Lg</code></td>
<td><code>%Le</code> <code>%Lf</code> <code>%Lg</code></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%Lf"</span>, &amp;ld);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%Lf"</span>, ld);</span><br></pre></td></tr></table></figure>
<h2 id="7-3-字符型"><a href="#7-3-字符型" class="headerlink" title="7.3    字符型"></a>7.3    字符型</h2><blockquote>
<p><strong>char：</strong><code>Q&amp;A</code> <code>char</code>类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。<br><strong>ASCII字符集：</strong>用7位代码表示128个字符，一些计算机把ASCII码扩展为8位代码以便可以表示256个字符。<br><strong>字符常量：</strong>字符常量需要用单引号括起来，而不是双引号。<br><strong>将<code>char</code>当作整数：</strong>c语言会按小整数的方式处理字符，毕竟所有字符都是以二进制的形式进行编码的。在ASCII码中，字符的取值范围是0000000(0)~1111111(127)。</p>
<blockquote>
<p><strong>优点：</strong>利用字符和数相同的属性灵活处理字符，例如<code>for(ch = &#39;A&#39;; ch &lt;= &#39;Z&#39;; ch++) ...</code><br><strong>缺点：</strong></p>
<ol>
<li>导致编译器无法检查出的多种编程错误</li>
<li>编写出诸如<code>&#39;a&#39; * &#39;b&#39; / &#39;c&#39;</code>这类无意义的表达式</li>
<li>妨碍程序的可移植性（因为程序可能会基于一些对字符集的假设）</li>
</ol>
</blockquote>
<p><strong>有符号和无符号</strong></p>
<blockquote>
<p><strong>编译器行为：</strong>一些编译器按照有符号数据(-128~127)处理<code>char</code>，另一些则为无符号(0~255)<code>char</code>。设置有些编译器允许程序员通过编译器选项选择<code>char</code>时有符号型还是无符号型<br><strong>可移植性技巧：</strong>用<code>signed char</code>或<code>unsigned char</code>代替<code>char</code>。</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="string">'a'</span>;<span class="comment">//i is now 97</span></span><br><span class="line">ch = <span class="number">65</span>;<span class="comment">//ch is now 'A'</span></span><br><span class="line">ch = ch + <span class="number">1</span>;<span class="comment">//ch is now 'B'</span></span><br><span class="line">ch++;<span class="comment">//ch is now 'C'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果ch时小写字母，转为大写字母</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">	ch = ch - <span class="string">'a'</span> + <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-1-转义序列"><a href="#7-3-1-转义序列" class="headerlink" title="7.3.1    转义序列"></a>7.3.1    转义序列</h3><blockquote>
<p><strong>用途：</strong>c语言为了处理字符集中的每一个字符，提供了<code>转义字符</code>用来表示一些不可见或无法从键盘输入的字符。<br><strong>字符转义字符：</strong>没有包含所有无法打印的ASCII字符，只包含了最常用的字符。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>转移序列</th>
</tr>
</thead>
<tbody>
<tr>
<td>警报（响铃）符</td>
<td>\a</td>
</tr>
<tr>
<td>回退符</td>
<td><code>\b</code></td>
</tr>
<tr>
<td>换页符</td>
<td><code>\f</code></td>
</tr>
<tr>
<td>换行符</td>
<td><code>\n</code></td>
</tr>
<tr>
<td>回车符</td>
<td><code>\r</code></td>
</tr>
<tr>
<td>横向制表符</td>
<td><code>\t</code></td>
</tr>
<tr>
<td>纵向制表符</td>
<td><code>\v</code></td>
</tr>
<tr>
<td>反斜杠</td>
<td><code>\\</code></td>
</tr>
<tr>
<td>问号</td>
<td><code>\?</code></td>
</tr>
<tr>
<td>单引号</td>
<td><code>\&#39;</code></td>
</tr>
<tr>
<td>双引号</td>
<td><code>\&quot;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>数字转义字符：</strong>可以表示任何字符，突破<code>字符转义字符</code>的限制。<br><strong>转义字符常量：</strong>有8进制和16进制两种书写方式，需要用一对单引号括起来。</p>
</blockquote>
<table>
<thead>
<tr>
<th>进制</th>
<th>书写方式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制转义序列</td>
<td><code>\最多含有三位数字的八进制数</code></td>
<td>必须表示为无符号字符型</td>
</tr>
<tr>
<td>十六进制转义序列</td>
<td><code>\x十六进制数</code></td>
<td>标准c对于数字个数没有限制，<code>x</code>必须为小写，十六进制数无限制</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># define ESC '\33'	//用宏的方式定义数字转义字符常量</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>补充：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>其它序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>三字符序列（trigraph sequence）</td>
<td>一些特殊的ASCII字符的代码</td>
</tr>
<tr>
<td>多字节字符（multibyte character）</td>
<td></td>
</tr>
<tr>
<td>宽字符（nultibyte character）</td>
</tr>
</tbody>
</table>
<h3 id="7-3-2-字符处理函数"><a href="#7-3-2-字符处理函数" class="headerlink" title="7.3.2    字符处理函数"></a>7.3.2    字符处理函数</h3><blockquote>
<p><strong>toupper：</strong>c语言的toupper库函数，用来检测自身的参数是否是小写字母，如果是则将其转换成相应的大写字母。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">toupper</span>(ch)) == <span class="string">'A'</span>) ...</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-读-写字符"><a href="#7-3-3-读-写字符" class="headerlink" title="7.3.3    读/写字符"></a>7.3.3    读/写字符</h3><blockquote>
<p><strong>两种方式：</strong><code>printf</code>/<code>scanf</code>和<code>getChar</code>/<code>putchar</code></p>
</blockquote>
<h4 id="7-3-3-1-printf-和-scanf"><a href="#7-3-3-1-printf-和-scanf" class="headerlink" title="7.3.3.1    printf 和 scanf"></a>7.3.3.1    printf 和 scanf</h4><blockquote>
<p><strong>转换说明：</strong><code>%c</code><br><strong>技巧：</strong></p>
<ul>
<li>在格式串转换说明<code>%c</code>前面加一个空格，强制<code>scanf</code>函数在读入字符前跳过空白字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;ch);<span class="comment">//会跳过零个或多个空白字符</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通常情况下scanf函数不会跳过空白，所以很容易检查到输入行的结尾</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">&#125;<span class="keyword">while</span>(ch != <span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;hc);<span class="comment">//reads a single character</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);<span class="comment">//writes a single character</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-3-2-getchar-和-putchar"><a href="#7-3-3-2-getchar-和-putchar" class="headerlink" title="7.3.3.2    getchar 和 putchar"></a>7.3.3.2    getchar 和 putchar</h4><blockquote>
<p><strong>说明：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>库方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>getchar</td>
<td>读入一个字符并返回这个字符</td>
<td>不会跳过空白字符</td>
</tr>
<tr>
<td>putchar</td>
<td>用来单独写一个字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>执行速度快：</strong>比 scanf 和 printf 节约时间。</p>
<ol>
<li>这两个函数比scanf和prinf简单，因为scanf和prinf是设计用来读/写多种不同格式类型数据的</li>
<li>为了额外的速度提升，通常getchar函数和puchar函数是作为宏来实现的</li>
</ol>
<p><strong>可以应用多种不同的c语言惯用法：</strong>包括用循环搜索字符或跳过所有出现的统一字符。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环搜索字符</span></span><br><span class="line"><span class="keyword">while</span>(getchar != <span class="string">'\n'</span>)</span><br><span class="line">;</span><br><span class="line"><span class="comment">//跳过所有出现的统一字符</span></span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) == <span class="string">' '</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>避免混合使用<code>scanf</code>和<code>getchar</code>：</strong>scanf函数有一种留下后边字符的趋势，也就是说对于输入后面的字符只是看了一下，并没有读入。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter an interger:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">//读入i的同时，scanf函数调用将会留下后面没有消耗掉的人一字符，包括换行符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a command:"</span>);</span><br><span class="line">command = getchar();<span class="comment">//getchar会取回第一个声誉字符</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-4-程序：确定消息的长度"><a href="#7-3-4-程序：确定消息的长度" class="headerlink" title="7.3.4    程序：确定消息的长度"></a>7.3.4    程序：确定消息的长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determines the length a message</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a message:"</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		len ++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Your message was %d character(s) long.\n"</span>, len);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./length2 </span><br><span class="line"> Enter a message:1234567</span><br><span class="line"> Your message was 7 character(s) long.</span><br></pre></td></tr></table></figure>
<h2 id="7-4-sizeof运算符"><a href="#7-4-sizeof运算符" class="headerlink" title="7.4    sizeof运算符"></a>7.4    sizeof运算符</h2><blockquote>
<p><strong>说明：</strong>编译器本身就可以计算sizeof表达式的值，所以sizeof 是一种特殊的运算符（一元运算符）<br><strong>用途：</strong>用来计算制定类型值所需空间的大小。<br><strong>sizeof表达式：</strong><code>sizeof(类型名)</code><br><strong>参数：</strong>常量、变量或表达式<br><strong>优先级：</strong>高于二元运算符（比如+）<br><strong>返回值：</strong>字节数，类型由实现定义，通常是无符号整数<br><strong>圆括号：</strong>当应用于表示式时不需要圆括号，比如<code>sizeof i</code>，但是由于运算符优先级的问题，建议始终在sizeof表达式中采用圆括号。<br><strong>以<code>int</code>为例：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>处理器架构</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2(通常)</td>
</tr>
<tr>
<td>32</td>
<td>4(通常)</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把sizeof表达式转换成`unsigned long`(最大的无符号类型)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Size of int:%lu\n"</span>, (unsigned long)<span class="keyword">sizeof</span>(int));</span><br></pre></td></tr></table></figure>
<h2 id="7-5-类型转换"><a href="#7-5-类型转换" class="headerlink" title="7.5    类型转换"></a>7.5    类型转换</h2><blockquote>
<p><strong>计算机执行算术运算的限制：</strong>要求操作数大小相同，存储方式也相同。</p>
</blockquote>
<h2 id="7-5-1-隐式转换（implicit-conversion"><a href="#7-5-1-隐式转换（implicit-conversion" class="headerlink" title="7.5.1    隐式转换（implicit conversion)"></a>7.5.1    隐式转换（implicit conversion)</h2><blockquote>
<p><strong>说明：</strong>c语言允许在表达式中混合使用基本数据类型（整数、浮点数甚至是字符）。此时c语言编译器需要生成一些指令将某些操作数转换成不同类型，是的硬件可以对表达式进行计算。<br><strong>隐式转换情景：</strong></p>
<ul>
<li>当算术表达式或逻辑表达式中操作数的类型不相同时（常用算数转换）</li>
<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时</li>
<li>当函数调用中使用的参数类型与其对应的参数的类型不匹配时</li>
<li>当 return语句中表达式的类型和函数返回值的类型不匹配时</li>
</ul>
</blockquote>
<h3 id="7-5-1-常用算数转换"><a href="#7-5-1-常用算数转换" class="headerlink" title="7.5.1    常用算数转换"></a>7.5.1    常用算数转换</h3><blockquote>
<p><strong>原理：</strong>为了统一操作数的类型，通常可以将相对狭小的操作数转换成另一个操作数的类型来实现（即提升）。<br><strong>整型提升（integral promition）：</strong>把<code>char</code>或<code>short int</code>转换成<code>int</code>（或<code>unsigned int</code>）。</p>
<p><strong>两种情况：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>情况</th>
<th>提升方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>任一操作数的类型时浮点型的情况</td>
<td><code>long double&lt;-double&lt;-float</code></td>
</tr>
<tr>
<td>两个操作数都不是浮点型的情况</td>
<td><code>unsigned long int&lt;-long int&lt;-usigned int&lt;-int</code></td>
</tr>
<tr>
<td><code>long int</code>和<code>unsigned int</code></td>
<td>两个操作数都会转换成<code>usigned long int</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>尽量避免使用<code>unsigned int</code>，特别不要把它和有符号整数混合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i ,u;</span><br><span class="line">i = <span class="number">-10</span>;</span><br><span class="line">u = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int转换为usigned int时最高位的符号位不再是符号位</span></span><br><span class="line">i &lt; u;<span class="comment">//0，因为会进行隐式转换导致讲-10当作unsigned int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> ul;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line">i = i + c;<span class="comment">//c被转为int</span></span><br><span class="line">i = i + s;<span class="comment">//s被转为int</span></span><br><span class="line">u = u + i;<span class="comment">//i被转为unsigned int</span></span><br><span class="line">l = l + u;<span class="comment">//l被转为long int</span></span><br><span class="line">ul = ul + <span class="number">1</span>;<span class="comment">//l被转为unsigned long int</span></span><br><span class="line">f = f + ul;<span class="comment">//f被转为double</span></span><br><span class="line">d = d + f;<span class="comment">//f被转为double</span></span><br><span class="line">ld = ld + d;<span class="comment">//d被转为long double</span></span><br></pre></td></tr></table></figure>
<h3 id="7-5-2-赋值中的转换"><a href="#7-5-2-赋值中的转换" class="headerlink" title="7.5.2    赋值中的转换"></a>7.5.2    赋值中的转换</h3><blockquote>
<p><strong>转化规则：</strong>把赋值运算右边的表达式转换成左边变量的类型。</p>
</blockquote>
<h4 id="7-5-2-1-两边类型一样“宽”"><a href="#7-5-2-1-两边类型一样“宽”" class="headerlink" title="7.5.2.1    两边类型一样“宽”"></a>7.5.2.1    两边类型一样“宽”</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">i = c;<span class="comment">//c被转为int</span></span><br><span class="line">f = i;<span class="comment">//i被转为float</span></span><br><span class="line">d = f;<span class="comment">//f被转为double</span></span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-2-浮点数赋值给整型"><a href="#7-5-2-2-浮点数赋值给整型" class="headerlink" title="7.5.2.2    浮点数赋值给整型"></a>7.5.2.2    浮点数赋值给整型</h4><blockquote>
<p><strong>规则：</strong>去掉小数部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="number">842.97</span>;<span class="comment">//i为842</span></span><br><span class="line">i = <span class="number">-842.87</span>;<span class="comment">//i为-842</span></span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-3-溢出"><a href="#7-5-2-3-溢出" class="headerlink" title="7.5.2.3    溢出"></a>7.5.2.3    溢出</h4><blockquote>
<p><strong>说明：</strong><code>Q&amp;A</code>如果取值在变量类型范围之外，那么把值赋给一个狭小类型的变量将会得到无意义的结果（设置更糟）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c = <span class="number">10000</span>;</span><br><span class="line">i = <span class="number">1.0e20</span>;</span><br><span class="line">f = <span class="number">1.0e100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-3-强制类型转换"><a href="#7-5-3-强制类型转换" class="headerlink" title="7.5.3    强制类型转换"></a>7.5.3    强制类型转换</h3><blockquote>
<p><strong>强制转换表达式：</strong><code>（类型名）表达式</code><br><strong>优先级：</strong>被当作一元运算符，因此高于二元运算符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f, frac_part;</span><br><span class="line">frac_part = f - (int)f;<span class="comment">//获得浮点数f的小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> quotient;</span><br><span class="line"><span class="keyword">int</span> divided, divisor;</span><br><span class="line">quotient = (float)dividend / divisor;<span class="comment">//divisor会被迫使编译器把divisor也转换成为float类型。</span></span><br></pre></td></tr></table></figure>
<h2 id="7-6-类型定义"><a href="#7-6-类型定义" class="headerlink" title="7.6    类型定义"></a>7.6    类型定义</h2><blockquote>
<p><strong>语法：</strong><code>typedef 原本类型名 类型别名;</code><br><strong>说明：</strong>采用typedef定义类型别名会导致编译器将其加入到类型列表中。<br><strong>用途：</strong></p>
<ol>
<li>如果程序员使用有意义的类型名，会使程序更加易于理解</li>
<li>使程序更加易于维护</li>
<li>是编写可移植程序的一种重要工具</li>
</ol>
<p><strong>可移植性技巧：</strong>为了更大的可移植性，可以考虑使用<code>typedef</code>定义新的整型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在16位机器上</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line">Quantity q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在32位机器上</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line">Quantity q;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>编译器库中（可能）自带的类型定义：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> Dollars;</span><br><span class="line">Dollars cash_in, cash_out;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/6 循环/" itemprop="url">
                  6 循环
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T18:09:39+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="6-1-while语句"><a href="#6-1-while语句" class="headerlink" title="6.1    while语句"></a>6.1    while语句</h2><blockquote>
<p><strong>语法：</strong><code>while(表达式)语句</code></p>
<ul>
<li>圆括号强制要求，循环体外面的大括号不强制要求使用（多个语句除外）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-无限循环"><a href="#6-1-1-无限循环" class="headerlink" title="6.1.1    无限循环"></a>6.1.1    无限循环</h3><blockquote>
<p><strong>说明：</strong>如果控制表达式的值始终是非零值的话，while语句将无法终止。<br><strong>技巧：</strong>c语言程序员有时故意用非零常量作为控制表达式来构造无限循环。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) ...</span><br></pre></td></tr></table></figure>
<h3 id="6-1-2-程序：显示平方值的表格"><a href="#6-1-2-程序：显示平方值的表格" class="headerlink" title="6.1.2    程序：显示平方值的表格"></a>6.1.2    程序：显示平方值的表格</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of squares using a while statement</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"This program prints a table of ssquares.\n"</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of entries in table :"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> 	i = <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%10d%10d\n"</span>, i, i*i);</span><br><span class="line"> 		i++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./square                          </span><br><span class="line"> This program prints a table of ssquares.</span><br><span class="line"> Enter number of entries <span class="keyword">in</span> table :5</span><br><span class="line">         1         1</span><br><span class="line">         2         4</span><br><span class="line">         3         9</span><br><span class="line">         4        16</span><br><span class="line">         5        25</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-程序：数列求和"><a href="#6-1-3-程序：数列求和" class="headerlink" title="6.1.3    程序：数列求和"></a>6.1.3    程序：数列求和</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sums a series of numbers</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program sums a series of intergers.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter intergers (0 to terminate:)"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		sum += n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The sun is:%d\n"</span>, sum);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./sum </span><br><span class="line"> This program sums a series of intergers.</span><br><span class="line"> Enter intergers (0 to terminate:)1 2 3 4 0</span><br><span class="line"> The sun is:10</span><br></pre></td></tr></table></figure>
<h2 id="6-2-do语句"><a href="#6-2-do语句" class="headerlink" title="6.2    do语句"></a>6.2    do语句</h2><blockquote>
<p><strong>语法：</strong><code>do 语句 while(表达式);</code><br><strong>语句说明：</strong>do语句的本质就是while语句，只不过do语句是在每次执行循环体之后对控制表达式进行判定的。<br><strong>适用场景：</strong>至少要执行一次的循环体<br><strong>注意：</strong>最好所有的do语句都适用大括号，因为没有大括号的do语句很容易被误认为while语句。</p>
</blockquote>
<h3 id="程序：计算整数中数字的位数"><a href="#程序：计算整数中数字的位数" class="headerlink" title="程序：计算整数中数字的位数"></a>程序：计算整数中数字的位数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Calculates the number od digits in an interger</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> digits = <span class="number">0</span>, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter a nonnegative interger:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"> 	<span class="comment">//如果使用while循环，输入0将导致判断错误（认为0为0位数字）</span></span><br><span class="line"> 	<span class="keyword">do</span>&#123;</span><br><span class="line"> 		n /= <span class="number">10</span>;</span><br><span class="line"> 		digits++;</span><br><span class="line"> 	&#125;<span class="keyword">while</span>(n &gt; <span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"The number has %d digit(s).\n"</span>, digits);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./numdigit </span><br><span class="line"> Enter a nonnegative interger:20150621</span><br><span class="line"> The number has 8 digit(s).</span><br></pre></td></tr></table></figure>
<h2 id="6-3-for语句"><a href="#6-3-for语句" class="headerlink" title="6.3    for语句"></a>6.3    for语句</h2><blockquote>
<p><strong>语法：</strong><code>for (表达式1;表达式2;表达式3) 语句</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">10</span>;  i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"T minus %d and counting\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>while模拟for：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span>；</span><br><span class="line"><span class="keyword">while</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句</span><br><span class="line">    表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-1-for语句的惯用法"><a href="#6-3-1-for语句的惯用法" class="headerlink" title="6.3.1    for语句的惯用法"></a>6.3.1    for语句的惯用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从0向上加到n-1</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="comment">//从1向上加到n</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; n++)</span><br><span class="line"><span class="comment">//从n-1减到0</span></span><br><span class="line"><span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="comment">//从n减到1</span></span><br><span class="line"><span class="keyword">for</span>(i = n; i &gt; <span class="number">0</span>; i--)</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-在-for语句中省略表达式"><a href="#6-3-2-在-for语句中省略表达式" class="headerlink" title="6.3.2 在 for语句中省略表达式"></a>6.3.2 在 for语句中省略表达式</h3><table>
<thead>
<tr>
<th>省略</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>表达式1</td>
<td><code>for(; 表达式2; 表达式3)</code></td>
<td>执行循环前没有初始化的操作</td>
</tr>
<tr>
<td>表达式2</td>
<td><code>for(表达式1; ; 表达式3)</code></td>
<td>表达式2默认为真值，无限循环</td>
</tr>
<tr>
<td>表达式3</td>
<td><code>for(表达式1; 表达式2;)</code></td>
<td>循环体有责任确认第二个表达式的值最终回变为假</td>
</tr>
<tr>
<td>表达式1、3</td>
<td><code>for(;表达式2;)</code></td>
<td>同<code>while</code></td>
</tr>
<tr>
<td>表达式1、2、3</td>
<td><code>for(;;)</code></td>
<td>简单的无限循环</td>
</tr>
</tbody>
</table>
<h3 id="6-3-3-逗号运算符"><a href="#6-3-3-逗号运算符" class="headerlink" title="6.3.3    逗号运算符"></a>6.3.3    逗号运算符</h3><blockquote>
<p><strong>语法：</strong><code>表达式1,表达式2</code><br><strong>用途：</strong>为了在c语言要求单独一个表达式的情况下使用两个或多个表达式。<br><strong>使用场景：</strong>宏、<code>for</code>循环<br><strong>优先级：</strong>低于所有其它运算符。<br><strong>计算过程：</strong></p>
<ol>
<li>计算表达式1并且仍低哦计算出的值</li>
<li>计算表达式2，把这个值作为整个表达式的值</li>
</ol>
<p><strong>注意：</strong>计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。</p>
</blockquote>
<h3 id="6-2-4-程序：显示平方值的表格（改进版）"><a href="#6-2-4-程序：显示平方值的表格（改进版）" class="headerlink" title="6.2.4    程序：显示平方值的表格（改进版）"></a>6.2.4    程序：显示平方值的表格（改进版）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a table of squares using a for statement</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, n;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"This program prints a table of squares."</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of entries in table:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%10d%10d\n"</span>, i, i * i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-退出循环"><a href="#6-4-退出循环" class="headerlink" title="6.4    退出循环"></a>6.4    退出循环</h2><h3 id="6-4-1-break语句"><a href="#6-4-1-break语句" class="headerlink" title="6.4.1    break语句"></a>6.4.1    break语句</h3><blockquote>
<p><strong>作用：</strong>把程序从<code>switch</code>语句中转移出来；跳出<code>while</code>、<code>do</code>、<code>for</code>循环。<br><strong>注意：</strong>break只能跳出一层循环</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a number (enter 0 to stop):"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d cubed is %d\n"</span>, n, n*n*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-2-continue-语句"><a href="#6-4-2-continue-语句" class="headerlink" title="6.4.2    continue 语句"></a>6.4.2    continue 语句</h3><blockquote>
<p><strong>作用：</strong>把程序控制正号转移到循环结束之前的一点；只能用于循环。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">	sun += i;</span><br><span class="line">	n ++;</span><br><span class="line">	<span class="comment">/*continue jumps to here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-goto语句"><a href="#6-4-3-goto语句" class="headerlink" title="6.4.3    goto语句"></a>6.4.3    goto语句</h3><blockquote>
<p><strong>语法：</strong></p>
<ul>
<li>标号语句：<code>标识符 : 语句</code></li>
<li>goto语句：<code>goto 标识符</code></li>
</ul>
<p><strong>注意：</strong><code>break</code> <code>continue</code> <code>return</code>本质上都是受限制的goto语句，它们和<code>exit</code>函数配合可以应对大多数需要goto语句的情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(d = <span class="number">2</span>; d &lt; n; d++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n % d == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//goto语句</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标号语句</span></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span>(d &lt; n)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d is divisible by %d\n"</span>, n, d);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d is prime\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-4-程序：账目簿结算"><a href="#6-4-4-程序：账目簿结算" class="headerlink" title="6.4.4    程序：账目簿结算"></a>6.4.4    程序：账目簿结算</h3><h2 id="6-5-空语句"><a href="#6-5-空语句" class="headerlink" title="6.5    空语句"></a>6.5    空语句</h2><blockquote>
<p><strong>语法：</strong><code>;</code><br><strong>用途：</strong></p>
<ul>
<li>编写空循环体（在某些情况下帮助省略循环体）</li>
<li><code>goto</code>语句的标号不能独立存在，后面必须有语句，可以使用空语句</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(d =<span class="number">2</span>; d &lt; n &amp;&amp; n % d != <span class="number">0</span>; d++)</span><br><span class="line">;<span class="comment">/*empty body*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>建议将空语句单独放在一行，便于代码阅读。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/5 选择语句/" itemprop="url">
                  5 选择语句
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T17:51:28+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>c语言语句：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>语句</th>
</tr>
</thead>
<tbody>
<tr>
<td>return语句</td>
<td><code>return</code></td>
</tr>
<tr>
<td>表达式语句</td>
<td><code>表达式;</code></td>
</tr>
<tr>
<td>选择语句</td>
<td><code>if</code> <code>switch</code></td>
</tr>
<tr>
<td>循环语句</td>
<td><code>while</code> <code>do</code> <code>for</code></td>
</tr>
<tr>
<td>跳转语句</td>
<td><code>break</code> <code>continue</code> <code>goto</code></td>
</tr>
<tr>
<td>复合语句</td>
<td>几条语句组合成一个</td>
</tr>
<tr>
<td>空语句</td>
<td>不执行任何操作</td>
</tr>
</tbody>
</table>
<h2 id="5-1-逻辑表达式"><a href="#5-1-逻辑表达式" class="headerlink" title="5.1    逻辑表达式"></a>5.1    逻辑表达式</h2><blockquote>
<p><strong>注意：</strong>c语言没有<code>Boolean</code>类型，表达式的<code>真假</code>依赖于其结果是<code>0</code>或<code>非0</code>。</p>
</blockquote>
<h3 id="5-1-1-关系运算符"><a href="#5-1-1-关系运算符" class="headerlink" title="5.1.1    关系运算符"></a>5.1.1    关系运算符</h3><p><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code></p>
<blockquote>
<p><strong>操作数类型：</strong>可以用关系运算符比较整数和浮点数，以及混合类型的操作数。<br><strong>返回值：</strong>c语言的表达式中产生的结果是<code>0或1</code><br><strong>优先级于结合性：</strong>关系运算符的优先级低于算术运算符。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i &lt; j &lt; k;<span class="comment">//(i &lt; j) &lt; k</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-判等运算符"><a href="#5-1-2-判等运算符" class="headerlink" title="5.1.2    判等运算符"></a>5.1.2    判等运算符</h3><p><code>==</code> <code>!=</code></p>
<blockquote>
<p><strong>操作数类型：</strong>同关系运算符<br><strong>返回值：</strong>同关系运算符<br><strong>优先级于结合性：</strong>优先级低于关系运算符，左结合<br><strong>技巧：</strong>利用关系运算符和判等运算符返回整数值这一事实</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(i &gt;= j) + (i == j);<span class="comment">//0(大于),1(等于),2(小于)</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-逻辑运算符"><a href="#5-1-3-逻辑运算符" class="headerlink" title="5.1.3    逻辑运算符"></a>5.1.3    逻辑运算符</h3><p><code>&amp;&amp;</code> <code>\|\|</code> <code>!</code></p>
<blockquote>
<p><strong>操作数类型：</strong>真（任何非零值操作数），假（零值）。<br><strong>返回值：</strong>0（假）或1（真）。<br><strong>优先级于结合性：</strong><code>&amp;&amp;</code>和<code>||</code>优先级低于关系运算符和判等运算符，左结合；<code>!</code>优先级同<code>+(正)、-(负)</code>。<br><strong>注意：</strong><code>&amp;&amp;</code>和<code>||</code>都对运算符进行<code>短路</code>计算，也就是说，计算机先计算左侧的值，如果通过左侧的值推导出表达式的值就不需要运行计算右侧的值（操作数的副作用也不会发生）。</p>
</blockquote>
<h2 id="5-2-if语句"><a href="#5-2-if语句" class="headerlink" title="5.2    if语句"></a>5.2    if语句</h2><blockquote>
<p><strong>语法：</strong><code>if (表达式) 语句（单独一条）</code><br><strong>注意：</strong>为语句增加大括号或表达式使用圆括号有时并不是必需的，但会使程序更易读，使编译器更容易理解。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lent_num == MAX_LINES)&#123;</span><br><span class="line">	line_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-1-复合语句"><a href="#5-2-1-复合语句" class="headerlink" title="5.2.1    复合语句"></a>5.2.1    复合语句</h3><blockquote>
<p><strong>语法：</strong><code>if(表达式){语句1;语句2;...}</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lent_num == MAX_LINES)&#123;</span><br><span class="line">	line_num = <span class="number">0</span>;</span><br><span class="line">	page_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-else语句"><a href="#5-2-2-else语句" class="headerlink" title="5.2.2 else语句"></a>5.2.2 else语句</h3><blockquote>
<p><strong>语法：</strong><code>if(表达式) 语句 else 语句</code></p>
<h3 id="5-2-3-级联if语句"><a href="#5-2-3-级联if语句" class="headerlink" title="5.2.3    级联if语句"></a>5.2.3    级联if语句</h3><p><strong>语法：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n is less than 0\n"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"n is equal to 0\n"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"n is greter than 0\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-程序：计算股票经纪人的佣金"><a href="#5-2-4-程序：计算股票经纪人的佣金" class="headerlink" title="5.2.4    程序：计算股票经纪人的佣金"></a>5.2.4    程序：计算股票经纪人的佣金</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Calculate a broker's commission</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> commission, value;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter value of trade:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;value);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span> (value &lt; <span class="number">2500.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">30.00</span> + <span class="number">.017</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">6250.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">56.00</span> + <span class="number">.0066</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">20000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">76.00</span> + <span class="number">.0034</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">50000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">100.00</span> + <span class="number">.0022</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">500000.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">155.00</span> + <span class="number">.0011</span> * value;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 		commission = <span class="number">255.00</span> + <span class="number">.0009</span> * value;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(commission &lt; <span class="number">39.00</span>)&#123;</span><br><span class="line"> 		commission = <span class="number">39.00</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"commission:$%.2f\n\n"</span>, commission);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./broker </span><br><span class="line"> Enter value of trade:6000</span><br><span class="line"> commission:<span class="variable">$95</span>.60</span><br></pre></td></tr></table></figure>
<h3 id="5-2-5-“悬空else”的问题"><a href="#5-2-5-“悬空else”的问题" class="headerlink" title="5.2.5    “悬空else”的问题"></a>5.2.5    “悬空else”的问题</h3><blockquote>
<p><strong>规则：</strong>c语言遵循的规则是else字句应该属于离它最近的且还未和其他else匹配的if语句。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">		result = x / y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error:y is equal to 0\n"</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5-2-6-条件表达式"><a href="#5-2-6-条件表达式" class="headerlink" title="5.2.6    条件表达式"></a>5.2.6    条件表达式</h3><blockquote>
<p><strong>又名：</strong>三元运算符<br><strong>语法：</strong><code>表达式1 ? 表达式2 : 表达式3</code><br><strong>优先级：</strong>低于所有其它运算符<br><strong>使用场景：</strong>return语句、printf函数中、某些类型的宏定义<br><strong>注意：</strong>条件表达式使程序更加短小也更难以阅读，所以最好避免使用<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">k = i &gt; (j ? i : j) + j;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5-2-7-模拟布尔值"><a href="#5-2-7-模拟布尔值" class="headerlink" title="5.2.7    模拟布尔值"></a>5.2.7    模拟布尔值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL int</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(flag == TRUE) ...</span><br><span class="line"><span class="keyword">if</span>(flag == FALSE) ...</span><br><span class="line"><span class="keyword">if</span>(!flag) ...</span><br></pre></td></tr></table></figure>
<h2 id="5-3-switch语句"><a href="#5-3-switch语句" class="headerlink" title="5.3    switch语句"></a>5.3    switch语句</h2><blockquote>
<p><strong>语法：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式 : 多条语句</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> 常量表达式 : 多条语句</span><br><span class="line">	<span class="keyword">default</span> : 多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>特点：</strong></p>
<ol>
<li>不允许由重复的情况标号</li>
<li>对情况的顺序没有要求（default）不一定要放置在最后</li>
<li>不要求一定要有default，如果不匹配任何情况又没有default，则什么也不做</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制表达式</td>
<td>switch <code>控制表达式</code></td>
<td>整数或字符（也会被当作整数）</td>
</tr>
<tr>
<td>情况标号</td>
<td><code>case 常量表达式</code></td>
<td>常量表达式中只能存在常量（包括宏）</td>
</tr>
<tr>
<td>语句</td>
<td>每个情况标号后边任意数量的语句</td>
<td>c语言中少数几个不需要大括号的地方之一</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Passing"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"Failing"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal grade"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-1-break语句的作用"><a href="#5-3-1-break语句的作用" class="headerlink" title="5.3.1    break语句的作用"></a>5.3.1    break语句的作用</h3><blockquote>
<p><strong>说明：</strong>switch语句实际上是一种基于计算的跳转，如果没有break或其它跳转语句，程序控制将会从一种情况继续到下面一种情况。<br><strong>注意：</strong>break的故意省略需要明确指出以防某些人尝试修正“错误”。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		num_passing++;</span><br><span class="line">		<span class="comment">/*FALL THROUGH*/</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: total grades++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-程序：显示法定格式的日期"><a href="#5-3-2-程序：显示法定格式的日期" class="headerlink" title="5.3.2    程序：显示法定格式的日期"></a>5.3.2    程序：显示法定格式的日期</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a date in legal form</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> month, day, year;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter date (mm/dd/yy):"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d /%d /%d"</span>, &amp;month, &amp;day, &amp;year);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Dated this %d"</span>, day);</span><br><span class="line"> 	<span class="keyword">switch</span>(day)&#123;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">case</span> <span class="number">21</span>:<span class="keyword">case</span> <span class="number">31</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"st"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"nd"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"th"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">" day of "</span>);</span><br><span class="line"> 	<span class="keyword">switch</span>(month)&#123;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"January"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"February"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"Marth"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"April"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"May"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">"June"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">"July"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">"August"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">"September"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">10</span>: <span class="built_in">printf</span>(<span class="string">"October"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">11</span>: <span class="built_in">printf</span>(<span class="string">"November"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 		<span class="keyword">case</span> <span class="number">12</span>: <span class="built_in">printf</span>(<span class="string">"December"</span>);<span class="keyword">break</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">",20%.2d\n"</span>, year);</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ ./date                        </span><br><span class="line"> Enter date (mm/dd/yy):6/21/15          </span><br><span class="line"> Dated this 21st day of June,2015</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/09/4 表达式/" itemprop="url">
                  4	表达式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-09T16:41:12+08:00" content="2016-05-09">
              2016-05-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1    算数运算符"></a>4.1    算数运算符</h2><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号运算符</td>
<td>在<code>经典c</code>中不存在这种运算符，它主要用于强调某数值常量是正数</td>
</tr>
<tr>
<td>-</td>
<td>一元负号号运算符</td>
</tr>
</tbody>
</table>
<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>除<code>%</code>外，二元运算符允许操作数既可以是整数也可以是浮点数，或者是两者混合</li>
<li><code>int</code>类型的操作数和<code>float</code>型操作数混合在一起时，运算结果为<code>float</code>型</li>
<li>当<code>/</code>和<code>%</code>用于负操作数时，其结果与具体实现有关</li>
</ol>
<p><strong>由实现定义(implementtion-defined)：</strong>软件在特定的平台上编译、链接和执行，行为可能会稍有差异。这是c语言为了和硬件平台匹配追求高效率的结果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法运算符</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减法运算符</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>乘法运算符</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td>除法运算符</td>
<td>当两个操作数都是整数时，运算结果会向下取整</td>
</tr>
<tr>
<td>%</td>
<td>取余运算符</td>
<td>操作数要求都是整数，否则无法编译通过</td>
</tr>
</tbody>
</table>
<h3 id="4-1-1-运算符的优先级与结合性"><a href="#4-1-1-运算符的优先级与结合性" class="headerlink" title="4.1.1    运算符的优先级与结合性"></a>4.1.1    运算符的优先级与结合性</h3><blockquote>
<p><strong>注意：</strong>很少有程序员会费心记住优先级和结合性规则，而是在需要时参考运算符表或添加足够多的<code>()</code>。<br><strong>运算符优先级：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>最高优先级</td>
<td><code>+(负)</code> <code>-（正）</code>  <code>*</code> <code>/</code> <code>%</code></td>
</tr>
<tr>
<td>最低优先级</td>
<td><code>+(加)</code> <code>-(减)</code></td>
</tr>
</tbody>
</table>
<p><strong>结合性：</strong></p>
<ul>
<li>一元运算符都是右结合<code>(right assoiative)</code>的,即从右向左结合</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-+i;<span class="comment">//-(+i)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>二元运算符都是左结合<code>(left assoiative)</code>的，即从左向右结合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i-j-k;<span class="comment">//(i-j)-k</span></span><br><span class="line">+i+jk/;<span class="comment">//(+i)+(j/k)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-程序：计算通用产品代码的校验位"><a href="#4-1-2-程序：计算通用产品代码的校验位" class="headerlink" title="4.1.2    程序：计算通用产品代码的校验位"></a>4.1.2    程序：计算通用产品代码的校验位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Compaer a Universal Prouct Code check digit</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, first_sum, second_sum, total;</span><br><span class="line"> 	<span class="comment">/*输入左边第一位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter the first (single) digit:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line"> 	<span class="comment">/*输入2-6位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter first groun of value digits:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%1d%1d%1d%1d%1d"</span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;i5);</span><br><span class="line"> 	<span class="comment">/*输入7-11位数字*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter second group of five digits:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%1d%1d%1d%1d%1d"</span>, &amp;j1, &amp;j2, &amp;j3, &amp;j4, &amp;j5);</span><br><span class="line"> 	first_sum = d + i2 + i4 + j1 + j3 + j5;</span><br><span class="line"> 	second_sum = i1 + i3 + i5 + j2 + j4;</span><br><span class="line"> 	total = <span class="number">3</span> * first_sum + second_sum;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Check digit:%d\n"</span>, <span class="number">9</span> - ((total - <span class="number">1</span>) % <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./upc </span><br><span class="line"> Enter the first (single) digit:2</span><br><span class="line"> Enter first groun of value digits:23456</span><br><span class="line"> Enter second group of five digits:78954</span><br><span class="line"> Check digit:5</span><br></pre></td></tr></table></figure>
<h2 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2    赋值运算符"></a>4.2    赋值运算符</h2><blockquote>
<p><strong>注意：</strong>c语言的<code>=</code>不是<code>语句</code>，而是<code>运算符</code>。赋值表达式<code>v=e</code>的结果是v的值。</p>
</blockquote>
<h3 id="4-2-1-简单赋值"><a href="#4-2-1-简单赋值" class="headerlink" title="4.2.1    简单赋值"></a>4.2.1    简单赋值</h3><blockquote>
<p><strong>语法：</strong><code>v=e</code>，<code>e</code>可以是常量、变量或表达式。<br><strong>副作用：</strong>简单赋值运算符是已知的第一个有副作用的运算符，因为它会改变操作数的值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = j = k = <span class="number">0</span>;<span class="comment">//i = (j = k = 0)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="4-2-2-左值"><a href="#4-2-2-左值" class="headerlink" title="4.2.2    左值"></a>4.2.2    左值</h3><blockquote>
<p><strong>定义：</strong><code>Q&amp;A</code>左值表示存储在计算机内存中的对象，而不是常量和计算结果。例如变量。<br><strong>注意：</strong>赋值运算符要求左边的操作数必须是左值。</p>
</blockquote>
<h3 id="4-2-3-复合赋值"><a href="#4-2-3-复合赋值" class="headerlink" title="4.2.3    复合赋值"></a>4.2.3    复合赋值</h3><blockquote>
<p><strong>用途：</strong>简化利用变量原有值计算出新值，并重新赋值给这个变量的操作。<br><strong>列举：</strong>共10种</p>
</blockquote>
<table>
<thead>
<tr>
<th>+=</th>
<th>-=</th>
<th>*=</th>
<th>/=</th>
<th>%=</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><code>v += e</code>并不完全等同于<code>v = v + e</code>(优先级问题)</li>
</ol>
</blockquote>
<h2 id="4-3-自增运算符和自减运算符"><a href="#4-3-自增运算符和自减运算符" class="headerlink" title="4.3    自增运算符和自减运算符"></a>4.3    自增运算符和自减运算符</h2><blockquote>
<p><strong>和<code>i+=1</code>或<code>i-=1</code>的区别</strong>：</p>
<ol>
<li><code>++</code>和<code>--</code>既可以是前缀运算符，也可以是后缀运算符</li>
<li>和赋值运算符一样，<code>++</code>和<code>--</code>也有副作用：它会改变操作数的值</li>
</ol>
</blockquote>
<p><strong>前缀使用和后缀使用的区别：</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>语法</th>
<th>执行时机</th>
<th>优先级</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀方式</td>
<td><code>++i</code>或<code>--i</code></td>
<td>立即执行</td>
<td>和<code>一元正负号</code>优先级相同，右结合方式</td>
</tr>
<tr>
<td>后缀方式</td>
<td><code>i++</code>或<code>++i</code></td>
<td>稍后再执行</td>
<td>高于<code>一元正负号</code>，左结合方式</td>
<td><code>Q&amp;A</code>没有给出明确的时间，当会是下一条语句执行之前</td>
</tr>
</tbody>
</table>
<h2 id="4-4-表达式求值"><a href="#4-4-表达式求值" class="headerlink" title="4.4    表达式求值"></a>4.4    表达式求值</h2><h3 id="4-4-1-部分c语言运算符表"><a href="#4-4-1-部分c语言运算符表" class="headerlink" title="4.4.1    部分c语言运算符表"></a>4.4.1    部分c语言运算符表</h3><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-06-19%20%E4%B8%8B%E5%8D%888.44.42.png" alt="Alt text"></p>
<h3 id="4-4-2-为表达式添加圆括号"><a href="#4-4-2-为表达式添加圆括号" class="headerlink" title="4.4.2    为表达式添加圆括号"></a>4.4.2    为表达式添加圆括号</h3><blockquote>
<p><strong>过程：</strong>检查表达式，找到最高优先级地运算符后，用圆括号把运算符合相应的操作数括起来，圆括号的内容将被看成一个单独的操作数。然后重复此类操作指导表达式被完全加上圆括号。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&gt;start: start</span><br><span class="line">e=&gt;end: end</span><br><span class="line">op1=&gt;operation: a = b += c++ - d + --e / -f</span><br><span class="line">op2=&gt;operation: a = b += (c++) - d + (--e) / (-f)</span><br><span class="line">op3=&gt;operation: a = b += (c++) - d + ((--e) / (-f))</span><br><span class="line">op4=&gt;operation: a = b += ((c++) - d + (((--e) / (-f))))</span><br><span class="line">op5=&gt;operation: (a = b += ((c++) - d + (((--e) / (-f)))))</span><br><span class="line"></span><br><span class="line">s-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="4-4-3-子表达式的求值顺序"><a href="#4-4-3-子表达式的求值顺序" class="headerlink" title="4.4.3    子表达式的求值顺序"></a>4.4.3    子表达式的求值顺序</h3><blockquote>
<p><strong>注意：</strong>c语言并没有定义子表达式的求值顺序（<code>&amp;&amp;</code> <code>||</code> <code>条件运算符</code> <code>逗号运算符</code>除外）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span>;</span><br><span class="line">c = (b = a + <span class="number">2</span>) - (a = <span class="number">1</span>)<span class="comment">//c可能是6也可能是2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>建议：</strong>不在表达式种使用赋值运算符，而是采用一串分离的赋值表达式。</p>
</blockquote>
<h2 id="4-5-表达式语句"><a href="#4-5-表达式语句" class="headerlink" title="4.5    表达式语句"></a>4.5    表达式语句</h2><blockquote>
<p><strong>表达式转换为语句：</strong>任何表达式都可以通过添加分号转换为语句。<br><strong>注意：</strong>除非表达式有副作用，否则将表达式用作语句并没有任何意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i --;<span class="comment">//因为副作用的关系起到了作用</span></span><br><span class="line"></span><br><span class="line">i * j - <span class="number">1</span>;<span class="comment">//因为没有副作用，将该表达式作为语句使用没有任何意义</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/3 格式化输入／输出/" itemprop="url">
                  3 格式化输入／输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T22:48:34+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-1-printf函数"><a href="#3-1-printf函数" class="headerlink" title="3.1    printf函数"></a>3.1    printf函数</h2><blockquote>
<p><strong>语法：</strong><code>printf(格式串,表达式1,表达式2,...)</code><br><strong>转换说明（conversion specification）：</strong>以字符<code>%</code>开头，用来表示打印过程中填充了值的占位符。<code>%</code>后面的信息指定了把数值从内部（二进制）形式转换成打印（字符）形式的方法。<br><strong>注意：</strong></p>
<ol>
<li>单独调用一次prinf函数时可以打印的值的个数没有限制</li>
<li>c语言编译器不会检测格式串中转换说明的数据是否和输出项的数量相匹配</li>
<li>也不检测转换说明是否适合要显示项的数据类型</li>
</ol>
</blockquote>
<h3 id="3-1-1-转换说明"><a href="#3-1-1-转换说明" class="headerlink" title="3.1.1    转换说明"></a>3.1.1    转换说明</h3><blockquote>
<p><strong>格式：</strong><code>%m.pX</code>或<code>%-m.pX</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">含义</th>
<th style="text-align:left">必选</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">左对齐</td>
<td style="text-align:left">否</td>
<td>左对齐（默认右对齐）</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">minimum field width</td>
<td style="text-align:left">否</td>
<td>最小字段宽度</td>
<td>当<code>打印字符数&lt;m</code>时会根据对齐方式在前或后放置额外的空格；<code>打印字符数&gt;m</code>时字段宽度会自动扩展为需要的尺寸。</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">分隔</td>
<td style="text-align:left">否</td>
<td>分隔m和p，p存在时才存在</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">precision</td>
<td style="text-align:left">否</td>
<td>含义依赖于<code>X</code>的选择</td>
<td><code>d</code>(数字的最少个数，不够用0补够，默认1)；<code>e</code>(小数点后数字个数，默认6) ;<code>f</code>(同e); <code>g</code>(有效数字的最大数量)</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">conversion specifier</td>
<td style="text-align:left">是</td>
<td>在显示数值前对其进行那种转换</td>
<td><code>d</code>(十进制)；<code>e</code>(指数)；<code>f</code>(浮点数)<code>g</code>(根据数的大小决定指数形式还是浮点数形式)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>以上只就部分转换说明符进行了说明。</p>
</blockquote>
<h3 id="3-1-2-程序：用printf函数格式化数"><a href="#3-1-2-程序：用printf函数格式化数" class="headerlink" title="3.1.2    程序：用printf函数格式化数"></a>3.1.2    程序：用printf函数格式化数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints int and float values in various formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">float</span> x;</span><br><span class="line"></span><br><span class="line"> 	i = <span class="number">40</span>;</span><br><span class="line"> 	x = <span class="number">839.21</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"|%d|%5d|%-5d|%5.3d|\n"</span>, i, i, i, i);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"|%10.3f|%10.3e|%-10g|\n"</span>, x, x, x);</span><br><span class="line"></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./tprintf </span><br><span class="line"> |40|   40|40   |  040|</span><br><span class="line"> |   839.210| 8.392e+02|839.21    |</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-转义序列"><a href="#3-1-3-转义序列" class="headerlink" title="3.1.3    转义序列"></a>3.1.3    转义序列</h3><blockquote>
<p><strong>简介：</strong>通过使用<code>\</code>组合其它字符实现对字符的转义，转义字符使字符串包含一些特殊字符而又不会使编译器引发问题，包括非打印的控制字符和对编译器有特殊含义的字符（比如<code>&quot;</code>）。</p>
</blockquote>
<p><code>只提供部分</code></p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报（响铃）</td>
</tr>
<tr>
<td>\b</td>
<td>回退符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Item\tUnit\tPurpose\n\tPrice\tDate\n"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-2-scanf函数"><a href="#3-2-scanf函数" class="headerlink" title="3.2    scanf函数"></a>3.2    scanf函数</h2><blockquote>
<p><strong>语法：</strong><code>scanf(格式串, 表达式1, 表达式2, ...)</code><br><strong>注意：</strong></p>
<ul>
<li>编译器不会检查转换说明的数量与输入变量是否相匹配</li>
<li>编译器不会检查转换说明和对应输入变量格式是否合适</li>
<li>忘记在变量前放置符号<code>&amp;</code>将会产生不可预知的结果（比如变量没有初始化）</li>
</ul>
</blockquote>
<h3 id="3-2-1-scanf函数的工作方法"><a href="#3-2-1-scanf函数的工作方法" class="headerlink" title="3.2.1    scanf函数的工作方法"></a>3.2.1    scanf函数的工作方法</h3><blockquote>
<p><strong>简述：</strong>scanf函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成功。<br><strong>空白字符(white-space)：</strong>空格、横向（纵向）制表符、换页符、换行符。<br><strong>匹配规则：</strong></p>
<ol>
<li>从左边开始处理输入的字符串的信息</li>
<li>对格式串中的每一个转换说明，scanf函数努力从输入的数据中定位适当类型的项，并且跳过必要的空白符</li>
<li>遇到不可能属于当前转换说明的字符时结束对当前转换字符的匹配，并将已经匹配的字符赋值给对应变量</li>
<li>如果用户输入的字符都和当前转换说明不匹配，则不再查看格式串的剩余部分</li>
</ol>
</blockquote>
<h3 id="3-2-2-格式串中的普通字符"><a href="#3-2-2-格式串中的普通字符" class="headerlink" title="3.2.2    格式串中的普通字符"></a>3.2.2    格式串中的普通字符</h3><blockquote>
<p><strong>空白字符</strong>：当再格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符。<br><strong>其他字符：</strong>当格式串中国年遇到一个非空白字符时，scanf会把它与下一个输入字符进行比较。如果匹配则丢掉匹配的部分，并针对后面的输入及对应的格式串进行处理；否则异常退出。</p>
</blockquote>
<h3 id="3-2-3-混淆printf函数和scanf函数"><a href="#3-2-3-混淆printf函数和scanf函数" class="headerlink" title="3.2.3    混淆printf函数和scanf函数"></a>3.2.3    混淆printf函数和scanf函数</h3><p><strong>常见问题</strong></p>
<ul>
<li>在printf函数调用时在变量前面放置<code>&amp;</code></li>
<li>scanf中格式串中出现不必要的<code>\n</code>，导致交互程序会一直匹配用户输入的空白符</li>
</ul>
<h3 id="3-2-4-程序：计算持有的股票的价值"><a href="#3-2-4-程序：计算持有的股票的价值" class="headerlink" title="3.2.4    程序：计算持有的股票的价值"></a>3.2.4    程序：计算持有的股票的价值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes the value of stock holdings</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> price, shares;</span><br><span class="line"> 	<span class="keyword">float</span> num, denom, value;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter share price (must inclide a fraction):\n"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d%f/%f"</span>, &amp;price, &amp;num, &amp;denom);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter number of shares:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;shares);</span><br><span class="line"></span><br><span class="line"> 	value = (price + num / denom) * shares;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Value of holdings:$%.2f\n"</span>, value);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./stocks </span><br><span class="line"> Enter share price (must inclide a fraction):</span><br><span class="line"> 64 18/40</span><br><span class="line"> Enter number of shares:100</span><br><span class="line"> Value of holdings:<span class="variable">$6445</span>.00</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/2 c语言基本概念/" itemprop="url">
                  2 c语言基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T22:24:08+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2    c语言基本概念</p>
<h2 id="2-1-编写一个简单地c程序"><a href="#2-1-编写一个简单地c程序" class="headerlink" title="2.1    编写一个简单地c程序"></a>2.1    编写一个简单地c程序</h2><h3 id="2-1-1-程序：显示双关语"><a href="#2-1-1-程序：显示双关语" class="headerlink" title="2.1.1    程序：显示双关语"></a>2.1.1    程序：显示双关语</h3><blockquote>
<p><strong>注意：</strong>编译器往往要求文件的扩展名为<code>.c</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-编译和链接"><a href="#2-1-2-编译和链接" class="headerlink" title="2.1.2    编译和链接"></a>2.1.2    编译和链接</h3><blockquote>
<p><strong>预处理器（processor）：</strong>优点类似编辑器，它可以给程序添加内容，也可以对程序进行修改。<br><strong>指令（directive）：</strong>以<code>#</code>开头的命令，由预处理器执行为程序文件添加内容。<br><strong>目标代码（object code）：</strong>编译生成的机器指令（需要链接才能运行）<br><strong>编译器（complier）：</strong>在编译阶段将程序翻译成目标代码。比如UNIX下的<code>cc</code><br><strong>连接器（linker）：</strong>把编译产生的目标代码和任何其它附加代码整合在一起，生成可执行文件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 编写程序</span><br><span class="line">e=&gt;end: 执行</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 预处理：执行指令，引入相关代码</span><br><span class="line">op2=&gt;operation: 编译：将预处理后的代码翻译为目标代码</span><br><span class="line">op3=&gt;operation: 链接：整合目标代码和附加代码（包括库函数），生成完全可执行的程序</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure>
<h4 id="cc"><a href="#cc" class="headerlink" title="cc"></a>cc</h4><table>
<thead>
<tr>
<th>-o</th>
<th>允许为含有可执行程序的文件命名</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>使用技巧</strong></p>
<ul>
<li><strong>自动链接：</strong>使用<code>cc</code>进行编译时，系统会自动进行链接操作，不需要单独的链接命令</li>
<li><strong>可执行文件命名：</strong>默认为<code>文件名.out</code></li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cc -o pun pun.c<span class="comment"># 可执行文件名为pun</span></span><br></pre></td></tr></table></figure>
<h4 id="gcc-GNU-C-Complier）"><a href="#gcc-GNU-C-Complier）" class="headerlink" title="gcc(GNU C Complier）"></a>gcc(GNU C Complier）</h4><table>
<thead>
<tr>
<th>-Wall</th>
<th>使gcc比平常更彻底地检查程序并警告可能发生的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>简介：</strong>UNIX系统中最常用的编译器之一。<br><strong>自由软件基金会（Free Software Foundation, FSF）：</strong>由<code>Richard M.Stallman</code>创建，旨在对抗UNIX正版软件的使用限制和高额费用。重写了大量UNIX软件并免费发布。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -o pun pun.c</span><br></pre></td></tr></table></figure>
<h2 id="2-2-简单程序的通用形式"><a href="#2-2-简单程序的通用形式" class="headerlink" title="2.2    简单程序的通用形式"></a>2.2    简单程序的通用形式</h2><blockquote>
<p><strong>一般形式：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指令</span><br><span class="line">main()&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3个关键语言特性：</strong><code>指令</code> <code>函数</code> <code>语句</code></p>
</blockquote>
<h3 id="2-2-1-指令"><a href="#2-2-1-指令" class="headerlink" title="2.2.1    指令"></a>2.2.1    指令</h3><blockquote>
<p><strong>头文件：</strong>都包含一些标准库的内容<br><strong>语法：</strong></p>
<ol>
<li>所有的指令都以<code>#</code>开始，用以和c程序的其它代码进行区分</li>
<li>默认情况下指令是一行</li>
<li>在每条指令的结尾既没有分号也没有其它特殊标记</li>
</ol>
</blockquote>
<h3 id="2-2-2-函数"><a href="#2-2-2-函数" class="headerlink" title="2.2.2    函数"></a>2.2.2    函数</h3><blockquote>
<p><strong>定义：</strong>一系列组合在一起并且赋予了名字的语句<br><strong>分2类：</strong></p>
<ul>
<li>程序员编写的函数</li>
<li>编译器提供的库函数(<code>library function</code>)</li>
</ul>
</blockquote>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h4><blockquote>
<p><strong>简介：</strong>c程序可以包含多个函数，但前置规定必须有一个<code>main</code>函数<br><strong>特点：</strong></p>
<ul>
<li>在执行程序时系统会自动调用main函数</li>
<li>名字<code>main</code>是至关重要的，不能改写为<code>begin</code> <code>start</code>，甚至<code>MAIN</code></li>
</ul>
<p><strong>注意：</strong>建议在<code>main</code>函数末尾用一条<code>return</code>结束语句，<code>Q&amp;A</code>如果不这样做，某些编译器可能会产生一条警告信息。</p>
</blockquote>
<h3 id="2-2-3-语句"><a href="#2-2-3-语句" class="headerlink" title="2.2.3    语句"></a>2.2.3    语句</h3><blockquote>
<p><strong>定义：</strong>程序运行时执行的命令<br><strong>语法：</strong></p>
<ul>
<li>除复合语句和指令除外，每条语句都要用<code>;</code>结尾</li>
</ul>
</blockquote>
<h3 id="2-2-4-显示字符串"><a href="#2-2-4-显示字符串" class="headerlink" title="2.2.4    显示字符串"></a>2.2.4    显示字符串</h3><blockquote>
<p><strong>字符串字面量：</strong>用一对双引号保卫的一系列字符<br><code>printf</code>：不会自动跳转到下一行（除非在末尾添加<code>\n</code>）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"To, or not to c:"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"that is the question.\n:"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3    注释"></a>2.3    注释</h2><blockquote>
<p><strong>语法：</strong><code>/**/</code>，可以出现在程序的任何位置，单独占行或和其它程序放在同一行。</p>
</blockquote>
<h3 id="2-3-1-文档说明"><a href="#2-3-1-文档说明" class="headerlink" title="2.3.1    文档说明"></a>2.3.1    文档说明</h3><h4 id="2-3-1-1-举个栗子"><a href="#2-3-1-1-举个栗子" class="headerlink" title="2.3.1.1    举个栗子"></a>2.3.1.1    举个栗子</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Name:	pun.c 			 */</span></span><br><span class="line"><span class="comment">/* Purpose:	Prints a bad pun */</span></span><br><span class="line"><span class="comment">/* Author:	K. N. King		 */</span></span><br><span class="line"><span class="comment">/* Date written:	5/21/95	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To c, or not to c:that is the question.\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-2-其它形式"><a href="#2-3-1-2-其它形式" class="headerlink" title="2.3.1.2    其它形式"></a>2.3.1.2    其它形式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span><br><span class="line"> * Name:	pun.c 			  *</span><br><span class="line"> * Purpose:	Prints a bad pun  *</span><br><span class="line"> * Author:	K. N. King		  *</span><br><span class="line"> * Date written:	5/21/95	  *</span><br><span class="line"> * ****************************/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* Name:	pun.c 	</span><br><span class="line">* Purpose:	Prints a bad pun </span><br><span class="line">* Author:	K. N. King	</span><br><span class="line">* Date written:	5/21/95	 </span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-翼型注释"><a href="#2-3-2-翼型注释" class="headerlink" title="2.3.2    翼型注释"></a>2.3.2    翼型注释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()<span class="comment">/* Beginning of main program */</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-变量和赋值"><a href="#2-4-变量和赋值" class="headerlink" title="2.4    变量和赋值"></a>2.4    变量和赋值</h2><h3 id="2-4-1-类型"><a href="#2-4-1-类型" class="headerlink" title="2.4.1    类型"></a>2.4.1    类型</h3><blockquote>
<p><strong>简介：</strong>类型用来寿命变量所存储的数据的种类。类型会影响变量的存储方式，所以选择合适的类型非常关键。</p>
<h4 id="int和float"><a href="#int和float" class="headerlink" title="int和float"></a><code>int</code>和<code>float</code></h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>速度</th>
<th>存储</th>
<th>取值特点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>整数</td>
<td>较快</td>
<td>占用少</td>
<td>取值范围小</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>浮点数</td>
<td>较慢</td>
<td>占用多</td>
<td>取值范围大</td>
<td>存储的数值往往只是数值的近似值，存在摄入误差</td>
</tr>
</tbody>
</table>
<h3 id="2-4-2-声明"><a href="#2-4-2-声明" class="headerlink" title="2.4.2    声明"></a>2.4.2    声明</h3><p><strong>语法：</strong></p>
<ul>
<li>每条声明都要以<code>;</code>结尾</li>
<li>声明多个相同类型的变量时，中间用<code>,</code>隔开</li>
</ul>
<p><strong>建议：</strong>在声明和语句之间留出空白。<br><strong>注意：</strong><code>main</code> 函数包含声明时，必须把声明放置在语句之前。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  声明</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-4-3-赋值"><a href="#2-4-3-赋值" class="headerlink" title="2.4.3    赋值"></a>2.4.3    赋值</h3><blockquote>
<p><strong>语法：</strong><code>变量 = 表达式</code><br><strong>表达式：</strong>赋值运算的右侧的包含常量、变量和运算符的公式。</p>
</blockquote>
<h3 id="2-4-4-显示变量的值"><a href="#2-4-4-显示变量的值" class="headerlink" title="2.4.4    显示变量的值"></a>2.4.4    显示变量的值</h3><blockquote>
<p><strong>方式：</strong>通过<code>printf</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Height: %d Length: %d\n"</span>, height, length);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-程序：计算箱子的空间重量"><a href="#2-4-5-程序：计算箱子的空间重量" class="headerlink" title="2.4.5    程序：计算箱子的空间重量"></a>2.4.5    程序：计算箱子的空间重量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Name:	pun.c 			 */</span></span><br><span class="line"><span class="comment">/* Purpose:	Prints a bad pun */</span></span><br><span class="line"><span class="comment">/* Author:	K. N. King		 */</span></span><br><span class="line"><span class="comment">/* Date written:	5/21/95	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height, length, width, volume, weight;</span><br><span class="line">	</span><br><span class="line">	height = <span class="number">8</span>;</span><br><span class="line">	length = <span class="number">12</span>;</span><br><span class="line">	width = <span class="number">10</span>;</span><br><span class="line">	volume = height * length * width;</span><br><span class="line">	weight = (volume + <span class="number">165</span>) / <span class="number">166</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensions: %dx%dx%d\n"</span>, length, width, height);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"volume(cubic inches):%d\n"</span>, volume);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensional weight (pounds):%d\n"</span>, weight);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -o pun pun.c</span><br><span class="line">$ ./pun</span><br><span class="line"> Dimensions: 12x10x8</span><br><span class="line"> volume(cubic inches):960</span><br><span class="line"> Dimensional weight (pounds):6</span><br></pre></td></tr></table></figure>
<h3 id="2-4-6-初始化"><a href="#2-4-6-初始化" class="headerlink" title="2.4.6    初始化"></a>2.4.6    初始化</h3><blockquote>
<p><strong>初始化式（initializer）：</strong>在变量声明中加入初始值。<br><strong>注意：</strong>程序开始执行时，默契热情况下某些变量会自动设置为零，而大多数变量则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> height, length = <span class="number">12</span>, width = <span class="number">12</span>;<span class="comment">/*其中第一个个变量的值未知*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-7-显示表达式的值"><a href="#2-4-7-显示表达式的值" class="headerlink" title="2.4.7    显示表达式的值"></a>2.4.7    显示表达式的值</h3><p><code>在任何需要数值的地方，都可以使用具有相同类型的表达式。</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prinf(<span class="string">"%d\n"</span>, height * length * width);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-读入输入"><a href="#2-5-读入输入" class="headerlink" title="2.5    读入输入"></a>2.5    读入输入</h2><blockquote>
<p><code>scanf</code>:和<code>printf</code>相对应的c库函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);<span class="comment">/*读入一个整数给i*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;x);<span class="comment">/*读入一个float数值给x*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="程序：计算箱子的空间重量（改进版）"><a href="#程序：计算箱子的空间重量（改进版）" class="headerlink" title="程序：计算箱子的空间重量（改进版）"></a>程序：计算箱子的空间重量（改进版）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Computes the dimensioal weight of a box</span><br><span class="line"> * from input provided by the user</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height, length, width, volume, weight;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter height of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;height);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter length of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter width of box:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;width);</span><br><span class="line"></span><br><span class="line">	volume = height * length * width;</span><br><span class="line">	weight = (volume + <span class="number">165</span>) / <span class="number">166</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"volume(cubic inches):%d\n"</span>, volume);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dimensional weight (pounds):%d\n"</span>, weight);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./dweight2 </span><br><span class="line"> Enter height of box:2</span><br><span class="line"> Enter length of box:3</span><br><span class="line"> Enter width of box:4</span><br><span class="line"> volume(cubic inches):24</span><br><span class="line"> Dimensional weight (pounds):1</span><br></pre></td></tr></table></figure>
<h2 id="2-6-定义常量"><a href="#2-6-定义常量" class="headerlink" title="2.6    定义常量"></a>2.6    定义常量</h2><blockquote>
<p><strong>宏定义（macro definition）：</strong>对程序进行预处理时，预处理器会把每一个宏用其表示的值替换回来。<br><strong>语法：</strong><code># define 宏变量名 字面量或表达式</code><br><strong>注意：</strong></p>
<ul>
<li>常量的名字使用大写字母（沿用了10几年的规范）</li>
<li>当宏包含运算符时，必须使用括号把表达式括起来</li>
</ul>
</blockquote>
<h3 id="程序：华氏温度转换为摄氏温度"><a href="#程序：华氏温度转换为摄氏温度" class="headerlink" title="程序：华氏温度转换为摄氏温度"></a>程序：华氏温度转换为摄氏温度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************</span><br><span class="line"> * Converts a Fahrenheit temperature to Celsius *</span><br><span class="line"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">define</span> FREEZING_PT  32.0</span></span><br><span class="line"> <span class="meta"># <span class="meta-keyword">define</span> SCALE_FACTOR (5.0 / 9.0)<span class="comment">/*如果是(5/9)结果为0*/</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">float</span> fahrenheit, celsius;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter Fahrenheit temperature:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;fahrenheit);</span><br><span class="line"></span><br><span class="line"> 	celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;<span class="comment">/*温度转换*/</span></span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Celsius equivalent:%.1f\n"</span>, celsius);<span class="comment">/*保留小数点后一位*/</span></span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./celsius </span><br><span class="line"> Enter Fahrenheit temperature:32</span><br><span class="line"> Celsius equivalent:0.0</span><br></pre></td></tr></table></figure>
<h2 id="2-7-标识符"><a href="#2-7-标识符" class="headerlink" title="2.7    标识符"></a>2.7    标识符</h2><blockquote>
<p><strong>定义：</strong>变量、函数］宏和其他尸体的名字成为标识符(identifier)。<br><strong>规则：</strong></p>
<ol>
<li>可以包含字母、数字和下划线</li>
<li>必须以字母或者下划线开头</li>
<li>区分大小写</li>
<li><code>Q&amp;A</code>标准C对标识符的最大长度没有限制</li>
<li>不能使用<code>关键字</code>作为标识符<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-06-16%20%E4%B8%8B%E5%8D%882.54.55.png" alt="Alt text"></li>
</ol>
</blockquote>
<h2 id="2-8-c语言程序的布局"><a href="#2-8-c语言程序的布局" class="headerlink" title="2.8    c语言程序的布局"></a>2.8    c语言程序的布局</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>语句可以划分在任意多行内</li>
<li>记号间的空格应该便于肉眼区别记号。因此通常在每个运算符的前后都放上一个空格。</li>
<li>缩进有助于轻松识别程序嵌套</li>
<li>空行可以把程序划分成逻辑单元，从而使读者更容易辨别程序的结构。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/08/1 c语言概述/" itemprop="url">
                  1 c语言概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-08T21:47:27+08:00" content="2016-05-08">
              2016-05-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-c语言的历史"><a href="#1-1-c语言的历史" class="headerlink" title="1.1    c语言的历史"></a>1.1    c语言的历史</h2><h3 id="1-1-1-起源"><a href="#1-1-1-起源" class="headerlink" title="1.1.1    起源"></a>1.1.1    起源</h3><blockquote>
<p><strong>简介：</strong>c语言是在贝尔实验室由<code>Ken Thompson</code> <code>Dennis Ritchie</code>及其同事在开发UNIX操作系统的过程中的副产品。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 1969</span><br><span class="line">e=&gt;end: 1973</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: Thompson独自动手使用汇编语言编写了UNIX操作系统的最初版本</span><br><span class="line">op2=&gt;operation: Thompson在BCPL语言（基于ALGOL 60）的基础上开发B语言</span><br><span class="line">op3=&gt;operation: 1970年，B语言经过改进运行在PDP-11上</span><br><span class="line">op4=&gt;operation: 1971年，B语言暴露出不适合PDP-11的问题</span><br><span class="line">op5=&gt;operation: Ritchie开始开发B语言的升级版，NB</span><br><span class="line">op6=&gt;operation: NB越来越脱离B,改名C语言</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-标准化"><a href="#1-1-2-标准化" class="headerlink" title="1.1.2    标准化"></a>1.1.2    标准化</h3><blockquote>
<p><strong>注意：</strong>c语言目前最新标准是1999年修订的<code>C99</code>(ISO 9899:1999)，但目前没有得到广发应用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 1978</span><br><span class="line">e=&gt;end: 1990</span><br><span class="line">op1=&gt;operation: 1978年，《The C Programming Language》第一版出版，成为事实标准，即经典C(K&amp;R C)</span><br><span class="line">op2=&gt;operation: 1983年，ANSI开始编制C语言标准</span><br><span class="line">op3=&gt;operation: 1988年，经过多次修订，C语言标准完成</span><br><span class="line">op4=&gt;operation: 1989年12月通过，成为ANSI标准X3.159-1989</span><br><span class="line">op5=&gt;operation: 1990年，ISO通过此项标准，成为ISO/IEC 9899-1990国际标准，即标准C(ANSI C或ANSI/ISO C)</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-C-语言"><a href="#1-1-3-C-语言" class="headerlink" title="1.1.3    C++语言"></a>1.1.3    C++语言</h3><blockquote>
<p><strong>相关：</strong><code>Concurrent C</code> <code>Object C</code> <code>C++</code><br><strong>C++简介：</strong>贝尔实验室的<code>Bjarne Stroustrup</code>设计，在许多方面对C语言进行扩展，支持面向对象。<br><strong>为什么不直接学习c++：</strong></p>
<ul>
<li>+c++语言比c语言更加难学，最好先精通c</li>
<li>存在大量c语言代码需要维护</li>
<li>并不是所有场景都适合c++</li>
</ul>
</blockquote>
<h2 id="1-2-C语言的优缺点"><a href="#1-2-C语言的优缺点" class="headerlink" title="1.2    C语言的优缺点"></a>1.2    C语言的优缺点</h2><blockquote>
<ul>
<li>c语言是一种低级语言</li>
<li>c语言是一种小型语言</li>
<li>c语言是一种包容性语言</li>
</ul>
</blockquote>
<h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1    优点"></a>1.2.1    优点</h3><ul>
<li>高效性</li>
<li>可移植</li>
<li>功能强大</li>
<li>灵活性</li>
<li>标准库</li>
<li>与UNIX系统的集成</li>
</ul>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ul>
<li>c语言可能会漏洞百出</li>
<li>c程序可能会难以理解</li>
<li>c程序可能会难以修改</li>
</ul>
<h3 id="1-2-3-高效地使用c语言"><a href="#1-2-3-高效地使用c语言" class="headerlink" title="1.2.3    高效地使用c语言"></a>1.2.3    高效地使用c语言</h3><ul>
<li>学习如何规避c语言地缺陷</li>
<li>使用软件工具使程序更加可靠</li>
<li>利用现有地代码库</li>
<li>采用一套切合实际地编码规范</li>
<li>避免“投机取巧”和极度复杂地代码</li>
<li>避免不可移植性</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">85</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
