<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/8/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/8/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="url">
                  2 对c的扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T22:36:43+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_02  对C的扩展/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_02  对C的扩展/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-1-最简单的-Objective-C-程序"><a href="#2-1-最简单的-Objective-C-程序" class="headerlink" title="2.1   最简单的 Objective-C 程序"></a>2.1   最简单的 Objective-C 程序</h2><blockquote>
<p><strong>说明：</strong>项目创建过程如下</p>
<ol>
<li>创建 workspace：File-New-Workspace</li>
<li>创建 project：File-New-&gt;Project</li>
</ol>
<ul>
<li>选择模版：OS X-&gt;Applicetion-&gt; Command Line</li>
<li>选择语言：Object-C</li>
<li>选择 Workspace</li>
</ul>
</blockquote>
<h2 id="2-2-解构-Hello-Objective-C-程序"><a href="#2-2-解构-Hello-Objective-C-程序" class="headerlink" title="2.2   解构 Hello Objective-C 程序"></a>2.2   解构 Hello Objective-C 程序</h2><blockquote>
<p><strong>默认编译器：</strong> XCode 的默认编译器为<code>LLVM</code>，可以处理<code>C</code>（.c文件）、<code>C++</code>（.cpp）、<code>Objective-C</code>（.m）。<br><strong>扩展：</strong>扩展名<code>.m</code>代表<code>message</code>，它值得是<code>Object-C</code>的一个主要特征。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O-C 支持的模块导入方式</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main 的声明语句和结尾的 return 语句和 C 一样</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-1-import-语句"><a href="#2-2-1-import-语句" class="headerlink" title="2.2.1    #import 语句"></a>2.2.1    #import 语句</h3><blockquote>
<p><strong>功能：</strong>通知编译器查询头文件中相应的代码并导入，一个文件中只会被包含一次（无论调用多少次<code>#import</code>语句）<br><strong>说明：</strong>相比<code>C</code>的<code>#include</code>，<code>#import</code>能避免文件相互包含的情况导致的错误（<code>C</code>语言通过<code>ifdef</code>实现）。<br><strong>注意：</strong><code>Foundation</code>框架的头文件占用了近1MB的磁盘空间，使用<code>#import &lt;Foundation/Foundation.h&gt;</code>包含头文件时，Xcode使用<code>预编译头文件</code>加快读取速度。</p>
</blockquote>
<h3 id="2-2-2-框架"><a href="#2-2-2-框架" class="headerlink" title="2.2.2    框架"></a>2.2.2    框架</h3><blockquote>
<p><strong>框架：</strong>是一种把<code>头文件、库、图片、声音等内容</code>聚集在一个独立单元中的集合体。<br><strong>框架集：</strong>一系列框架的集合。</p>
</blockquote>
<h4 id="苹果公司提供的框架集"><a href="#苹果公司提供的框架集" class="headerlink" title="苹果公司提供的框架集"></a>苹果公司提供的框架集</h4><blockquote>
<p><strong>说明：</strong>苹果公司将<code>Cocoa</code>、<code>Carbon</code>、<code>QuickTime</code>、<code>OpenGL</code>等技术作为框架集来提供。<br><strong>Cocoa框架集：</strong>包括以下框架</p>
<ul>
<li>Foundation</li>
<li>Application Kit（简称AppKit）</li>
<li>支持性框架（Core Animation 和 Core Image）</li>
</ul>
<p><strong>扩展：</strong><a href="">Learn Cocoa On The Mac</a></p>
</blockquote>
<h3 id="2-2-3-NSLog-和-quot-字符串-quot"><a href="#2-2-3-NSLog-和-quot-字符串-quot" class="headerlink" title="2.2.3    NSLog()和@&quot;字符串&quot;"></a>2.2.3    <code>NSLog()</code>和<code>@&quot;字符串&quot;</code></h3><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>给其所有函数、常量和类型名都添加了<code>NS前缀</code>（使用<code>NS</code>而不是<code>Cocoa</code>源自历史遗留：<code>Cocoa</code>的前身为<code>NextSTEP</code>工具包）。</p>
</blockquote>
<h4 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h4><blockquote>
<p><strong>说明：</strong>用于向控制台输出内容<br><strong>原型：</strong><code>NSObjCRuntime.h</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">** @param &#123;NSString *&#125; format 字符串（可以包含格式说明符） </span><br><span class="line">** @param &#123;...&#125; 对应格式串中格式说明符可变参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...)</span><br></pre></td></tr></table></figure></p>
<p><strong>技巧：</strong>建议在<code>O-C</code>中使用<code>NSLog</code>替代<code>printf</code>，因为它添加了一些特性，比如</p>
<ul>
<li>时间戳</li>
<li>日期戳</li>
<li>自动附带换行符<code>\n</code>等</li>
</ul>
</blockquote>
<h4 id="NSString-quot-字符串-quot"><a href="#NSString-quot-字符串-quot" class="headerlink" title="NSString(@&quot;字符串&quot;)"></a>NSString(<code>@&quot;字符串&quot;</code>)</h4><blockquote>
<p><strong>说明：</strong><code>Cocoa</code>提供的<code>NSString</code>集成了大量<code>C</code>语言字符串没有的特性。<code>@&quot;字符串&quot;</code>表明其中的<code>字符串</code>作为<code>Cocoa</code>的<code>NSString</code>元素来处理。</p>
<ul>
<li>字符串的长度</li>
<li>字符串比较</li>
<li>转换为整数和浮点数</li>
</ul>
<p><strong>格式串：</strong>输出对象使用<code>%@</code>，会调用对象的<code>description</code>方法</p>
</blockquote>
<h2 id="2-3-布尔类型"><a href="#2-3-布尔类型" class="headerlink" title="2.3   布尔类型"></a>2.3   布尔类型</h2><blockquote>
<p><strong>关键字：</strong><code>BOOL</code>(比<code>C</code>语言的<code>bool</code>早十多年)<br><strong>说明：</strong>本质是<code>signed char</code>（通过<code>typedef</code>定义），使用8位存储空间</p>
<ul>
<li><code>NO</code>：本质是<code>signed char</code>值0</li>
<li><code>YES</code>：本质是<code>signed char</code>值1</li>
</ul>
<p><strong>注意：</strong><code>O-C</code>的<code>BOOL</code>不仅能保存<code>NO</code>和<code>YES</code>，编译器将其作为<code>8位二进制数</code>处理，也就是说可以赋值其它整数和<code>char</code>类型值（大于一个字节将溢出）。</p>
</blockquote>
<h3 id="2-3-1-BOOL-强大的实用功能"><a href="#2-3-1-BOOL-强大的实用功能" class="headerlink" title="2.3.1    BOOL 强大的实用功能"></a>2.3.1    BOOL 强大的实用功能</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较两个 int 型值是否相等</span><br><span class="line"> * @param &#123;int&#125; thing1 第一个值</span><br><span class="line"> * @param &#123;int&#125; thing2 第二个值</span><br><span class="line"> * @return &#123;BOOL&#125; YES 相等， NO 不相等</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> areIntsDifferent (<span class="keyword">int</span> thing1, <span class="keyword">int</span> thing2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thing1 == thing2) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NO</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 输出 BOOL 值对应的描述</span><br><span class="line"> * @param &#123;BOOL&#125; yesNo BOOL值</span><br><span class="line"> * @return &#123;NSString&#125; YES "YES", NO "NO"</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *boolString (<span class="built_in">BOOL</span> yesNo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (yesNo == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"NO"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">@"YES"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> areTheyDifferent;</span><br><span class="line">    <span class="comment">// 调用areTheDifferent函数</span></span><br><span class="line">    areTheyDifferent = areIntsDifferent(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 调用boolString函数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"are %d and %d different? %@"</span>, <span class="number">5</span>, <span class="number">5</span>, boolString(areTheyDifferent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4   小结"></a>2.4   小结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/o-c基础教程第二版_01 启程/" itemprop="url">
                  1 启程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T11:14:49+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/o-c基础教程第二版_01 启程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/o-c基础教程第二版_01 启程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-预备知识"><a href="#1-1-预备知识" class="headerlink" title="1.1 预备知识"></a>1.1 预备知识</h2><h2 id="1-2-历史"><a href="#1-2-历史" class="headerlink" title="1.2 历史"></a>1.2 历史</h2><blockquote>
<p><strong>Objective-C：</strong>20世纪80年代，<code>Brad Cox</code>为了融合流行的、可移植的<code>C语言</code>和<code>Smalltalk语言</code>的优势，设计出了<code>Objective-C语言</code>。 <strong>NeXT公司：</strong>1985年，<code>史蒂夫.乔布斯</code>创建，致力于创建功能强大且经济实惠的工作站。<br><strong>NextSTEP：</strong>使用<code>Object-C</code>开发的一款功能强大的用户界面工具包。 <strong>Cocoa：</strong>1996年，苹果收购了<code>NeXT</code>,之后<code>NextSTEP</code>更名为<code>Cocoa</code>。</p>
</blockquote>
<h2 id="1-3-内容简介"><a href="#1-3-内容简介" class="headerlink" title="1.3 内容简介"></a>1.3 内容简介</h2><h2 id="1-4-准备工作"><a href="#1-4-准备工作" class="headerlink" title="1.4 准备工作"></a>1.4 准备工作</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/25 国际化特性/" itemprop="url">
                  25 国际化特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:30:56+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/25 国际化特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/25 国际化特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>地区：</strong>可能是国家、洲或省活着一种特定的文化。<br><strong>扩展：</strong>1994年通过的<code>ISO C标准修正草案1</code>提供了编写额外国际化程序增加的额外库</p>
<ul>
<li>iso646.h</li>
<li>wctype.h</li>
<li>wchar.h</li>
</ul>
</blockquote>
<h2 id="25-1-locale-h：本地化"><a href="#25-1-locale-h：本地化" class="headerlink" title="25.1 locale.h：本地化"></a>25.1 locale.h：本地化</h2><blockquote>
<p><strong>标准库中依赖地区的部分：</strong></p>
<ul>
<li><strong>数值的格式：</strong>例如，一些地区小数点是一个圆点（297.48），而在另一些地方则是逗号（297,48）<br><strong>货币的格式：</strong>例如，不同国家的货币符号不同<br><strong>字符集：</strong>例如，亚洲国家通常比西方国家需要更大的字符集<br><strong>日期和时间的表示形式：</strong>例如，一些地方习惯在写日期时先写月（8/24/97），而另一些地方习惯先写日（24/8/97）</li>
</ul>
</blockquote>
<h3 id="25-1-1-类别"><a href="#25-1-1-类别" class="headerlink" title="25.1.1    类别"></a>25.1.1    类别</h3><blockquote>
<p><strong>说明：</strong><code>locale.h</code>提供了一系列的以<code>LC_</code>开头的宏来，这些宏分别对某些库的某些方面的行为产生影响。<br><strong>扩展：</strong>C语言的实现提供了其它类型并且定义了上面未列出的以<code>LC_</code>开头的宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>影响</th>
<th>头文件</th>
<th>相关章节</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE</td>
<td>strcoll函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td></td>
<td>strxfrm函数</td>
<td>string.h</td>
<td><a href="">23.5</a></td>
<td>字符串比较函数</td>
</tr>
<tr>
<td>LC_CTYPES</td>
<td>isdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>isxdigit函数</td>
<td>ctype.h</td>
<td><a href="">23.4</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>多字节函数</td>
<td>stdlib.h</td>
<td><a href="">25.2.1</a></td>
<td></td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>影响该函数返回的货币格式信息</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>格式化输入输出函数中使用的小数点字符</td>
<td>stdio.h</td>
<td><a href="">22</a></td>
<td>比如<code>printf</code>和<code>scanf</code></td>
</tr>
<tr>
<td></td>
<td>字符串转换函数</td>
<td>stdlib.h</td>
<td><a href="">26.2.1</a></td>
<td><code>atof</code>和<code>strtod</code></td>
</tr>
<tr>
<td></td>
<td>localeconv函数</td>
<td>locale.h</td>
<td></td>
<td>该函数返回的非货币格式信息</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>strftime函数</td>
<td>time.h</td>
<td><a href="">26.3.2</a></td>
<td>该函数用于将时间转换为字符串</td>
</tr>
</tbody>
</table>
<h3 id="25-1-2-setlocale函数"><a href="#25-1-2-setlocale函数" class="headerlink" title="25.1.2    setlocale函数"></a>25.1.2    setlocale函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>用来修改当前的地区，也可以用来获取当前地区的信息。<br><strong>参数：</strong><br><strong>1：</strong> 可以针对一种类型，也可以针对所有类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数1取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_COLLATE、LC_CTYPE、LC_MONETARY 、LC_NUMERIC、LC_TIME</td>
<td>针对一种类型</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>针对所有类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>2：</strong> C语言标准为第二个参数仅定义了两种可能值：”c”或” “。其他地区可以针对不同的实现定义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数二取值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;C&quot;</code></td>
<td>按正常方式执行，小数点是一个句点</td>
<td></td>
</tr>
<tr>
<td><code>&quot; &quot;</code></td>
<td>换到<code>本地模式（native locale）</code></td>
<td><code>C语言标准</code>没有定义切换到本地模式的具体影响</td>
</tr>
<tr>
<td><code>&quot;Germany&quot;</code></td>
<td>德国</td>
<td>部分编译器支持</td>
</tr>
<tr>
<td>类似<code>en_GB.WIN1252</code>格式的字符串</td>
<td>英语_英国.Windows多语言字符集</td>
<td>一些常用编译器支持</td>
</tr>
<tr>
<td><code>NULL</code></td>
<td>不设置任何东西</td>
<td>仅仅返回指向与当前地区类型的设置相关联的字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>如果需要获得与当前地区关联字符串，可以在调用setlocale函数时第一个参数给<code>LC_ALL</code>，第二个参数给<code>NULL</code>.<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; category  指定影响哪些库的哪些方面</span><br><span class="line">* @param &#123;char *&#125; locale 指定地区</span><br><span class="line">* @return &#123;char *&#125; 指向字符串（可能是地点名字自身）：成功；空指针：调用失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setlocale</span><span class="params">(<span class="keyword">int</span> category, <span class="keyword">const</span> <span class="keyword">char</span> *locale)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意程序执行开始时，都会隐含执行调用</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取地区信息字符串 */</span></span><br><span class="line"><span class="keyword">char</span> *temp, *old_locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前地区信息 */</span></span><br><span class="line">temp = setlocale(LC_ALL, NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查是否获取到信息 */</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为信息的副本分配空间 */</span></span><br><span class="line">old_locale = <span class="built_in">malloc</span>(strlen(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (old_locale == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* 分配内存失败 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将信息拷贝进去 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(old_locale, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换到本地模式 */</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按照存储的信息恢复就的地区设置 */</span></span><br><span class="line">setlocale(LU_ALL, old_locale);</span><br></pre></td></tr></table></figure>
<h3 id="25-1-3-localeconv函数"><a href="#25-1-3-localeconv函数" class="headerlink" title="25.1.3    localeconv函数"></a>25.1.3    localeconv函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>获取当前地区的各种信息<br><strong>原型：</strong><code>locale.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;struct lconv *&#125; 指向包含当前地区的详细信息的结构体指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> lconv *<span class="title">localeconv</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="struct-lconv"><a href="#struct-lconv" class="headerlink" title="struct lconv"></a>struct lconv</h4><hr>
<blockquote>
<p><strong>说明：</strong>存储当前地区的各种信息的结构体<br><strong>结构成员：</strong>有<code>char *</code>和<code>char</code>两种类型</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">char *型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.50.57.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">char型成员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.53.18.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>p_sign_posn和n_sign_posn的值：</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.56.18.png" alt="Alt text"></p>
</blockquote>
<p><strong>案例：用于美国和意大利两国的lconv结构成员的货币型常用值</strong><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.57.34.png" alt="Alt text"></p>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-18%20%E4%B8%8B%E5%8D%889.59.18.png" alt="Alt text"></p>
<h2 id="25-2-多字节字符和宽字符"><a href="#25-2-多字节字符和宽字符" class="headerlink" title="25.2 多字节字符和宽字符"></a>25.2 多字节字符和宽字符</h2><blockquote>
<p><strong>字符集（美国）：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>地位</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII</td>
<td>主流计算机采用</td>
</tr>
<tr>
<td>EBCDIC</td>
<td>其他计算机</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>可扩展字符集：</strong>C语言允许编译器提供一种可扩展的字符集</p>
</blockquote>
<table>
<thead>
<tr>
<th>可扩展字符集编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>多字节字符（multibyte character）</td>
<td>一个或多个字节表示一个可扩展的字符</td>
</tr>
<tr>
<td>宽字符（wide character）</td>
<td>一种其值表示字符的整数，具有相同的字节数</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>基本字符：</strong>任何可扩展的字符集必须包含C语言要求的<code>基本字符</code>（即<code>字母</code>、<code>数字</code>、<code>运算符</code>、<code>标点符</code>、<code>空白字符</code>），而且这些字符要求是单字节的。<br><strong>用途：</strong>c语言同时提供了多字节字符和宽字符用于不同的目的</p>
<ul>
<li><strong>多字节字符：</strong>多用于输入／输出，因为输入／输出设备经常是面向字节的</li>
<li><strong>宽字符：</strong>更适用于程序内部，因为没个宽字符占有相同的空间，便于程序内部操作。</li>
</ul>
<p><strong>技巧：</strong>程序可以读入多字节字符，然后转为便于程序内部操作的宽字符格式，谈后再把宽字符转换回用于输出的多字节格式。</p>
</blockquote>
<h3 id="25-2-1-多字节字符"><a href="#25-2-1-多字节字符" class="headerlink" title="25.2.1    多字节字符"></a>25.2.1    多字节字符</h3><blockquote>
<p><strong>空字符(<code>\0</code>)：</strong>无论移位状态如何，c标准都要求<code>\0</code>始终用来表示空字符。而且，<code>\0</code>不能是多字节字符的第二个（或之后）字节。<br><strong>按是否依赖状态分类：</strong><code>mblen函数</code>、<code>mbtowc函数</code>、<code>wctomb函数</code>都可用检测对字节字符是否是依赖状态的。只要其char *型参数给予NULL实参，则返回非零说明依赖状态；返回零说明依赖状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖状态编码（state-dependent enciding）</td>
<td>每个多字节字符序列都以<code>初始移位状态（initial shift state）</code>开始，序列中稍后遇到的一些多字节字符会改变移位状态，并且会影响后续字节的含义</td>
<td>日本的JIS编码</td>
</tr>
<tr>
<td>不依赖状态编码</td>
<td>每个字符要求一个或者两个字节，但是双字节字符的第一个字节可以始终区别与单字节字符</td>
<td>日本的Shift-JIS编码</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关宏：</strong>两个</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏</th>
<th>头文件</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>MB_LEN_MAX</td>
<td>limit.h</td>
<td>任意支持区域的最大值</td>
<td></td>
</tr>
<tr>
<td>MB_CUR_MAX</td>
<td>stdlib.h</td>
<td>当前区域的最大值</td>
<td>改变地区可能会影响多字节字符的解释</td>
</tr>
</tbody>
</table>
<h3 id="25-2-2-宽字符"><a href="#25-2-2-宽字符" class="headerlink" title="25.2.2    宽字符"></a>25.2.2    宽字符</h3><blockquote>
<p><strong>说明：</strong>采用特殊实现（比如<code>unsigned short int</code>）支持的所有宽字符都要求相同的字节数。<br><strong>宽字符类型：</strong><code>wchar_t</code> (<code>stddef.h</code>、<code>stdlib.h</code>)<br><strong>宽字符常量和宽字符串常量：</strong><code>L字符（串）常量</code></p>
<ul>
<li>宽字符常量：<code>L&#39;a&#39;</code></li>
<li>宽字符串常量：<code>L&quot;abc&quot;</code></li>
</ul>
</blockquote>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><blockquote>
<p><strong>说明：</strong>非常重要的固定长度编码的字符集。<br><strong>字符宽度：</strong>两个字节</p>
</blockquote>
<h3 id="25-2-3-多字节字符／宽字符转换函数"><a href="#25-2-3-多字节字符／宽字符转换函数" class="headerlink" title="25.2.3    多字节字符／宽字符转换函数"></a>25.2.3    多字节字符／宽字符转换函数</h3><h4 id="mblen函数"><a href="#mblen函数" class="headerlink" title="mblen函数"></a>mblen函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>检测s是否指向形成由效多字节字符的字节序列<br><strong>原型：</strong><code>stdlib.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符的字节序列</span><br><span class="line">* @param &#123;size_t&#125; a 最多能将测的字节的数量（通常为MB_CUR_MAX）</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符序列；0:空字符；-1：不是多字节字符序列</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mblen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, size_t a)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 确定字符串是否由有效的多字节字符构成</span><br><span class="line">* @param &#123;char *s&#125; 指向以空字符结尾的普通字符串</span><br><span class="line">* @return &#123;int&#125; 0或－1</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbcheck</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 通过mblen(NULL, 0)设置该函数的移位状态，以便可以正确解释字符串中稍后的字符</span></span><br><span class="line">	<span class="keyword">for</span> (mblen(NULL, <span class="number">0</span>); ; s += n) &#123;</span><br><span class="line">		<span class="comment">// 当</span></span><br><span class="line">		<span class="keyword">if</span> ((n = mblen(s, MB_CUR_MAX)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mbtowc函数"><a href="#mbtowc函数" class="headerlink" title="mbtowc函数"></a>mbtowc函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将多字节字符串转换为宽字符<br><strong>原型：</strong><code>stdlib.h.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;wchar_t *&#125; pwc 函数将存储结果的变量</span><br><span class="line">* @para &#123;char *&#125; s 多字节字符</span><br><span class="line">* @param &#123;size_t&#125; n 最大将检测的字节的数量</span><br><span class="line">* @return &#123;int&#125;  字符中的字节数：是多字节字符；0:空字符；-1：不是多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbtowc</span><span class="params">(wchar_t *pwc, <span class="keyword">const</span> <span class="keyword">char</span> *s, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="wctomb函数"><a href="#wctomb函数" class="headerlink" title="wctomb函数"></a>wctomb函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把宽字符转换为多字节字符<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储结果的变量（不回附加空字符）</span><br><span class="line">* @param &#123;wchar_t&#125; wchar 多字节字符</span><br><span class="line">* @return &#123;int&#125; 字符中的字节数：有效；1：空字符；-1：无效</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wctomb</span><span class="params">(<span class="keyword">char</span> *s, wchar_t wchar)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将测是否可以把宽字符的字符串转换为有效的多字节字符</span><br><span class="line">* @param &#123;wchar_t *&#125; wcs 宽字符序列</span><br><span class="line">* @return &#123;int&#125; -1：不可以；0：可以</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wccheck</span> <span class="params">(wchar_t *wcs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[MB_len_max];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span> (wctpmb (NULL, <span class="number">0</span>); ; ++wcs) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((n = wctomb(buf, *wcs)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (buf[n - <span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">			return <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-2-4-多字节字符／宽字符串函数"><a href="#25-2-4-多字节字符／宽字符串函数" class="headerlink" title="25.2.4    多字节字符／宽字符串函数"></a>25.2.4    多字节字符／宽字符串函数</h3><h4 id="mbstowcs函数"><a href="#mbstowcs函数" class="headerlink" title="mbstowcs函数"></a>mbstowcs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把多字节字符序列转换为宽字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（存储在宽字符数组中的)<code>\0</code>时，函数停止</li>
<li>假设要转换的字符串以初始迁移状态开始</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 宽字符数组</span><br><span class="line">* @param &#123;char *&#125; s 待转换的多字节字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的宽字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无效的多字节字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> mbstowcs(<span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h4 id="wcstombs函数"><a href="#wcstombs函数" class="headerlink" title="wcstombs函数"></a>wcstombs函数</h4><blockquote>
<p><strong>说明：</strong>把宽字符序列转换为多字节字符序列</p>
<ul>
<li>如何进行转换依赖于当前地区的<code>LC_CTYPES</code>类别</li>
<li>当达到上限或者遇到（自己存入的)<code>\0</code>时，函数停止</li>
<li>产生的字符串是以初始迁移状态开始的</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 多字节字符数组</span><br><span class="line">* @param &#123;whcar_t *&#125; pwcs 待转换的宽字符数组</span><br><span class="line">* @param &#123;size_t&#125; 可以存储在数组中的多字节字符数量</span><br><span class="line">* @return &#123;size_t&#125; 修改的数组元素的数量（不包括末尾的`\0`）：一切顺利；-1：遇到无法转换为对应多字节字符的宽字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> wcstombs(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">wchar_t</span> * <span class="keyword">restrict</span> pwcs, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<h2 id="25-3-三字符序列"><a href="#25-3-三字符序列" class="headerlink" title="25.3    三字符序列"></a>25.3    三字符序列</h2><blockquote>
<p><strong>三字符序列（trigraph sequence）：</strong>简称“三字符”，是一种三个字符的字符码。以<code>??字符</code>的形式出现。<br><strong>用途：</strong>可以替换ASCII中的一些特殊字符。<br><strong>兼容性：</strong>尽管不是一直需要，但是所有标准C编译器都要求接受三字符序列。<br><strong>技巧：</strong>字符串中的<code>??</code>可能会被编译器作为三字符序列的开始标志，可以通过使用<code>\</code>将第二个<code>?</code>转义（即<code>?\?</code>）来避免。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-21%20%E4%B8%8A%E5%8D%889.53.05.png" alt="Alt text"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">??=include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main () ??&lt;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, world??/n"</span>); </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">??&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/26 其它库函数/" itemprop="url">
                  26 其他库函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T21:25:08+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/26 其它库函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/26 其它库函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="26-1-stdarg-h：可变实参"><a href="#26-1-stdarg-h：可变实参" class="headerlink" title="26.1    stdarg.h：可变实参"></a>26.1    stdarg.h：可变实参</h2><blockquote>
<p><strong>带有可变参数的函数：</strong>带有可变数量参数的函数必须至少有一个“正常的”形式参数，在最后一个正常参数的后边始终会有省略号出现在参数列表的末尾。<br><strong>可变部分实参提升：</strong>当调用带有可变实参列表的函数时，编译器会在匹配省略号的全部参数上执行默认的<code>实参提升</code>（<a href="">9.3</a>）</p>
<ul>
<li>char -&gt; int</li>
<li>short -&gt; int</li>
<li>float -&gt; double</li>
</ul>
</blockquote>
<h4 id="va-arg宏（函数）"><a href="#va-arg宏（函数）" class="headerlink" title="va_arg宏（函数）"></a>va_arg宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>获得所在函数的可变参数中的下一个参数<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 指向可变参数列表的某个位置</span><br><span class="line">* @param &#123;类型&#125; 期待相应位置实参的类型</span><br><span class="line">* @return &#123;类型&#125; 相应位置(下一个)实参</span><br><span class="line">*/</span></span><br><span class="line">类型 va_arg(va_list ap, 类型);</span><br></pre></td></tr></table></figure>
<h4 id="va-start宏（函数）"><a href="#va-start宏（函数）" class="headerlink" title="va_start宏（函数）"></a>va_start宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过支持实参列表中可变长度部分开始的位置初始化<code>va_list</code>类型的实参列表。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 存储参数列表的变量</span><br><span class="line">* @param &#123;*&#125; paramN 可变参数前的最后一个正常实参</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(va_list ap, paramN)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="va-end宏（函数）"><a href="#va-end宏（函数）" class="headerlink" title="va_end宏（函数）"></a>va_end宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>执行对<code>va_list</code>类型变量的清理，使其无法被继续使用。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 可变实参部分的列表</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; n 后面可变参数的数量</span><br><span class="line">* @param &#123;*&#125; ... 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 可变实参中的最大值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span> <span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明存储可变实参列表的变量</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">int</span> i, current, largest;</span><br><span class="line">	<span class="comment">// 初始化存储可变部分的实参的列表</span></span><br><span class="line">	va_start(ap, n);</span><br><span class="line">	<span class="comment">// 遍历寻找最大值</span></span><br><span class="line">	largest = va_arg(ap, int);</span><br><span class="line">	<span class="keyword">for</span> (i = i; i &lt; n; i ++) &#123;</span><br><span class="line">		current = va_arg(ap, int);</span><br><span class="line">		<span class="keyword">if</span> (current &gt; largest) &#123;</span><br><span class="line">			largest = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清理存储可变实参的列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	return largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-1-1-调用可变实参列表的函数"><a href="#26-1-1-调用可变实参列表的函数" class="headerlink" title="26.1.1    调用可变实参列表的函数"></a>26.1.1    调用可变实参列表的函数</h3><blockquote>
<p><strong>说明：</strong>调用带有可变实参列表的函数带有一定风险，需要一些措施规避</p>
<ul>
<li><p>确定可变参数数量</p>
<blockquote>
<p><strong>例子：</strong>max_int函数依靠第一个是惨知名跟随其后的其他参数的数量</p>
</blockquote>
</li>
<li><p>确定每种参数的类型</p>
<blockquote>
<p><strong>例子：</strong>像printf函数和scanf函数依靠格式化字符串来描述其他的参数的数量和每种参数的类型</p>
</blockquote>
</li>
<li><p>特别处理<code>NULL</code>作为参数：当把<code>NULL</code>(0)传递给带有可变实参列表的函数时，编译器会假定它表示的是一个整数</p>
<blockquote>
<p><strong>强制类型转换：</strong><code>(void *) NULL</code>代替<code>NULL</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="26-1-2-v…printf类函数"><a href="#26-1-2-v…printf类函数" class="headerlink" title="26.1.2    v…printf类函数"></a>26.1.2    v…printf类函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...printf类函数</code>相比，由一个<code>va_list</code>类型的参数取代了可变参数部分。<br><strong>用途：</strong>编写“包装”函数。外部的包装函数接受可变数量的实参，并且稍后把这些参数传递给<code>v...printf类函数</code>。</p>
</blockquote>
<h4 id="vfprintf函数"><a href="#vfprintf函数" class="headerlink" title="vfprintf函数"></a>vfprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向第一个参数说明的流（任何输出流）中写输出。<br><strong>关联的函数：</strong><code>vfprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（流）</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE * <span class="keyword">restrict</span> stream, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vprintf函数"><a href="#vprintf函数" class="headerlink" title="vprintf函数"></a>vprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向stdout输出，利用格式串控制输出的形式<br><strong>关联的函数：</strong><code>vprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @param &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list rga)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vsprintf函数"><a href="#vsprintf函数" class="headerlink" title="vsprintf函数"></a>vsprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>类似printf函数和fprintf函数，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定制错误输出</span><br><span class="line">* @param &#123;char *&#125; format 格式化字符串</span><br><span class="line">* @param &#123;...*&#125; 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 输出的字符数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">errorf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num_errors = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 声明可变数组列表</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	num_errors++;</span><br><span class="line">	<span class="comment">// 打印需要增强的部分</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"** Error %d: "</span>, num_errors);</span><br><span class="line">	<span class="comment">// 初始化可变数组列表</span></span><br><span class="line">	va_start(ap, format);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入字符串（打印到屏幕）</span></span><br><span class="line">	n = <span class="built_in">vfprintf</span>(stderr, format, ap);</span><br><span class="line">	<span class="comment">// 清理可变参数列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入“换行”</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-2-stdlib-h-通用的使用工具"><a href="#26-2-stdlib-h-通用的使用工具" class="headerlink" title="26.2    stdlib.h:    通用的使用工具"></a>26.2    stdlib.h:    通用的使用工具</h2><blockquote>
<p><strong>说明：</strong>涵盖累全部不适合于任何其他头的函数。</p>
<ul>
<li>字符串转换函数</li>
<li>伪随机序列生成函数</li>
<li>内存管理函数</li>
<li>与外部环境的通信</li>
<li>搜索与排序使用工具</li>
<li>整数算术运算函数(<a href="">17</a>)</li>
<li>多子节字符和字符串函数(<a href="">25.2</a>)</li>
</ul>
</blockquote>
<h3 id="26-2-1-字符串转换函数"><a href="#26-2-1-字符串转换函数" class="headerlink" title="26.2.1    字符串转换函数"></a>26.2.1    字符串转换函数</h3><blockquote>
<p><strong>字符串中的特殊子串：</strong></p>
<ul>
<li><strong>十六进制浮点数</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>0x(X)</code></th>
<th>一个或多个<code>十六进制数字</code>（可能包括<code>小数点</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>无穷数</strong>：<code>INF</code>（不要求大小写）或`INFINITY（不要求大小写）</li>
<li><strong>NaN</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>NAN</code></th>
<th><code>(</code></th>
<th><code>空</code>或<code>一系列字符</code></th>
<th><code>)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>不要求大小写</td>
<td></td>
<td>可以包含字母、数组或下划线，用于<code>为NaN值的二进制表示指定某些位</code>或被<code>nan函数</code>(<a href="">23.4</a>)调用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="atof函数（c89之前）"><a href="#atof函数（c89之前）" class="headerlink" title="atof函数（c89之前）"></a>atof函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>double</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;double&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoi函数（c89之前）"><a href="#atoi函数（c89之前）" class="headerlink" title="atoi函数（c89之前）"></a>atoi函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span><br><span class="line">int atoi (const chat *nptr)；</span><br></pre></td></tr></table></figure>
<h4 id="atol函数（c89之前）"><a href="#atol函数（c89之前）" class="headerlink" title="atol函数（c89之前）"></a>atol函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>long int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtod函数（c89）"><a href="#strtod函数（c89）" class="headerlink" title="strtod函数（c89）"></a>strtod函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>double</code>，相比<code>atof函数（c89之前）</code></p>
<ul>
<li>返回值为<code>double</code>而不是<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtold</code>、<code>strtof</code>)</li>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回正或负的<code>HUGE_VAL</code>(<a href="">23.3</a>)</li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）<br><strong>原型：</strong><code>stdlib.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">strtod</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtol函数（c89）"><a href="#strtol函数（c89）" class="headerlink" title="strtol函数（c89）"></a>strtol函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code>，相比<code>atol函数（c89之前）</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoul函数（c89）"><a href="#strtoul函数（c89）" class="headerlink" title="strtoul函数（c89）"></a>strtoul函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtold函数-C99"><a href="#strtold函数-C99" class="headerlink" title="strtold函数(C99)"></a>strtold函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long double</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>long double</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtof</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;long double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">strtold</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoll函数-c99"><a href="#atoll函数-c99" class="headerlink" title="atoll函数(c99)"></a>atoll函数(c99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，和<code>atol函数（c89之前）</code>相比</p>
<ul>
<li>转换为<code>long long int</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code></li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtof函数-C99"><a href="#strtof函数-C99" class="headerlink" title="strtof函数(C99)"></a>strtof函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>float</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtold</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;float&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">strtof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoll函数-C99"><a href="#strtoll函数-C99" class="headerlink" title="strtoll函数(C99)"></a>strtoll函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，类似<code>strtol函数（c89）</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoull函数-C99"><a href="#strtoull函数-C99" class="headerlink" title="strtoull函数(C99)"></a>strtoull函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>unsigned long long int</code>，类似<code>strtoul函数(c89)</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoull</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试数值转换函数"><a href="#程序：测试数值转换函数" class="headerlink" title="程序：测试数值转换函数"></a>程序：测试数值转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Test c89 numeric conversion functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHK_VALID printf(<span class="string">"    %s        %s\n"</span>, \</span><br><span class="line"> 					     errno != ERANGE ? <span class="string">"Yes"</span> : <span class="string">"No "</span>, \</span><br><span class="line"> 					     *ptr == <span class="string">'\0'</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="comment">/* 检测程序启动方式是否正确 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: tnumconv string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使用c89之前的3个旧转换函数 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function Return Value\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------    --------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atof        %g\n"</span>, atof(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atoi        %d\n"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atol        %ld\n"</span>, atol(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function    Return Value    Valid?    "</span></span><br><span class="line">		   <span class="string">"String Consumed?\n"</span></span><br><span class="line">		   <span class="string">"--------    ------------    ------    "</span></span><br><span class="line">		   <span class="string">"------------------\n"</span>);</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtod    %-12g\n"</span>, strtod(argv[<span class="number">1</span>], &amp;ptr));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtol    %-12ld\n"</span>, strtol(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtoul    %-12lu\n"</span>, strtoul(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-24%20%E4%B8%8A%E5%8D%8810.36.50.png" alt="Alt text"></p>
<h3 id="26-2-3-伪随机序列生成函数"><a href="#26-2-3-伪随机序列生成函数" class="headerlink" title="26.2.3    伪随机序列生成函数"></a>26.2.3    伪随机序列生成函数</h3><h4 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>返回一个<code>0～RAND_MAX(stdlib.h)</code>的随机数。<br><strong>说明：</strong><code>rand函数</code>返回的数事实上不是随机的，这些数是由“种子”值（默认为1）产生的，但对于偶然的观察者而言，rand函数似乎能能够产生不相关的数值序列。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;int&#125; `0～RAND_MAX(stdlib.h)`的随机数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="srand函数"><a href="#srand函数" class="headerlink" title="srand函数"></a>srand函数</h4><blockquote>
<p><strong>描述：</strong>在<code>rand函数</code>执行前执行该函数来为<code>rand函数</code>提供种子值。<br><strong>注意：</strong>同一个种子值对应着一组特定的随机序列<br><strong>技巧：</strong>把<code>time函数</code>的返回值传递给<code>srand函数</code>设置“随机化”的种子值，这样可以使<code>rand函数</code>在每次运行时的行为都不相同。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests the pseudo-random sequence generation functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program displays the first five value of "</span></span><br><span class="line">		   <span class="string">"rand.\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter new seed value (0 to terminate):"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seed);</span><br><span class="line">		<span class="keyword">if</span> (seed == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		srand(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-3-与环境的通信"><a href="#26-2-3-与环境的通信" class="headerlink" title="26.2.3    与环境的通信"></a>26.2.3    与环境的通信</h3><blockquote>
<p><strong>说明：</strong>一组简单的操作系统接口。</p>
<ol>
<li>正常或不正常地终止程序，并且想操作系统反悔一个状态码</li>
<li>从用户的外部环境获取信息</li>
<li>执行操作系统的命令</li>
</ol>
</blockquote>
<h4 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统。<br><strong>细节：</strong>通常还会在后台做一些最后的动作</p>
<ul>
<li>清洗包好未输出数据的输出缓冲区</li>
<li>关闭打开的流</li>
<li>删除临时文件</li>
<li>调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
</ul>
<p><strong>说明：</strong>通常等价于在<code>main函数</code>中执行<code>return n</code>，具有可移植性的状态码包括</p>
<ul>
<li><strong>EXIT_SUCCESS宏：</strong>正常退出(整数0)</li>
<li><strong>EXIT_FAILURE宏：</strong>非正常退出</li>
</ul>
<p><strong>注意：</strong><code>exit函数</code>和<code>return语句</code>的不同表现在</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>exit函数</th>
<th>return语句</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main函数</code>中局部变量的生命周期</td>
<td>不结束</td>
<td>结束（如果用<code>atexit函数</code>注册的函数或<code>清洗输出流的缓冲区</code>访问这些变量就会出现问题）</td>
</tr>
<tr>
<td>使用<code>int</code>之外的类型</td>
<td>可以</td>
<td>必须和<code>mian函数</code>的返回类型保持一致，否则</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>当把函数指针传递给<code>aexit函数</code>时，它会把指针保存起来，当程序正常终止时会被调用。</p>
<ul>
<li>通过<code>exit函数</code>被调用或<code>main函数</code>中的<code>return</code>语句触发</li>
<li>如果注册了两个或更多函数，那么将按照与注册顺序<code>相反</code>的顺序调用它们</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void (*func)(void)&#125; func 函数指针</span><br><span class="line">* @return &#123;int&#125; 未知</span><br><span class="line">*/</span><br><span class="line">int atexit (void (*func)(void));</span><br></pre></td></tr></table></figure>
<h4 id="Exit函数（c99）"><a href="#Exit函数（c99）" class="headerlink" title="_Exit函数（c99）"></a>_Exit函数（c99）</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统<br><strong>说明：</strong>类似<code>exit函数</code></p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
<li>不会调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
<li>不回发送信号触发<code>signal函数</code>（<a href="">24.3</a>）注册的函数</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> _Exit (<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>通常会导致异常的程序终止，长生<code>SIGABRT信号</code>并向系统返回一个表示“不成功”的状态码。<br><strong>注意：</strong>有一种情况下不会导致程序终止，那就是通过<code>signal函数</code>为<code>SIGABRT信号</code>注册处理函数，且处理函数调用了<code>longjmp函数</code>恢复到之前的执行环境。<br><strong>说明：</strong>类似<code>exit</code>函数，特点是</p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a>getenv函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>提供了访问用户环境中的任意字符串（环境变量）的功能。<br><strong>说明：</strong>获得的指针指向的字符串是静态的，有可能会被其它函数调用或系统自身修改。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; name 环境变量名</span><br><span class="line">* @return &#123;char *&#125; 指向静态分配的字符串的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "/usr/local/bin:/bin:/usr/bin:." */</span></span><br><span class="line"><span class="keyword">char</span> *p = getenv(<span class="string">"PATH"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>运行另一个c程序（可以是操作系统命令）<br><strong>说明：</strong>类似在操作系统终端使用命令行</p>
<ul>
<li><strong>参数：</strong>以<code>NULL</code>作为参数有特殊含义</li>
<li><strong>返回值</strong>：（由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; string 命令</span><br><span class="line">* @return &#123;int&#125; 由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用UNIX(Linux)的ls命令，并将结果存入myfiles</span></span><br><span class="line">system(<span class="string">"ls &gt;myfiles"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="26-2-4-搜索和排序使用工具"><a href="#26-2-4-搜索和排序使用工具" class="headerlink" title="26.2.4    搜索和排序使用工具"></a>26.2.4    搜索和排序使用工具</h3><h4 id="bsearch函数"><a href="#bsearch函数" class="headerlink" title="bsearch函数"></a>bsearch函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据键在<code>有序数组</code>中搜索一个特定的值。<br><strong>说明：</strong>通常会使用<code>二分搜索算法</code>来搜索在数组中搜索<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; key 指向键（匹配依据）的指针</span><br><span class="line">* @param &#123;void *&#125; base 数组</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @param &#123;Function *&#125; compar 指向比较函数的指针</span><br><span class="line">* @return &#123;void *&#125; 指向与键匹配的指针：匹配到；NULL：没匹配到</span><br><span class="line">*/</span><br><span class="line">void *bsearch (const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h4 id="qsort函数"><a href="#qsort函数" class="headerlink" title="qsort函数"></a>qsort函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>为数组进行排序<br><strong>相关：</strong><a href="">17.1</a><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;Function *&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h3 id="程序：确定航空里程"><a href="#程序：确定航空里程" class="headerlink" title="程序：确定航空里程"></a>程序：确定航空里程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine air mileage from New York City.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> city_info &#123;</span><br><span class="line">	<span class="keyword">char</span> *city;</span><br><span class="line">	<span class="keyword">int</span> miles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> city_name[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">struct</span> city_info *ptr;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> city_info mileage[] = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Berlin"</span>, <span class="number">3965</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Buenos Aires"</span>, <span class="number">5297</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cairo"</span>, <span class="number">5602</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Calcutta"</span>, <span class="number">7918</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cape Town"</span>, <span class="number">7764</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter city name:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%80[^\n]"</span>, city_name);</span><br><span class="line">	ptr = bsearch(city_name, mileage, sizeof(mileage) / sizeof(mileage[<span class="number">0</span>]), sizeof(mileage[<span class="number">0</span>]), compare_cityes);</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is %d miles from New York City.\n"</span>, city_name, ptr-&gt;miles);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s wasn't found."</span>, city_name);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">strcmp</span>((char *) key_ptr, ((struct city_info *) element_ptr)-&gt;city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-5-整数运算函数"><a href="#26-2-5-整数运算函数" class="headerlink" title="26.2.5    整数运算函数"></a>26.2.5    整数运算函数</h3><h4 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; j 需要求绝对值的整数</span><br><span class="line">* @return &#123;int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="labs函数"><a href="#labs函数" class="headerlink" title="labs函数"></a>labs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="llabs函数"><a href="#llabs函数" class="headerlink" title="llabs函数"></a>llabs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="div函数"><a href="#div函数" class="headerlink" title="div函数"></a>div函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>ldiv</code><br>|比较|<code>div(ldiv)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>div（ldiv）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; number 除数</span><br><span class="line">* @param &#123;int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> div (<span class="keyword">int</span> number, <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="ldiv函数（c99）"><a href="#ldiv函数（c99）" class="headerlink" title="ldiv函数（c99）"></a>ldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>div</code><br>|比较|<code>ldiv(div)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>ldiv（div）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; number 除数</span><br><span class="line">* @param &#123;long  int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="lldiv函数（c99）"><a href="#lldiv函数（c99）" class="headerlink" title="lldiv函数（c99）"></a>lldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; number 除数</span><br><span class="line">* @param &#123;long long int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h2 id="26-3-time-h：日期和时间"><a href="#26-3-time-h：日期和时间" class="headerlink" title="26.3    time.h：日期和时间"></a>26.3    time.h：日期和时间</h2><blockquote>
<p><strong>说明：</strong>存储时间的数据结构。</p>
<ul>
<li><code>clock_t</code>：按照“时钟滴答”进行度量的时间值。</li>
<li><code>time_t</code>：紧凑的时间和日期编码（日历时间）</li>
<li><code>struct tm</code>：包含分解的时间的结构体<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-02%20%E4%B8%8B%E5%8D%889.40.49.png" alt="Alt text"><br>❶ 允许两个额外的“闰秒”。c99中最大值为60。<br>❷ 如果夏令时有效，就为正数；如果无效，为零；如果这一信息未知，就为负数。</li>
</ul>
</blockquote>
<h3 id="26-3-1-时间处理函数"><a href="#26-3-1-时间处理函数" class="headerlink" title="26.3.1    时间处理函数"></a>26.3.1    时间处理函数</h3><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回程序从开始执行到当前时刻的处理器时间（时钟数）。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;clock_t&#125; 程序从此启动到当前经过的处理器时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">clock_t</span> clock (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>为了将处理器时间转换为秒，将其除以<code>CLOCK_PER_SEC</code>(定义在<code>time.h</code>)。</li>
<li>当用<code>clock</code>函数来确定程序已经运行多长时间时（不包括到达<code>main函数</code>之前的时间），习惯做法时调用<code>clock函数</code>两次：一次在<code>main函数</code>开始处，一次在程序要终止之前。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 第一次调用 */</span></span><br><span class="line">	<span class="keyword">clock_t</span> start_clock = clock();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* 第二次调用 */</span></span><br><span class="line">	<span class="comment">/* CLOCK_PER_SEC：类型由实现定义，c99指定其为clock_t类型 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Processor time used: %g sec.\n"</span>, (clock() - start_clock / (double) CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回当前的日历时间。</p>
<ul>
<li>如果参数不为<code>NULL</code>,那么<code>time函数</code>还会把日历时间存储在实参指向的空间中。</li>
</ul>
<p><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t *&#125; timer 指向存储当前日历时间的存储空间（可以为NULL）</span><br><span class="line">* @return &#123;time_t&#125; 当前的日历时间 </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">time_t</span> time (<span class="keyword">time_t</span> *timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用返回值</span></span><br><span class="line">cur_time = time(NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过参数指定存储的位置</span></span><br><span class="line">time(&amp;cur_time);</span><br></pre></td></tr></table></figure>
<h4 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过两个时间点的日历时间，返回两个时间点之间的时间差（秒）<br><strong>用途：</strong>计算程序的运行时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; 日历时间</span><br><span class="line">* @param &#123;time_t&#125; 日历时间（较早的时间）</span><br><span class="line">* @return &#123;double&#125; time0和time1之间按秒衡量的差值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(time_t time1, time_t time0)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第一个日历时间</span></span><br><span class="line">	<span class="keyword">time_t</span> start_time = time(NUULL);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 第二个日历时间，并计算时间差</span></span><br><span class="line">	ptintf(<span class="string">"Return time: %g sec.\n"</span>, difftime(NULL), start_time);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把<code>struct tm</code>(分解时间)类型的时间转换为日历时间并返回。<br><strong>用途：</strong>对于和时间、日期相关的计算非常有用。<br><strong>副作用：</strong>会按照一定规则调整结构的成员</p>
<ul>
<li><strong>改变值不在合法范围内的成员：</strong>一个成员的数值的调整可能会导致接连对其它成员的调整，直到全部合法。</li>
<li>初始化<code>tm_wday</code>（一星期的第几天）和<code>tm_yday</code>（一年中的第几天）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明分解时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化分解时间 */</span></span><br><span class="line">t.tm_mday = <span class="number">27</span>;<span class="comment">/* 日 */</span></span><br><span class="line">t.tm_mon = <span class="number">6</span>;<span class="comment">/* 月 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保证其他成员被正确初始化 */</span></span><br><span class="line">t.tm_sec = <span class="number">0</span>;</span><br><span class="line">t.tm_min = <span class="number">0</span>;</span><br><span class="line">t.tm_hour = <span class="number">0</span>;</span><br><span class="line">t.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 制造超出取值范围的情况 */</span></span><br><span class="line">t.tm_mday = += <span class="number">16</span>; <span class="comment">/* 43 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将分解时间转为日历时间，将导致原本的分解时间成员被修改 */</span></span><br><span class="line">mktime(&amp;t);</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.42.02.png" alt="Alt text"></p>
<h3 id="26-3-2-时间转换函数"><a href="#26-3-2-时间转换函数" class="headerlink" title="26.3.2    时间转换函数"></a>26.3.2    时间转换函数</h3><blockquote>
<p><strong>说明：</strong>转换示意图<br> <img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.44.39.png" alt="Alt text"><br><strong>注意：</strong>其中的<code>mktime函数</code>被C标准定义为<code>处理函数</code>而不是<code>转换函数</code>。</p>
</blockquote>
<h4 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是<code>UTC</code>(协调世界时间)。<br><strong>注意：</strong>返回值指向的是一个静态分配的结构，会被后续的<code>getime函数</code>或<code>localtime函数</code>调用修改。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; timer 日历时间</span><br><span class="line">* @return &#123;struct tm&#125; 分解时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是本地时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;&#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asctime函数"><a href="#asctime函数" class="headerlink" title="asctime函数"></a>asctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将分解时间转换为字符串格式。</p>
<blockquote>
<p><code>Sun Jun 3 17:48:34 2007\n</code></p>
</blockquote>
<p><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 指向分解时间结构体的指针</span><br><span class="line">* @return &#123;char *&#125; 字符串形式的时间(ASCII时间)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ctime函数"><a href="#ctime函数" class="headerlink" title="ctime函数"></a>ctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为字符串格式。<br><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; time 日历时间</span><br><span class="line">* @return &#123;char *&#125; 描述本地时间的字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span> <span class="params">(<span class="keyword">const</span> time_t *time)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strftime函数"><a href="#strftime函数" class="headerlink" title="strftime函数"></a>strftime函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>把分解时间转换成字符串格式。<br><strong>注意：</strong>函数对地区敏感，改变<code>LC_TIME</code>可能会影响转换说明符的行为。<br><strong>转换说明符：</strong></p>
<ul>
<li>针对<code>&quot;C&quot;</code>地区（c89~c99），支持<code>ISO 8601</code><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.54.27.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.55.24.png" alt="Alt text"></li>
<li>一些转换说明符在<code>&quot;C&quot;</code>地区的替换字符串（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.58.53.png" alt="Alt text"></li>
<li><code>E</code>或<code>O</code>修饰符：修改特定的转换说明符，替换为依赖当前地区的备选格式（<code>&quot;C&quot;</code>地区忽略<code>E</code>或<code>O</code>）（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8811.04.15.png" alt="Alt text"></li>
</ul>
<p><strong>说明：</strong>类似<code>asctime函数</code>，但提供了大量对时间进行格式化的控制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 指向用来存储字符串形式的时间的空间</span><br><span class="line">* @param &#123;size_t&#125; maxsize 存储在s中的字符数量上限</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 分解时间</span><br><span class="line">* @return &#123;size_t&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strftime (<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, <span class="keyword">const</span> <span class="keyword">struct</span> tm * restricy timeptr);</span><br></pre></td></tr></table></figure>
<h3 id="程序：显示日期和时间"><a href="#程序：显示日期和时间" class="headerlink" title="程序：显示日期和时间"></a>程序：显示日期和时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Display the current date and time in three formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 1. 获得日历时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> current = time(NULL);</span><br><span class="line">	<span class="keyword">struct</span> tm *ptr;</span><br><span class="line">	<span class="keyword">char</span> date_time[<span class="number">21</span>];</span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="keyword">char</span> am_or_pm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：ctime默认的的字符串形式 */</span></span><br><span class="line">	<span class="built_in">puts</span>(ctime(&amp;current));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：strftime默认的字符串形式 */</span></span><br><span class="line">	strftime(date_time, <span class="keyword">sizeof</span>(date_time), <span class="string">"%m-%d-%Y %I:%M%p\n"</span>, localtime(&amp;current));</span><br><span class="line">	<span class="built_in">puts</span>(date_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期和时间：使用printf结合分解时间 */</span></span><br><span class="line">	ptr = localtime(&amp;current);</span><br><span class="line">	hour = ptr-&gt;tm_hour;</span><br><span class="line">	<span class="keyword">if</span> (hour &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">		am_or_pm = <span class="string">'a'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hour -= <span class="number">12</span>;</span><br><span class="line">		am_or_pm = <span class="string">'p'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour == <span class="number">0</span>) &#123;</span><br><span class="line">		hour = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2d-%.2d-%.2d %2d:%.2d%c\n"</span>, ptr-&gt;tm_mon + <span class="number">1</span>, ptr-&gt;tm_mday, ptr-&gt;tm_year + <span class="number">1900</span>, hour, ptr-&gt;tm_min, am_or_pm);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./datetime</span><br><span class="line"> Wed Nov  4 10:41:12  2015</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41AM</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41a</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/24 错误处理/" itemprop="url">
                  24 错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T11:42:41+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/24 错误处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/24 错误处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>C语言的弱项：</strong>错误的检测和处理并不是c语言的强项</p>
<ul>
<li>C语言对运行时错误以多种形式表示，而没有提供一种统一的方式</li>
<li>程序员必须将检测错误的代码编写在程序代码中，因此很容易忽略一些错误</li>
</ul>
<p><strong>扩展：</strong>C++语言对C语言的这一弱点进行了改进，提供了一种新的错误错误的方式－异常处理（exception handling）。</p>
</blockquote>
<h2 id="24-1-assert-h：诊断"><a href="#24-1-assert-h：诊断" class="headerlink" title="24.1    assert.h：诊断"></a>24.1    <code>assert.h</code>：诊断</h2><h4 id="assert宏（函数）"><a href="#assert宏（函数）" class="headerlink" title="assert宏（函数）"></a>assert宏（函数）</h4><blockquote>
<p><strong>断言：</strong>一个我们认为在正常情况下一顶为真的表达式。<br><strong>错误信息：</strong>标准C要求在显示的消息中指明以下内容</p>
<ul>
<li>传递给assert函数的参数</li>
<li>包括assert调用的文件名</li>
<li>assert调用所在的行号</li>
</ul>
<p><strong>说明：</strong>检查断言，如果值不为0，会向<code>stderr</code>输出一条信息，并调用<code>abort函数</code>终止程序。<br><strong>技巧：</strong>因为引入了额外的检查，因此会增加程序的运行时间。可以在测试没问题后通过<code>NDEBUG</code>（宏）进制<code>assert</code>调用。<br><strong>注意：</strong>因为assert可能会被禁用，因此不要在assert调用中使用有副作用的表达式。<br><strong>原型</strong><code>assert.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; expresstion 断言</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i];</span><br><span class="line">assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; N);<span class="comment">// 保证下标不回溢出</span></span><br><span class="line">a [i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><em>禁止assert调用</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG<span class="comment">// 值不重要，定义了就行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="24-2-errno-h：错误"><a href="#24-2-errno-h：错误" class="headerlink" title="24.2    errno.h：错误"></a>24.2    <code>errno.h</code>：错误</h2><blockquote>
<p><strong>说明：</strong>除了<code>EDOM</code>和<code>ERANGE</code>,还定义了其他宏，这是合法的，但命名要遵循C标准，即<code>E数组或大写字母</code></p>
</blockquote>
<h4 id="errno宏"><a href="#errno宏" class="headerlink" title="errno宏"></a>errno宏</h4><hr>
<blockquote>
<p><strong>描述：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和变量一样使用。<br><strong>说明：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和普通变量一样使用。<br><strong>用途：</strong>函数被调用后会会为<code>errno</code>赋值，如果<code>errno</code>不为0，代表函数调用过程中有错误发生。<br><strong>应用：</strong>大部分使用<code>errno</code>变量的函数集中在<code>math.h</code>，也有一些在标准库的其他部分。<br><strong>相关宏：</strong><code>EDOM</code>和<code>ERANGE</code>,errno中存储的值通常是这两个宏</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏（errno的值）</th>
<th>错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDOM</td>
<td>定义域错误</td>
<td>传递给函数的一个参数不属于函数的定义域</td>
</tr>
<tr>
<td>ERANGE</td>
<td>取值范围错误</td>
<td>函数的返回值太大，无法用double</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用库函数</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sqrt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>向<code>stderr</code>输出一条错误信息。<br><strong>错误信息：</strong><code>sqrt error: Math argument</code>（定义域错误）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">perror的参数</th>
<th style="text-align:center">分号</th>
<th style="text-align:center">空格</th>
<th style="text-align:center">出错消息</th>
<th style="text-align:center">换行符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sqrt error</td>
<td style="text-align:center">:</td>
<td style="text-align:center"></td>
<td style="text-align:center">Math argument</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 错误描述</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sqrt</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测运行状况</span></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"sqrt error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据错误类型行值返回指向错误字符串的指针。<br><strong>原型：</strong><code>string.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; errnum 错误类型值</span><br><span class="line">* @return &#123;char *&#125; 对应的错误字符串 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="24-3-signal-h：信号处理"><a href="#24-3-signal-h：信号处理" class="headerlink" title="24.3    signal.h：信号处理"></a>24.3    <code>signal.h</code>：信号处理</h2><blockquote>
<p><strong>信号（signal）：</strong>处理异常情况的工具</p>
<ul>
<li><p>运行时错误</p>
<blockquote>
<p>例如：除以0</p>
</blockquote>
</li>
<li><p>程序以外导致的事件</p>
<blockquote>
<p>例如：许多操作系统都允许用户终端或终止运行的程序</p>
</blockquote>
</li>
</ul>
<p><strong>异步的：</strong>它们可以在程序执行过程中的任意时刻发生，而不仅是在程序员所知道的特定时刻发生</p>
</blockquote>
<h3 id="24-3-1-信号宏"><a href="#24-3-1-信号宏" class="headerlink" title="24.3.1    信号宏"></a>24.3.1    信号宏</h3><blockquote>
<p><strong>兼容性：</strong>C标准不要求下面列表中的信号都会发生，大多数C语言的实现都至少支持其中一部分。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>异常终止（可能由于调用abort导致）</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>在数学运算中发生错误（可能是除以0或溢出）</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGINT</td>
<td>中断</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法存储访问</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止请求</td>
</tr>
</tbody>
</table>
<h3 id="24-3-2-signal函数"><a href="#24-3-2-signal函数" class="headerlink" title="24.3.2    signal函数"></a>24.3.2    signal函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>为指定信号注册指定处理函数。<br><strong>相关宏：</strong><code>SIG_ERR</code></p>
<blockquote>
<p><strong>说明：</strong>当注册失败时会返回该值<br><strong>用途：</strong>检测注册处理函数是否成功</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p><strong>多对一：</strong><code>信号</code>与处理函数是<code>多对一</code>的关系</p>
<ul>
<li>可以对多种信号绑定同一个处理函数，处理函数可以根据传入的参数（信号类型）决定进行哪种操作</li>
<li>也可以对同一个信号注册多个处理程序，但前面注册的会被后面注册的处理函数覆盖。</li>
</ul>
<p><strong>同步性：</strong>发出信号的行为是异步的，但处理函数处理的过程是同步的。也就是说，注册了处理函数的信号出现后，程序会暂停并执行信号处理函数，返回后暂停的程序从信号发生点恢复并继续执行。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>处理函数返回后程序行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>终止</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>处理函数返回后的程序行为未定义</td>
</tr>
<tr>
<td>其它</td>
<td>暂停的程序从信号发生点恢复并继续执行</td>
</tr>
</tbody>
</table>
<blockquote>
<blockquote>
<p><strong>一次性：</strong>信号处理完之后，除非处理函数被重新注册，否则该信号不回被同一个函数处理两遍。<br><strong>无限递归问题：</strong>如果信号是由处理这个信号的函数引发的，如果没有其它机制将会发生无限递归。所以，C语言要求，除了<code>SIGTLL</code>，当一个信号的处理函数被调用时，该信号对应的处理函数要么要被重置为<code>SIG_DFL</code>或以其它方式加以封锁。</p>
</blockquote>
<p><strong>限制：</strong>处理函数和普通函数相比多了一些限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>可以</th>
<th>不可以</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以忽略该信号</td>
<td>自由调用库函数</td>
</tr>
<tr>
<td>执行一些错误修复</td>
<td>访问静态存储期限的变量</td>
</tr>
<tr>
<td>终止程序</td>
<td></td>
</tr>
<tr>
<td>可以调用<code>signal</code>，只要第一个参数为正被处理的信号</td>
<td></td>
</tr>
<tr>
<td>调用库函数，只要信号处理函数是由raise或abort调用的</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @param &#123;func *&#125; func 处理函数</span><br><span class="line">* @return &#123;func *&#125; 指向注册过同样信号的上一个处理函数的指针：成功；SIG_ERR：注册失败（同时会在errno中存储一个正值）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> *(*signal)(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(int));<span class="comment">// 书上写法是：void (*signal(int sig, void (*func)(int)))(int);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为中断注册处理函数，并将之前的处理函数存储下来</span></span><br><span class="line">orig_handler = signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orig_handler == SIG_ERR) &#123;</span><br><span class="line">	<span class="comment">// 注册处理函数失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成原来的处理函数</span></span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-3-预定义的信号处理函数"><a href="#24-3-3-预定义的信号处理函数" class="headerlink" title="24.3.3    预定义的信号处理函数"></a>24.3.3    预定义的信号处理函数</h3><blockquote>
<p><strong>说明：</strong>出了编写我们自己的信号处理函数，我们还可以选择使用<code>signal.h</code>提供的预定义的处理函数。<br><strong>预定义的信号处理函数命名规则：</strong></p>
<blockquote>
<p><code>SIG_</code>大写字母</p>
</blockquote>
</blockquote>
<h4 id="SIG-DFL宏（函数）"><a href="#SIG-DFL宏（函数）" class="headerlink" title="SIG_DFL宏（函数）"></a>SIG_DFL宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>按“默认”的方式处理<br><strong>描述：</strong>行为由实现定义，大多数情况下会导致程序终止。<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_DFL</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN); <span class="comment">// 使用默认行为响应“中断”信号</span></span><br></pre></td></tr></table></figure>
<h4 id="SIG-IGN宏（函数）"><a href="#SIG-IGN宏（函数）" class="headerlink" title="SIG_IGN宏（函数）"></a>SIG_IGN宏（函数）</h4><hr>
<blockquote>
<p><strong>描述：</strong>什么都不做，忽略信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_IGN</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="24-3-4-raise函数"><a href="#24-3-4-raise函数" class="headerlink" title="24.3.4    raise函数"></a>24.3.4    raise函数</h3><hr>
<blockquote>
<p><strong>说明：</strong>触发信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发SIGABORT</span></span><br><span class="line">raise(SIGABOUT);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-5-程序：测试信号"><a href="#24-3-5-程序：测试信号" class="headerlink" title="24.3.5    程序：测试信号"></a>24.3.5    程序：测试信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests signals</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明函数指针</span></span><br><span class="line">	<span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1. 第一次实验*/</span></span><br><span class="line">	<span class="comment">// 注册处理函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---first--- %d\n"</span>, SIGILL);</span><br><span class="line">	signal(SIGILL, handler);</span><br><span class="line">	<span class="comment">// 触发信号</span></span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2. 第二次实验*/</span></span><br><span class="line">	<span class="comment">// 再次注册,忽略相应信号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---second---\n"</span>);</span><br><span class="line">	orig_handler = signal(SIGILL, SIG_IGN);</span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3. 第三次实验*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---third---\n"</span>);</span><br><span class="line">	<span class="comment">// 更改为第一次实验使用的处理函数</span></span><br><span class="line">	signal(SIGILL, orig_handler);</span><br><span class="line">	raise_sig();</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Handler called for signal %d\n"</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	raise(SIGILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsignal</span><br><span class="line"> ---first--- 4</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br><span class="line"> ---second---</span><br><span class="line"> ---third---</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br></pre></td></tr></table></figure>
<h2 id="24-4-setjmp-h：非局部跳转"><a href="#24-4-setjmp-h：非局部跳转" class="headerlink" title="24.4    setjmp.h：非局部跳转"></a>24.4    setjmp.h：非局部跳转</h2><blockquote>
<p><strong>说明：</strong>通常情况下，函数调用后会回到它被调用的位置。但<code>setjmp.h</code>提供了使一个函数直接跳转到另一个函数（而且不需要返回）的方式。<br><strong>goto：</strong>只能配合标记实现<code>局部跳转</code>，也就是在同一个函数内部跳转。</p>
</blockquote>
<h3 id="setjmp宏（函数）"><a href="#setjmp宏（函数）" class="headerlink" title="setjmp宏（函数）"></a>setjmp宏（函数）</h3><blockquote>
<p><strong>描述：</strong>标记程序中的一个“位置”<br><strong>应用：</strong>生成标记位置，稍后提供给<code>longjmp函数</code><br><strong>限制：</strong>按照<code>标准C</code>，只有两种使用setjmp的方式是合法的(否则不具备可移植性)</p>
<ul>
<li>作为表达式语句（可能会前置转换成void）</li>
<li>作为<code>if、switch、while、do、for</code>语句中控制表达式的一部分(<code>constexp</code>：计算结果为整数的<em>常量表达式</em>；<code>op</code>：<em>关系</em>或<em>判等</em>运算符)</li>
</ul>
<ol>
<li>setjmp(…)</li>
<li>!setjmp(…)</li>
<li><code>constexp</code> <code>op</code> <code>constexp</code></li>
<li>setjmp(…) <code>op</code> <code>constexp</code></li>
</ol>
<p><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env 用来保存生成的被调用时所处的“位置”(数组)</span><br><span class="line">* @return &#123;int&#125; 0：第一次调用时返回；非0：longjmp将控制权重新转给最初的setjmp宏调用，后者这次的返回值非零</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a>longjmp函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>首先根据参数env的值恢复当前环境，然后从<code>setjmp宏</code>调用中返回<br><strong>注意：</strong>一定要确保参数env已经被<code>setjmp宏</code>初始化了，否则程序可能会崩溃。<br><strong>应用：</strong>可以由多种潜在的用途，但主要被用于错误处理。<br><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env</span><br><span class="line">* @param &#123;int&#125; val</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试setjmp和longjmp"><a href="#程序：测试setjmp和longjmp" class="headerlink" title="程序：测试setjmp和longjmp"></a>程序：测试setjmp和longjmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests setjmp/longjmp</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @type &#123;jmp_buf&#125; env 存储位置数据的全局变量</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">// 获得存储位置</span></span><br><span class="line">	ret = setjmp(env);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"setjmp returned %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次执行到这里的时候值不为0</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Program terminates: longjmp called\n"</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f1();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这句不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Program terminates normally\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 begins\n"</span>);</span><br><span class="line">	f2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 returns\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 begins\n"</span>);</span><br><span class="line">	<span class="comment">// 按照env的值跳转到指定的环境</span></span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 returns\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsetjmp               </span><br><span class="line"> setjmp returned <span class="number">0</span></span><br><span class="line"> f1 begins</span><br><span class="line"> f2 begins</span><br><span class="line"> setjmp returned <span class="number">1</span></span><br><span class="line"> Program terminates: longjmp called</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/23 库对数值和字符数据的支持/" itemprop="url">
                  23 库对数值和字符数据的支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:31:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/23 库对数值和字符数据的支持/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/23 库对数值和字符数据的支持/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="23-1-float-h-浮点型的特性"><a href="#23-1-float-h-浮点型的特性" class="headerlink" title="23.1    float.h:浮点型的特性"></a>23.1    <code>float.h</code>:浮点型的特性</h2><p><strong>说明：</strong>提供了用来定义浮点型的范围和精度的宏（没有类型和函数的定义）。<br><strong>应用：</strong>由于只有进行数值分析的专家才会对上述<code>float.h</code>中定义的宏感兴趣，这可能是标砖哭中最不常用的宏。</p>
<h3 id="23-1-1-对浮点数通用的宏"><a href="#23-1-1-对浮点数通用的宏" class="headerlink" title="23.1.1    对浮点数通用的宏"></a>23.1.1    对浮点数通用的宏</h3><h4 id="FLT-ROUND宏"><a href="#FLT-ROUND宏" class="headerlink" title="FLT_ROUND宏"></a>FLT_ROUND宏</h4><p><strong>说明：</strong>浮点加法的舍入模式，存在5中可能<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.12.40.png" alt="Alt text"></p>
<h4 id="FLT-RADIX宏"><a href="#FLT-RADIX宏" class="headerlink" title="FLT_RADIX宏"></a>FLT_RADIX宏</h4><p><strong>说明：</strong>指定了基数的形式，最小值是2（二进制）</p>
<h3 id="23-1-2-其它宏"><a href="#23-1-2-其它宏" class="headerlink" title="23.1.2    其它宏"></a>23.1.2    其它宏</h3><p><strong>说明：</strong>其他宏用来描述特定类型的特性。<br><strong>宏命名：</strong>根据宏是针对的浮点类型有不同的前缀</p>
<table>
<thead>
<tr>
<th>宏前缀</th>
<th>针对的浮点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT</td>
<td>float</td>
</tr>
<tr>
<td>DBL</td>
<td>double</td>
</tr>
<tr>
<td>LDBL</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h4 id="与有效数字个数相关的宏"><a href="#与有效数字个数相关的宏" class="headerlink" title="与有效数字个数相关的宏"></a>与有效数字个数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.19.57.png" alt="Alt text"></p>
<h4 id="与指数相关的宏"><a href="#与指数相关的宏" class="headerlink" title="与指数相关的宏"></a>与指数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="Alt text"></p>
<h4 id="其它宏"><a href="#其它宏" class="headerlink" title="其它宏"></a>其它宏</h4><p><strong>说明：</strong>描述了最大值、最接近0的值（最小正数），两个数之间的最小差值。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.22.22.png" alt="Alt text"></p>
<h2 id="23-2-limit-h：整值类型的大小"><a href="#23-2-limit-h：整值类型的大小" class="headerlink" title="23.2    limit.h：整值类型的大小"></a>23.2    <code>limit.h</code>：整值类型的大小</h2><p><strong>说明：</strong>提供了用于定义每种整型和字符型取值范围的宏（没有类型或函数）。</p>
<h3 id="23-2-1-用于字符型的宏"><a href="#23-2-1-用于字符型的宏" class="headerlink" title="23.2.1    用于字符型的宏"></a>23.2.1    用于字符型的宏</h3><p><strong>说明：</strong><code>char、signed char、unsigned char</code><br><strong>注意：</strong>char类型在有些机器上默认为unsigned char，有些默认为signed char。CHAR_MIN和CHAR_MAX的值因不同情况有所不同。<br>①</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MIN</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MIN</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MAX</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MAX</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR_MAX</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.08.05.png" alt="Alt text"></p>
<h3 id="23-2-2-用于整型的宏"><a href="#23-2-2-用于整型的宏" class="headerlink" title="23.2.2    用于整型的宏"></a>23.2.2    用于整型的宏</h3><p><strong>说明：</strong><code>[{signed|unsigned}] [{short|long}] int</code><br><strong>用途：</strong>在查看编译器是否支持特定大小的整数时十分方便<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.27.34.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用预处理指令判断int型是否可以用来存储100 000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small<span class="comment">// 终止编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择正确的类型定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &gt;= 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="23-3-math-h：数学计算"><a href="#23-3-math-h：数学计算" class="headerlink" title="23.3    math.h：数学计算"></a>23.3    <code>math.h</code>：数学计算</h2><p><strong>说明：</strong>包含5中类型</p>
<ol>
<li>三角函数</li>
<li>双曲函数</li>
<li>指数和对数函数</li>
<li>幂函数</li>
<li>就近取整函数绝对值函数和取余函数</li>
</ol>
<h3 id="23-3-1-错误"><a href="#23-3-1-错误" class="headerlink" title="23.3.1    错误"></a>23.3.1    错误</h3><p><strong>相关库：</strong><code>errno.h</code><br><strong>特点：</strong><code>math.h</code>中，大多数函数会将一个错误代码存储到一个名字为<code>errno</code>（<code>math.h</code>）的特定变量中（这一点不同于其他库）。<br><strong>相关宏：</strong><code>HUGE_VAL</code>(<code>math.h</code>， IEEE标准)</p>
<blockquote>
<p><strong>说明：</strong>在<code>math.h</code>中定义，double类型，不一定是一个普通的数，代表无穷大（<a href="">7.2</a>）。<br><strong>用途：</strong>当函数的返回值大于double类型的最大值时，会返回<code>HUGE_VAL</code>。<br><strong>更多错误：</strong><a href="">附录D</a></p>
</blockquote>
<h4 id="参数超出定义域"><a href="#参数超出定义域" class="headerlink" title="参数超出定义域"></a>参数超出定义域</h4><p><strong>描述：</strong>函数的是惨超出了函数的定义域。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>EDOM</code>(定义域错误)<br><strong>返回值：</strong><code>NAN</code>(<code>math.h</code>， IEEE标准)</p>
<h4 id="返回值超出取值范围"><a href="#返回值超出取值范围" class="headerlink" title="返回值超出取值范围"></a>返回值超出取值范围</h4><p><strong>描述：</strong>函数的返回值超出了double类型的取值范围。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>ERANGE</code>(取值范围错误)，绝对值过小（下溢出）的情况又可能不存储<code>ERANGE</code><br><strong>返回值：</strong>分两种情况</p>
<ol>
<li><strong>绝对值过大：</strong>根据返回值的正负返回正或负的<code>HIGE_VAL</code></li>
<li><strong>绝对值过小：</strong>返回0</li>
</ol>
<h3 id="23-3-2-三角函数"><a href="#23-3-2-三角函数" class="headerlink" title="23.3.2    三角函数"></a>23.3.2    三角函数</h3><h4 id="cos函数"><a href="#cos函数" class="headerlink" title="cos函数"></a>cos函数</h4><p><strong>说明：</strong>余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sin函数"><a href="#sin函数" class="headerlink" title="sin函数"></a>sin函数</h4><p><strong>说明：</strong>正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tan函数"><a href="#tan函数" class="headerlink" title="tan函数"></a>tan函数</h4><p><strong>说明：</strong>正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="acos函数"><a href="#acos函数" class="headerlink" title="acos函数"></a>acos函数</h4><p><strong>说明：</strong>反余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 余弦值</span><br><span class="line">* @return &#123;double&#125; 余弦值对应的弧度（0~π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asin函数"><a href="#asin函数" class="headerlink" title="asin函数"></a>asin函数</h4><p><strong>说明：</strong>反正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正弦值</span><br><span class="line">* @return &#123;double&#125; 正弦值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan函数"><a href="#atan函数" class="headerlink" title="atan函数"></a>atan函数</h4><p><strong>说明：</strong>反正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正切值</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan2函数"><a href="#atan2函数" class="headerlink" title="atan2函数"></a>atan2函数</h4><p><strong>说明：</strong>反正切，<code>atan(x)&lt;==&gt;atan2(x, 1.0)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; y y</span><br><span class="line">* @param &#123;double&#125; x x</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π～π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cos</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(PI/<span class="number">4</span>);<span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">1.0</span>);<span class="comment">// 0.0</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">1.0</span>);<span class="comment">// 1.5708</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1.0</span>);<span class="comment">// 0.785398</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-4-双曲函数"><a href="#23-3-4-双曲函数" class="headerlink" title="23.3.4    双曲函数"></a>23.3.4    双曲函数</h3><h4 id="cosh函数"><a href="#cosh函数" class="headerlink" title="cosh函数"></a>cosh函数</h4><p><strong>说明：</strong>计算双曲余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cosh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sinh函数"><a href="#sinh函数" class="headerlink" title="sinh函数"></a>sinh函数</h4><p><strong>说明：</strong>计算双曲正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sinh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p><strong>说明：</strong>计算双曲正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tanh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cosh</span>(<span class="number">0.5</span>);<span class="comment">// 1.12763</span></span><br><span class="line"><span class="built_in">sinh</span>(<span class="number">0.5</span>);<span class="comment">// 0.521095</span></span><br><span class="line"><span class="built_in">tanh</span>(<span class="number">0.5</span>);<span class="comment">// 0.462117</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-指数函数和对数函数"><a href="#22-3-4-指数函数和对数函数" class="headerlink" title="22.3.4 指数函数和对数函数"></a>22.3.4 指数函数和对数函数</h3><h4 id="exp函数"><a href="#exp函数" class="headerlink" title="exp函数"></a>exp函数</h4><p><strong>说明：</strong>返回e的幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 指数</span><br><span class="line">* @return &#123;double&#125; e的x次幂</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e的3次幂</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">3.0</span>);<span class="comment">// 20.0855</span></span><br></pre></td></tr></table></figure>
<h4 id="log函数"><a href="#log函数" class="headerlink" title="log函数"></a>log函数</h4><p><strong>说明：</strong>以e为底的对数（exp函数的逆运算）<br><strong>原型：</strong>math.h``</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return double 以e为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">20.0855</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="log10函数"><a href="#log10函数" class="headerlink" title="log10函数"></a>log10函数</h4><p><strong>说明：</strong>计算常用对数（以10为底的对数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return &#123;double&#125; 以10为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log10</span>(<span class="number">1000</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 对任意的x和b，计算以b为底x的对数</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @param &#123;double&#125; b 底数</span><br><span class="line">* @return &#123;double&#125; 以b为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">logb</span><span class="params">(<span class="keyword">double</span> x. <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">log</span>(x) / <span class="built_in">log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="frexp函数"><a href="#frexp函数" class="headerlink" title="frexp函数"></a>frexp函数</h4><p><strong>说明：</strong>将浮点数拆成小数部分f和指数部分n，使得原始值等于<code>f x 2^n</code>。<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 浮点数原始值</span><br><span class="line">* @param &#123;double *&#125; iptr 存储n的地址</span><br><span class="line">* @return &#123;double&#125; f（0.5&lt;=f&lt;=1）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lfexp</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">frexp</span>(<span class="number">12.0</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// .75, exp: 4</span></span><br><span class="line"><span class="built_in">frexp</span>(<span class="number">0.25</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// 0.5, exp: -1</span></span><br></pre></td></tr></table></figure>
<h4 id="ldexp函数"><a href="#ldexp函数" class="headerlink" title="ldexp函数"></a>ldexp函数</h4><p><strong>说明：</strong>将小数部分f和整数部分exp组合为，一般而言为<code>f x 2^exp</code>(frexp函数的逆函数)<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; f 小数部分</span><br><span class="line">* @param &#123;int&#125; exp 整数部分</span><br><span class="line">* @return &#123;double&#125; f x 2^exp</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ldexp</span><span class="params">(<span class="keyword">double</span> f <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ldexp</span>(<span class="number">.75</span>, <span class="number">4</span>);<span class="comment">// 12.0</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.5</span>, <span class="number">-1</span>);<span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>
<h4 id="modf函数"><a href="#modf函数" class="headerlink" title="modf函数"></a>modf函数</h4><p><strong>说明：</strong>将一个浮点数的整数部分和小数部分拆解开，返回小数部分，并将整数部分存入第二个参数所指向的变量中<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 原始浮点数</span><br><span class="line">* @param &#123;double *&#125; iptr 存储整数部分的地址</span><br><span class="line">* @return &#123;double&#125; 小数部分 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-3-5-幂函数"><a href="#23-3-5-幂函数" class="headerlink" title="23.3.5    幂函数"></a>23.3.5    幂函数</h3><h4 id="pow函数"><a href="#pow函数" class="headerlink" title="pow函数"></a>pow函数</h4><p><strong>说明：</strong>计算x的y次幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 底数</span><br><span class="line">* @param &#123;double&#125; y 指数</span><br><span class="line">* @param &#123;double&#125; x^y</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);<span class="comment">// 9.0</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">0.5</span>);<span class="comment">// 1.73205</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">-3.0</span>);<span class="comment">// 0.037037</span></span><br></pre></td></tr></table></figure>
<h4 id="sqrt函数"><a href="#sqrt函数" class="headerlink" title="sqrt函数"></a>sqrt函数</h4><p><strong>说明：</strong>计算平方根（算数平方根），<code>sqrt(x)</code>相当于<code>pow(x, 0.5)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 开放数</span><br><span class="line">* @return &#123;double&#125; 平方根</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(<span class="number">3.0</span>);<span class="comment">// 1.73205</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-6-就近取整函数、绝对值函数和取余函数"><a href="#23-3-6-就近取整函数、绝对值函数和取余函数" class="headerlink" title="23.3.6    就近取整函数、绝对值函数和取余函数"></a>23.3.6    就近取整函数、绝对值函数和取余函数</h3><h4 id="ceil函数"><a href="#ceil函数" class="headerlink" title="ceil函数"></a>ceil函数</h4><p><strong>说明：</strong>向上舍入（计算大于或等于其参数的最小整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="floor函数"><a href="#floor函数" class="headerlink" title="floor函数"></a>floor函数</h4><p><strong>说明：</strong>向下舍入（计算小于或等于其参数的最大整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.1</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.8</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.1</span>);<span class="comment">// -7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.1</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.8</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.1</span>);<span class="comment">// -8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 实现“四舍五入”（标准库没实现）</span><br><span class="line">* @param &#123;double&#125; x 原始的浮点数</span><br><span class="line">* @return &#123;double&#125; 四舍五入后的</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	return x &lt; <span class="number">0.07</span> ? <span class="built_in">ceil</span>(x - <span class="number">0.5</span>) : <span class="built_in">floor</span>(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fabs函数"><a href="#fabs函数" class="headerlink" title="fabs函数"></a>fabs函数</h4><p><strong>说明：</strong>计算参数的绝对值<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 原始浮点数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="number">7.1</span>);<span class="comment">// 7.1</span></span><br><span class="line"><span class="built_in">fabs</span>(<span class="number">-7.1</span>);<span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<h4 id="fmod函数"><a href="#fmod函数" class="headerlink" title="fmod函数"></a>fmod函数</h4><p><strong>说明：</strong>取余（第一个参数除以第二个参数所得的余数）<br><strong>注意：</strong><code>%</code>只能用于整数，不能用于浮点数<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;double&#125; x 被除数</span><br><span class="line">* @param &#123;double&#125; y 除数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(<span class="number">5.5</span>, <span class="number">2.2</span>);<span class="comment">// 1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="23-4-ctype-h：字符处理"><a href="#23-4-ctype-h：字符处理" class="headerlink" title="23.4    ctype.h：字符处理"></a>23.4    <code>ctype.h</code>：字符处理</h2><p><strong>说明：</strong><code>ctype.h</code>提供了两类函数</p>
<ol>
<li><p>字符测试函数</p>
<blockquote>
<p><strong>举例</strong><br><code>isdigit函数</code>：用来检测一个字符是否是数字</p>
</blockquote>
</li>
<li><p>字符大小写转换函数</p>
<blockquote>
<p><strong>举例</strong><br><code>toupper函数</code>：用来将一个小写字母转换成大写字母</p>
</blockquote>
</li>
</ol>
<p><strong>技巧：</strong>建议使用<code>ctype.h</code>中提供的函数而不是用其他手段测试字符或进行大小写转换</p>
<ol>
<li>性能更好（大多数是用宏实现的）</li>
<li>可移植性更好（可以在任何字符集上运行）</li>
<li>国际化（可以正确运行在世界上不同地点）</li>
</ol>
<p><strong>特点（参数和返回值类型）</strong><code>ctype.h</code>中的函数都以<code>int</code>类型作为参数，并返回一个<code>int</code>类型的值（C语言可以自动将<code>char</code>类型的参数转换为<code>int</code>类型，或将<code>int</code>类型的返回值转换成<code>char</code>类型）。</p>
<h3 id="23-4-1-字符测试函数"><a href="#23-4-1-字符测试函数" class="headerlink" title="23.4.1    字符测试函数"></a>23.4.1    字符测试函数</h3><p><strong>说明：</strong>这些函数具有一样的<code>参数类型</code>和<code>返回值类型</code>。<br><strong>原型：</strong><code>ctype.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 要测试的字符</span><br><span class="line">* @param &#123;int&#125; 1:测试符合期待；0:测试不符合期待</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> 函数名(<span class="keyword">int</span> c);</span><br></pre></td></tr></table></figure>
<h4 id="字符测试函数列表"><a href="#字符测试函数列表" class="headerlink" title="字符测试函数列表"></a>字符测试函数列表</h4><table>
<thead>
<tr>
<th>字符测试函数</th>
<th>测试类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum</code></td>
<td>字母或数字</td>
</tr>
<tr>
<td><code>isalpha</code></td>
<td>字母</td>
</tr>
<tr>
<td><code>iscntrl</code></td>
<td>控制字符</td>
<td>包括<code>\0x00~\0x1f</code>、<code>\0x7f</code></td>
</tr>
<tr>
<td><code>isdigit</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>isgraph</code></td>
<td>可显示字符（除空格外）</td>
</tr>
<tr>
<td><code>islower</code></td>
<td>小写字母</td>
</tr>
<tr>
<td><code>isprint</code></td>
<td>可显示字符（包括空格）</td>
</tr>
<tr>
<td><code>ispunct</code></td>
<td>标点符号</td>
<td>空格、字母、数字以外的可显示字符</td>
</tr>
<tr>
<td><code>isspace</code></td>
<td>空白字符</td>
<td>空格、换页符(<code>\f</code>)、换行符(<code>\n</code>)、回车符(<code>\r</code>)、横向制表符(<code>\t</code>)、纵向制表符(<code>\v</code>)</td>
</tr>
<tr>
<td><code>isupper</code></td>
<td>大写字母</td>
</tr>
<tr>
<td><code>isxdigit</code></td>
<td>十六进制数字</td>
</tr>
</tbody>
</table>
<h3 id="23-4-2-程序：测试字符测试函数"><a href="#23-4-2-程序：测试字符测试函数" class="headerlink" title="23.4.2    程序：测试字符测试函数"></a>23.4.2    程序：测试字符测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(f) printf(<span class="string">"%6c"</span>, f(*p) ? <span class="string">'x'</span> : <span class="string">' '</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   alnum cntrl graph print space xdigit alpha digit lower punc       upper\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"azAZ0	!\t"</span>; *p != <span class="string">'0'</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(*p)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\\x%02x:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%5c:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		TEST(<span class="built_in">isalnum</span>);</span><br><span class="line">		TEST(<span class="built_in">iscntrl</span>);</span><br><span class="line">		TEST(<span class="built_in">isgraph</span>);</span><br><span class="line">		TEST(<span class="built_in">isprint</span>);</span><br><span class="line">		TEST(<span class="built_in">isspace</span>);</span><br><span class="line">		TEST(<span class="built_in">isxdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">isalpha</span>);</span><br><span class="line">		TEST(<span class="built_in">isdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">islower</span>);</span><br><span class="line">		TEST(<span class="built_in">ispunct</span>);</span><br><span class="line">		TEST(<span class="built_in">isupper</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.01.33.png" alt="Alt text"></p>
<h3 id="23-4-3-字符大小写转换函数"><a href="#23-4-3-字符大小写转换函数" class="headerlink" title="23.4.3    字符大小写转换函数"></a>23.4.3    字符大小写转换函数</h3><h4 id="tolower函数"><a href="#tolower函数" class="headerlink" title="tolower函数"></a>tolower函数</h4><p><strong>说明：</strong>返回与作为参数的字母相对应的小写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的小写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="toupper函数"><a href="#toupper函数" class="headerlink" title="toupper函数"></a>toupper函数</h4><hr>
<p><strong>说明：</strong>返回与作为参数的字母相对应的大写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的大写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-4-4-程序：测试大小写转换函数"><a href="#23-4-4-程序：测试大小写转换函数" class="headerlink" title="23.4.4    程序：测试大小写转换函数"></a>23.4.4    程序：测试大小写转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"aA0!"</span>; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tolower('%c') is '%c';\n"</span>, *p, <span class="built_in">tolower</span>(*p));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"toupper('%c') is '%c'\n"</span>, *p, <span class="built_in">toupper</span>(*p));</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.39.11.png" alt="Alt text"></p>
<h2 id="23-5-string-h：字符串处理"><a href="#23-5-string-h：字符串处理" class="headerlink" title="23.5    string.h：字符串处理"></a>23.5    <code>string.h</code>：字符串处理</h2><p><strong>相关章节：</strong><a href="">13.5</a><br><strong>函数分类：</strong>可以分为5类</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复制函数</td>
<td style="text-align:center">将字符从内存中的一处复制到另一处</td>
</tr>
<tr>
<td style="text-align:center">拼接函数</td>
<td style="text-align:center">向字符串末尾追加字符</td>
</tr>
<tr>
<td style="text-align:center">比较函数</td>
<td style="text-align:center">比较字符数组的函数</td>
</tr>
<tr>
<td style="text-align:center">搜索函数</td>
<td style="text-align:center">在字符数组中搜索特定字符、字符组或字符串</td>
</tr>
<tr>
<td style="text-align:center">其他函数</td>
<td style="text-align:center">初始化字符数组或计算字符串的长度</td>
</tr>
</tbody>
</table>
<h3 id="23-5-1-复制函数"><a href="#23-5-1-复制函数" class="headerlink" title="23.5.1    复制函数"></a>23.5.1    复制函数</h3><p><strong>说明：</strong>共4个函数，用于将字符（字节）将内存的一处（源）移动到另一处（目的）。要求第一个参数指向目的，第二个参数指向源，并返回第一个参数（即指向目的的指针）。</p>
<h4 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时无法正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>限制：</strong>当从一块内存区域复制到另一块可能重叠的内存区域时，不能保证正常工作。<br><strong>性能：</strong>比<code>memmove函数</code>快一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">4</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">7</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时仍然可以正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>性能：</strong>比<code>memcpy函数</code>性能差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，会持续肤质字符，知道遇到一个空字符为止。<br><strong>对源的要求：</strong>要求字符串以空字符结尾。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(dest, souce);<span class="comment">// h, o, t, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncpy函数"><a href="#strncpy函数" class="headerlink" title="strncpy函数"></a>strncpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，<code>strcpy函数</code>的增强版<br><strong>对源的要求：</strong>不要求字符串以空字符串结尾，对任意内存块正常工作。<br><strong>安全：</strong>比<code>strcpy函数</code>更安全<br><strong>性能：</strong>比<code>strcpy</code>差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符（如果）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, \0, \0, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-2-拼接函数"><a href="#23-5-2-拼接函数" class="headerlink" title="23.5.2    拼接函数"></a>23.5.2    拼接函数</h3><h4 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h4><hr>
<p><strong>说明：</strong>将第一个参数追加到第一个参数的末尾</p>
<ul>
<li><strong>参数：</strong>要求两个参数都是以<code>\0</code>结尾的字符串</li>
<li><strong>返回值：</strong>返回的字符串会自动在末尾添加<code>\0</code>。</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">"bag"</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncat函数"><a href="#strncat函数" class="headerlink" title="strncat函数"></a>strncat函数</h4><hr>
<p><strong>说明：</strong><code>strcat</code>的增强版，第3个参数会限制复制的字符的个数。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @param &#123;size_t&#125; n 限制复制的字符的个数</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">2</span>);<span class="comment">// t, e, a, b, a, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">3</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">4</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-3-比较函数"><a href="#23-5-3-比较函数" class="headerlink" title="23.5.3    比较函数"></a>23.5.3    比较函数</h3><p><strong>注意：</strong>下面5个函数可以分为两类</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>比较依据</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memcmp函数</code> 、<code>strcmp函数</code>、<code>strncmp函数</code></td>
<td>计算机自身的排序顺序（通常是ACILL）</td>
<td>好</td>
</tr>
<tr>
<td><code>strcoll函数</code>、<code>strxfrm函数</code></td>
<td>依赖当前的本地化设置</td>
<td>差</td>
</tr>
</tbody>
</table>
<h4 id="memcpm函数"><a href="#memcpm函数" class="headerlink" title="memcpm函数"></a>memcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串的大小(具有限制参与比较的字符个数的参数)<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;void *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<h4 id="strcpm函数"><a href="#strcpm函数" class="headerlink" title="strcpm函数"></a>strcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串（不能设置参与比较的字符数上限），在其中一个字符数组遇到<code>\0</code>时停止比较。</p>
<ul>
<li><strong>参数：</strong>必须是以<code>\0</code>结尾的字符串</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strncmp函数"><a href="#strncmp函数" class="headerlink" title="strncmp函数"></a>strncmp函数</h4><hr>
<p><strong>说明：</strong>结合<code>memcmp</code>和<code>strcmp</code>，当比较的字符数达到字符数上限或任意一个字符数组中遇到<code>\0</code>时停止比较。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="strcoll函数"><a href="#strcoll函数" class="headerlink" title="strcoll函数"></a>strcoll函数</h4><hr>
<p><strong>说明：</strong>类似<code>strcmp</code>，不同点在于比较结果依赖本地化设置（通过调用<code>setlocale函数</code><a href="">25.1.2</a>）。<br><strong>缺点：</strong>性能差。<br><strong>应用：</strong>适用于那些根据程序运行的地点不同而可能按不同方式比较的程序。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strxfrm函数"><a href="#strxfrm函数" class="headerlink" title="strxfrm函数"></a>strxfrm函数</h4><hr>
<p><strong>说明：</strong>按照本地化设置转换字符串。<br><strong>技巧：</strong>需要考虑本地化时可以配合<code>strcmp</code>来取代<code>strcoll</code>。因为对两个转化后的参数调用<code>strcmp</code>等价直接调用<code>strcoll</code>。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 转换后的字符串存储到s1</span><br><span class="line">* @return &#123;char *&#125; s2 需要转换的字符串</span><br><span class="line">* @param &#123;char *&#125; size_t 转换的字符数量上限</span><br><span class="line">* @return &#123;size_t&#125; 转换后字符串的长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strxfrm(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * restict s2, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> *transformed;</span><br><span class="line"><span class="comment">// 获取转换后字符串的长度</span></span><br><span class="line">len = strxfrm(NULL, original, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">transformed = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将转换后的字符串存储到分配的内存中</span></span><br><span class="line">strxfrm(transformed, original, len);</span><br></pre></td></tr></table></figure>
<h3 id="23-5-4-搜索函数"><a href="#23-5-4-搜索函数" class="headerlink" title="23.5.4    搜索函数"></a>23.5.4    搜索函数</h3><h4 id="strchr函数"><a href="#strchr函数" class="headerlink" title="strchr函数"></a>strchr函数</h4><hr>
<p><strong>说明：</strong>在字符串中搜索指定字符。<br><strong>停止搜索时机：</strong>遇到首个<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;char *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,  <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">'f'</span>);<span class="comment">// 找到第一个'f'</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">strchr</span>(p + <span class="number">1</span>, <span class="string">'f'</span>);<span class="comment">// 找到第二个'f'</span></span><br></pre></td></tr></table></figure>
<h4 id="memchr函数"><a href="#memchr函数" class="headerlink" title="memchr函数"></a>memchr函数</h4><hr>
<p><strong>说明：</strong>类似<code>strchr</code>，在字符串中搜索指定字符<br><strong>停止搜索时机：</strong>搜索了指定数量的字符后<br><strong>用途：</strong>适用于不希望对整个字符串进行搜索或搜索的内存块不是以<code>\0</code>结尾时<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @param &#123;size_t&#125; n 要搜索的字符数量上限</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strrhrc函数"><a href="#strrhrc函数" class="headerlink" title="strrhrc函数"></a>strrhrc函数</h4><hr>
<p><strong>说明：</strong>函数会首先找到字符串末尾的空字符，然后反向查找字符。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s1, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[<span class="number">22</span>] = <span class="string">"Form follows function"</span>;</span><br><span class="line"><span class="comment">// 反向搜索字符'f'</span></span><br><span class="line">p = <span class="built_in">memchr</span>(strr, <span class="string">'f'</span>, sizeof(str));</span><br></pre></td></tr></table></figure>
<h4 id="strpbrk函数"><a href="#strpbrk函数" class="headerlink" title="strpbrk函数"></a>strpbrk函数</h4><hr>
<p><strong>说明：</strong>返回指向第一个实际参数中与第二个实参中任意一个字符匹配的最左边一个字符的指针。<br><strong>更通用：</strong><code>strchr</code>相当于<code>strpbrk</code>的第二个参数字符串中只给一个字符的情况。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 匹配字符集</span><br><span class="line">* @return &#123;char *&#125; 指向匹配到的字符：匹配到；指针：没有匹配到</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索第一个'm'或'n'</span></span><br><span class="line">p = <span class="built_in">strpbrk</span>(str, <span class="string">"mm"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strspn函数"><a href="#strspn函数" class="headerlink" title="strspn函数"></a>strspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个不属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<h4 id="strcspn函数"><a href="#strcspn函数" class="headerlink" title="strcspn函数"></a>strcspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strcspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">" \t\n"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h4><hr>
<p><strong>说明：</strong>在第一个参数（字符串）中搜索能匹配第二个参数（字符串）的子串，并返回找到的第一处匹配子串的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在str中搜索"fun"</span></span><br><span class="line">p = <span class="built_in">strstr</span>(str, <span class="string">"fun"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><hr>
<p><strong>说明：</strong>分割出一段子字符串。<br><strong>原理：</strong>在s1中搜索，按照s2指定的分隔符找出一系列非空字符（不包含s2中指定的字符）。<code>strtok函数</code>会写入一个<code>\0</code>来标记字符序列的末尾，并返回指向这个序列的首字符的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串（要作为分割字符的字符集合）</span><br><span class="line">* @return &#123;char *&#125; 指向新分割出来的子字符串的指针（指向首字符）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>原始字符串状态</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">" Apri1  28,1990"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th><code> </code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>月</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割出第一个序列，使用" \t"中的字符作为分隔符</span></span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">p = strtok(str, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th><code>A</code></th>
<th><code>p</code></th>
<th><code>r</code></th>
<th><code>i</code></th>
<th><code>1</code></th>
<th><code>\0</code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>日</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th><code>2</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>年</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>\0</th>
<th><code>1</code></th>
<th><code>9</code></th>
<th><code>9</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="23-5-5-其他函数"><a href="#23-5-5-其他函数" class="headerlink" title="23.5.5    其他函数"></a>23.5.5    其他函数</h3><h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><hr>
<p><strong>说明：</strong>将一个字符的多个副本存储到指定区域。<br><strong>应用：</strong>将数组元素全部初始化为0<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 指向用来存储字符副本的空间</span><br><span class="line">* @param &#123;int&#125; c 用于填充的字符</span><br><span class="line">* @param &#123;size_t&#125; n 从s指向的地址往后填充空间大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 第一个参数（空间地址）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为p指向的内存的N哥字节存储空格</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="string">' '</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组a初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>
<h4 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h4><hr>
<p><strong>说明：</strong>返回字符串的长度，不计算字符串末尾的<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @return &#123;size_t&#125; 字符串的常速</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p><strong>说明：</strong><a href="">24.2</a><br><strong>原型：</strong><code>errno.h</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/22 输入／输出/" itemprop="url">
                  22 输入/输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:01:02+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/22 输入／输出/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/22 输入／输出/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="22-1-流"><a href="#22-1-流" class="headerlink" title="22.1    流"></a>22.1    流</h2><blockquote>
<p><strong>说明：</strong>在C语言中，术语流意味着任意输入的源或人意输出的目的地。<code>stdio.h</code>中的许多函数不仅可以处理表示成文件的流，还可以处理所有其它形式的流。<br><strong>流：</strong>流常常表示为磁盘上的文件，但却可以和其它类型的设备相关联：调制解调器、网络端口、打印机、光盘驱动器等。</p>
</blockquote>
<h3 id="22-1-1-文件指针"><a href="#22-1-1-文件指针" class="headerlink" title="22.1.1    文件指针"></a>22.1.1    文件指针</h3><blockquote>
<p><strong>文件指针（file pointer）：</strong><code>File *</code>(<code>File</code>定义在<code>stdio.h</code>中)<br><strong>用途：</strong>C程序中流的访问是通过<code>文件指针</code>实现的<br><strong>限制：</strong>操作系统通常会限制在任意某时刻可以打开的流的数量（但是一个程序中可以声明任意数量的<code>File *</code>型变量）。</p>
</blockquote>
<h3 id="22-1-2-标准流和重定向"><a href="#22-1-2-标准流和重定向" class="headerlink" title="22.1.2    标准流和重定向"></a>22.1.2    标准流和重定向</h3><h4 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h4><blockquote>
<p><strong>说明：</strong>由<code>stdio.h</code>提供，一共3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件指针</th>
<th>流</th>
<th>默认的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输出</td>
<td>屏幕</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关的函数：</strong><code>printf</code>、<code>scanf</code>、<code>putchar</code>、<code>getchar</code>、<code>puts</code>、<code>gets</code></p>
</blockquote>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><blockquote>
<p><strong>说明：</strong>某些操作系统（比如UNIX/Linux/DOS）允许通过所谓的<code>重定向（redirextion）</code>机制来改变标准流默认的含义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入重定向(input redirection)</td>
<td>使<code>stdin流</code>表示为文件(而非键盘)</td>
<td>程序不回意识到正在从文件读取数据</td>
</tr>
<tr>
<td>输出重定向(output redirection)</td>
<td>使<code>stdout流</code>和<code>stderr流</code>表示为文件（而飞屏幕）</td>
<td>程序不会意识到正在向文件中写数据</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入重定向</span></span><br><span class="line">demo &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出重定向</span></span><br><span class="line">demo &gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">demo &lt; in.dat &gt;out.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-1-3-文本文件与二进制文件"><a href="#22-1-3-文本文件与二进制文件" class="headerlink" title="22.1.3    文本文件与二进制文件"></a>22.1.3    文本文件与二进制文件</h3><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>支持两种类型的文件（文本文件和二进制文件）<br><strong>存储方式：</strong>文本文件和二进制文件都是字节的序列，不同点在于存储的数据类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>数据类型（假设字符集为ASCII，16位机器）</th>
<th>空间利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本文件(text file)</td>
<td>字符（占一个字节）</td>
<td>低</td>
</tr>
<tr>
<td>二进制文件(binary file)</td>
<td>字符（占一个字节）、整数（两个字节）、浮点数（四个字节）等</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>结束符：</strong></p>
<ul>
<li><strong>DOS系统：</strong>文本文件和二进制文件不同</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>文本文件</th>
<th>二进制文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>回行符＋回车符</td>
<td>回行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>Ctrl+Z(\x1a)，但不是必需的（有的编辑器会加上</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>UNIX系统：</strong>对文本文件和二进制文件不进行区分</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>换行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>在屏幕上显示文件内容的程序会假设文件为文本文件</li>
<li>复制文件时如果设定文件为文本文件，只会复制到出现文件末尾符出现的地方</li>
</ol>
<p><strong>技巧：</strong>在无法确定文件是文本文件还是二进制文件时，安全的做法是把文件假设为二进制文件。</p>
</blockquote>
<h2 id="22-2-文件操作"><a href="#22-2-文件操作" class="headerlink" title="22.2    文件操作"></a>22.2    文件操作</h2><h3 id="22-2-1-打开文件"><a href="#22-2-1-打开文件" class="headerlink" title="22.2.1    打开文件"></a>22.2.1    打开文件</h3><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><blockquote>
<p><strong>说明：</strong>用流的方式打开文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 含有要大开文件名的字符串（可能包含文件位置的信息，例如驱动号或路径）</span><br><span class="line">* @param &#123;char *&#125; mode 模式字符串，例如"r"代表只读方式</span><br><span class="line">* @return &#123;FILE *&#125; 文件指针（如果文件不存在或未获得打开文件的许可则返回空指针）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>在DOS中的文件名中含有”\”字符要用”\替代”<br><strong>注意：</strong>永远不能假设可以打开文件，为了确保不回返回空指针，需要测试<code>fopen</code>函数的返回值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"c:\\project\\test1.dat"</span>, r); <span class="comment">// 以只读方式打开</span></span><br></pre></td></tr></table></figure>
<h3 id="22-2-2-模式"><a href="#22-2-2-模式" class="headerlink" title="22.2.2    模式"></a>22.2.2    模式</h3><blockquote>
<p><strong>说明：</strong>模式字符串依据文件是文本文件还是二进制文件分为两大类。<br><strong>注意：</strong>可读且可写的模式（包含<code>+</code>）存在如下限制</p>
<ul>
<li>调用<code>文件定位函数</code>后，可读才能转换为可写</li>
<li>调用<code>文件定位函数</code>或<code>fflush函数</code>后，可写才能转换为可读</li>
</ul>
</blockquote>
<h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>rb</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>wb</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>ab</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h3 id="22-2-3-关闭文件"><a href="#22-2-3-关闭文件" class="headerlink" title="22.2.3    关闭文件"></a>22.2.3    关闭文件</h3><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><blockquote>
<p><strong>说明：</strong>关闭不再使用的文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针（来自fopen函数或freopen函数）</span><br><span class="line">* @return 0:关闭成功；EOF(stdio.h宏)：关闭失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="string">"example.dat"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.大开文件</span></span><br><span class="line">	fp = fopen(FILE_NAME, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Cant't open %s\n"</span>, FILE_NAME);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Opened!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.操作文件</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 3.关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-4-为流附加文件"><a href="#22-2-4-为流附加文件" class="headerlink" title="22.2.4    为流附加文件"></a>22.2.4    为流附加文件</h3><h4 id="freopen函数"><a href="#freopen函数" class="headerlink" title="freopen函数"></a>freopen函数</h4><blockquote>
<p><strong>说明：</strong>为已经打开的流附加一个不同的文件<br><strong>应用：</strong>把文件和一个标准流相关联<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;char *&#125; mode 打开模式</span><br><span class="line">* @param &#123;FILE *&#125; stream 标准流（stdin或stdout或stderr）</span><br><span class="line">* @return &#123;FILE *&#125; 附加成功：文件指针；NULL：打开失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,  FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.如果stdout通过命令行重定向或者freopen函数已经和其它文件关联，则先关闭与stdout相关联的文件</span></span><br><span class="line"><span class="comment">// fclose(frp); // fp指向是和stdout关联的流（文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开foo文件，并使此文件和stdout相关联</span></span><br><span class="line"><span class="comment">// 如果无法关闭旧的文件，那么freopen函数会忽略掉错误</span></span><br><span class="line">frp = freopen(<span class="string">"foo"</span>, <span class="string">"w"</span>, stdout)</span><br><span class="line"><span class="keyword">if</span> (frp == NULL) &#123;</span><br><span class="line">	<span class="comment">// 打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-5-从命令行获取文件名"><a href="#22-2-5-从命令行获取文件名" class="headerlink" title="22.2.5    从命令行获取文件名"></a>22.2.5    从命令行获取文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*</span><br><span class="line">* @param &#123;int&#125; argc 实际参数的数量</span><br><span class="line">* @param &#123;[].(char *)&#125;  一个指针数组，argv[0]指向程序的名字，其余指向实际参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv[0]: demo</span></span><br><span class="line"><span class="comment"># argv[1]: name.dat</span></span><br><span class="line"><span class="comment"># argv[2]: dates.dat.dat</span></span><br><span class="line">$ demo name.dat dates.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-6-程序：检查文件是否可以打开"><a href="#22-2-6-程序：检查文件是否可以打开" class="headerlink" title="22.2.6    程序：检查文件是否可以打开"></a>22.2.6    程序：检查文件是否可以打开</h3><blockquote>
<p><strong>说明：</strong>若文件存在就可以打开进行读入，在运行程序时，用户将给出要检测的文件的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks whether a file can be opened for reading</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="comment">// 如果没有正确调用，给出使用提示</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: canopen filanem\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不能以只读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s can't be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果能以只读的方式打开 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s can be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ canopen f1.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-7-临时文件"><a href="#22-2-7-临时文件" class="headerlink" title="22.2.7    临时文件"></a>22.2.7    临时文件</h3><blockquote>
<p><strong>说明：</strong>只在程序运行时存在的文件。<code>stdio.h</code>提供了两个函数用来处理临时文件，即<code>tmpfile</code>和<code>tmpname</code></p>
</blockquote>
<h4 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>产生临时文件，这些临时文件将存到文件关闭时或程序终止时。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @ return &#123;FILE *&#125; 指向临时文件的文件指针(如果创建失败则为NULL)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *tmpptr;</span><br><span class="line">Tempptr = tmpfile(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h4 id="tmpfile函数-1"><a href="#tmpfile函数-1" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>为临时文件产生名字。<br><strong>用途：</strong>解决<code>tmpfile函数</code>无法知道临时文件的名字的问题。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  如果实际参数为NULL，那么tmpnam函数会把文件名存储到静态变量中，并且返回指向此变量的指针；</span><br><span class="line">*  否则，如果提供了字符数组作为参数，函数会把文件名复制到程序员提供的字符数组中。</span><br><span class="line">*</span><br><span class="line">* @param &#123;char *&#125; NULL或者一个字符数组（字符串）</span><br><span class="line">* @return &#123;char *&#125; 指向静态变量（存储着临时文件名）的指针：如果参数为NULL；指向临时文件名的指针（非静态）：如果提供了有效的参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>参数为NULL</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line">filename = tmpnam(NULL); <span class="comment">// 创建临时文件名</span></span><br></pre></td></tr></table></figure>
<p><em>参数为字符数组</em></p>
<blockquote>
<p><strong>说明：</strong><code>tmpnam函数</code>会把声称的临时文件名复制到程序员提供的字符数组中，而且仍然会返回指向临时文件名的指针。<br><strong>注意：</strong>作为参数的字符数组长度至少为<code>L_tmpnam</code>,产生的临时文件名的最大数量不能超过<code>TMP_MAX</code>。</p>
<ul>
<li><code>L_tmpnam</code>：在<code>stdio.h</code>中定义的一个宏，保存着临时文件名的字符数组的长度。</li>
<li><code>TMP_MAX</code>：在<code>stdio.h</code>中定义的一个宏，保存着程序执行期间<code>tmpnam函数</code>产生的临时文件名的最大数量。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> filename[L_tmpnam];</span><br><span class="line">tmpnam(filename);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-8-文件缓冲"><a href="#22-2-8-文件缓冲" class="headerlink" title="22.2.8    文件缓冲"></a>22.2.8    文件缓冲</h3><blockquote>
<p><strong>说明：</strong>缓冲发生在屏幕的后台，而且通常不用担心它的操作。然而，极少的情况下可能需要我们承担更主动的作用，需要使用<code>fflush函数</code>、<code>setbuf函数</code>和<code>setbuf函数</code>。<br><strong>输入流缓存：</strong>从硬盘或磁盘读取，包含来自输入设备（键盘或磁盘）的数据<br><strong>写入（输出）流缓存：</strong>向输出设备（屏幕或磁盘）写入，包含来自</p>
</blockquote>
<h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><blockquote>
<p><strong>说明：</strong>针对输出（写入）流，把缓冲区的内容传递给磁盘（当缓冲区满了或者关闭文件时，缓冲区会自动“清洗”）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 把缓冲区的内容传递给磁盘</span><br><span class="line">* 当参数为NULL时，“清洗”所有缓冲区；否则，只清洗和参数指向的文件相关的缓冲区</span><br><span class="line">*</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 0：成功；EOF：发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fflush(fp); <span class="comment">// 为fp指向的文件</span></span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">// 清洗全部输出流</span></span><br></pre></td></tr></table></figure>
<h4 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h4><blockquote>
<p><strong>说明：</strong>改变缓冲流的方式，控制缓冲区的大小和位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; buf 期望缓冲区的地址</span><br><span class="line">* @param &#123;int&#125; 期望缓冲区的类型&#123;_IOFBF|_IOLBF|IONBF&#125;</span><br><span class="line">* @param &#123;size_t&#125; 缓冲区内字节的数量</span><br><span class="line">* @return &#123;int&#125; 0：成功；非零：要求的缓冲区模式无效或无法提供</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数要点：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>第N个参数</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>缓冲区的地址</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>缓冲区的类型</td>
<td>值为定义在<code>stdio.h</code>中的宏</td>
</tr>
<tr>
<td>4</td>
<td>缓冲区的大小</td>
<td>较大的缓冲区可以提供更好的性能，而较小的缓冲区可以节约时间。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的类型（宏）</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_IOFBF</td>
<td>满缓冲</td>
<td>当缓冲区为空时，从流读入数据；活着当缓冲区满时，向流写入数据</td>
</tr>
<tr>
<td>_IONLF</td>
<td>行缓冲</td>
<td>每次从流读入数据活着直接向流写入数据</td>
</tr>
<tr>
<td>_IOLBF</td>
<td>无缓冲</td>
<td>每次从流读入数据活着直接向流卸乳数据，而没有缓冲区</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的存储特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>存在于程序运行的整个过程中</td>
</tr>
<tr>
<td>自动存储期限</td>
<td>允许在它的空间在块退出时被自动重声明（?）</td>
</tr>
<tr>
<td>动态分配</td>
<td>在不需要时可以释放缓冲区</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>限制：</strong>必需在打开stream之后，在stream上执行任何操作之前调用<code>setvbuf</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建缓冲区</span></span><br><span class="line"><span class="keyword">char</span> buffer[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对缓冲区进行设置（必需在打开stream之后，在stream上执行任何操作之前调用setvbuf）</span></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, N);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-9-其他文件操作"><a href="#22-2-9-其他文件操作" class="headerlink" title="22.2.9    其他文件操作"></a>22.2.9    其他文件操作</h3><h4 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h4><blockquote>
<p><strong>说明：</strong>根据文件名删除文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">"foo"</span>); <span class="comment">// 删除名为foo的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h4><blockquote>
<p><strong>说明：</strong>文件重命名<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; old 旧文件名</span><br><span class="line">* @param &#123;char *&#125; new 新文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *old, <span class="keyword">const</span> <span class="keyword">char</span> *new)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>一定要确保在调用<code>rename函数</code>之前文件是关闭的，否则无法对文件重命名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="22-3-格式化的输入／输出"><a href="#22-3-格式化的输入／输出" class="headerlink" title="22.3    格式化的输入／输出"></a>22.3    格式化的输入／输出</h2><h3 id="22-3-1-…printf类函数"><a href="#22-3-1-…printf类函数" class="headerlink" title="22.3.1    …printf类函数"></a>22.3.1    …printf类函数</h3><h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><blockquote>
<p><strong>说明：</strong>向<code>stdout</code>输出，利用格式串控制输出的形式<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Total: %d\n"</span>, total);</span><br></pre></td></tr></table></figure>
<h4 id="fprintf函数"><a href="#fprintf函数" class="headerlink" title="fprintf函数"></a>fprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>和<code>printf函数</code>唯一的不同就是，<code>printf函数</code>始终向标准输出流<code>stdout</code>向中写入，而<code>fprintf函数</code>则向第一个参数说明的流（任何输出流）中写输出。<br><strong>应用：</strong>向标准错误<code>stderr</code>写出错信息。<br><strong>扩展：</strong><code>stdio.h</code>中还有其他两种函数也可以向流写入格式化的输出，分别是<code>vfprintf函数</code>和<code>vprintf函数</code>,而且它们都还依赖<code>stdarg.h</code>(<a href="">26.1</a>)。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向磁盘中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"Total:%d\n"</span>, total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向stderr中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: data file can't be opened.\n"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="22-3-2-…printf类函数的转换说明"><a href="#22-3-2-…printf类函数的转换说明" class="headerlink" title="22.3.2    …printf类函数的转换说明"></a>22.3.2    …printf类函数的转换说明</h3><blockquote>
<p><strong>说明：</strong>对已知的转换说明内容进行回顾，并把剩余的内容补充完整。<br><strong>注意：</strong>格式串必需遵守规则编写，许多看似可能的转换说明（<code>%le、%lf、%lg</code>等）实际上是无效的。</p>
</blockquote>
<h4 id="转换说明：-012-5Lg"><a href="#转换说明：-012-5Lg" class="headerlink" title="转换说明：%# 012.5Lg"></a><strong>转换说明：</strong><code>%# 012.5Lg</code></h4><table>
<thead>
<tr>
<th>%</th>
<th># 0</th>
<th>12</th>
<th>.5</th>
<th>L</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊标志</td>
<td>➋最小字段宽度</td>
<td>➌精度</td>
<td>➍长度修饰符</td>
<td>➎转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选（可多于一个）</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>转换说明提示符：</strong>标记格式串的开始<br><strong>➊标志：</strong>设置对齐方式、前缀、进制、填充</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>+</code></td>
<td>用<code>+</code>作为正数的前缀</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>用<code>空格</code>作为正数的前缀</td>
</tr>
<tr>
<td><code># 0</code>、<code># 0x(X)</code></td>
<td><code># 0</code>（8进制）、<code># 0x(X)</code>(16进制)，转换说明<code>g(G)</code>转换出的尾部0不能删除</td>
</tr>
<tr>
<td><code>0</code></td>
<td>除非转换说明为<code>d、i、o、u、x(X)</code>且制定了精度，否则用前导0在字段宽度内进行填充</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➋最小字段宽度：</strong>值为<code>有效整数</code>或<code>*</code></p>
<ul>
<li><code>有效整数</code>：**字符数少于最小字段宽度时对字符填充，默认右对齐（在左侧填充<code>空格</code>）；大于最小字段宽度则完整显示。</li>
<li><code>*</code>：格式串中的n个<code>*</code>对应<code>参数2</code>~<code>参数n-1</code>，可以是宏</li>
</ul>
<p><strong>➌精度：</strong>值为<code>.整数</code>或<code>.*</code>(精度的含义即依赖于转换说明符，也依赖于自身的值)</p>
</blockquote>
<table>
<thead>
<tr>
<th>说明符</th>
<th>精度值：<code>.整数</code></th>
<th>精度值：<code>.*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i、o、u、x(X)</code></td>
<td>最小数字位数（如果数字位数少于精度值，则添加前导0）</td>
<td>同<code>最小字段宽度</code>❷中<code>*</code>的含义</td>
</tr>
<tr>
<td><code>e(E)、f</code></td>
<td>小数点后的数字位数</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>最大有效数字位</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>最大字符数</td>
<td>（同上）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➍长度修饰符：</strong>共3个，只能和一些转换说明符搭配</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➎转换说明符：</strong>当对带有可变实参的函数（比如<code>printf</code>）传参时，会发生默认的实际参数的提升。<code>float</code>会转换为<code>double</code>，<code>char</code>会转换为<code>int</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参类型</th>
<th>格式化后的形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i</code></td>
<td>signed int</td>
<td>十进制形式</td>
</tr>
<tr>
<td><code>o、u、x(X)</code></td>
<td>unsigned int</td>
<td><code>o</code>(8进制)、<code>u</code>(10进制)、<code>x</code>(16进制，a-f来显示)、<code>X</code>(16进制，A-F来显示)</td>
</tr>
<tr>
<td><code>f</code></td>
<td>double</td>
<td>十进制形式（默认的精度为小数点后显示6位）</td>
</tr>
<tr>
<td><code>e(E)</code></td>
<td>double</td>
<td>科学计数法表示的double，默认精度为小数点后显示6位（<code>e</code>表示指数前为e，<code>E</code>表示指数前为E)</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>double</td>
<td><code>-4 &gt;= 指数部分 &lt; 精度值</code>则相当于<code>e</code>（对应<code>g</code>）或者<code>E</code>（对应<code>G</code>）；否则相当于<code>f</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>unsigned int</td>
<td>无符号整数</td>
</tr>
<tr>
<td><code>s</code></td>
<td>指向字符串的指针</td>
<td>按照<code>void *</code>型显示，达到精度值（如果存在）或空字符(<code>\0</code>)时停止写操作</td>
</tr>
<tr>
<td><code>p</code></td>
<td>*</td>
<td>转化为可显示格式的<code>void *</code>型值</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>int *</code>(指向int型数的指针)</td>
<td><code>...printf类函数</code>返回值（不会输出到屏幕，而是存储到所指向的int型数中）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>无对应参数</td>
<td>字符串”%”</td>
</tr>
</tbody>
</table>
<h3 id="22-3-3-…printf类函数的转换说明示例"><a href="#22-3-3-…printf类函数的转换说明示例" class="headerlink" title="22.3.3    …printf类函数的转换说明示例"></a>22.3.3    …printf类函数的转换说明示例</h3><h4 id="标志➊"><a href="#标志➊" class="headerlink" title="标志➊"></a>标志➊</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.07.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.22.png" alt="Alt text"></p>
<h4 id="最小字段宽度➋-精度➌"><a href="#最小字段宽度➋-精度➌" class="headerlink" title="最小字段宽度➋ + 精度➌"></a>最小字段宽度➋ + 精度➌</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.29.png" alt="Alt text"></p>
<h4 id="转换说明➎"><a href="#转换说明➎" class="headerlink" title="转换说明➎"></a>转换说明➎</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.08.42.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.45.png" alt="Alt text"></p>
<h4 id="最小字符宽度❷和精度❸中"><a href="#最小字符宽度❷和精度❸中" class="headerlink" title="最小字符宽度❷和精度❸中*"></a>最小字符宽度❷和精度❸中*</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小字符宽度❷和精度❸中*的用法示例</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.4d"</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.4d"</span>, <span class="number">6</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.*d"</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, <span class="number">6</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, WIDTH, I, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, page_width/num_cols, I, i); <span class="comment">// ..1234</span></span><br></pre></td></tr></table></figure>
<h4 id="转换说明p和n"><a href="#转换说明p和n" class="headerlink" title="转换说明p和n"></a>转换说明<code>p</code>和<code>n</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (void *)ptr); <span class="comment">// 显示指针ptr的值（可能会以8进制或16进制形式显示）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%n"</span>, <span class="number">123</span>, &amp;len); <span class="comment">// 将printf函数显示的字符数存储到len</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-…scanf类函数"><a href="#22-3-4-…scanf类函数" class="headerlink" title="22.3.4    …scanf类函数"></a>22.3.4    …scanf类函数</h3><h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><blockquote>
<p><strong>说明：</strong>从<code>stdin</code>（键盘）读入内容，根据格式串中的转换说明进行转换并存储在指针指定的位置上。<br><strong>原型：</strong><code>stdio.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;char *&#125; format 格式串</span><br><span class="line">&gt;* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">&gt;* return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> chat *format, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取一串整数，在首个"?"处停止</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;I) == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fscanf函数"><a href="#fscanf函数" class="headerlink" title="fscanf函数"></a>fscanf函数</h4><blockquote>
<p><strong>说明：</strong><code>scanf函数</code>从<code>stdin</code>读入数据，而<code>fscanf函数</code>则从它自己的第一个实参所指定的流中妇孺内容。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 指定的流</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="22-3-5-…scanf类函数的格式化字符串"><a href="#22-3-5-…scanf类函数的格式化字符串" class="headerlink" title="22.3.5    …scanf类函数的格式化字符串"></a>22.3.5    …scanf类函数的格式化字符串</h3><table>
<thead>
<tr>
<th>比较</th>
<th><code>...printf类函数</code></th>
<th><code>...scanf类函数</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>格式串的作用</td>
<td>转换数据形式并拼接</td>
<td>模式匹配和数据类型转换</td>
</tr>
<tr>
<td>数据源</td>
<td>指定的实参（不定参数部分）的值</td>
<td><code>stdin</code>（键盘输入）</td>
</tr>
<tr>
<td>数据源类型</td>
<td>多种类型</td>
<td>字符</td>
</tr>
</tbody>
</table>
<h4 id="格式串"><a href="#格式串" class="headerlink" title="格式串"></a>格式串</h4><blockquote>
<p><strong>例子：</strong><code>ISBN %d-%d-%ld-%d</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>ISBN</th>
<th>空格</th>
<th>%d</th>
<th>-</th>
<th>%d</th>
<th>-</th>
<th>%ld</th>
<th>-</th>
<th>%d</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISBN</td>
<td>空白字符（0或多个）</td>
<td>一个整数</td>
<td>-</td>
<td>一个整数</td>
<td>-</td>
<td>一个长整数</td>
<td>-</td>
<td>一个整数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
</tr>
</tbody>
</table>
<h5 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h5><blockquote>
<p><strong>说明：</strong>类似<code>...printf函数</code>格式串中中的转换说明。<br><strong>特点：</strong></p>
<ul>
<li>大多数转换说明会在输入项的开始出跳过空白字符（<code>%[、%c、%n</code>除外）</li>
<li>转换说明从来不回跳过尾部的空白字符（遇到换行符时，不会读区之并停止匹配返回）</li>
</ul>
</blockquote>
<h5 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h5><blockquote>
<p><strong>说明：</strong>格式串中的一个（或多个）空白字符匹配0个或多个输入流中的空白字符。</p>
</blockquote>
<h5 id="非空白字符"><a href="#非空白字符" class="headerlink" title="非空白字符"></a>非空白字符</h5><blockquote>
<p><strong>说明：</strong>非空白字符和输入流中相同字符进行匹配（<code>%</code>除外）</p>
</blockquote>
<h3 id="22-3-6-…scanf类函数的转换说明"><a href="#22-3-6-…scanf类函数的转换说明" class="headerlink" title="22.3.6    …scanf类函数的转换说明"></a>22.3.6    …scanf类函数的转换说明</h3><h4 id="转换说明：-12Ld"><a href="#转换说明：-12Ld" class="headerlink" title="转换说明：%*12Ld"></a><strong>转换说明：</strong><code>%*12Ld</code></h4><table>
<thead>
<tr>
<th>%</th>
<th>＊</th>
<th>12</th>
<th>L</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊赋值屏蔽</td>
<td>➋最小字段宽度</td>
<td>➌长度修饰符</td>
<td>❹转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❶赋值屏蔽（assignment suppression）：</strong>使用符号<code>*</code>，匹配空白符之外的连续字符，直到遇到空白符为止。</p>
<ul>
<li>匹配的数据项会被读入，但不会被赋值给变量</li>
<li>用*匹配到的数据相不回包含在<code>...scanf类函数</code>返回的计数中</li>
</ul>
<p><strong>❷最大字段宽度：</strong>限制转换说明匹配的输入项的字符数量（不计算跳过的空白符），达到限制的字符数量后便停止当前输入项的转换。<br><strong>❸长度修饰符：</strong>共3个，只能和一些转换说明符搭配，同时长度修饰符的选择取决于要存储为相匹配实参所指向的变量类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>对应实参（指针）的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>double</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❹转换说明符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参指针应当指向类型</th>
<th>匹配的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数</td>
<td>十进制整数</td>
</tr>
<tr>
<td>i</td>
<td>整数</td>
<td>自动判断进制（0打头：8进制；0x(X)打头：16进制；否则十进制）</td>
</tr>
<tr>
<td>o</td>
<td>unsigned int</td>
<td>八进制整数</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>十进制整数</td>
</tr>
<tr>
<td>x(X)</td>
<td>unsigned int</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>float</td>
<td>float型小数</td>
</tr>
<tr>
<td>s</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>一系列非空白字符</td>
</tr>
<tr>
<td>[</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>来自<code>扫描集合</code>的非空字符序列。<code>扫描集合</code>可以包含任何字符集，特别的是如果<code>扫描集合</code>中包含<code>]</code>，则要放在首位，例如<code>[]abc]</code>（<code>[abc]</code>：表示匹配只含有字母<code>a、b、c</code>的字符序列；<code>[^abc]</code>：表示匹配<code>a、b、c</code>都不存在的字符序列）</td>
</tr>
<tr>
<td>c</td>
<td>char *(指定<code>❷最大字段宽度</code>n，则在末尾添加<code>\0</code>，否则不添加)</td>
<td>指定<code>❷最大字段宽度</code>n，则匹配n个字符，否则旧就匹配一个字符</td>
</tr>
<tr>
<td>p</td>
<td>void *</td>
<td><code>...printf类函数</code>可以打印出的指针值（地址）</td>
</tr>
<tr>
<td>n</td>
<td>int(不指定<code>❸长度修饰符</code>)、short int(<code>❸长度修饰符</code>为<code>h</code>)、long int(<code>❸长度修饰符</code>为<code>l</code>)</td>
<td>不匹配任何字符，因而也不回影响<code>...scanf类函数</code>的放回值（对应的变量存储的是到目前为止已经读入的字符数）</td>
</tr>
<tr>
<td>%</td>
<td>char</td>
<td>匹配字符%</td>
</tr>
</tbody>
</table>
<h4 id="strtol函数-26-2-1"><a href="#strtol函数-26-2-1" class="headerlink" title="strtol函数(26.2.1)"></a>strtol函数(<a href="">26.2.1</a>)</h4><blockquote>
<p><strong>说明：</strong>将字符串根据参数base来转换成长整型数<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; nptr 要转换的字符串</span><br><span class="line">* @param &#123;int&#125; base 基数（0或2~36）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr,<span class="keyword">char</span> **endptr,<span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>和<code>...scanf类函数</code>转换说明符之间的对应关系</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>strol的参数base的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>10</td>
</tr>
<tr>
<td>i</td>
<td>0</td>
</tr>
<tr>
<td>o</td>
<td>8</td>
</tr>
<tr>
<td>u</td>
<td>10</td>
</tr>
<tr>
<td>x(X)</td>
<td>16</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="22-3-7-…scanf函数的示例"><a href="#22-3-7-…scanf函数的示例" class="headerlink" title="22.3.7    …scanf函数的示例"></a>22.3.7    …scanf函数的示例</h3><h4 id="转换说明、空白字符、非空白字符组合效果"><a href="#转换说明、空白字符、非空白字符组合效果" class="headerlink" title="转换说明、空白字符、非空白字符组合效果"></a>转换说明、空白字符、非空白字符组合效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.10.png" alt="Alt text"></p>
<h4 id="赋值屏蔽和指定字段宽度效果"><a href="#赋值屏蔽和指定字段宽度效果" class="headerlink" title="赋值屏蔽和指定字段宽度效果"></a>赋值屏蔽和指定字段宽度效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.25.png" alt="Alt text"></p>
<h4 id="难懂的转换说明：i、-、n"><a href="#难懂的转换说明：i、-、n" class="headerlink" title="难懂的转换说明：i、[、n"></a>难懂的转换说明：<code>i、[、n</code></h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.38.png" alt="Alt text"></p>
<h3 id="22-3-8-检测文件末尾和错误条件"><a href="#22-3-8-检测文件末尾和错误条件" class="headerlink" title="22.3.8    检测文件末尾和错误条件"></a>22.3.8    检测文件末尾和错误条件</h3><blockquote>
<p><strong>错误指示器（error indicator）：</strong>打开流时被清除，遇到错误时会被设置。<br><strong>文件末尾指示器（end of file indicator）：</strong>打开流时被清除，遇到文件末尾时被设置。<br><strong><code>...scanf类函数</code>出错分类：</strong>当<code>...scanf类函数</code>的返回值小于不定参数（要匹配）的数量时，由3中可能</p>
<ol>
<li><strong>提前遇到文件末尾：</strong>函数在完全匹配格式串之前遇到了文件末尾</li>
<li><strong>匹配失败：</strong>数据相的格式错误（比如函数在搜索整数的第一个数字期间遇到了一个字母）</li>
<li><strong>错误：</strong>错误的发生超出了函数控制的范围</li>
</ol>
</blockquote>
<h4 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h4><blockquote>
<p><strong>说明：</strong>清除文件末尾指示器和错误指示器<br><strong>注意：</strong><code>Q&amp;A</code>某些其他库函数因为副作用可以清除某种指示器或两种都可以清除，所以不回需要经常使用该函数。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>末尾指示器</code>，判断是否已经到达输入流（文件或<code>stdin</code>）末尾。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入文件的末尾</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ferror函数"><a href="#ferror函数" class="headerlink" title="ferror函数"></a>ferror函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>错误指示器</code>，判断输入过程是否发生错误<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入过程发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 搜索文件中以某个整数起始的行并返回行号</span><br><span class="line">* </span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;int *&#125; ptr 指向要将找到的整数存储到变量的指针</span><br><span class="line">* @return &#123;int&#125; 以整数起始的行的行号</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	<span class="function">FILE *fp <span class="title">fopen</span> <span class="params">(filename, <span class="string">"r"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, ptr) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果是输入错误</span></span><br><span class="line">		<span class="keyword">if</span> (ferror (fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是到达文件末尾</span></span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-3</span>; <span class="comment">// 整数没找到</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">"%*[^\n]"</span>); <span class="comment">// 跳过一行的其余部分</span></span><br><span class="line">		line++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">n = find_int(<span class="string">"foo"</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<h2 id="22-4-字符的输入／输出"><a href="#22-4-字符的输入／输出" class="headerlink" title="22.4    字符的输入／输出"></a>22.4    字符的输入／输出</h2><blockquote>
<p><strong>说明：</strong>本节的所有函数用于文本流和二进制流是等效的。</p>
</blockquote>
<h3 id="22-4-1-输出函数"><a href="#22-4-1-输出函数" class="headerlink" title="22.4.1    输出函数"></a>22.4.1    输出函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...scanf类函数</code>一样，<code>fputc、putc、putchar</code>出现错误都会为流设置<code>错误指示器</code>并返回<code>EOF</code>。</p>
</blockquote>
<h4 id="fputc函数"><a href="#fputc函数" class="headerlink" title="fputc函数"></a>fputc函数</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符（<code>putc</code>和<code>putchar</code>更通用的版本）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE * stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putc宏"><a href="#putc宏" class="headerlink" title="putc宏"></a>putc宏</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符(宏实现)<br><strong>优点和缺点：</strong><a href="">14.3</a><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putchar宏"><a href="#putchar宏" class="headerlink" title="putchar宏"></a>putchar宏</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>（屏幕）写一个字符，通常作为宏来实现（底层是<code>fputc</code>，因此性能不如<code>putc</code>）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> putchat(c) putc((c), stdout);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @return &#123;int&#125; </span><br><span class="line">int putchar(int c);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-2-输入函数"><a href="#22-4-2-输入函数" class="headerlink" title="22.4.2    输入函数"></a>22.4.2    输入函数</h3><blockquote>
<p><strong>注意：</strong><code>Q&amp;A</code>把char型变量与<code>EOF</code>比较可能会产生错误的结果。</p>
</blockquote>
<h4 id="getc宏"><a href="#getc宏" class="headerlink" title="getc宏"></a>getc宏</h4><blockquote>
<p><strong>说明：</strong>从指定流中读入一个字符（宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读入字符直到遇到文件末尾</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fgetc函数"><a href="#fgetc函数" class="headerlink" title="fgetc函数"></a>fgetc函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读如一个字符。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = fgetc(fp); <span class="comment">// 从fp中读取一个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="getchar（宏）"><a href="#getchar（宏）" class="headerlink" title="getchar（宏）"></a>getchar（宏）</h4><blockquote>
<p><strong>说明：</strong>从标准输出流<code>stdout</code>（键盘）中获得一个字符（通常是用宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar getc(stdin);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-3-程序：复制文件"><a href="#22-4-3-程序：复制文件" class="headerlink" title="22.4.3    程序：复制文件"></a>22.4.3    程序：复制文件</h3><blockquote>
<p><strong>说明：</strong>采用”rb”和”wb”作为文件的模式使<code>fcopy</code>程序既可以复制文本文件也可以复制二进制文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Copy a file(既可以是文本文件，也可以是二进制文件)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *source_fp, *dest_fp;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有给出正确的参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: fcopy source dest\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开原始文件</span></span><br><span class="line">	<span class="keyword">if</span> ((source_fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开目标文件</span></span><br><span class="line">	<span class="keyword">if</span> ((dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">"wb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制内容(一个字符一个字符地)</span></span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(source_fp)) != EOF) &#123;</span><br><span class="line">		putc(ch, dest_fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(source_fp);</span><br><span class="line">	fclose(dest_fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./fcopy source.dat dest.dat</span><br></pre></td></tr></table></figure>
<h2 id="22-5-行的输入／输出"><a href="#22-5-行的输入／输出" class="headerlink" title="22.5    行的输入／输出"></a>22.5    行的输入／输出</h2><blockquote>
<p><strong>说明：</strong>读和写行的苦函数（虽然也可以有效地用于二进制文件流，但多数用于文本流）。</p>
</blockquote>
<h3 id="22-5-1-输出函数"><a href="#22-5-1-输出函数" class="headerlink" title="22.5.1    输出函数"></a>22.5.1    输出函数</h3><h4 id="puts函数-13-3"><a href="#puts函数-13-3" class="headerlink" title="puts函数(13.3)"></a>puts函数(<a href="">13.3</a>)</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>写入一串字符（总会在后面添加一个换行符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">puts</span><span class="params">(chat *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Hi, there!"</span>); <span class="comment">// 向stdout(屏幕)输出"Hi, there!"</span></span><br></pre></td></tr></table></figure>
<h4 id="fputs函数"><a href="#fputs函数" class="headerlink" title="fputs函数"></a>fputs函数</h4><blockquote>
<p><strong>说明：</strong>向指定的流输出一串字符（不会在后面自动添加换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fput</span><span class="params">(chat *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">"Hi, there!"</span>, fp); <span class="comment">// 向fp输出"Hi. there!"</span></span><br></pre></td></tr></table></figure>
<h3 id="22-5-2-输入函数"><a href="#22-5-2-输入函数" class="headerlink" title="22.5.2    输入函数"></a>22.5.2    输入函数</h3><blockquote>
<p><strong>返回值：</strong>无论<code>gets</code>还是<code>fgets</code>，如果出现了错误，活着使在存储人和字符之前大道了输入流的末尾，都会返回空指针<code>NULL</code>;否则，返回指向读入字符串的指针。<br><strong>末尾空字符：</strong>两个函数都会在字符串的末尾存储空字符。<br><strong>技巧：</strong>大多数情况下用<code>fgets</code>而不是<code>gets</code>（只有在确保读入的字符正好适合数组大小时才使用），因为后者会超出接收数组范围的可能</p>
</blockquote>
<h4 id="gets函数（13-3）"><a href="#gets函数（13-3）" class="headerlink" title="gets函数（13.3）"></a>gets函数（<a href="">13.3</a>）</h4><blockquote>
<p><strong>说明：</strong>从标准输入流<code>stdin</code>中读取一串字符（逐个读取字符，并且把它们存储在字符串中，直到读取到换行符为止，因此不存储换行符）<br><strong>注意：</strong>只有在确保读入的字符正好适合数组大小时才使用，因为会有超出接收数组范围的可能。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储位置（首地址）</span><br><span class="line">* @return &#123;char *&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">chat *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读取一串字符（有时会存储换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;char *&#125; s  存储位置（首地址）</span><br><span class="line">* @param &#123;int&#125; n 限制读取字符的数量(保证不回超过s的存储能力)</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件字符（要读取的目标流）</span><br><span class="line">* @return &#123;char *&#125; 读取到的字符串</span><br><span class="line">*/</span><br><span class="line">char *fget(char *s, int n, FILE *stream));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>可以从任意流中读取信息</li>
<li>比<code>gets</code>更加安全，因为可以限制要存储的字符的数量</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个读入字符，在遇到首个换行符时或已经读入sizeof(str)-1个字符时结束操作</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-6-块的输入／输出"><a href="#22-6-块的输入／输出" class="headerlink" title="22.6    块的输入／输出"></a>22.6    块的输入／输出</h2><blockquote>
<p><strong>说明：</strong><code>fread</code>和<code>fwrite</code>允许程序在一次读和写大的数据块（任意数据类型）。<br><strong>用途：</strong>当程序在终止之前使用<code>fwrite函数</code>把数据存储到文件中，稍后，程序可以把数据从文件读入到内存。<br><strong>注意：</strong><code>Q&amp;A</code>小心使用<code>fread</code>函数和<code>fwrite</code>函数可以用于文本流，但它们主要还是用于二进制的流。</p>
</blockquote>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><blockquote>
<p><strong>说明：</strong>从流读入数据块。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 读入后数据块存储位置的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块的数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要读的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际读入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line">fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从fp指向的流位置读出数组并存储到数组a中</span></span><br><span class="line">n = fread(a, sizeof(a[<span class="number">0</span>], sizeof(a)/sizeof(a[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure>
<h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><blockquote>
<p><strong>说明：</strong>把内存中的数据块复制到流。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 存储数据块的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要写入的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际写入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream );</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内存中数组a复制到fp指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(a, <span class="keyword">sizeof</span>(a[<span class="number">0</span>], sizeof(a)/sizof(a[<span class="number">0</span>]), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存中的结构体（实例）存储到指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(&amp;s, sizeof(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-7-文件的定位"><a href="#22-7-文件的定位" class="headerlink" title="22.7    文件的定位"></a>22.7    文件的定位</h2><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>提供了5个函数允许程序确定当前的文件位置或者改变文件位置，通过这些函数可以实现文件的随机访问（任意访问）。<br><strong>注意：</strong>文件定为函数最适合二进制文件，处理文本流可能出现操作系统差异。<br><strong>文件位置（file position）：</strong>每个流都由文件位置，可以看作当前访问到的位置。在执行读或者写操作时，文件位置会自动推进。</p>
</blockquote>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><blockquote>
<p><strong>说明：</strong>改变指定流的文件位置，相关的宏有3个</p>
<ul>
<li>SEEK_SET：文件的起始处</li>
<li>SEEK_CUR：文件的当前位置</li>
<li>SEEK_END：文件的末尾处</li>
</ul>
<p><strong>注意：</strong>fseek函数对流是<code>文本型</code>还是<code>二进制型</code>非常敏感</p>
<ul>
<li><strong>文本型：</strong>参数必须是以下两种情景之一</li>
</ul>
<ol>
<li>offset必须为0（即只能移动到文件的起始处或末尾）</li>
<li>whence必须是<code>SEEK_SET</code>，且offset是通过<code>ftell函数</code>获取的（即返回前一次访问到的位置）</li>
</ol>
<ul>
<li><strong>二进制型：</strong>不要求支持whience是SEEK_END<br><strong>原型：</strong><code>stdio.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;long int&#125; offset 目标位置距离whence的距离，可以是负值</span><br><span class="line">* @param &#123;int&#125; whence 参照位置，值为SEEK_SET或SEEK_CUR或SEEK_END</span><br><span class="line">* @return &#123;int&#125; 0:成功；非0:产生错误（比如位置不存在）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置移动到文件起始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置移动到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置基于当前位置向后移动10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10</span>L, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><blockquote>
<p><strong>说明：</strong>以长整型返回当前文件位置<br><strong>注意：</strong><code>二进制文件</code>和<code>文本文件</code>的返回值情况有所不同</p>
<ul>
<li><strong>二进制文件：</strong>以字节计算返回当前位置</li>
<li><strong>文本文件：</strong>不一定按照字节计数</li>
</ul>
<p><strong>用途：</strong>可能会存储返回的值并且稍后将其提供给<code>fseek函数</code><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @patam &#123;long int&#125; 当前文件位置：成功；－1L：发生错误（同时会把错误码存储到errno中）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> file_pos;</span><br><span class="line">...</span><br><span class="line">file_pos = ftell(fp); <span class="comment">// 获取当前文件位置</span></span><br><span class="line">...</span><br><span class="line">fseek(fp, file_pos, SEEK_SET); <span class="comment">// 返回到之前存储下的文件位置处</span></span><br></pre></td></tr></table></figure>
<h4 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h4><blockquote>
<p><strong>说明：</strong>把文件位置设置到文件起始处，几乎等价于<code>fseek(fp, 0L, SEEK_SET)</code>,差异是该函数没有返回值，但会为fp清除掉<code>错误指示器</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgetpos函数"><a href="#fgetpos函数" class="headerlink" title="fgetpos函数"></a>fgetpos函数</h4><blockquote>
<p><strong>说明：</strong>将指定流的文件位置存储到fpos_t型变量中<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE * restrict&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t * restrict&#125; fpos_t型变量</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> stream, fpos_t * <span class="keyword">restrict</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsetpos函数"><a href="#fsetpos函数" class="headerlink" title="fsetpos函数"></a>fsetpos函数</h4><blockquote>
<p><strong>说明：</strong>为指定流设置文件fpos_t型位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t&#125; pos 文件位置</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream,  <span class="keyword">const</span> fpos_t *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fpos_t</span> file_pos;</span><br><span class="line">...</span><br><span class="line">fgetpos(fp, &amp;file_pos); <span class="comment">// 获取当前文件位置并保存</span></span><br><span class="line">...</span><br><span class="line">fsetpos(fp, &amp;file_pos); <span class="comment">// 设置文件位置到之前保存的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="程序：修改零件记录文件"><a href="#程序：修改零件记录文件" class="headerlink" title="程序：修改零件记录文件"></a>程序：修改零件记录文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * modify a file of part records by setting the quantity</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NAME_LEN 25	</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"><span class="keyword">struct</span> part &#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_parts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开清单</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"invent.dat"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open inventory file\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取零件(元素为结构体的数组)</span></span><br><span class="line">	num_parts = fread(inventory, sizeof(struct part), MAX_PARTS, fp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line">		inventory[i].on_hand = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动到文件开始处</span></span><br><span class="line">	rewind(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将修改后的清单数据存储到文件中</span></span><br><span class="line">	fwrite(inventory, <span class="keyword">sizeof</span>(struct part), num_parts, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-8-字符串的输入／输出"><a href="#22-8-字符串的输入／输出" class="headerlink" title="22.8    字符串的输入／输出"></a>22.8    字符串的输入／输出</h2><blockquote>
<p><strong>扩展：</strong>还有一个依赖<code>stdarg.h</code>定义<code>va_list</code>的<code>vsprintf函数</code>（<a href="">26.1.2</a>）</p>
</blockquote>
<h4 id="sprintf函数"><a href="#sprintf函数" class="headerlink" title="sprintf函数"></a>sprintf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>printf函数</code>和<code>fprintf函数</code>，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d/%d/%d"</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">94</span>); <span class="comment">// str: 9/20/94</span></span><br></pre></td></tr></table></figure>
<h4 id="sscanf函数"><a href="#sscanf函数" class="headerlink" title="sscanf函数"></a>sscanf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>scanf函数</code>和<code>fscanf函数</code>，唯一的不同是该函数是从字符数组而不是流中读取数据。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败(找到第一个数据项之前到达)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用fgets函数来获取一行输入，然后把此行数据传递给scanf函数进一步处理</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d%d"</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串中读取日期</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str, <span class="string">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sscanf(str, <span class="string">"%d-%d-%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/21 标准库/" itemprop="url">
                  21	标准库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:33:07+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/21 标准库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/21 标准库/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="21-1-标准库的使用"><a href="#21-1-标准库的使用" class="headerlink" title="21.1    标准库的使用"></a>21.1    标准库的使用</h2><blockquote>
<p><strong>标准头：</strong>依据C标准，一个“标准头”不需要一定是文件，有可能内置在编译器自身中。<br><strong>标准库：</strong>C语言的标准库总共划分成<code>15</code>个部分，每个部分用一个头描述。<br><strong>扩展：</strong>许多编译器会使用扩展后的库，这类库（头文件）通常提供一些针对特定畸形或特定操作系统的函数（比如更多对屏幕或键盘操作的函数，用于支持图形或窗口界面的头等）</p>
</blockquote>
<h3 id="21-1-1-包含标准头的程序中使用的名字的一些限制"><a href="#21-1-1-包含标准头的程序中使用的名字的一些限制" class="headerlink" title="21.1.1    包含标准头的程序中使用的名字的一些限制"></a>21.1.1    包含标准头的程序中使用的名字的一些限制</h3><blockquote>
<p><strong>意义：</strong>虽然这些规则并不总是强制性的，但不遵守这些规则可能会导致程序的可移植性下降。</p>
</blockquote>
<h4 id="必需遵守"><a href="#必需遵守" class="headerlink" title="必需遵守"></a>必需遵守</h4><ul>
<li><strong>宏的名字：</strong>不能再使用在头文件中定义过的宏的名字</li>
<li><strong>类型名（<code>typedef</code>）：</strong>具有文件作用域的库名（包括类型名）不可以在文件层次重新定义</li>
</ul>
<h4 id="建议遵守（避开保留字）"><a href="#建议遵守（避开保留字）" class="headerlink" title="建议遵守（避开保留字）"></a>建议遵守（避开保留字）</h4><ul>
<li>由<code>_大写字母</code>或<code>__</code>开头的标识符</li>
<li>由<code>_</code>开头的标识符（除非仅声明在函数内部）</li>
<li>标准库中所有具备外部链接的标识符，特别是所有标准库中的函数</li>
</ul>
<h3 id="21-1-2-使用宏隐藏函数"><a href="#21-1-2-使用宏隐藏函数" class="headerlink" title="21.1.2    使用宏隐藏函数"></a>21.1.2    使用宏隐藏函数</h3><blockquote>
<p><strong>说明：</strong>标准库中经常会为小的实际函数定义同名的宏函数，这是允许的，目的是提高程序的运行速度。<br><strong>取消隐藏：</strong>如果需要尽量缩小可执行代码的大小，或者需要一个指向这个库函数的指针，可以使用<code>undef</code>取消相应的红定义即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> isprint <span class="comment">// 即使isprint没定义过，也不会有负面影响</span></span></span><br></pre></td></tr></table></figure>
<p><strong>绕过宏调用：</strong>可以通过为函数名加圆括号来屏蔽个别宏调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(isptint)(); <span class="comment">// 预处理器无法分辨出带圆括号的宏，而编译器仍可认出isprint函数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-2-标准库概述"><a href="#21-2-标准库概述" class="headerlink" title="21.2    标准库概述"></a>21.2    标准库概述</h2><table>
<thead>
<tr>
<th>概述</th>
<th>标准头（15个）</th>
<th>提供的功能</th>
<th>相关章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>诊断</td>
<td>assert.h</td>
<td>仅包含<code>assert</code>宏，检查程序的状态，一旦任何检查失败，程序终止</td>
<td><a href="">24.1</a></td>
</tr>
<tr>
<td>字符处理</td>
<td>ctype.h</td>
<td>包括用于字符分类及大小写转换的函数</td>
<td><a href="">23.4</a></td>
</tr>
<tr>
<td>错误</td>
<td>errno.h</td>
<td>提供了<code>errno(&quot;errno number&quot;)</code>，errno是一个左值，可以在调用特定苦函数后进行监测，来判断调用过程中是否有错误发生</td>
<td><a href="">24.2</a></td>
</tr>
<tr>
<td>浮点型的特点</td>
<td>float.h</td>
<td>提供了用于描述浮点型特点的宏，包括值的范围及精度</td>
<td><a href="">23.1</a></td>
</tr>
<tr>
<td>整型的大小</td>
<td>limits.h</td>
<td>提供了用于描述整数类型和字符类型的宏，包括它们的最大值和最小值</td>
<td><a href="">23.2</a></td>
</tr>
<tr>
<td>本地化</td>
<td>locale.h</td>
<td>与本地化相关的行为，包括小数点的字符、货币的格式、字符集一集日期和时间的显示</td>
<td><a href="">25.1</a></td>
</tr>
<tr>
<td>数学计算</td>
<td>math.h</td>
<td>大量用于数据计算的函数，大部分使用double类型的实参，并返回一个double类型的值</td>
<td><a href="">23.3</a></td>
</tr>
<tr>
<td>非本地条转</td>
<td>setjmp.h</td>
<td>setjmp函数和longjmp函数<a href="**setjmp函数和long函数：**会“标记”程序中的一个位置，随后可以用`longjmp`返回被标记的位置，这些函数可以用来从一个函数跳转到另一个（仍然活动中的）函数中绕过正常的函数返回机制。`setjmp`函数和`longjmp`函数主要用来处理程序执行过程中的重大问题。">^21-2-7</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>信号处理</td>
<td>signal.h</td>
<td>用于异常情况（信号）处理的函数，包括终端和运行时错误<a href="**sinal函数：**可以设置一个函数，使系统会在给定信号发生后自动调用改函数；`raise函数`用来产生一个信号。">^21-2-8-signal</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>可变实际参数</td>
<td>stdarg.h</td>
<td>提供给函数可以处理不定个参数的的工具，就像<code>printf</code>和<code>scanf</code>函数</td>
<td><a href="">26.1</a></td>
</tr>
<tr>
<td>常用定义</td>
<td>stddef.h</td>
<td>提供了经常使用的类型和宏的定义</td>
<td><a href="">21.3</a></td>
</tr>
<tr>
<td>输入／输出</td>
<td>stdio.h</td>
<td>提供了大量用于输入／输出的函数，包括对顺序读写和随机读写文件的操作</td>
<td><a href="">22.1</a></td>
<td></td>
</tr>
<tr>
<td>常用实用程序</td>
<td>stdlib.h</td>
<td>包含了大量无法华贵其它头的函数[^stdlib]</td>
<td><a href="">26.2</a></td>
</tr>
<tr>
<td>字符串处理</td>
<td>string.h</td>
<td>提供了用于进行字符串操作的函数，包括肤质、拼接、比较以及搜索</td>
<td><a href="">23.5</a></td>
</tr>
<tr>
<td>日期与时间</td>
<td>time.h</td>
<td>提供相应的函数来获取日期和时间、操作时间和以多种方式显示时间等。</td>
<td><a href="">26.3</a></td>
</tr>
</tbody>
</table>
<h2 id="21-3-：常用定义"><a href="#21-3-：常用定义" class="headerlink" title="21.3    ：常用定义"></a>21.3    <stddef.h>：常用定义</stddef.h></h2><blockquote>
<p><strong>说明：</strong><code>stddef.h</code>提供了常用的类型和宏的定义，但没有声明任何函数。</p>
</blockquote>
<h3 id="21-3-1-定义的类型"><a href="#21-3-1-定义的类型" class="headerlink" title="21.3.1    定义的类型"></a>21.3.1    定义的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>原始类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptrdiff_t</td>
<td>当记性指针相减运算时，其结果的类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>size_t</td>
<td>运算符<code>sizeof</code>的返回值类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>wchar_t</td>
<td>一种足够大的、可以用于表示所有支持的地区的所有字符的类型</td>
<td>整数类型</td>
</tr>
</tbody>
</table>
<h3 id="21-3-2-定义的宏"><a href="#21-3-2-定义的宏" class="headerlink" title="21.3.2    定义的宏"></a>21.3.2    定义的宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>空指针</td>
</tr>
<tr>
<td>offsetof</td>
<td>计算结构的起点到指定成员间的字节数</td>
</tr>
</tbody>
</table>
<h4 id="21-3-2-1-offsetof"><a href="#21-3-2-1-offsetof" class="headerlink" title="21.3.2.1    offsetof"></a>21.3.2.1    offsetof</h4><blockquote>
<p><strong>说明：</strong>计算结构成员的偏移量（距结构起点的距离）<br><strong>用途：</strong>对人和编译器都会返回正确的偏移量，使我们可以编写一致性更好的程序。<br><strong>结构体成员的偏移量：</strong>一些编译器会在结构中留下一些空洞（无效字节），从而影响到<code>offsetof</code>产生的值。</p>
</blockquote>
<p><code>@param {struct}</code> 结构类型本身（不是实例）<br><code>@param {*}</code> 结构的成员<br><code>@return {int}</code> 结构的起点到指定成员的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> s &#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetof(<span class="keyword">struct</span> s, a); <span class="comment">// 0，C语言确保结构的第一个成员的地址与结构自身地址相同</span></span><br><span class="line"></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, b); <span class="comment">// 1（或2）</span></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, c); <span class="comment">// 5（或6）</span></span><br></pre></td></tr></table></figure>
<hr>
<p>[^stdlib]:  包含在<code>&lt;stdlib.h&gt;</code>中的函数可以将字符串转换成数、产生随机值、执行内存管理任务、域操作系统通信、执行搜索与排序以及对多字节字符及字符串进行操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/20 低级程序设计/" itemprop="url">
                  20 低级程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:05:58+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/20 低级程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/20 低级程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>位操作和其他一些低级运算在编写系统程序（包括编译器和操作系统）、加密程序、图形程序以及其他一些需要高执行速度或高效地使用空间的程序时非常有用。</p>
</blockquote>
<h2 id="20-1-按位运算符"><a href="#20-1-按位运算符" class="headerlink" title="20.1    按位运算符"></a>20.1    按位运算符</h2><blockquote>
<p><strong>说明：</strong>C语言一共提供了6个按位运算符。</p>
</blockquote>
<h3 id="20-1-1-移位运算符"><a href="#20-1-1-移位运算符" class="headerlink" title="20.1.1    移位运算符"></a>20.1.1    移位运算符</h3><blockquote>
<p><strong>说明：</strong>移位运算符可以改变数的二进制形式，将它的位向左或向右移动。<br><strong>优先级：</strong>低于算数运算符<code>i&lt;&lt;2+1 &lt;==&gt; i&lt;&lt;(2+1)</code><br><strong>操作数类型要求：</strong>可以是任意整型或字符型的<br><strong>副作用：</strong>不存在（不会改变操作数本身）<br>|运算符|名称|示例|返回值|复合移位运算符|<br>|-|-|-|-|-|<br>|<code>&lt;&lt;</code>|左位移|<code>i&lt;&lt;j</code>|<code>i</code>中的位左移<code>j</code>位的结果（左端溢出，右端补0）|<code>&lt;&lt;=</code>|<br>|<code>&gt;&gt;</code>|右位移|<code>i&gt;&gt;j</code>|<code>i</code>中的位右移<code>j</code>位的结果（右端溢出，左端补0或保存符号位而补1）|<code>&gt;&gt;=</code>|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">13</span>; <span class="comment">// 0000000000001101(16位)</span></span><br><span class="line">j = i &lt;&lt; <span class="number">2</span>; <span class="comment">// 0000000000110100(16位)</span></span><br><span class="line">j = i &gt;&gt; <span class="number">2</span>; <span class="comment">// 0000000000000011(16位)</span></span><br></pre></td></tr></table></figure>
<h3 id="20-1-2-按位求反、按位与、按位亦或、按位或"><a href="#20-1-2-按位求反、按位与、按位亦或、按位或" class="headerlink" title="20.1.2    按位求反、按位与、按位亦或、按位或"></a>20.1.2    按位求反、按位与、按位亦或、按位或</h3><blockquote>
<p><strong>优先级：</strong><code>~</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code>，都比<code>关系运算符</code>和<code>判等运算符</code>低。<br><strong>技巧：</strong>使用<code>~</code>创建在位一级具备可移植性的程序（例子）</p>
<ol>
<li>~0：所有位都为1的整数（否则就要最大的整数，但不同位的机器不同）</li>
<li>~0x001f：除了最后5位其它为都为1<br>|符号|名称|返回值|复合运算符|<br>|-|-|-|-|<br>|<code>~</code>|按位求反|将每一个0替换成1，每一个1替换成0|<code>~=</code>|<br>|<code>&amp;</code>|按位与|对两个操作数相应的位执行逻辑与运算|<code>&amp;=</code>|<br>|<code>^</code>|按位亦或|对两个操作数相应的位执行逻辑或操作，都是1时产生0|<code>^=</code>|<br>|<code>\</code>|按位或|对两个操作数相应的位执行逻辑或操作，都是1时产生1|<code>\=</code>|</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设unsigned int类型的值占16位</span></span><br><span class="line">i = <span class="number">21</span>; <span class="comment">//    0000000000010101</span></span><br><span class="line">j = <span class="number">56</span>; <span class="comment">//    0000000000111000</span></span><br><span class="line">k = ~i; <span class="comment">//    1111111111101010</span></span><br><span class="line">k = i &amp; j; <span class="comment">// 0000000000010000</span></span><br><span class="line">k = i ^ j; <span class="comment">// 0000000000101101</span></span><br><span class="line">k = i | j; <span class="comment">// 0000000000111101</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">21</span>;</span><br><span class="line">j = <span class="number">56</span>;</span><br><span class="line">i &amp;= j;</span><br><span class="line">i ^= j;</span><br><span class="line">i |= j;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-3-用按位运算符访问位"><a href="#20-1-3-用按位运算符访问位" class="headerlink" title="20.1.3    用按位运算符访问位"></a>20.1.3    用按位运算符访问位</h3><blockquote>
<p><strong>说明：</strong>通过按位运算，可以提取或修改存储在少数几个位中的数据。<br><strong>用途：</strong>比如，在编写图形程序时，可能会需要讲两个或更多的像素挤在一个字节中，从而降低空间复杂度和时间复杂度。<br><strong>方式：</strong>构造“掩码”，通过按位复合运算修改位</p>
<h4 id="设置位（为1）"><a href="#设置位（为1）" class="headerlink" title="设置位（为1）"></a>设置位（为1）</h4><p><strong>说明：</strong> 通过与“掩码”进行<code>按位或运算</code>设置某一位为1<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>0000000000001000</code>）。<br><strong>相关按位运算：</strong><code>按位或运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x0000</span>;</span><br><span class="line"><span class="comment">// 将第4位设置为1</span></span><br><span class="line"><span class="comment">// 0000000000000000 (i)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (按位或运算结果)</span></span><br><span class="line">i |= <span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算灵活构造掩码</span></span><br><span class="line">i |= <span class="number">1</span> &lt;&lt; j; <span class="comment">// 使用移位运算构造掩码</span></span><br></pre></td></tr></table></figure>
<h4 id="将位清零"><a href="#将位清零" class="headerlink" title="将位清零"></a>将位清零</h4><blockquote>
<p><strong>说明：</strong>通过与“掩码”进行<code>按位且运算</code>设置某一位为0<br><strong>掩码：</strong>除要清零的位外都为1的掩码（可以通过<code>移位运算</code>和<code>按位非运算</code>）构造（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x00ff</span>;  <span class="comment">// 0000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000000011111111（i）</span></span><br><span class="line"><span class="comment">// 1111111111110111 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000011110111 (按位且运算结果)</span></span><br><span class="line">i &amp;= ~<span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算和按位非灵活构造掩码</span></span><br><span class="line">i &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br></pre></td></tr></table></figure>
<h4 id="检测位"><a href="#检测位" class="headerlink" title="检测位"></a>检测位</h4><blockquote>
<p><strong>说明：</strong>检测某一位是否被设置过（设置为1）。<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置需要的掩码(假设在16位机器上)</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BLUE = <span class="number">1</span>, <span class="comment">// 0000000000000001</span></span><br><span class="line">	GREN = <span class="number">2</span>, <span class="comment">// 0000000000000010</span></span><br><span class="line">	RED = <span class="number">4</span>   <span class="comment">// 0000000000000100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i |= BULE; <span class="comment">// 设置BLUE bit(最后一位为1)</span></span><br><span class="line">i &amp;= ~BLUE; <span class="comment">// 抹掉BLUE bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测BLUE bit是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; BULUE) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测BLUE bit和GREEN bit是否都被设置了</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (BLUE | GREEN)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-4-用按位运算符访问位域"><a href="#20-1-4-用按位运算符访问位域" class="headerlink" title="20.1.4    用按位运算符访问位域"></a>20.1.4    用按位运算符访问位域</h3><blockquote>
<p><strong>位域：</strong>连续的几个位<br><strong>位域下标记法：</strong>最右边是最低位，记为0位</p>
<h4 id="修改位域"><a href="#修改位域" class="headerlink" title="修改位域"></a>修改位域</h4><p><strong>说明：</strong>不同于修改位，修改位域并不单纯的只是设置位或清除位，目标值中1和0可以并存，因此多了清除先清除位域的操作。<br><strong>相关按位运算：</strong><code>按位与</code>（用来清除位域）；<code>按位或</code>（用来将新的位存入域）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将二进制的值101存入变量i的第4-6位*/</span></span><br><span class="line"><span class="comment">// 0000000000000000，i的值可以使任意的16位整数</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将i的4-6位清零，然后用构造的掩码设置4-6位</span></span><br><span class="line"><span class="comment">// 0000000001110000 (0x0070)</span></span><br><span class="line"><span class="comment">// 1111111110001111 (~0x0070，掩码)</span></span><br><span class="line"><span class="comment">// 0000000001010000 (0x0050，4-6位上为要存储的二进制)</span></span><br><span class="line">i = i &amp; ~<span class="number">0x0070</span> | <span class="number">0x0050</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让上名的例子更加通用*/</span></span><br><span class="line"><span class="comment">// 0000000000000101, 包含需要存储的值</span></span><br><span class="line">j = <span class="number">5</span>;</span><br><span class="line">i = (i &amp; ~<span class="number">0x0070</span>) | (j &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取位域"><a href="#获取位域" class="headerlink" title="获取位域"></a>获取位域</h4><blockquote>
<p><strong>说明：</strong>获得指定位域上的值。<br><strong>相关按位运算：</strong><code>按位与</code><br><strong>技巧：</strong>当位域处在数的末尾区间时，获取值更加方便。如果要获取的位域不在末尾，可以先通过位移移至末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0000000000000111 (0x0007)</span></span><br><span class="line">j = i &amp; <span class="number">0x0007</span>; <span class="comment">// 获取0-2位上的位并放在j的末端</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = (i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0007</span>;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-5-程序：XOR加密"><a href="#20-1-5-程序：XOR加密" class="headerlink" title="20.1.5    程序：XOR加密"></a>20.1.5    程序：XOR加密</h3><blockquote>
<p><strong>说明：</strong>将每一个字符与一个密匙进行亦或（XOR）运算；要将信息解码，只需要再次加密，即可得到原来的字符。<br><strong>注意：</strong>读或写包含控制字符的文件时会在一些操作系统中引发错误，应当避免。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------加密---------------</span><br><span class="line">		<span class="number">01111010</span> (z， 加密前)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 密匙)</span><br><span class="line">		<span class="number">01011100</span> (\, 加密后)</span><br><span class="line">-------------解密---------------</span><br><span class="line">		<span class="number">01011100</span> (\, 解密)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 同样的密匙)</span><br><span class="line">		<span class="number">01111010</span> (z, 解密后)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 以文件作为输入，使用XOR加密(或解密)。并将加密(或解密)后的文本输出</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> KEY <span class="string">'&amp;'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> orig_char, new_char;</span><br><span class="line">	<span class="comment">// 遍历输入流中的每一个字符，加密后输出，直到文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> ((orig_char = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="comment">// 加密</span></span><br><span class="line">		new_char = orig_char ^ KEY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果加密（或解密）后的字符是控制字符则不加密（或解密）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(orig_char) || <span class="built_in">iscntrl</span>(new_char)) &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(orig_char);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(new_char);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./xor &lt; msg.txt</span><br></pre></td></tr></table></figure>
<h2 id="20-2-结构中的位域"><a href="#20-2-结构中的位域" class="headerlink" title="20.2    结构中的位域"></a>20.2    结构中的位域</h2><blockquote>
<p><strong>说明：</strong>C语言提供了可以在结构中声明存储在位域中的成员。<br><strong>语法：</strong>位域的类型必需是<code>int</code>、<code>unsigned int</code>或<code>signed int</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构名 &#123;</span><br><span class="line">	&#123;<span class="keyword">int</span>|<span class="keyword">unsigned</span> <span class="keyword">int</span>|<span class="keyword">signed</span> <span class="keyword">int</span>&#125; [成员名]: 位数;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>使用<code>按位运算</code>可以达到同样的效果，而且可能更快些，当可读性不如<code>结构中的位域</code>。<br><strong>局限性：</strong>通常位域没有地址，因此C语言不允许将<code>&amp;运算符</code>或<code>scanf函数</code>用于位域。<br><strong>可移植性技巧：</strong>将所有的位域声明为<code>unsigned int</code>或<code>signed int</code>而不是<code>int</code>，因为一些编译器将位域的最高位作为符号位，而其它一些编译器则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="位域是如何存储的"><a href="#位域是如何存储的" class="headerlink" title="位域是如何存储的"></a>位域是如何存储的</h3><blockquote>
<p><strong>存储单元：</strong>一个存储单元的大小是由实现定义的，通常是8位、16位或32位。<br><strong>未命名为域：</strong>将无法被赋值和使用，但正常占据空间。经常用来作为成员间的填充，以保证其它位域存储在适当的位置。<br><strong>长度为0的位域：</strong>告诉编译器将下一个位域放在一个存储单元的起始位置，即如果当前存储单元还有空间剩余，无论能否放下长度为0的成员的后面的成员，都会将其放在下一个存储单元中。</p>
</blockquote>
<ul>
<li><strong>存储顺序：</strong>当编译器处理结构实例时，会将位域逐个存入存储单元（从左向右或从右向左）</li>
<li><strong>位域型成员之间的间隙：</strong>位域之间没有间隙，直到剩下的空间不够放下一个位域（这时会跳到下一个存储单元继续存放，即<code>存在间隙</code>或跨存储单元存放，即<code>没有间隙</code>）。</li>
</ul>
<p><strong>案例</strong></p>
<blockquote>
<p><strong>说明：</strong>假设位域是<code>从右至左</code>存储，且当一个存储单元剩余的空间无法存储下一个位域成员时会<code>跨存储单元存储</code>。这时DOS系统上编译常用的方式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构实例</span></span><br><span class="line"><span class="keyword">struct</span> file_date fd;</span><br><span class="line">fd.day = <span class="number">28</span>;</span><br><span class="line">fd.month = <span class="number">12</span>;</span><br><span class="line">fd.year = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>*</th>
<th>year</th>
<th>month</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>0001000</td>
<td>1100</td>
<td>11100</td>
</tr>
<tr>
<td>大小（bit）</td>
<td>7</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>区间</td>
<td>15-9</td>
<td>8-5</td>
<td>4-0</td>
</tr>
</tbody>
</table>
<h2 id="20-3-其他低级技术"><a href="#20-3-其他低级技术" class="headerlink" title="20.3    其他低级技术"></a>20.3    其他低级技术</h2><h3 id="20-3-1-定义依赖机器的类型"><a href="#20-3-1-定义依赖机器的类型" class="headerlink" title="20.3.1    定义依赖机器的类型"></a>20.3.1    定义依赖机器的类型</h3><blockquote>
<p><strong>说明：</strong>可以将<code>char</code>作为一个字节（不一定存储字符）来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-2-用联合从多个视角看待数据"><a href="#20-3-2-用联合从多个视角看待数据" class="headerlink" title="20.3.2    用联合从多个视角看待数据"></a>20.3.2    用联合从多个视角看待数据</h3><h4 id="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"><a href="#案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。" class="headerlink" title="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"></a>案例一：使用<code>联合</code>结合<code>结构体（位域成员）</code>实现文件日期和整数的转换。</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>获取：可以通过成员<code>i</code>以两个字节的形式获得日期的整数形式</li>
<li>设置：可以通过成员<code>fd</code>以结构体的方式设置文件日期（以两个字节的方式存储）</li>
</ul>
</blockquote>
<p><em>文件日期定义</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>封装一个方便读取和设置数据结构</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> int_date &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ;</span><br><span class="line">	<span class="keyword">struct</span> file_date fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>实践</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将整数形式（两个字节）的日期以作为文件日期数据结构打印</span><br><span class="line">* @param &#123;undesigned int&#125; n 存储这日期信息的整数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_date</span> <span class="params">(undesigned <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> int_date u;</span><br><span class="line">	u.i = n;</span><br><span class="line">	<span class="comment">// 年只显示后两位（比如1990年简称90年）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d/%d/%.2d\n"</span>, u.fd.month, u.fd.day, (u.fd.year + <span class="number">1980</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="案例二：模拟对寄存器的访问（Intel-80x86）"><a href="#案例二：模拟对寄存器的访问（Intel-80x86）" class="headerlink" title="案例二：模拟对寄存器的访问（Intel 80x86）"></a>案例二：模拟对寄存器的访问（Intel 80x86）</h4><blockquote>
<p><strong>说明：</strong>需要对16位寄存器和8位寄存器进行访问，同时保留它们之间的关系。<br><strong>寄存器：</strong>Intel 80x86处理器包涵4个16位的寄存器（<code>AX(AH|AL)</code>、<code>BX(BH|BL)</code>、<code>CX(CH|CL)</code>、<code>DX(DH|DL)</code>），其中每个16位寄存器都包含2个8位寄存器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="comment">// 16位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		WORD ax, bx, cx. dx;</span><br><span class="line">	&#125; word;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 8位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		BYTE al, ah, bl, bh, cl, ch, dl, dh;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; regs;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照8位寄存器的方式修改</span></span><br><span class="line">regs.byte.ah = <span class="number">0x12</span>;</span><br><span class="line">regs.byte.al = <span class="number">0x34</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照16位寄存器的方式观察</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AX: %x\n"</span>, regs.word.ax);</span><br></pre></td></tr></table></figure>
<h3 id="20-3-3-将指针作为地址使用（将地址转换为指针使用）"><a href="#20-3-3-将指针作为地址使用（将地址转换为指针使用）" class="headerlink" title="20.3.3    将指针作为地址使用（将地址转换为指针使用）"></a>20.3.3    将指针作为地址使用（将地址转换为指针使用）</h3><blockquote>
<p><strong>说明：</strong>指针按照其自身的构造方式可以分为两类（以16位机器为例）<br>|分类|组成|大小(bit)|地址转换为指针|情景|<br>|-|-|-|-|<br>|近指针|偏移量||16|将整数强制转换为指针|在一些计算机中|<br>|远指针|段地址＋偏移量|32|<code>far(关键字，非标准c)</code>+<code>MK_FP</code>(dos.h中的宏)|Intel CPU的实时模式（DOS使用的模式）|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 近指针</span></span><br><span class="line">BYTE *p;</span><br><span class="line">p = (BYTE *) <span class="number">0x1000</span>; <span class="comment">// 将16位整数地址直接转换为指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远指针</span></span><br><span class="line">BYTE far *p; <span class="comment">// 使用far声明一个远指针</span></span><br><span class="line">p = MKFP(segment, offset); <span class="comment">// 段地址， 偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="20-3-4-程序：设置Num-Lock-键"><a href="#20-3-4-程序：设置Num-Lock-键" class="headerlink" title="20.3.4    程序：设置Num Lock 键"></a>20.3.4    程序：设置Num Lock 键</h3><blockquote>
<p><strong>说明：</strong>在<code>IBM PC</code>机极其兼容机上，<code>Num Lock</code>切换涌来确定数字键盘上的按键是作为数字键使用，还是作为移动光标的方向键。<br><strong>原理：</strong><code>Num Lock</code>的状态保存在地址位地址段为40（16进制）、偏移量为17（16进制）的字节中。该字节的第5位（最低位为0位）用来控制<code>Num Lock</code>的状态。</p>
</blockquote>
<p><strong>开启Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 开启num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0000000000100000 (掩码)</span></span><br><span class="line">	*p |= <span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1111111111011111 (掩码)</span></span><br><span class="line">	*p &amp;= ～<span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-5-volatile类型限定符"><a href="#20-3-5-volatile类型限定符" class="headerlink" title="20.3.5    volatile类型限定符"></a>20.3.5    volatile类型限定符</h3><blockquote>
<p><strong>关键字：</strong><code>volatile</code><br><strong>说明：</strong>通常使用在用于指向易变内存空间的指针的声明中。用来防止编译器优化过程中错误地将易变内容缓存在了寄存器中，而不再读取内存中易变内容。</p>
</blockquote>
<p><em>优化前的逻辑</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前的逻辑</span></span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入; <span class="comment">// 将输入存储到*p</span></span><br><span class="line">	buffer[i] = *p;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>优化后的逻辑</em></p>
<blockquote>
<p><strong>说明：</strong>注意到这个循环中既没有改变p，也没有改变<em>p，因此对程序进行优化，使</em>p只被读取一次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在寄存器中存储*p;</span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入;</span><br><span class="line">	buffer[i] = 存储在寄存器中的值;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/19 程序设计/" itemprop="url">
                  19 程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:00:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/19 程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/19 程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="19-1-模块"><a href="#19-1-模块" class="headerlink" title="19.1    模块"></a>19.1    模块</h2><blockquote>
<p><strong>说明：</strong><code>模块</code>是一组功能（服务）的集合，其中一些功能可以被程序的其它部分（<code>客户</code>）使用。每个模块都有一个<code>接口</code>来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的<code>实现</code>中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td><code>模块名.h</code>(头文件)</td>
</tr>
<tr>
<td>实现</td>
<td>对应头文件<code>模块名.c</code>文件</td>
</tr>
<tr>
<td>客户</td>
<td>通过<code>#include</code>引入模块的文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>优点：</strong>将程序分割成模块有一系列好处</p>
<ul>
<li>抽象：不必了解功能的实现细节，只需对模块的接口达成一致</li>
<li>可复用：每个模块都可以在另一个程序中复用</li>
<li>可维护性（最重要）：当程序出现错误或需要升级时，通常只会影响一个模块</li>
</ul>
<p><strong>扩展：</strong><a href="">Fundamental of SoftWare Engineer</a></p>
</blockquote>
<h3 id="19-1-1-内聚性与耦合性"><a href="#19-1-1-内聚性与耦合性" class="headerlink" title="19.1.1    内聚性与耦合性"></a>19.1.1    内聚性与耦合性</h3><blockquote>
<p><strong>说明：</strong>一个好的模块接口并不是随意的一组声明，应具有下面两个性质</p>
<ul>
<li>高内聚：模块中的元素应该紧密相关</li>
<li>低耦合：模块之间应该尽可能相互独立</li>
</ul>
</blockquote>
<h3 id="19-1-2-模块的类型"><a href="#19-1-2-模块的类型" class="headerlink" title="19.1.2    模块的类型"></a>19.1.2    模块的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据池</td>
<td>一些相关的变量或常量的集合</td>
<td><code>&lt;float.h&gt;</code>(<a href="">23.1</a>)、 <code>&lt;limits.h&gt;</code>(<a href="">23.2</a>)</td>
<td>通常不建议将变量放在头文件</td>
</tr>
<tr>
<td>库</td>
<td>一组相关函数的集合</td>
<td><code>&lt;string.h&gt;</code></td>
<td></td>
</tr>
<tr>
<td>抽象对象</td>
<td>对隐藏的数据结构进行操作的一组函数的集合</td>
<td></td>
<td>如果数据是隐藏起来的，那么这个对象那个就是“抽象的”</td>
</tr>
<tr>
<td>抽象数据类型</td>
<td>将具体数据实现方式隐藏起来的数据类型称为抽象数据类型</td>
<td></td>
<td>抽象数据类型在当今的程序设计中起着非常重要的作用</td>
</tr>
</tbody>
</table>
<h2 id="19-2-信息隐藏"><a href="#19-2-信息隐藏" class="headerlink" title="19.2    信息隐藏"></a>19.2    信息隐藏</h2><blockquote>
<p><strong>说明：</strong>一个设计良好的模块经常会对它的客户隐藏一些信息。谨慎的对客户隐藏信息的方法称为信息隐藏。<br><strong>优点：</strong></p>
<ul>
<li>安全性：<code>客户</code>只能通过<code>模块</code>自身的函数进行参数</li>
<li>灵活性：修改模块通常不必修改接口，对<code>客户</code>没有影响</li>
</ul>
<p><strong>原理：</strong>使用<code>static</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰</th>
<th>链接情况</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数</td>
<td>内部链接</td>
<td>只能在只能被同一文件中被调用</td>
</tr>
<tr>
<td>变量（文件作用域）</td>
<td>内部链接</td>
<td>只能被同一文件中的其它函数访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>使用宏定义“公有”和“私有”可以使程序含义更加清晰（尤其是<code>static</code>，因为它在c语言中有许多用法）</p>
<h3 id="栈模块-实现部分"><a href="#栈模块-实现部分" class="headerlink" title="栈模块(实现部分)"></a>栈模块(实现部分)</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC  <span class="comment">// 定义为空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIVATE static</span></span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> contents[STACK_SIZE] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PRIVATE <span class="keyword">int</span> <span class="title">is_full</span> <span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">pop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-3-抽象数据类型"><a href="#19-3-抽象数据类型" class="headerlink" title="19.3    抽象数据类型"></a>19.3    抽象数据类型</h2><blockquote>
<p><strong>说明：</strong>c语言没有设计专门用于封装类型的特性（<code>class</code>），即无法定义真正的抽象数据类型。<br><strong>案例缺陷：</strong>之前定义的栈模块提供的栈不基于一种抽象数据类型，而是仅仅提供了一个相当于“栈的实例”的数据结构。当需要多个栈实例时就无能为力了。</p>
</blockquote>
<p><em>stack.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 下面定义的Stack不是抽象数据类型，因为stack.h暴露了Stack的具体实现方式（结构体实例的成员是暴露的)</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empyt</span> <span class="params">(Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">const</span> Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(Stack *s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span> <span class="params">(Stack *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>客户</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 理想的使用方式</span></span><br><span class="line">	Stack s1, s2;</span><br><span class="line">	make_empty(&amp;s1);</span><br><span class="line">	make_empty(&amp;s2);</span><br><span class="line">	push(&amp;s1, <span class="number">1</span>);</span><br><span class="line">	push(&amp;s2, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!is_empty(&amp;s1)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(&amp;s1)); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不理想的方式</span></span><br><span class="line">	Stack s3;</span><br><span class="line">	s3.top = <span class="number">0</span>; <span class="comment">//直接访问了暴露出来的成员</span></span><br><span class="line">	s3.contents[top++] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-4-C-语言"><a href="#19-4-C-语言" class="headerlink" title="19.4    C++语言"></a>19.4    C++语言</h2><blockquote>
<p><strong>说明：</strong>C++语言是由<code>AT&amp;T</code>贝尔实验室的Bjqrne Stroustrup在20世纪80年代开发出来的C语言的扩展版。<br><strong>新特性（相对C）：</strong></p>
<ul>
<li>面向对象：允许从已经存在的类“派生”（继承）出新的类</li>
<li>运算符重载：为传统的C语言的运算符赋予新的含义</li>
<li>模版：可以使我们写出通用的、高度可复用的类和函数</li>
<li>异常处理：一种同一的方式用来检测并响应错误</li>
</ul>
<p><strong>兼容C：</strong>C++语言包含了标准C的全部特性，然而不是所有C语言都可以在C++的环境下编译，因为C++语言增加了更多强制限制，比C语言更加安全。</p>
</blockquote>
<h3 id="19-4-1-C语言与C-语言之间的差异"><a href="#19-4-1-C语言与C-语言之间的差异" class="headerlink" title="19.4.1    C语言与C++语言之间的差异"></a>19.4.1    C语言与C++语言之间的差异</h3><h4 id="19-4-1-1-注释"><a href="#19-4-1-1-注释" class="headerlink" title="19.4.1.1    注释"></a>19.4.1.1    注释</h4><blockquote>
<p><strong>新特性：</strong>C++语言支持单行注释</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a Comment</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-2-标记与类型名"><a href="#19-4-1-2-标记与类型名" class="headerlink" title="19.4.1.2    标记与类型名"></a>19.4.1.2    标记与类型名</h4><blockquote>
<p><strong>新特性：</strong>标记（结构、联合或枚举的名字）会自动被认为是类型名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">	<span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 相当于下列形式的c语言</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">typedef struct Complex &#123;</span><br><span class="line">	double re, im;</span><br><span class="line">&#125; Complex;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-3-不带参数的函数"><a href="#19-4-1-3-不带参数的函数" class="headerlink" title="19.4.1.3    不带参数的函数"></a>19.4.1.3    不带参数的函数</h4><blockquote>
<p><strong>新特性：</strong>在声明或定义一个不带参数的<code>C++</code>函数时，可以不使用<code>void</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">()</span></span>; <span class="comment">// 和void相同</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-4-默认实际参数"><a href="#19-4-1-4-默认实际参数" class="headerlink" title="19.4.1.4    默认实际参数"></a>19.4.1.4    默认实际参数</h4><blockquote>
<p><strong>新特性：</strong>C++语言允许函数的实际参数有默认值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示任意数量的换行符，如果没有提供参数，默认为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_line</span> <span class="params">(<span class="keyword">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_line(<span class="number">3</span>); <span class="comment">// 三个换行</span></span><br><span class="line">new_line(); <span class="comment">//一个换行</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-5-引用参数"><a href="#19-4-1-5-引用参数" class="headerlink" title="19.4.1.5    引用参数"></a>19.4.1.5    引用参数</h4><blockquote>
<p><strong>新特性：</strong>允许实际参数被声明为<code>引用</code>，而不是<code>指针</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c语言的方式</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">void swap (int *a, int *b) &#123;</span><br><span class="line">	int temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;i, &amp;j);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(i, j); <span class="comment">// 不需要再参数前加&amp;运算符</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-6-动态存储分配"><a href="#19-4-1-6-动态存储分配" class="headerlink" title="19.4.1.6    动态存储分配"></a>19.4.1.6    动态存储分配</h4><blockquote>
<p><strong>新特性：</strong>使用运算符<code>new</code>（分配空间）、 <code>delete</code>（释放空间）<br><strong>语法：</strong></p>
<ul>
<li>分配内存：<code>new 类型说明符</code></li>
<li>释放内存： <code>delete 指针</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> *int_ptr, *int_array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">int_ptr = new <span class="keyword">int</span>; <span class="comment">// 为整数分配存储空间</span></span><br><span class="line">int_array = new <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 为数组分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="keyword">delete</span> int_ptr; <span class="comment">// 为整数空间释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] int_array; <span class="comment">// 为数组释放空间</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-2-类"><a href="#19-4-2-类" class="headerlink" title="19.4.2    类"></a>19.4.2    类</h3><blockquote>
<p><strong>类：</strong>一个类从根本上说就是一个<code>抽象数据类型</code>：一组数据以及操作这些数据的函数<br><strong>说明：</strong>这个新数据类型的功能可以同基本数据类型同样强大。<br><strong>类的不足：</strong>类的设计和实现比较复杂，这是易用性必须付出的代价，而这也是计算机领域近几年内的妥协。</p>
</blockquote>
<h3 id="19-4-3-类定义"><a href="#19-4-3-类定义" class="headerlink" title="19.4.3    类定义"></a>19.4.3    类定义</h3><blockquote>
<p><strong>类标记（class tag）：</strong>可以直接作为类型名使用，不要求类名以大写开始，但许多C++程序员尊循首字母大写的规范。<br><strong>数据成员（data memeber）：</strong>类似结构的成员（但是默认是隐藏的，即“私有的”）<br><strong>类的实例（instance）：</strong>任何类的实例就是<code>对象</code>（object）<br><strong>访问成员：</strong>使用运算符<code>.</code>或<code>-&gt;</code>来访问公有的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 默认是私有的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 公有成员</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> numeratitor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-4-成员函数"><a href="#19-4-4-成员函数" class="headerlink" title="19.4.4    成员函数"></a>19.4.4    成员函数</h3><blockquote>
<p><strong>成员函数（member function）：</strong>属于类的函数称为成员函数，特别的，那些需要访问类的私有数据成员的函数必须声明在类里面。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 将函数的定义放在类的定义之中</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> denom)</span> </span>&#123;</span><br><span class="line">			numertor = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 只声明不定义（定义部分放在类外部）</span></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		* 乘法函数</span><br><span class="line">		* @param &#123;Fraction f&#125; </span><br><span class="line">		*/</span></span><br><span class="line">		<span class="function">Fraction <span class="title">mul</span><span class="params">(Fraction f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 乘法函数的定义</span><br><span class="line">* Fraction::前缀是必需的，否则C++编译器会将mul作为一个普通函数</span><br><span class="line">* @param &#123;Fraction f&#125; 分数</span><br><span class="line">*/</span></span><br><span class="line">Fraction Fraction::mul(Fraction f) &#123;</span><br><span class="line">	Fraction result;</span><br><span class="line">	result.numerator = numerator * f.numerator;</span><br><span class="line">	result.denominator = denominator * f.denominator;</span><br><span class="line">	result.reduce();</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fraction f1;</span><br><span class="line">f1.create(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Fraction f2 = f1.mul(f1);</span><br></pre></td></tr></table></figure>
<h3 id="19-4-5-构造函数"><a href="#19-4-5-构造函数" class="headerlink" title="19.4.5    构造函数"></a>19.4.5    构造函数</h3><blockquote>
<p><strong>构造函数（controctor）：</strong></p>
<ul>
<li>通常时自动调用的（编译器安排在合适的时机自动调用）</li>
<li>定义在public成员部分，不需要指定返回值类型</li>
<li>命名和类名相同</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		Fraction(<span class="keyword">int</span> num = <span class="number">0</span>, <span class="keyword">int</span> denom = <span class="number">1</span>) &#123;</span><br><span class="line">			numerator = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 通过构造函数声明并初始化实例</span></span><br><span class="line"><span class="function">Fraction <span class="title">f2</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 等同于Fraction f2(3, 1);</span></span><br><span class="line">Fraction f3; <span class="comment">// 等同于 f3(0, 1);</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-6-构造函数和动态存储分配"><a href="#19-4-6-构造函数和动态存储分配" class="headerlink" title="19.4.6    构造函数和动态存储分配"></a>19.4.6    构造函数和动态存储分配</h3><blockquote>
<p><strong>说明：</strong>构造函数和析构函数为那些内存分配和回收函数提供了比较合适的时机。<br><strong>举例：</strong>创建自己的<code>String</code>类型<br>|比较|C++的<code>String</code>（自定义）|C语言实现方式（<code>char</code>数组）|<br>|-|-|-|<br>|字符串长度|任意长度|受限于数组的长度|<br>|获取字符串长度|O(1)|O(n)|<br>|扩展性|需要时可给String类添加操作|无法修改（就算引入<string.h>，但无法扩展）|</string.h></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">	<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="comment">// 分配足够大的空间</span></span><br><span class="line">	text = new Char[len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">	<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-7-析构函数"><a href="#19-4-7-析构函数" class="headerlink" title="19.4.7    析构函数"></a>19.4.7    析构函数</h3><blockquote>
<p><strong>析构函数（destructor）：</strong></p>
<ul>
<li>名字：<code>~类名</code></li>
<li>返回值：没有返回值</li>
<li>参数：没有</li>
</ul>
<p><strong>用途：</strong>自动存储期限的类的实例，当其生存期结束后，普通成员的内存会被释放，但在构造函数中分配内存的成员指向的内存不会被释放（内存泄漏）。所以需要析构函数在对象释放时自动调用，清理构造函数动态分配的内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明并定义构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">			<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">			len = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="comment">// 分配足够大的空间</span></span><br><span class="line">			text = new Char[len + <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">			<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 声明并定义析构函数</span></span><br><span class="line">		~String() &#123;</span><br><span class="line">			<span class="keyword">delete</span> [] text;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-8-重载"><a href="#19-4-8-重载" class="headerlink" title="19.4.8    重载"></a>19.4.8    重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p><strong>说明：</strong>在同一作用域下存在两个或以上同名但参数不同的函数(包括构造函数)叫做函数的重载。<br><strong>用途：</strong>需要记住更少的函数名，编译器会根据实际参数的情况自动判断调用哪一个函数。<br><strong>默认构造函数：</strong>不带时机参数的构造函数，会在声明对象而没有制定初始值时被调用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sring &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	* 重载构造函数（默认）</span><br><span class="line">	* @overload</span><br><span class="line">	*/</span></span><br><span class="line">	String() &#123;</span><br><span class="line">		text = <span class="number">0</span>;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~String() &#123;</span><br><span class="line">		<span class="keyword">delete</span> [] text;</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *text;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s; <span class="comment">// 不带实际参数，会调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p><strong>说明：</strong>重载运算符后，根据操作数类型的不同，同样的运算符号可以代表不同的操作。<br><strong>用途：</strong>更易读，更自然（不需要定义一些难以记住的函数名）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 声明重载操作符：*</span></span><br><span class="line">	Fraction <span class="keyword">operator</span>*(Fraction f);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载操作符：*</span></span><br><span class="line">Fraction Fraction::operation*(Fraction f) &#123;</span><br><span class="line">	<span class="comment">//代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f3 = f1 * f2; <span class="comment">// 定义的*是一个二元运算符(相当于f3 = f1.operator*(f2);)</span></span><br></pre></td></tr></table></figure>
<h4 id="C-语言的输入／输出（）"><a href="#C-语言的输入／输出（）" class="headerlink" title="C++语言的输入／输出（）"></a>C++语言的输入／输出（<stdio.h>）</stdio.h></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">98</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
