<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta property="og:type" content="website">
<meta property="og:title" content="Sean">
<meta property="og:url" content="http://laputa-er.github.io/page/8/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sean">
<meta name="twitter:description" content="整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/page/8/"/>

  <title> Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/24 错误处理/" itemprop="url">
                  24 错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T11:42:41+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/24 错误处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/11/24 错误处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>C语言的弱项：</strong>错误的检测和处理并不是c语言的强项</p>
<ul>
<li>C语言对运行时错误以多种形式表示，而没有提供一种统一的方式</li>
<li>程序员必须将检测错误的代码编写在程序代码中，因此很容易忽略一些错误</li>
</ul>
<p><strong>扩展：</strong>C++语言对C语言的这一弱点进行了改进，提供了一种新的错误错误的方式－异常处理（exception handling）。</p>
</blockquote>
<h2 id="24-1-assert-h：诊断"><a href="#24-1-assert-h：诊断" class="headerlink" title="24.1    assert.h：诊断"></a>24.1    <code>assert.h</code>：诊断</h2><h4 id="assert宏（函数）"><a href="#assert宏（函数）" class="headerlink" title="assert宏（函数）"></a>assert宏（函数）</h4><blockquote>
<p><strong>断言：</strong>一个我们认为在正常情况下一顶为真的表达式。<br><strong>错误信息：</strong>标准C要求在显示的消息中指明以下内容</p>
<ul>
<li>传递给assert函数的参数</li>
<li>包括assert调用的文件名</li>
<li>assert调用所在的行号</li>
</ul>
<p><strong>说明：</strong>检查断言，如果值不为0，会向<code>stderr</code>输出一条信息，并调用<code>abort函数</code>终止程序。<br><strong>技巧：</strong>因为引入了额外的检查，因此会增加程序的运行时间。可以在测试没问题后通过<code>NDEBUG</code>（宏）进制<code>assert</code>调用。<br><strong>注意：</strong>因为assert可能会被禁用，因此不要在assert调用中使用有副作用的表达式。<br><strong>原型</strong><code>assert.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; expresstion 断言</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i];</span><br><span class="line">assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; N);<span class="comment">// 保证下标不回溢出</span></span><br><span class="line">a [i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><em>禁止assert调用</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG<span class="comment">// 值不重要，定义了就行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="24-2-errno-h：错误"><a href="#24-2-errno-h：错误" class="headerlink" title="24.2    errno.h：错误"></a>24.2    <code>errno.h</code>：错误</h2><blockquote>
<p><strong>说明：</strong>除了<code>EDOM</code>和<code>ERANGE</code>,还定义了其他宏，这是合法的，但命名要遵循C标准，即<code>E数组或大写字母</code></p>
</blockquote>
<h4 id="errno宏"><a href="#errno宏" class="headerlink" title="errno宏"></a>errno宏</h4><hr>
<blockquote>
<p><strong>描述：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和变量一样使用。<br><strong>说明：</strong>如果确实是宏，C语言标准要求它表示左值<a href="">4.2.2</a>，以便和普通变量一样使用。<br><strong>用途：</strong>函数被调用后会会为<code>errno</code>赋值，如果<code>errno</code>不为0，代表函数调用过程中有错误发生。<br><strong>应用：</strong>大部分使用<code>errno</code>变量的函数集中在<code>math.h</code>，也有一些在标准库的其他部分。<br><strong>相关宏：</strong><code>EDOM</code>和<code>ERANGE</code>,errno中存储的值通常是这两个宏</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏（errno的值）</th>
<th>错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDOM</td>
<td>定义域错误</td>
<td>传递给函数的一个参数不属于函数的定义域</td>
</tr>
<tr>
<td>ERANGE</td>
<td>取值范围错误</td>
<td>函数的返回值太大，无法用double</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用库函数</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sqrt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>向<code>stderr</code>输出一条错误信息。<br><strong>错误信息：</strong><code>sqrt error: Math argument</code>（定义域错误）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">perror的参数</th>
<th style="text-align:center">分号</th>
<th style="text-align:center">空格</th>
<th style="text-align:center">出错消息</th>
<th style="text-align:center">换行符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sqrt error</td>
<td style="text-align:center">:</td>
<td style="text-align:center"></td>
<td style="text-align:center">Math argument</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 错误描述</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sqrt</span></span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测运行状况</span></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"sqrt error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据错误类型行值返回指向错误字符串的指针。<br><strong>原型：</strong><code>string.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; errnum 错误类型值</span><br><span class="line">* @return &#123;char *&#125; 对应的错误字符串 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="24-3-signal-h：信号处理"><a href="#24-3-signal-h：信号处理" class="headerlink" title="24.3    signal.h：信号处理"></a>24.3    <code>signal.h</code>：信号处理</h2><blockquote>
<p><strong>信号（signal）：</strong>处理异常情况的工具</p>
<ul>
<li><p>运行时错误</p>
<blockquote>
<p>例如：除以0</p>
</blockquote>
</li>
<li><p>程序以外导致的事件</p>
<blockquote>
<p>例如：许多操作系统都允许用户终端或终止运行的程序</p>
</blockquote>
</li>
</ul>
<p><strong>异步的：</strong>它们可以在程序执行过程中的任意时刻发生，而不仅是在程序员所知道的特定时刻发生</p>
</blockquote>
<h3 id="24-3-1-信号宏"><a href="#24-3-1-信号宏" class="headerlink" title="24.3.1    信号宏"></a>24.3.1    信号宏</h3><blockquote>
<p><strong>兼容性：</strong>C标准不要求下面列表中的信号都会发生，大多数C语言的实现都至少支持其中一部分。</p>
</blockquote>
<table>
<thead>
<tr>
<th>宏名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>异常终止（可能由于调用abort导致）</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>在数学运算中发生错误（可能是除以0或溢出）</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGINT</td>
<td>中断</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法存储访问</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止请求</td>
</tr>
</tbody>
</table>
<h3 id="24-3-2-signal函数"><a href="#24-3-2-signal函数" class="headerlink" title="24.3.2    signal函数"></a>24.3.2    signal函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>为指定信号注册指定处理函数。<br><strong>相关宏：</strong><code>SIG_ERR</code></p>
<blockquote>
<p><strong>说明：</strong>当注册失败时会返回该值<br><strong>用途：</strong>检测注册处理函数是否成功</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p><strong>多对一：</strong><code>信号</code>与处理函数是<code>多对一</code>的关系</p>
<ul>
<li>可以对多种信号绑定同一个处理函数，处理函数可以根据传入的参数（信号类型）决定进行哪种操作</li>
<li>也可以对同一个信号注册多个处理程序，但前面注册的会被后面注册的处理函数覆盖。</li>
</ul>
<p><strong>同步性：</strong>发出信号的行为是异步的，但处理函数处理的过程是同步的。也就是说，注册了处理函数的信号出现后，程序会暂停并执行信号处理函数，返回后暂停的程序从信号发生点恢复并继续执行。</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>处理函数返回后程序行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>终止</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>处理函数返回后的程序行为未定义</td>
</tr>
<tr>
<td>其它</td>
<td>暂停的程序从信号发生点恢复并继续执行</td>
</tr>
</tbody>
</table>
<blockquote>
<blockquote>
<p><strong>一次性：</strong>信号处理完之后，除非处理函数被重新注册，否则该信号不回被同一个函数处理两遍。<br><strong>无限递归问题：</strong>如果信号是由处理这个信号的函数引发的，如果没有其它机制将会发生无限递归。所以，C语言要求，除了<code>SIGTLL</code>，当一个信号的处理函数被调用时，该信号对应的处理函数要么要被重置为<code>SIG_DFL</code>或以其它方式加以封锁。</p>
</blockquote>
<p><strong>限制：</strong>处理函数和普通函数相比多了一些限制</p>
</blockquote>
<table>
<thead>
<tr>
<th>可以</th>
<th>不可以</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以忽略该信号</td>
<td>自由调用库函数</td>
</tr>
<tr>
<td>执行一些错误修复</td>
<td>访问静态存储期限的变量</td>
</tr>
<tr>
<td>终止程序</td>
<td></td>
</tr>
<tr>
<td>可以调用<code>signal</code>，只要第一个参数为正被处理的信号</td>
<td></td>
</tr>
<tr>
<td>调用库函数，只要信号处理函数是由raise或abort调用的</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @param &#123;func *&#125; func 处理函数</span><br><span class="line">* @return &#123;func *&#125; 指向注册过同样信号的上一个处理函数的指针：成功；SIG_ERR：注册失败（同时会在errno中存储一个正值）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> *(*signal)(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(int));<span class="comment">// 书上写法是：void (*signal(int sig, void (*func)(int)))(int);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为中断注册处理函数，并将之前的处理函数存储下来</span></span><br><span class="line">orig_handler = signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orig_handler == SIG_ERR) &#123;</span><br><span class="line">	<span class="comment">// 注册处理函数失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成原来的处理函数</span></span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-3-预定义的信号处理函数"><a href="#24-3-3-预定义的信号处理函数" class="headerlink" title="24.3.3    预定义的信号处理函数"></a>24.3.3    预定义的信号处理函数</h3><blockquote>
<p><strong>说明：</strong>出了编写我们自己的信号处理函数，我们还可以选择使用<code>signal.h</code>提供的预定义的处理函数。<br><strong>预定义的信号处理函数命名规则：</strong></p>
<blockquote>
<p><code>SIG_</code>大写字母</p>
</blockquote>
</blockquote>
<h4 id="SIG-DFL宏（函数）"><a href="#SIG-DFL宏（函数）" class="headerlink" title="SIG_DFL宏（函数）"></a>SIG_DFL宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>按“默认”的方式处理<br><strong>描述：</strong>行为由实现定义，大多数情况下会导致程序终止。<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_DFL</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN); <span class="comment">// 使用默认行为响应“中断”信号</span></span><br></pre></td></tr></table></figure>
<h4 id="SIG-IGN宏（函数）"><a href="#SIG-IGN宏（函数）" class="headerlink" title="SIG_IGN宏（函数）"></a>SIG_IGN宏（函数）</h4><hr>
<blockquote>
<p><strong>描述：</strong>什么都不做，忽略信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; signal 信号类型</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIG_IGN</span><span class="params">(<span class="keyword">int</span> signal)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="24-3-4-raise函数"><a href="#24-3-4-raise函数" class="headerlink" title="24.3.4    raise函数"></a>24.3.4    raise函数</h3><hr>
<blockquote>
<p><strong>说明：</strong>触发信号<br><strong>原型：</strong><code>signal.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; sig 信号类型</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发SIGABORT</span></span><br><span class="line">raise(SIGABOUT);</span><br></pre></td></tr></table></figure>
<h3 id="24-3-5-程序：测试信号"><a href="#24-3-5-程序：测试信号" class="headerlink" title="24.3.5    程序：测试信号"></a>24.3.5    程序：测试信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests signals</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明函数指针</span></span><br><span class="line">	<span class="keyword">void</span> (*orig_handler)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1. 第一次实验*/</span></span><br><span class="line">	<span class="comment">// 注册处理函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---first--- %d\n"</span>, SIGILL);</span><br><span class="line">	signal(SIGILL, handler);</span><br><span class="line">	<span class="comment">// 触发信号</span></span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2. 第二次实验*/</span></span><br><span class="line">	<span class="comment">// 再次注册,忽略相应信号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---second---\n"</span>);</span><br><span class="line">	orig_handler = signal(SIGILL, SIG_IGN);</span><br><span class="line">	raise_sig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3. 第三次实验*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---third---\n"</span>);</span><br><span class="line">	<span class="comment">// 更改为第一次实验使用的处理函数</span></span><br><span class="line">	signal(SIGILL, orig_handler);</span><br><span class="line">	raise_sig();</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Handler called for signal %d\n"</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_sig</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	raise(SIGILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsignal</span><br><span class="line"> ---first--- 4</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br><span class="line"> ---second---</span><br><span class="line"> ---third---</span><br><span class="line"> Handler called <span class="keyword">for</span> signal 4</span><br></pre></td></tr></table></figure>
<h2 id="24-4-setjmp-h：非局部跳转"><a href="#24-4-setjmp-h：非局部跳转" class="headerlink" title="24.4    setjmp.h：非局部跳转"></a>24.4    setjmp.h：非局部跳转</h2><blockquote>
<p><strong>说明：</strong>通常情况下，函数调用后会回到它被调用的位置。但<code>setjmp.h</code>提供了使一个函数直接跳转到另一个函数（而且不需要返回）的方式。<br><strong>goto：</strong>只能配合标记实现<code>局部跳转</code>，也就是在同一个函数内部跳转。</p>
</blockquote>
<h3 id="setjmp宏（函数）"><a href="#setjmp宏（函数）" class="headerlink" title="setjmp宏（函数）"></a>setjmp宏（函数）</h3><blockquote>
<p><strong>描述：</strong>标记程序中的一个“位置”<br><strong>应用：</strong>生成标记位置，稍后提供给<code>longjmp函数</code><br><strong>限制：</strong>按照<code>标准C</code>，只有两种使用setjmp的方式是合法的(否则不具备可移植性)</p>
<ul>
<li>作为表达式语句（可能会前置转换成void）</li>
<li>作为<code>if、switch、while、do、for</code>语句中控制表达式的一部分(<code>constexp</code>：计算结果为整数的<em>常量表达式</em>；<code>op</code>：<em>关系</em>或<em>判等</em>运算符)</li>
</ul>
<ol>
<li>setjmp(…)</li>
<li>!setjmp(…)</li>
<li><code>constexp</code> <code>op</code> <code>constexp</code></li>
<li>setjmp(…) <code>op</code> <code>constexp</code></li>
</ol>
<p><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env 用来保存生成的被调用时所处的“位置”(数组)</span><br><span class="line">* @return &#123;int&#125; 0：第一次调用时返回；非0：longjmp将控制权重新转给最初的setjmp宏调用，后者这次的返回值非零</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a>longjmp函数</h3><hr>
<blockquote>
<p><strong>描述：</strong>首先根据参数env的值恢复当前环境，然后从<code>setjmp宏</code>调用中返回<br><strong>注意：</strong>一定要确保参数env已经被<code>setjmp宏</code>初始化了，否则程序可能会崩溃。<br><strong>应用：</strong>可以由多种潜在的用途，但主要被用于错误处理。<br><strong>原型：</strong><code>setjmp.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;jmp_buf&#125; env</span><br><span class="line">* @param &#123;int&#125; val</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试setjmp和longjmp"><a href="#程序：测试setjmp和longjmp" class="headerlink" title="程序：测试setjmp和longjmp"></a>程序：测试setjmp和longjmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests setjmp/longjmp</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @type &#123;jmp_buf&#125; env 存储位置数据的全局变量</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">// 获得存储位置</span></span><br><span class="line">	ret = setjmp(env);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"setjmp returned %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次执行到这里的时候值不为0</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Program terminates: longjmp called\n"</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f1();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这句不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Program terminates normally\n"</span>);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 begins\n"</span>);</span><br><span class="line">	f2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f1 returns\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 begins\n"</span>);</span><br><span class="line">	<span class="comment">// 按照env的值跳转到指定的环境</span></span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"f2 returns\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./tsetjmp               </span><br><span class="line"> setjmp returned <span class="number">0</span></span><br><span class="line"> f1 begins</span><br><span class="line"> f2 begins</span><br><span class="line"> setjmp returned <span class="number">1</span></span><br><span class="line"> Program terminates: longjmp called</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/23 库对数值和字符数据的支持/" itemprop="url">
                  23 库对数值和字符数据的支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:31:50+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/23 库对数值和字符数据的支持/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/23 库对数值和字符数据的支持/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="23-1-float-h-浮点型的特性"><a href="#23-1-float-h-浮点型的特性" class="headerlink" title="23.1    float.h:浮点型的特性"></a>23.1    <code>float.h</code>:浮点型的特性</h2><p><strong>说明：</strong>提供了用来定义浮点型的范围和精度的宏（没有类型和函数的定义）。<br><strong>应用：</strong>由于只有进行数值分析的专家才会对上述<code>float.h</code>中定义的宏感兴趣，这可能是标砖哭中最不常用的宏。</p>
<h3 id="23-1-1-对浮点数通用的宏"><a href="#23-1-1-对浮点数通用的宏" class="headerlink" title="23.1.1    对浮点数通用的宏"></a>23.1.1    对浮点数通用的宏</h3><h4 id="FLT-ROUND宏"><a href="#FLT-ROUND宏" class="headerlink" title="FLT_ROUND宏"></a>FLT_ROUND宏</h4><p><strong>说明：</strong>浮点加法的舍入模式，存在5中可能<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.12.40.png" alt="Alt text"></p>
<h4 id="FLT-RADIX宏"><a href="#FLT-RADIX宏" class="headerlink" title="FLT_RADIX宏"></a>FLT_RADIX宏</h4><p><strong>说明：</strong>指定了基数的形式，最小值是2（二进制）</p>
<h3 id="23-1-2-其它宏"><a href="#23-1-2-其它宏" class="headerlink" title="23.1.2    其它宏"></a>23.1.2    其它宏</h3><p><strong>说明：</strong>其他宏用来描述特定类型的特性。<br><strong>宏命名：</strong>根据宏是针对的浮点类型有不同的前缀</p>
<table>
<thead>
<tr>
<th>宏前缀</th>
<th>针对的浮点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT</td>
<td>float</td>
</tr>
<tr>
<td>DBL</td>
<td>double</td>
</tr>
<tr>
<td>LDBL</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h4 id="与有效数字个数相关的宏"><a href="#与有效数字个数相关的宏" class="headerlink" title="与有效数字个数相关的宏"></a>与有效数字个数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.19.57.png" alt="Alt text"></p>
<h4 id="与指数相关的宏"><a href="#与指数相关的宏" class="headerlink" title="与指数相关的宏"></a>与指数相关的宏</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="Alt text"></p>
<h4 id="其它宏"><a href="#其它宏" class="headerlink" title="其它宏"></a>其它宏</h4><p><strong>说明：</strong>描述了最大值、最接近0的值（最小正数），两个数之间的最小差值。<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-08%20%E4%B8%8A%E5%8D%8810.22.22.png" alt="Alt text"></p>
<h2 id="23-2-limit-h：整值类型的大小"><a href="#23-2-limit-h：整值类型的大小" class="headerlink" title="23.2    limit.h：整值类型的大小"></a>23.2    <code>limit.h</code>：整值类型的大小</h2><p><strong>说明：</strong>提供了用于定义每种整型和字符型取值范围的宏（没有类型或函数）。</p>
<h3 id="23-2-1-用于字符型的宏"><a href="#23-2-1-用于字符型的宏" class="headerlink" title="23.2.1    用于字符型的宏"></a>23.2.1    用于字符型的宏</h3><p><strong>说明：</strong><code>char、signed char、unsigned char</code><br><strong>注意：</strong>char类型在有些机器上默认为unsigned char，有些默认为signed char。CHAR_MIN和CHAR_MAX的值因不同情况有所不同。<br>①</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MIN</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MIN</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>CHAR_MAX</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>SCHAR_MAX</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR_MAX</td>
</tr>
</tbody>
</table>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.08.05.png" alt="Alt text"></p>
<h3 id="23-2-2-用于整型的宏"><a href="#23-2-2-用于整型的宏" class="headerlink" title="23.2.2    用于整型的宏"></a>23.2.2    用于整型的宏</h3><p><strong>说明：</strong><code>[{signed|unsigned}] [{short|long}] int</code><br><strong>用途：</strong>在查看编译器是否支持特定大小的整数时十分方便<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8A%E5%8D%8810.27.34.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用预处理指令判断int型是否可以用来存储100 000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small<span class="comment">// 终止编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择正确的类型定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &gt;= 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="23-3-math-h：数学计算"><a href="#23-3-math-h：数学计算" class="headerlink" title="23.3    math.h：数学计算"></a>23.3    <code>math.h</code>：数学计算</h2><p><strong>说明：</strong>包含5中类型</p>
<ol>
<li>三角函数</li>
<li>双曲函数</li>
<li>指数和对数函数</li>
<li>幂函数</li>
<li>就近取整函数绝对值函数和取余函数</li>
</ol>
<h3 id="23-3-1-错误"><a href="#23-3-1-错误" class="headerlink" title="23.3.1    错误"></a>23.3.1    错误</h3><p><strong>相关库：</strong><code>errno.h</code><br><strong>特点：</strong><code>math.h</code>中，大多数函数会将一个错误代码存储到一个名字为<code>errno</code>（<code>math.h</code>）的特定变量中（这一点不同于其他库）。<br><strong>相关宏：</strong><code>HUGE_VAL</code>(<code>math.h</code>， IEEE标准)</p>
<blockquote>
<p><strong>说明：</strong>在<code>math.h</code>中定义，double类型，不一定是一个普通的数，代表无穷大（<a href="">7.2</a>）。<br><strong>用途：</strong>当函数的返回值大于double类型的最大值时，会返回<code>HUGE_VAL</code>。<br><strong>更多错误：</strong><a href="">附录D</a></p>
</blockquote>
<h4 id="参数超出定义域"><a href="#参数超出定义域" class="headerlink" title="参数超出定义域"></a>参数超出定义域</h4><p><strong>描述：</strong>函数的是惨超出了函数的定义域。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>EDOM</code>(定义域错误)<br><strong>返回值：</strong><code>NAN</code>(<code>math.h</code>， IEEE标准)</p>
<h4 id="返回值超出取值范围"><a href="#返回值超出取值范围" class="headerlink" title="返回值超出取值范围"></a>返回值超出取值范围</h4><p><strong>描述：</strong>函数的返回值超出了double类型的取值范围。<br><strong>会被存储到<code>errno</code>中的宏：</strong><code>ERANGE</code>(取值范围错误)，绝对值过小（下溢出）的情况又可能不存储<code>ERANGE</code><br><strong>返回值：</strong>分两种情况</p>
<ol>
<li><strong>绝对值过大：</strong>根据返回值的正负返回正或负的<code>HIGE_VAL</code></li>
<li><strong>绝对值过小：</strong>返回0</li>
</ol>
<h3 id="23-3-2-三角函数"><a href="#23-3-2-三角函数" class="headerlink" title="23.3.2    三角函数"></a>23.3.2    三角函数</h3><h4 id="cos函数"><a href="#cos函数" class="headerlink" title="cos函数"></a>cos函数</h4><p><strong>说明：</strong>余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sin函数"><a href="#sin函数" class="headerlink" title="sin函数"></a>sin函数</h4><p><strong>说明：</strong>正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tan函数"><a href="#tan函数" class="headerlink" title="tan函数"></a>tan函数</h4><p><strong>说明：</strong>正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="acos函数"><a href="#acos函数" class="headerlink" title="acos函数"></a>acos函数</h4><p><strong>说明：</strong>反余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 余弦值</span><br><span class="line">* @return &#123;double&#125; 余弦值对应的弧度（0~π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asin函数"><a href="#asin函数" class="headerlink" title="asin函数"></a>asin函数</h4><p><strong>说明：</strong>反正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正弦值</span><br><span class="line">* @return &#123;double&#125; 正弦值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan函数"><a href="#atan函数" class="headerlink" title="atan函数"></a>atan函数</h4><p><strong>说明：</strong>反正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 正切值</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π/2~π/2）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atan2函数"><a href="#atan2函数" class="headerlink" title="atan2函数"></a>atan2函数</h4><p><strong>说明：</strong>反正切，<code>atan(x)&lt;==&gt;atan2(x, 1.0)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; y y</span><br><span class="line">* @param &#123;double&#125; x x</span><br><span class="line">* @return &#123;double&#125; 正切值对应的弧度（-π～π）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cos</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(PI/<span class="number">4</span>);<span class="comment">// 0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(PI/<span class="number">4</span>);<span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">1.0</span>);<span class="comment">// 0.0</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">1.0</span>);<span class="comment">// 1.5708</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1.0</span>);<span class="comment">// 0.785398</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-4-双曲函数"><a href="#23-3-4-双曲函数" class="headerlink" title="23.3.4    双曲函数"></a>23.3.4    双曲函数</h3><h4 id="cosh函数"><a href="#cosh函数" class="headerlink" title="cosh函数"></a>cosh函数</h4><p><strong>说明：</strong>计算双曲余弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲余弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cosh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sinh函数"><a href="#sinh函数" class="headerlink" title="sinh函数"></a>sinh函数</h4><p><strong>说明：</strong>计算双曲正弦<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正弦值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sinh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p><strong>说明：</strong>计算双曲正切<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 弧度</span><br><span class="line">* @return &#123;double&#125; 双曲正切值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tanh</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cosh</span>(<span class="number">0.5</span>);<span class="comment">// 1.12763</span></span><br><span class="line"><span class="built_in">sinh</span>(<span class="number">0.5</span>);<span class="comment">// 0.521095</span></span><br><span class="line"><span class="built_in">tanh</span>(<span class="number">0.5</span>);<span class="comment">// 0.462117</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-指数函数和对数函数"><a href="#22-3-4-指数函数和对数函数" class="headerlink" title="22.3.4 指数函数和对数函数"></a>22.3.4 指数函数和对数函数</h3><h4 id="exp函数"><a href="#exp函数" class="headerlink" title="exp函数"></a>exp函数</h4><p><strong>说明：</strong>返回e的幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 指数</span><br><span class="line">* @return &#123;double&#125; e的x次幂</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e的3次幂</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">3.0</span>);<span class="comment">// 20.0855</span></span><br></pre></td></tr></table></figure>
<h4 id="log函数"><a href="#log函数" class="headerlink" title="log函数"></a>log函数</h4><p><strong>说明：</strong>以e为底的对数（exp函数的逆运算）<br><strong>原型：</strong>math.h``</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return double 以e为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">20.0855</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="log10函数"><a href="#log10函数" class="headerlink" title="log10函数"></a>log10函数</h4><p><strong>说明：</strong>计算常用对数（以10为底的对数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @return &#123;double&#125; 以10为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log10</span>(<span class="number">1000</span>);<span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 对任意的x和b，计算以b为底x的对数</span><br><span class="line">* @param &#123;double&#125; x 真数</span><br><span class="line">* @param &#123;double&#125; b 底数</span><br><span class="line">* @return &#123;double&#125; 以b为底x的对数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">logb</span><span class="params">(<span class="keyword">double</span> x. <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">log</span>(x) / <span class="built_in">log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="frexp函数"><a href="#frexp函数" class="headerlink" title="frexp函数"></a>frexp函数</h4><p><strong>说明：</strong>将浮点数拆成小数部分f和指数部分n，使得原始值等于<code>f x 2^n</code>。<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 浮点数原始值</span><br><span class="line">* @param &#123;double *&#125; iptr 存储n的地址</span><br><span class="line">* @return &#123;double&#125; f（0.5&lt;=f&lt;=1）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lfexp</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">frexp</span>(<span class="number">12.0</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// .75, exp: 4</span></span><br><span class="line"><span class="built_in">frexp</span>(<span class="number">0.25</span>, &amp;<span class="built_in">exp</span>);<span class="comment">// 0.5, exp: -1</span></span><br></pre></td></tr></table></figure>
<h4 id="ldexp函数"><a href="#ldexp函数" class="headerlink" title="ldexp函数"></a>ldexp函数</h4><p><strong>说明：</strong>将小数部分f和整数部分exp组合为，一般而言为<code>f x 2^exp</code>(frexp函数的逆函数)<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; f 小数部分</span><br><span class="line">* @param &#123;int&#125; exp 整数部分</span><br><span class="line">* @return &#123;double&#125; f x 2^exp</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ldexp</span><span class="params">(<span class="keyword">double</span> f <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ldexp</span>(<span class="number">.75</span>, <span class="number">4</span>);<span class="comment">// 12.0</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.5</span>, <span class="number">-1</span>);<span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>
<h4 id="modf函数"><a href="#modf函数" class="headerlink" title="modf函数"></a>modf函数</h4><p><strong>说明：</strong>将一个浮点数的整数部分和小数部分拆解开，返回小数部分，并将整数部分存入第二个参数所指向的变量中<br><strong>用途：</strong>主要供<code>math.h</code>中的其他函数点用，很少在程序中直接使用<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; value 原始浮点数</span><br><span class="line">* @param &#123;double *&#125; iptr 存储整数部分的地址</span><br><span class="line">* @return &#123;double&#125; 小数部分 </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> *iptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-3-5-幂函数"><a href="#23-3-5-幂函数" class="headerlink" title="23.3.5    幂函数"></a>23.3.5    幂函数</h3><h4 id="pow函数"><a href="#pow函数" class="headerlink" title="pow函数"></a>pow函数</h4><p><strong>说明：</strong>计算x的y次幂<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 底数</span><br><span class="line">* @param &#123;double&#125; y 指数</span><br><span class="line">* @param &#123;double&#125; x^y</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);<span class="comment">// 9.0</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">0.5</span>);<span class="comment">// 1.73205</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">-3.0</span>);<span class="comment">// 0.037037</span></span><br></pre></td></tr></table></figure>
<h4 id="sqrt函数"><a href="#sqrt函数" class="headerlink" title="sqrt函数"></a>sqrt函数</h4><p><strong>说明：</strong>计算平方根（算数平方根），<code>sqrt(x)</code>相当于<code>pow(x, 0.5)</code><br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 开放数</span><br><span class="line">* @return &#123;double&#125; 平方根</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(<span class="number">3.0</span>);<span class="comment">// 1.73205</span></span><br></pre></td></tr></table></figure>
<h3 id="23-3-6-就近取整函数、绝对值函数和取余函数"><a href="#23-3-6-就近取整函数、绝对值函数和取余函数" class="headerlink" title="23.3.6    就近取整函数、绝对值函数和取余函数"></a>23.3.6    就近取整函数、绝对值函数和取余函数</h3><h4 id="ceil函数"><a href="#ceil函数" class="headerlink" title="ceil函数"></a>ceil函数</h4><p><strong>说明：</strong>向上舍入（计算大于或等于其参数的最小整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="floor函数"><a href="#floor函数" class="headerlink" title="floor函数"></a>floor函数</h4><p><strong>说明：</strong>向下舍入（计算小于或等于其参数的最大整数）<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.1</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.8</span>);<span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.1</span>);<span class="comment">// -7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.1</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.8</span>);<span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.1</span>);<span class="comment">// -8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 实现“四舍五入”（标准库没实现）</span><br><span class="line">* @param &#123;double&#125; x 原始的浮点数</span><br><span class="line">* @return &#123;double&#125; 四舍五入后的</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	return x &lt; <span class="number">0.07</span> ? <span class="built_in">ceil</span>(x - <span class="number">0.5</span>) : <span class="built_in">floor</span>(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fabs函数"><a href="#fabs函数" class="headerlink" title="fabs函数"></a>fabs函数</h4><p><strong>说明：</strong>计算参数的绝对值<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;double&#125; x 原始浮点数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="number">7.1</span>);<span class="comment">// 7.1</span></span><br><span class="line"><span class="built_in">fabs</span>(<span class="number">-7.1</span>);<span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<h4 id="fmod函数"><a href="#fmod函数" class="headerlink" title="fmod函数"></a>fmod函数</h4><p><strong>说明：</strong>取余（第一个参数除以第二个参数所得的余数）<br><strong>注意：</strong><code>%</code>只能用于整数，不能用于浮点数<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;double&#125; x 被除数</span><br><span class="line">* @param &#123;double&#125; y 除数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(<span class="number">5.5</span>, <span class="number">2.2</span>);<span class="comment">// 1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="23-4-ctype-h：字符处理"><a href="#23-4-ctype-h：字符处理" class="headerlink" title="23.4    ctype.h：字符处理"></a>23.4    <code>ctype.h</code>：字符处理</h2><p><strong>说明：</strong><code>ctype.h</code>提供了两类函数</p>
<ol>
<li><p>字符测试函数</p>
<blockquote>
<p><strong>举例</strong><br><code>isdigit函数</code>：用来检测一个字符是否是数字</p>
</blockquote>
</li>
<li><p>字符大小写转换函数</p>
<blockquote>
<p><strong>举例</strong><br><code>toupper函数</code>：用来将一个小写字母转换成大写字母</p>
</blockquote>
</li>
</ol>
<p><strong>技巧：</strong>建议使用<code>ctype.h</code>中提供的函数而不是用其他手段测试字符或进行大小写转换</p>
<ol>
<li>性能更好（大多数是用宏实现的）</li>
<li>可移植性更好（可以在任何字符集上运行）</li>
<li>国际化（可以正确运行在世界上不同地点）</li>
</ol>
<p><strong>特点（参数和返回值类型）</strong><code>ctype.h</code>中的函数都以<code>int</code>类型作为参数，并返回一个<code>int</code>类型的值（C语言可以自动将<code>char</code>类型的参数转换为<code>int</code>类型，或将<code>int</code>类型的返回值转换成<code>char</code>类型）。</p>
<h3 id="23-4-1-字符测试函数"><a href="#23-4-1-字符测试函数" class="headerlink" title="23.4.1    字符测试函数"></a>23.4.1    字符测试函数</h3><p><strong>说明：</strong>这些函数具有一样的<code>参数类型</code>和<code>返回值类型</code>。<br><strong>原型：</strong><code>ctype.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 要测试的字符</span><br><span class="line">* @param &#123;int&#125; 1:测试符合期待；0:测试不符合期待</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> 函数名(<span class="keyword">int</span> c);</span><br></pre></td></tr></table></figure>
<h4 id="字符测试函数列表"><a href="#字符测试函数列表" class="headerlink" title="字符测试函数列表"></a>字符测试函数列表</h4><table>
<thead>
<tr>
<th>字符测试函数</th>
<th>测试类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum</code></td>
<td>字母或数字</td>
</tr>
<tr>
<td><code>isalpha</code></td>
<td>字母</td>
</tr>
<tr>
<td><code>iscntrl</code></td>
<td>控制字符</td>
<td>包括<code>\0x00~\0x1f</code>、<code>\0x7f</code></td>
</tr>
<tr>
<td><code>isdigit</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>isgraph</code></td>
<td>可显示字符（除空格外）</td>
</tr>
<tr>
<td><code>islower</code></td>
<td>小写字母</td>
</tr>
<tr>
<td><code>isprint</code></td>
<td>可显示字符（包括空格）</td>
</tr>
<tr>
<td><code>ispunct</code></td>
<td>标点符号</td>
<td>空格、字母、数字以外的可显示字符</td>
</tr>
<tr>
<td><code>isspace</code></td>
<td>空白字符</td>
<td>空格、换页符(<code>\f</code>)、换行符(<code>\n</code>)、回车符(<code>\r</code>)、横向制表符(<code>\t</code>)、纵向制表符(<code>\v</code>)</td>
</tr>
<tr>
<td><code>isupper</code></td>
<td>大写字母</td>
</tr>
<tr>
<td><code>isxdigit</code></td>
<td>十六进制数字</td>
</tr>
</tbody>
</table>
<h3 id="23-4-2-程序：测试字符测试函数"><a href="#23-4-2-程序：测试字符测试函数" class="headerlink" title="23.4.2    程序：测试字符测试函数"></a>23.4.2    程序：测试字符测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(f) printf(<span class="string">"%6c"</span>, f(*p) ? <span class="string">'x'</span> : <span class="string">' '</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   alnum cntrl graph print space xdigit alpha digit lower punc       upper\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"azAZ0	!\t"</span>; *p != <span class="string">'0'</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(*p)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\\x%02x:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%5c:"</span>, *p);</span><br><span class="line">		&#125;</span><br><span class="line">		TEST(<span class="built_in">isalnum</span>);</span><br><span class="line">		TEST(<span class="built_in">iscntrl</span>);</span><br><span class="line">		TEST(<span class="built_in">isgraph</span>);</span><br><span class="line">		TEST(<span class="built_in">isprint</span>);</span><br><span class="line">		TEST(<span class="built_in">isspace</span>);</span><br><span class="line">		TEST(<span class="built_in">isxdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">isalpha</span>);</span><br><span class="line">		TEST(<span class="built_in">isdigit</span>);</span><br><span class="line">		TEST(<span class="built_in">islower</span>);</span><br><span class="line">		TEST(<span class="built_in">ispunct</span>);</span><br><span class="line">		TEST(<span class="built_in">isupper</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.01.33.png" alt="Alt text"></p>
<h3 id="23-4-3-字符大小写转换函数"><a href="#23-4-3-字符大小写转换函数" class="headerlink" title="23.4.3    字符大小写转换函数"></a>23.4.3    字符大小写转换函数</h3><h4 id="tolower函数"><a href="#tolower函数" class="headerlink" title="tolower函数"></a>tolower函数</h4><p><strong>说明：</strong>返回与作为参数的字母相对应的小写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的小写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="toupper函数"><a href="#toupper函数" class="headerlink" title="toupper函数"></a>toupper函数</h4><hr>
<p><strong>说明：</strong>返回与作为参数的字母相对应的大写字母<br><strong>原型：</strong><code>math.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 原始字符（字母）</span><br><span class="line">* @return &#123;int&#125; 对应的大写字母</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="23-4-4-程序：测试大小写转换函数"><a href="#23-4-4-程序：测试大小写转换函数" class="headerlink" title="23.4.4    程序：测试大小写转换函数"></a>23.4.4    程序：测试大小写转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="string">"aA0!"</span>; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tolower('%c') is '%c';\n"</span>, *p, <span class="built_in">tolower</span>(*p));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"toupper('%c') is '%c'\n"</span>, *p, <span class="built_in">toupper</span>(*p));</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-13%20%E4%B8%8B%E5%8D%882.39.11.png" alt="Alt text"></p>
<h2 id="23-5-string-h：字符串处理"><a href="#23-5-string-h：字符串处理" class="headerlink" title="23.5    string.h：字符串处理"></a>23.5    <code>string.h</code>：字符串处理</h2><p><strong>相关章节：</strong><a href="">13.5</a><br><strong>函数分类：</strong>可以分为5类</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复制函数</td>
<td style="text-align:center">将字符从内存中的一处复制到另一处</td>
</tr>
<tr>
<td style="text-align:center">拼接函数</td>
<td style="text-align:center">向字符串末尾追加字符</td>
</tr>
<tr>
<td style="text-align:center">比较函数</td>
<td style="text-align:center">比较字符数组的函数</td>
</tr>
<tr>
<td style="text-align:center">搜索函数</td>
<td style="text-align:center">在字符数组中搜索特定字符、字符组或字符串</td>
</tr>
<tr>
<td style="text-align:center">其他函数</td>
<td style="text-align:center">初始化字符数组或计算字符串的长度</td>
</tr>
</tbody>
</table>
<h3 id="23-5-1-复制函数"><a href="#23-5-1-复制函数" class="headerlink" title="23.5.1    复制函数"></a>23.5.1    复制函数</h3><p><strong>说明：</strong>共4个函数，用于将字符（字节）将内存的一处（源）移动到另一处（目的）。要求第一个参数指向目的，第二个参数指向源，并返回第一个参数（即指向目的的指针）。</p>
<h4 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时无法正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>限制：</strong>当从一块内存区域复制到另一块可能重叠的内存区域时，不能保证正常工作。<br><strong>性能：</strong>比<code>memmove函数</code>快一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">4</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">7</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h4><hr>
<p><strong>说明：</strong>从源向目的复制n个字节（当源和目的重叠时仍然可以正常工作）<br><strong>对源的要求：</strong>不要求字符串以空字符结尾，对任意内存块正常工作。<br><strong>性能：</strong>比<code>memcpy函数</code>性能差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;void *&#125; 目的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line">memmove(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, t, e, a</span></span><br></pre></td></tr></table></figure>
<h4 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，会持续肤质字符，知道遇到一个空字符为止。<br><strong>对源的要求：</strong>要求字符串以空字符结尾。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(dest, souce);<span class="comment">// h, o, t, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncpy函数"><a href="#strncpy函数" class="headerlink" title="strncpy函数"></a>strncpy函数</h4><hr>
<p><strong>说明：</strong>将一个以空字符结尾的字符串从源复制到目的，<code>strcpy函数</code>的增强版<br><strong>对源的要求：</strong>不要求字符串以空字符串结尾，对任意内存块正常工作。<br><strong>安全：</strong>比<code>strcpy函数</code>更安全<br><strong>性能：</strong>比<code>strcpy</code>差一些<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 目的地地址</span><br><span class="line">* @param &#123;void *&#125; s2 源位置地址</span><br><span class="line">* @param &#123;size_t&#125; n 不会复制多于n个字符（如果）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>, <span class="string">'0'</span>, <span class="string">'t'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, source, <span class="number">3</span>);<span class="comment">// h, o, t, \0, \0, \0, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-2-拼接函数"><a href="#23-5-2-拼接函数" class="headerlink" title="23.5.2    拼接函数"></a>23.5.2    拼接函数</h3><h4 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h4><hr>
<p><strong>说明：</strong>将第一个参数追加到第一个参数的末尾</p>
<ul>
<li><strong>参数：</strong>要求两个参数都是以<code>\0</code>结尾的字符串</li>
<li><strong>返回值：</strong>返回的字符串会自动在末尾添加<code>\0</code>。</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">"bag"</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h4 id="strncat函数"><a href="#strncat函数" class="headerlink" title="strncat函数"></a>strncat函数</h4><hr>
<p><strong>说明：</strong><code>strcat</code>的增强版，第3个参数会限制复制的字符的个数。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 原本的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 被追加的部分</span><br><span class="line">* @param &#123;size_t&#125; n 限制复制的字符的个数</span><br><span class="line">* @return &#123;char *&#125; 拼接后的字符串(第一个参数的指针)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">2</span>);<span class="comment">// t, e, a, b, a, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">3</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">"bag"</span>, <span class="number">4</span>);<span class="comment">// t, e, a, b, a, g, \0</span></span><br></pre></td></tr></table></figure>
<h3 id="23-5-3-比较函数"><a href="#23-5-3-比较函数" class="headerlink" title="23.5.3    比较函数"></a>23.5.3    比较函数</h3><p><strong>注意：</strong>下面5个函数可以分为两类</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>比较依据</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memcmp函数</code> 、<code>strcmp函数</code>、<code>strncmp函数</code></td>
<td>计算机自身的排序顺序（通常是ACILL）</td>
<td>好</td>
</tr>
<tr>
<td><code>strcoll函数</code>、<code>strxfrm函数</code></td>
<td>依赖当前的本地化设置</td>
<td>差</td>
</tr>
</tbody>
</table>
<h4 id="memcpm函数"><a href="#memcpm函数" class="headerlink" title="memcpm函数"></a>memcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串的大小(具有限制参与比较的字符个数的参数)<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;void *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[] == &#123;<span class="string">'b'</span>, <span class="string">'i'</span>, <span class="string">'g'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<h4 id="strcpm函数"><a href="#strcpm函数" class="headerlink" title="strcpm函数"></a>strcpm函数</h4><hr>
<p><strong>说明：</strong>比较两个字符串（不能设置参与比较的字符数上限），在其中一个字符数组遇到<code>\0</code>时停止比较。</p>
<ul>
<li><strong>参数：</strong>必须是以<code>\0</code>结尾的字符串</li>
</ul>
<p><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strncmp函数"><a href="#strncmp函数" class="headerlink" title="strncmp函数"></a>strncmp函数</h4><hr>
<p><strong>说明：</strong>结合<code>memcmp</code>和<code>strcmp</code>，当比较的字符数达到字符数上限或任意一个字符数组中遇到<code>\0</code>时停止比较。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @param &#123;size_t&#125; n 参与比较的字符个数上限</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) ...<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="strcoll函数"><a href="#strcoll函数" class="headerlink" title="strcoll函数"></a>strcoll函数</h4><hr>
<p><strong>说明：</strong>类似<code>strcmp</code>，不同点在于比较结果依赖本地化设置（通过调用<code>setlocale函数</code><a href="">25.1.2</a>）。<br><strong>缺点：</strong>性能差。<br><strong>应用：</strong>适用于那些根据程序运行的地点不同而可能按不同方式比较的程序。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 参与比较的字符串</span><br><span class="line">* @param &#123;char *&#125; s2 参与比较的字符串</span><br><span class="line">* @return &#123;int&#125; 负整数：s1 &lt; s2; 0：s1 == s2；正整数：s1 &gt; s2</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strxfrm函数"><a href="#strxfrm函数" class="headerlink" title="strxfrm函数"></a>strxfrm函数</h4><hr>
<p><strong>说明：</strong>按照本地化设置转换字符串。<br><strong>技巧：</strong>需要考虑本地化时可以配合<code>strcmp</code>来取代<code>strcoll</code>。因为对两个转化后的参数调用<code>strcmp</code>等价直接调用<code>strcoll</code>。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 转换后的字符串存储到s1</span><br><span class="line">* @return &#123;char *&#125; s2 需要转换的字符串</span><br><span class="line">* @param &#123;char *&#125; size_t 转换的字符数量上限</span><br><span class="line">* @return &#123;size_t&#125; 转换后字符串的长度</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strxfrm(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * restict s2, <span class="keyword">size_t</span> n);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> *transformed;</span><br><span class="line"><span class="comment">// 获取转换后字符串的长度</span></span><br><span class="line">len = strxfrm(NULL, original, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">transformed = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将转换后的字符串存储到分配的内存中</span></span><br><span class="line">strxfrm(transformed, original, len);</span><br></pre></td></tr></table></figure>
<h3 id="23-5-4-搜索函数"><a href="#23-5-4-搜索函数" class="headerlink" title="23.5.4    搜索函数"></a>23.5.4    搜索函数</h3><h4 id="strchr函数"><a href="#strchr函数" class="headerlink" title="strchr函数"></a>strchr函数</h4><hr>
<p><strong>说明：</strong>在字符串中搜索指定字符。<br><strong>停止搜索时机：</strong>遇到首个<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;char *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,  <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">'f'</span>);<span class="comment">// 找到第一个'f'</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">strchr</span>(p + <span class="number">1</span>, <span class="string">'f'</span>);<span class="comment">// 找到第二个'f'</span></span><br></pre></td></tr></table></figure>
<h4 id="memchr函数"><a href="#memchr函数" class="headerlink" title="memchr函数"></a>memchr函数</h4><hr>
<p><strong>说明：</strong>类似<code>strchr</code>，在字符串中搜索指定字符<br><strong>停止搜索时机：</strong>搜索了指定数量的字符后<br><strong>用途：</strong>适用于不希望对整个字符串进行搜索或搜索的内存块不是以<code>\0</code>结尾时<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @param &#123;size_t&#125; n 要搜索的字符数量上限</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strrhrc函数"><a href="#strrhrc函数" class="headerlink" title="strrhrc函数"></a>strrhrc函数</h4><hr>
<p><strong>说明：</strong>函数会首先找到字符串末尾的空字符，然后反向查找字符。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;int&#125; c 要搜索的字符</span><br><span class="line">* @return &#123;void *&#125; 指向s中要搜索的第一个c的指针：搜索到了c；空字符：没有搜索到c</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s1, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[<span class="number">22</span>] = <span class="string">"Form follows function"</span>;</span><br><span class="line"><span class="comment">// 反向搜索字符'f'</span></span><br><span class="line">p = <span class="built_in">memchr</span>(strr, <span class="string">'f'</span>, sizeof(str));</span><br></pre></td></tr></table></figure>
<h4 id="strpbrk函数"><a href="#strpbrk函数" class="headerlink" title="strpbrk函数"></a>strpbrk函数</h4><hr>
<p><strong>说明：</strong>返回指向第一个实际参数中与第二个实参中任意一个字符匹配的最左边一个字符的指针。<br><strong>更通用：</strong><code>strchr</code>相当于<code>strpbrk</code>的第二个参数字符串中只给一个字符的情况。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 匹配字符集</span><br><span class="line">* @return &#123;char *&#125; 指向匹配到的字符：匹配到；指针：没有匹配到</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索第一个'm'或'n'</span></span><br><span class="line">p = <span class="built_in">strpbrk</span>(str, <span class="string">"mm"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strspn函数"><a href="#strspn函数" class="headerlink" title="strspn函数"></a>strspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个不属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<h4 id="strcspn函数"><a href="#strcspn函数" class="headerlink" title="strcspn函数"></a>strcspn函数</h4><hr>
<p><strong>说明：</strong>返回字符串中第一个属于给定字符集中的字符的下标。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符集合</span><br><span class="line">* @return &#123;size_t&#125;  字符的下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strcspn</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br><span class="line">len = <span class="built_in">strspn</span>(str, <span class="string">" \t\n"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 0</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str, <span class="string">"morF"</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h4><hr>
<p><strong>说明：</strong>在第一个参数（字符串）中搜索能匹配第二个参数（字符串）的子串，并返回找到的第一处匹配子串的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">"Form follows function."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在str中搜索"fun"</span></span><br><span class="line">p = <span class="built_in">strstr</span>(str, <span class="string">"fun"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><hr>
<p><strong>说明：</strong>分割出一段子字符串。<br><strong>原理：</strong>在s1中搜索，按照s2指定的分隔符找出一系列非空字符（不包含s2中指定的字符）。<code>strtok函数</code>会写入一个<code>\0</code>来标记字符序列的末尾，并返回指向这个序列的首字符的指针。<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s1 字符串</span><br><span class="line">* @param &#123;char *&#125; s2 字符串（要作为分割字符的字符集合）</span><br><span class="line">* @return &#123;char *&#125; 指向新分割出来的子字符串的指针（指向首字符）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>原始字符串状态</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p, str[] = <span class="string">" Apri1  28,1990"</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th><code> </code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>月</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割出第一个序列，使用" \t"中的字符作为分隔符</span></span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">p = strtok(str, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th><code>A</code></th>
<th><code>p</code></th>
<th><code>r</code></th>
<th><code>i</code></th>
<th><code>1</code></th>
<th><code>\0</code></th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>,</th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>日</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th><code>2</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
<th>1</th>
<th>9</th>
<th>9</th>
<th>8</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>年</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上次结束的位置继续查找</span></span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">p = strtok(NULL, <span class="string">" \t"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code> </code></th>
<th>A</th>
<th>p</th>
<th>r</th>
<th>i</th>
<th>1</th>
<th>\0</th>
<th><code> </code></th>
<th>2</th>
<th>8</th>
<th>\0</th>
<th><code>1</code></th>
<th><code>9</code></th>
<th><code>9</code></th>
<th><code>8</code></th>
<th><code>\0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="23-5-5-其他函数"><a href="#23-5-5-其他函数" class="headerlink" title="23.5.5    其他函数"></a>23.5.5    其他函数</h3><h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><hr>
<p><strong>说明：</strong>将一个字符的多个副本存储到指定区域。<br><strong>应用：</strong>将数组元素全部初始化为0<br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; s 指向用来存储字符副本的空间</span><br><span class="line">* @param &#123;int&#125; c 用于填充的字符</span><br><span class="line">* @param &#123;size_t&#125; n 从s指向的地址往后填充空间大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 第一个参数（空间地址）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, size_t n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为p指向的内存的N哥字节存储空格</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="string">' '</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组a初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>
<h4 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h4><hr>
<p><strong>说明：</strong>返回字符串的长度，不计算字符串末尾的<code>\0</code><br><strong>原型：</strong><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符串</span><br><span class="line">* @return &#123;size_t&#125; 字符串的常速</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br></pre></td></tr></table></figure>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p><strong>说明：</strong><a href="">24.2</a><br><strong>原型：</strong><code>errno.h</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/22 输入／输出/" itemprop="url">
                  22 输入/输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T23:01:02+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/22 输入／输出/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/22 输入／输出/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="22-1-流"><a href="#22-1-流" class="headerlink" title="22.1    流"></a>22.1    流</h2><blockquote>
<p><strong>说明：</strong>在C语言中，术语流意味着任意输入的源或人意输出的目的地。<code>stdio.h</code>中的许多函数不仅可以处理表示成文件的流，还可以处理所有其它形式的流。<br><strong>流：</strong>流常常表示为磁盘上的文件，但却可以和其它类型的设备相关联：调制解调器、网络端口、打印机、光盘驱动器等。</p>
</blockquote>
<h3 id="22-1-1-文件指针"><a href="#22-1-1-文件指针" class="headerlink" title="22.1.1    文件指针"></a>22.1.1    文件指针</h3><blockquote>
<p><strong>文件指针（file pointer）：</strong><code>File *</code>(<code>File</code>定义在<code>stdio.h</code>中)<br><strong>用途：</strong>C程序中流的访问是通过<code>文件指针</code>实现的<br><strong>限制：</strong>操作系统通常会限制在任意某时刻可以打开的流的数量（但是一个程序中可以声明任意数量的<code>File *</code>型变量）。</p>
</blockquote>
<h3 id="22-1-2-标准流和重定向"><a href="#22-1-2-标准流和重定向" class="headerlink" title="22.1.2    标准流和重定向"></a>22.1.2    标准流和重定向</h3><h4 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h4><blockquote>
<p><strong>说明：</strong>由<code>stdio.h</code>提供，一共3种</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件指针</th>
<th>流</th>
<th>默认的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输出</td>
<td>屏幕</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>相关的函数：</strong><code>printf</code>、<code>scanf</code>、<code>putchar</code>、<code>getchar</code>、<code>puts</code>、<code>gets</code></p>
</blockquote>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><blockquote>
<p><strong>说明：</strong>某些操作系统（比如UNIX/Linux/DOS）允许通过所谓的<code>重定向（redirextion）</code>机制来改变标准流默认的含义。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入重定向(input redirection)</td>
<td>使<code>stdin流</code>表示为文件(而非键盘)</td>
<td>程序不回意识到正在从文件读取数据</td>
</tr>
<tr>
<td>输出重定向(output redirection)</td>
<td>使<code>stdout流</code>和<code>stderr流</code>表示为文件（而飞屏幕）</td>
<td>程序不会意识到正在向文件中写数据</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入重定向</span></span><br><span class="line">demo &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出重定向</span></span><br><span class="line">demo &gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">demo &lt; in.dat &gt;out.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-1-3-文本文件与二进制文件"><a href="#22-1-3-文本文件与二进制文件" class="headerlink" title="22.1.3    文本文件与二进制文件"></a>22.1.3    文本文件与二进制文件</h3><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>支持两种类型的文件（文本文件和二进制文件）<br><strong>存储方式：</strong>文本文件和二进制文件都是字节的序列，不同点在于存储的数据类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>数据类型（假设字符集为ASCII，16位机器）</th>
<th>空间利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本文件(text file)</td>
<td>字符（占一个字节）</td>
<td>低</td>
</tr>
<tr>
<td>二进制文件(binary file)</td>
<td>字符（占一个字节）、整数（两个字节）、浮点数（四个字节）等</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>结束符：</strong></p>
<ul>
<li><strong>DOS系统：</strong>文本文件和二进制文件不同</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>文本文件</th>
<th>二进制文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>回行符＋回车符</td>
<td>回行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>Ctrl+Z(\x1a)，但不是必需的（有的编辑器会加上</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>UNIX系统：</strong>对文本文件和二进制文件不进行区分</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>结束符分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>行的结尾</td>
<td>换行符</td>
</tr>
<tr>
<td>文件末尾</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>在屏幕上显示文件内容的程序会假设文件为文本文件</li>
<li>复制文件时如果设定文件为文本文件，只会复制到出现文件末尾符出现的地方</li>
</ol>
<p><strong>技巧：</strong>在无法确定文件是文本文件还是二进制文件时，安全的做法是把文件假设为二进制文件。</p>
</blockquote>
<h2 id="22-2-文件操作"><a href="#22-2-文件操作" class="headerlink" title="22.2    文件操作"></a>22.2    文件操作</h2><h3 id="22-2-1-打开文件"><a href="#22-2-1-打开文件" class="headerlink" title="22.2.1    打开文件"></a>22.2.1    打开文件</h3><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><blockquote>
<p><strong>说明：</strong>用流的方式打开文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 含有要大开文件名的字符串（可能包含文件位置的信息，例如驱动号或路径）</span><br><span class="line">* @param &#123;char *&#125; mode 模式字符串，例如"r"代表只读方式</span><br><span class="line">* @return &#123;FILE *&#125; 文件指针（如果文件不存在或未获得打开文件的许可则返回空指针）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong>在DOS中的文件名中含有”\”字符要用”\替代”<br><strong>注意：</strong>永远不能假设可以打开文件，为了确保不回返回空指针，需要测试<code>fopen</code>函数的返回值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"c:\\project\\test1.dat"</span>, r); <span class="comment">// 以只读方式打开</span></span><br></pre></td></tr></table></figure>
<h3 id="22-2-2-模式"><a href="#22-2-2-模式" class="headerlink" title="22.2.2    模式"></a>22.2.2    模式</h3><blockquote>
<p><strong>说明：</strong>模式字符串依据文件是文本文件还是二进制文件分为两大类。<br><strong>注意：</strong>可读且可写的模式（包含<code>+</code>）存在如下限制</p>
<ul>
<li>调用<code>文件定位函数</code>后，可读才能转换为可写</li>
<li>调用<code>文件定位函数</code>或<code>fflush函数</code>后，可写才能转换为可读</li>
</ul>
</blockquote>
<h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
<th>是否需要文件存在</th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>rb</td>
<td>可读</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>wb</td>
<td>可写</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>ab</td>
<td>追加</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>读和写</td>
<td>否</td>
<td>从文件头开始（追加到头部）</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>读和写</td>
<td>否</td>
<td>截去（覆盖）</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>读和写</td>
<td>否</td>
<td>追加</td>
</tr>
</tbody>
</table>
<h3 id="22-2-3-关闭文件"><a href="#22-2-3-关闭文件" class="headerlink" title="22.2.3    关闭文件"></a>22.2.3    关闭文件</h3><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><blockquote>
<p><strong>说明：</strong>关闭不再使用的文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针（来自fopen函数或freopen函数）</span><br><span class="line">* @return 0:关闭成功；EOF(stdio.h宏)：关闭失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="string">"example.dat"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.大开文件</span></span><br><span class="line">	fp = fopen(FILE_NAME, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Cant't open %s\n"</span>, FILE_NAME);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Opened!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.操作文件</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 3.关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-4-为流附加文件"><a href="#22-2-4-为流附加文件" class="headerlink" title="22.2.4    为流附加文件"></a>22.2.4    为流附加文件</h3><h4 id="freopen函数"><a href="#freopen函数" class="headerlink" title="freopen函数"></a>freopen函数</h4><blockquote>
<p><strong>说明：</strong>为已经打开的流附加一个不同的文件<br><strong>应用：</strong>把文件和一个标准流相关联<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;char *&#125; mode 打开模式</span><br><span class="line">* @param &#123;FILE *&#125; stream 标准流（stdin或stdout或stderr）</span><br><span class="line">* @return &#123;FILE *&#125; 附加成功：文件指针；NULL：打开失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,  FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.如果stdout通过命令行重定向或者freopen函数已经和其它文件关联，则先关闭与stdout相关联的文件</span></span><br><span class="line"><span class="comment">// fclose(frp); // fp指向是和stdout关联的流（文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开foo文件，并使此文件和stdout相关联</span></span><br><span class="line"><span class="comment">// 如果无法关闭旧的文件，那么freopen函数会忽略掉错误</span></span><br><span class="line">frp = freopen(<span class="string">"foo"</span>, <span class="string">"w"</span>, stdout)</span><br><span class="line"><span class="keyword">if</span> (frp == NULL) &#123;</span><br><span class="line">	<span class="comment">// 打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-5-从命令行获取文件名"><a href="#22-2-5-从命令行获取文件名" class="headerlink" title="22.2.5    从命令行获取文件名"></a>22.2.5    从命令行获取文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*</span><br><span class="line">* @param &#123;int&#125; argc 实际参数的数量</span><br><span class="line">* @param &#123;[].(char *)&#125;  一个指针数组，argv[0]指向程序的名字，其余指向实际参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv[0]: demo</span></span><br><span class="line"><span class="comment"># argv[1]: name.dat</span></span><br><span class="line"><span class="comment"># argv[2]: dates.dat.dat</span></span><br><span class="line">$ demo name.dat dates.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-6-程序：检查文件是否可以打开"><a href="#22-2-6-程序：检查文件是否可以打开" class="headerlink" title="22.2.6    程序：检查文件是否可以打开"></a>22.2.6    程序：检查文件是否可以打开</h3><blockquote>
<p><strong>说明：</strong>若文件存在就可以打开进行读入，在运行程序时，用户将给出要检测的文件的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks whether a file can be opened for reading</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="comment">// 如果没有正确调用，给出使用提示</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: canopen filanem\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不能以只读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s can't be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果能以只读的方式打开 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s can be opened\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ canopen f1.dat</span><br></pre></td></tr></table></figure>
<h3 id="22-2-7-临时文件"><a href="#22-2-7-临时文件" class="headerlink" title="22.2.7    临时文件"></a>22.2.7    临时文件</h3><blockquote>
<p><strong>说明：</strong>只在程序运行时存在的文件。<code>stdio.h</code>提供了两个函数用来处理临时文件，即<code>tmpfile</code>和<code>tmpname</code></p>
</blockquote>
<h4 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>产生临时文件，这些临时文件将存到文件关闭时或程序终止时。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @ return &#123;FILE *&#125; 指向临时文件的文件指针(如果创建失败则为NULL)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *tmpptr;</span><br><span class="line">Tempptr = tmpfile(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h4 id="tmpfile函数-1"><a href="#tmpfile函数-1" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h4><blockquote>
<p><strong>说明：</strong>为临时文件产生名字。<br><strong>用途：</strong>解决<code>tmpfile函数</code>无法知道临时文件的名字的问题。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  如果实际参数为NULL，那么tmpnam函数会把文件名存储到静态变量中，并且返回指向此变量的指针；</span><br><span class="line">*  否则，如果提供了字符数组作为参数，函数会把文件名复制到程序员提供的字符数组中。</span><br><span class="line">*</span><br><span class="line">* @param &#123;char *&#125; NULL或者一个字符数组（字符串）</span><br><span class="line">* @return &#123;char *&#125; 指向静态变量（存储着临时文件名）的指针：如果参数为NULL；指向临时文件名的指针（非静态）：如果提供了有效的参数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>参数为NULL</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line">filename = tmpnam(NULL); <span class="comment">// 创建临时文件名</span></span><br></pre></td></tr></table></figure>
<p><em>参数为字符数组</em></p>
<blockquote>
<p><strong>说明：</strong><code>tmpnam函数</code>会把声称的临时文件名复制到程序员提供的字符数组中，而且仍然会返回指向临时文件名的指针。<br><strong>注意：</strong>作为参数的字符数组长度至少为<code>L_tmpnam</code>,产生的临时文件名的最大数量不能超过<code>TMP_MAX</code>。</p>
<ul>
<li><code>L_tmpnam</code>：在<code>stdio.h</code>中定义的一个宏，保存着临时文件名的字符数组的长度。</li>
<li><code>TMP_MAX</code>：在<code>stdio.h</code>中定义的一个宏，保存着程序执行期间<code>tmpnam函数</code>产生的临时文件名的最大数量。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> filename[L_tmpnam];</span><br><span class="line">tmpnam(filename);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-8-文件缓冲"><a href="#22-2-8-文件缓冲" class="headerlink" title="22.2.8    文件缓冲"></a>22.2.8    文件缓冲</h3><blockquote>
<p><strong>说明：</strong>缓冲发生在屏幕的后台，而且通常不用担心它的操作。然而，极少的情况下可能需要我们承担更主动的作用，需要使用<code>fflush函数</code>、<code>setbuf函数</code>和<code>setbuf函数</code>。<br><strong>输入流缓存：</strong>从硬盘或磁盘读取，包含来自输入设备（键盘或磁盘）的数据<br><strong>写入（输出）流缓存：</strong>向输出设备（屏幕或磁盘）写入，包含来自</p>
</blockquote>
<h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><blockquote>
<p><strong>说明：</strong>针对输出（写入）流，把缓冲区的内容传递给磁盘（当缓冲区满了或者关闭文件时，缓冲区会自动“清洗”）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 把缓冲区的内容传递给磁盘</span><br><span class="line">* 当参数为NULL时，“清洗”所有缓冲区；否则，只清洗和参数指向的文件相关的缓冲区</span><br><span class="line">*</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 0：成功；EOF：发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fflush(fp); <span class="comment">// 为fp指向的文件</span></span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">// 清洗全部输出流</span></span><br></pre></td></tr></table></figure>
<h4 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h4><blockquote>
<p><strong>说明：</strong>改变缓冲流的方式，控制缓冲区的大小和位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; buf 期望缓冲区的地址</span><br><span class="line">* @param &#123;int&#125; 期望缓冲区的类型&#123;_IOFBF|_IOLBF|IONBF&#125;</span><br><span class="line">* @param &#123;size_t&#125; 缓冲区内字节的数量</span><br><span class="line">* @return &#123;int&#125; 0：成功；非零：要求的缓冲区模式无效或无法提供</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数要点：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>第N个参数</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>缓冲区的地址</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>缓冲区的类型</td>
<td>值为定义在<code>stdio.h</code>中的宏</td>
</tr>
<tr>
<td>4</td>
<td>缓冲区的大小</td>
<td>较大的缓冲区可以提供更好的性能，而较小的缓冲区可以节约时间。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的类型（宏）</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_IOFBF</td>
<td>满缓冲</td>
<td>当缓冲区为空时，从流读入数据；活着当缓冲区满时，向流写入数据</td>
</tr>
<tr>
<td>_IONLF</td>
<td>行缓冲</td>
<td>每次从流读入数据活着直接向流写入数据</td>
</tr>
<tr>
<td>_IOLBF</td>
<td>无缓冲</td>
<td>每次从流读入数据活着直接向流卸乳数据，而没有缓冲区</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>缓冲区的存储特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>存在于程序运行的整个过程中</td>
</tr>
<tr>
<td>自动存储期限</td>
<td>允许在它的空间在块退出时被自动重声明（?）</td>
</tr>
<tr>
<td>动态分配</td>
<td>在不需要时可以释放缓冲区</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>限制：</strong>必需在打开stream之后，在stream上执行任何操作之前调用<code>setvbuf</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建缓冲区</span></span><br><span class="line"><span class="keyword">char</span> buffer[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对缓冲区进行设置（必需在打开stream之后，在stream上执行任何操作之前调用setvbuf）</span></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, N);</span><br></pre></td></tr></table></figure>
<h3 id="22-2-9-其他文件操作"><a href="#22-2-9-其他文件操作" class="headerlink" title="22.2.9    其他文件操作"></a>22.2.9    其他文件操作</h3><h4 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h4><blockquote>
<p><strong>说明：</strong>根据文件名删除文件<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">"foo"</span>); <span class="comment">// 删除名为foo的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h4><blockquote>
<p><strong>说明：</strong>文件重命名<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; old 旧文件名</span><br><span class="line">* @param &#123;char *&#125; new 新文件名</span><br><span class="line">* @return &#123;int&#125; 0：成功；非0：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *old, <span class="keyword">const</span> <span class="keyword">char</span> *new)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>限制：</strong>一定要确保在调用<code>rename函数</code>之前文件是关闭的，否则无法对文件重命名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="22-3-格式化的输入／输出"><a href="#22-3-格式化的输入／输出" class="headerlink" title="22.3    格式化的输入／输出"></a>22.3    格式化的输入／输出</h2><h3 id="22-3-1-…printf类函数"><a href="#22-3-1-…printf类函数" class="headerlink" title="22.3.1    …printf类函数"></a>22.3.1    …printf类函数</h3><h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><blockquote>
<p><strong>说明：</strong>向<code>stdout</code>输出，利用格式串控制输出的形式<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Total: %d\n"</span>, total);</span><br></pre></td></tr></table></figure>
<h4 id="fprintf函数"><a href="#fprintf函数" class="headerlink" title="fprintf函数"></a>fprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>和<code>printf函数</code>唯一的不同就是，<code>printf函数</code>始终向标准输出流<code>stdout</code>向中写入，而<code>fprintf函数</code>则向第一个参数说明的流（任何输出流）中写输出。<br><strong>应用：</strong>向标准错误<code>stderr</code>写出错信息。<br><strong>扩展：</strong><code>stdio.h</code>中还有其他两种函数也可以向流写入格式化的输出，分别是<code>vfprintf函数</code>和<code>vprintf函数</code>,而且它们都还依赖<code>stdarg.h</code>(<a href="">26.1</a>)。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向磁盘中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"Total:%d\n"</span>, total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向stderr中写入</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: data file can't be opened.\n"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="22-3-2-…printf类函数的转换说明"><a href="#22-3-2-…printf类函数的转换说明" class="headerlink" title="22.3.2    …printf类函数的转换说明"></a>22.3.2    …printf类函数的转换说明</h3><blockquote>
<p><strong>说明：</strong>对已知的转换说明内容进行回顾，并把剩余的内容补充完整。<br><strong>注意：</strong>格式串必需遵守规则编写，许多看似可能的转换说明（<code>%le、%lf、%lg</code>等）实际上是无效的。</p>
</blockquote>
<h4 id="转换说明：-012-5Lg"><a href="#转换说明：-012-5Lg" class="headerlink" title="转换说明：%# 012.5Lg"></a><strong>转换说明：</strong><code>%# 012.5Lg</code></h4><table>
<thead>
<tr>
<th>%</th>
<th># 0</th>
<th>12</th>
<th>.5</th>
<th>L</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊标志</td>
<td>➋最小字段宽度</td>
<td>➌精度</td>
<td>➍长度修饰符</td>
<td>➎转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选（可多于一个）</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>转换说明提示符：</strong>标记格式串的开始<br><strong>➊标志：</strong>设置对齐方式、前缀、进制、填充</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>+</code></td>
<td>用<code>+</code>作为正数的前缀</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>用<code>空格</code>作为正数的前缀</td>
</tr>
<tr>
<td><code># 0</code>、<code># 0x(X)</code></td>
<td><code># 0</code>（8进制）、<code># 0x(X)</code>(16进制)，转换说明<code>g(G)</code>转换出的尾部0不能删除</td>
</tr>
<tr>
<td><code>0</code></td>
<td>除非转换说明为<code>d、i、o、u、x(X)</code>且制定了精度，否则用前导0在字段宽度内进行填充</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➋最小字段宽度：</strong>值为<code>有效整数</code>或<code>*</code></p>
<ul>
<li><code>有效整数</code>：**字符数少于最小字段宽度时对字符填充，默认右对齐（在左侧填充<code>空格</code>）；大于最小字段宽度则完整显示。</li>
<li><code>*</code>：格式串中的n个<code>*</code>对应<code>参数2</code>~<code>参数n-1</code>，可以是宏</li>
</ul>
<p><strong>➌精度：</strong>值为<code>.整数</code>或<code>.*</code>(精度的含义即依赖于转换说明符，也依赖于自身的值)</p>
</blockquote>
<table>
<thead>
<tr>
<th>说明符</th>
<th>精度值：<code>.整数</code></th>
<th>精度值：<code>.*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i、o、u、x(X)</code></td>
<td>最小数字位数（如果数字位数少于精度值，则添加前导0）</td>
<td>同<code>最小字段宽度</code>❷中<code>*</code>的含义</td>
</tr>
<tr>
<td><code>e(E)、f</code></td>
<td>小数点后的数字位数</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>最大有效数字位</td>
<td>（同上）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>最大字符数</td>
<td>（同上）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➍长度修饰符：</strong>共3个，只能和一些转换说明符搭配</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>➎转换说明符：</strong>当对带有可变实参的函数（比如<code>printf</code>）传参时，会发生默认的实际参数的提升。<code>float</code>会转换为<code>double</code>，<code>char</code>会转换为<code>int</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参类型</th>
<th>格式化后的形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d、i</code></td>
<td>signed int</td>
<td>十进制形式</td>
</tr>
<tr>
<td><code>o、u、x(X)</code></td>
<td>unsigned int</td>
<td><code>o</code>(8进制)、<code>u</code>(10进制)、<code>x</code>(16进制，a-f来显示)、<code>X</code>(16进制，A-F来显示)</td>
</tr>
<tr>
<td><code>f</code></td>
<td>double</td>
<td>十进制形式（默认的精度为小数点后显示6位）</td>
</tr>
<tr>
<td><code>e(E)</code></td>
<td>double</td>
<td>科学计数法表示的double，默认精度为小数点后显示6位（<code>e</code>表示指数前为e，<code>E</code>表示指数前为E)</td>
</tr>
<tr>
<td><code>g(G)</code></td>
<td>double</td>
<td><code>-4 &gt;= 指数部分 &lt; 精度值</code>则相当于<code>e</code>（对应<code>g</code>）或者<code>E</code>（对应<code>G</code>）；否则相当于<code>f</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>unsigned int</td>
<td>无符号整数</td>
</tr>
<tr>
<td><code>s</code></td>
<td>指向字符串的指针</td>
<td>按照<code>void *</code>型显示，达到精度值（如果存在）或空字符(<code>\0</code>)时停止写操作</td>
</tr>
<tr>
<td><code>p</code></td>
<td>*</td>
<td>转化为可显示格式的<code>void *</code>型值</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>int *</code>(指向int型数的指针)</td>
<td><code>...printf类函数</code>返回值（不会输出到屏幕，而是存储到所指向的int型数中）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>无对应参数</td>
<td>字符串”%”</td>
</tr>
</tbody>
</table>
<h3 id="22-3-3-…printf类函数的转换说明示例"><a href="#22-3-3-…printf类函数的转换说明示例" class="headerlink" title="22.3.3    …printf类函数的转换说明示例"></a>22.3.3    …printf类函数的转换说明示例</h3><h4 id="标志➊"><a href="#标志➊" class="headerlink" title="标志➊"></a>标志➊</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.07.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.22.png" alt="Alt text"></p>
<h4 id="最小字段宽度➋-精度➌"><a href="#最小字段宽度➋-精度➌" class="headerlink" title="最小字段宽度➋ + 精度➌"></a>最小字段宽度➋ + 精度➌</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.29.png" alt="Alt text"></p>
<h4 id="转换说明➎"><a href="#转换说明➎" class="headerlink" title="转换说明➎"></a>转换说明➎</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.08.42.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8811.04.45.png" alt="Alt text"></p>
<h4 id="最小字符宽度❷和精度❸中"><a href="#最小字符宽度❷和精度❸中" class="headerlink" title="最小字符宽度❷和精度❸中*"></a>最小字符宽度❷和精度❸中*</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小字符宽度❷和精度❸中*的用法示例</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.4d"</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.4d"</span>, <span class="number">6</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6.*d"</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, <span class="number">6</span>, <span class="number">4</span>, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, WIDTH, I, i); <span class="comment">// ..1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*d"</span>, page_width/num_cols, I, i); <span class="comment">// ..1234</span></span><br></pre></td></tr></table></figure>
<h4 id="转换说明p和n"><a href="#转换说明p和n" class="headerlink" title="转换说明p和n"></a>转换说明<code>p</code>和<code>n</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (void *)ptr); <span class="comment">// 显示指针ptr的值（可能会以8进制或16进制形式显示）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%n"</span>, <span class="number">123</span>, &amp;len); <span class="comment">// 将printf函数显示的字符数存储到len</span></span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-…scanf类函数"><a href="#22-3-4-…scanf类函数" class="headerlink" title="22.3.4    …scanf类函数"></a>22.3.4    …scanf类函数</h3><h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><blockquote>
<p><strong>说明：</strong>从<code>stdin</code>（键盘）读入内容，根据格式串中的转换说明进行转换并存储在指针指定的位置上。<br><strong>原型：</strong><code>stdio.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span><br><span class="line">&gt;* @param &#123;char *&#125; format 格式串</span><br><span class="line">&gt;* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">&gt;* return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> chat *format, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取一串整数，在首个"?"处停止</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;I) == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fscanf函数"><a href="#fscanf函数" class="headerlink" title="fscanf函数"></a>fscanf函数</h4><blockquote>
<p><strong>说明：</strong><code>scanf函数</code>从<code>stdin</code>读入数据，而<code>fscanf函数</code>则从它自己的第一个实参所指定的流中妇孺内容。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 指定的流</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="22-3-5-…scanf类函数的格式化字符串"><a href="#22-3-5-…scanf类函数的格式化字符串" class="headerlink" title="22.3.5    …scanf类函数的格式化字符串"></a>22.3.5    …scanf类函数的格式化字符串</h3><table>
<thead>
<tr>
<th>比较</th>
<th><code>...printf类函数</code></th>
<th><code>...scanf类函数</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>格式串的作用</td>
<td>转换数据形式并拼接</td>
<td>模式匹配和数据类型转换</td>
</tr>
<tr>
<td>数据源</td>
<td>指定的实参（不定参数部分）的值</td>
<td><code>stdin</code>（键盘输入）</td>
</tr>
<tr>
<td>数据源类型</td>
<td>多种类型</td>
<td>字符</td>
</tr>
</tbody>
</table>
<h4 id="格式串"><a href="#格式串" class="headerlink" title="格式串"></a>格式串</h4><blockquote>
<p><strong>例子：</strong><code>ISBN %d-%d-%ld-%d</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>ISBN</th>
<th>空格</th>
<th>%d</th>
<th>-</th>
<th>%d</th>
<th>-</th>
<th>%ld</th>
<th>-</th>
<th>%d</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISBN</td>
<td>空白字符（0或多个）</td>
<td>一个整数</td>
<td>-</td>
<td>一个整数</td>
<td>-</td>
<td>一个长整数</td>
<td>-</td>
<td>一个整数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
<td></td>
<td>允许整数前存在空白字符</td>
</tr>
</tbody>
</table>
<h5 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h5><blockquote>
<p><strong>说明：</strong>类似<code>...printf函数</code>格式串中中的转换说明。<br><strong>特点：</strong></p>
<ul>
<li>大多数转换说明会在输入项的开始出跳过空白字符（<code>%[、%c、%n</code>除外）</li>
<li>转换说明从来不回跳过尾部的空白字符（遇到换行符时，不会读区之并停止匹配返回）</li>
</ul>
</blockquote>
<h5 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h5><blockquote>
<p><strong>说明：</strong>格式串中的一个（或多个）空白字符匹配0个或多个输入流中的空白字符。</p>
</blockquote>
<h5 id="非空白字符"><a href="#非空白字符" class="headerlink" title="非空白字符"></a>非空白字符</h5><blockquote>
<p><strong>说明：</strong>非空白字符和输入流中相同字符进行匹配（<code>%</code>除外）</p>
</blockquote>
<h3 id="22-3-6-…scanf类函数的转换说明"><a href="#22-3-6-…scanf类函数的转换说明" class="headerlink" title="22.3.6    …scanf类函数的转换说明"></a>22.3.6    …scanf类函数的转换说明</h3><h4 id="转换说明：-12Ld"><a href="#转换说明：-12Ld" class="headerlink" title="转换说明：%*12Ld"></a><strong>转换说明：</strong><code>%*12Ld</code></h4><table>
<thead>
<tr>
<th>%</th>
<th>＊</th>
<th>12</th>
<th>L</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换说明提示符</td>
<td>➊赋值屏蔽</td>
<td>➋最小字段宽度</td>
<td>➌长度修饰符</td>
<td>❹转换说明符</td>
</tr>
<tr>
<td>必需</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>必需</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❶赋值屏蔽（assignment suppression）：</strong>使用符号<code>*</code>，匹配空白符之外的连续字符，直到遇到空白符为止。</p>
<ul>
<li>匹配的数据项会被读入，但不会被赋值给变量</li>
<li>用*匹配到的数据相不回包含在<code>...scanf类函数</code>返回的计数中</li>
</ul>
<p><strong>❷最大字段宽度：</strong>限制转换说明匹配的输入项的字符数量（不计算跳过的空白符），达到限制的字符数量后便停止当前输入项的转换。<br><strong>❸长度修饰符：</strong>共3个，只能和一些转换说明符搭配，同时长度修饰符的选择取决于要存储为相匹配实参所指向的变量类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>转换说明</th>
<th>对应实参（指针）的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>short int</td>
</tr>
<tr>
<td><code>l(L)</code></td>
<td>整数（<code>d、i、o、u、x(X)、n</code>）</td>
<td>long int</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>double</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>e(E)、f、g(G)</code></td>
<td>long double</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>❹转换说明符：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>对应实参指针应当指向类型</th>
<th>匹配的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数</td>
<td>十进制整数</td>
</tr>
<tr>
<td>i</td>
<td>整数</td>
<td>自动判断进制（0打头：8进制；0x(X)打头：16进制；否则十进制）</td>
</tr>
<tr>
<td>o</td>
<td>unsigned int</td>
<td>八进制整数</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>十进制整数</td>
</tr>
<tr>
<td>x(X)</td>
<td>unsigned int</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>float</td>
<td>float型小数</td>
</tr>
<tr>
<td>s</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>一系列非空白字符</td>
</tr>
<tr>
<td>[</td>
<td>char *(自动在末尾添加<code>\0</code>)</td>
<td>来自<code>扫描集合</code>的非空字符序列。<code>扫描集合</code>可以包含任何字符集，特别的是如果<code>扫描集合</code>中包含<code>]</code>，则要放在首位，例如<code>[]abc]</code>（<code>[abc]</code>：表示匹配只含有字母<code>a、b、c</code>的字符序列；<code>[^abc]</code>：表示匹配<code>a、b、c</code>都不存在的字符序列）</td>
</tr>
<tr>
<td>c</td>
<td>char *(指定<code>❷最大字段宽度</code>n，则在末尾添加<code>\0</code>，否则不添加)</td>
<td>指定<code>❷最大字段宽度</code>n，则匹配n个字符，否则旧就匹配一个字符</td>
</tr>
<tr>
<td>p</td>
<td>void *</td>
<td><code>...printf类函数</code>可以打印出的指针值（地址）</td>
</tr>
<tr>
<td>n</td>
<td>int(不指定<code>❸长度修饰符</code>)、short int(<code>❸长度修饰符</code>为<code>h</code>)、long int(<code>❸长度修饰符</code>为<code>l</code>)</td>
<td>不匹配任何字符，因而也不回影响<code>...scanf类函数</code>的放回值（对应的变量存储的是到目前为止已经读入的字符数）</td>
</tr>
<tr>
<td>%</td>
<td>char</td>
<td>匹配字符%</td>
</tr>
</tbody>
</table>
<h4 id="strtol函数-26-2-1"><a href="#strtol函数-26-2-1" class="headerlink" title="strtol函数(26.2.1)"></a>strtol函数(<a href="">26.2.1</a>)</h4><blockquote>
<p><strong>说明：</strong>将字符串根据参数base来转换成长整型数<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; nptr 要转换的字符串</span><br><span class="line">* @param &#123;int&#125; base 基数（0或2~36）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr,<span class="keyword">char</span> **endptr,<span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>和<code>...scanf类函数</code>转换说明符之间的对应关系</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>strol的参数base的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>10</td>
</tr>
<tr>
<td>i</td>
<td>0</td>
</tr>
<tr>
<td>o</td>
<td>8</td>
</tr>
<tr>
<td>u</td>
<td>10</td>
</tr>
<tr>
<td>x(X)</td>
<td>16</td>
</tr>
<tr>
<td>e(E)、f、g(G)</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="22-3-7-…scanf函数的示例"><a href="#22-3-7-…scanf函数的示例" class="headerlink" title="22.3.7    …scanf函数的示例"></a>22.3.7    …scanf函数的示例</h3><h4 id="转换说明、空白字符、非空白字符组合效果"><a href="#转换说明、空白字符、非空白字符组合效果" class="headerlink" title="转换说明、空白字符、非空白字符组合效果"></a>转换说明、空白字符、非空白字符组合效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.10.png" alt="Alt text"></p>
<h4 id="赋值屏蔽和指定字段宽度效果"><a href="#赋值屏蔽和指定字段宽度效果" class="headerlink" title="赋值屏蔽和指定字段宽度效果"></a>赋值屏蔽和指定字段宽度效果</h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.25.png" alt="Alt text"></p>
<h4 id="难懂的转换说明：i、-、n"><a href="#难懂的转换说明：i、-、n" class="headerlink" title="难懂的转换说明：i、[、n"></a>难懂的转换说明：<code>i、[、n</code></h4><p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8B%E5%8D%888.07.38.png" alt="Alt text"></p>
<h3 id="22-3-8-检测文件末尾和错误条件"><a href="#22-3-8-检测文件末尾和错误条件" class="headerlink" title="22.3.8    检测文件末尾和错误条件"></a>22.3.8    检测文件末尾和错误条件</h3><blockquote>
<p><strong>错误指示器（error indicator）：</strong>打开流时被清除，遇到错误时会被设置。<br><strong>文件末尾指示器（end of file indicator）：</strong>打开流时被清除，遇到文件末尾时被设置。<br><strong><code>...scanf类函数</code>出错分类：</strong>当<code>...scanf类函数</code>的返回值小于不定参数（要匹配）的数量时，由3中可能</p>
<ol>
<li><strong>提前遇到文件末尾：</strong>函数在完全匹配格式串之前遇到了文件末尾</li>
<li><strong>匹配失败：</strong>数据相的格式错误（比如函数在搜索整数的第一个数字期间遇到了一个字母）</li>
<li><strong>错误：</strong>错误的发生超出了函数控制的范围</li>
</ol>
</blockquote>
<h4 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h4><blockquote>
<p><strong>说明：</strong>清除文件末尾指示器和错误指示器<br><strong>注意：</strong><code>Q&amp;A</code>某些其他库函数因为副作用可以清除某种指示器或两种都可以清除，所以不回需要经常使用该函数。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>末尾指示器</code>，判断是否已经到达输入流（文件或<code>stdin</code>）末尾。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入文件的末尾</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ferror函数"><a href="#ferror函数" class="headerlink" title="ferror函数"></a>ferror函数</h4><blockquote>
<p><strong>说明：</strong>检测<code>错误指示器</code>，判断输入过程是否发生错误<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; 如果返回非零值，说明已经到达了输入过程发生错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 搜索文件中以某个整数起始的行并返回行号</span><br><span class="line">* </span><br><span class="line">* @param &#123;char *&#125; filename 文件名</span><br><span class="line">* @param &#123;int *&#125; ptr 指向要将找到的整数存储到变量的指针</span><br><span class="line">* @return &#123;int&#125; 以整数起始的行的行号</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	<span class="function">FILE *fp <span class="title">fopen</span> <span class="params">(filename, <span class="string">"r"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, ptr) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果是输入错误</span></span><br><span class="line">		<span class="keyword">if</span> (ferror (fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是到达文件末尾</span></span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">			return <span class="number">-3</span>; <span class="comment">// 整数没找到</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">"%*[^\n]"</span>); <span class="comment">// 跳过一行的其余部分</span></span><br><span class="line">		line++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">n = find_int(<span class="string">"foo"</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<h2 id="22-4-字符的输入／输出"><a href="#22-4-字符的输入／输出" class="headerlink" title="22.4    字符的输入／输出"></a>22.4    字符的输入／输出</h2><blockquote>
<p><strong>说明：</strong>本节的所有函数用于文本流和二进制流是等效的。</p>
</blockquote>
<h3 id="22-4-1-输出函数"><a href="#22-4-1-输出函数" class="headerlink" title="22.4.1    输出函数"></a>22.4.1    输出函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...scanf类函数</code>一样，<code>fputc、putc、putchar</code>出现错误都会为流设置<code>错误指示器</code>并返回<code>EOF</code>。</p>
</blockquote>
<h4 id="fputc函数"><a href="#fputc函数" class="headerlink" title="fputc函数"></a>fputc函数</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符（<code>putc</code>和<code>putchar</code>更通用的版本）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE * stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putc宏"><a href="#putc宏" class="headerlink" title="putc宏"></a>putc宏</h4><blockquote>
<p><strong>说明：</strong>向任意流写字符(宏实现)<br><strong>优点和缺点：</strong><a href="">14.3</a><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @ return &#123;int&#125; c转换为unsigned int的值：输出正确；EOF（负整数）：输出错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="putchar宏"><a href="#putchar宏" class="headerlink" title="putchar宏"></a>putchar宏</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>（屏幕）写一个字符，通常作为宏来实现（底层是<code>fputc</code>，因此性能不如<code>putc</code>）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> putchat(c) putc((c), stdout);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; c 函数会把char作为int型的值来处理</span><br><span class="line">* @return &#123;int&#125; </span><br><span class="line">int putchar(int c);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-2-输入函数"><a href="#22-4-2-输入函数" class="headerlink" title="22.4.2    输入函数"></a>22.4.2    输入函数</h3><blockquote>
<p><strong>注意：</strong><code>Q&amp;A</code>把char型变量与<code>EOF</code>比较可能会产生错误的结果。</p>
</blockquote>
<h4 id="getc宏"><a href="#getc宏" class="headerlink" title="getc宏"></a>getc宏</h4><blockquote>
<p><strong>说明：</strong>从指定流中读入一个字符（宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读入字符直到遇到文件末尾</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fgetc函数"><a href="#fgetc函数" class="headerlink" title="fgetc函数"></a>fgetc函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读如一个字符。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 读如的字符的int型值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = fgetc(fp); <span class="comment">// 从fp中读取一个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="getchar（宏）"><a href="#getchar（宏）" class="headerlink" title="getchar（宏）"></a>getchar（宏）</h4><blockquote>
<p><strong>说明：</strong>从标准输出流<code>stdout</code>（键盘）中获得一个字符（通常是用宏实现）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar getc(stdin);</span></span><br></pre></td></tr></table></figure>
<h3 id="22-4-3-程序：复制文件"><a href="#22-4-3-程序：复制文件" class="headerlink" title="22.4.3    程序：复制文件"></a>22.4.3    程序：复制文件</h3><blockquote>
<p><strong>说明：</strong>采用”rb”和”wb”作为文件的模式使<code>fcopy</code>程序既可以复制文本文件也可以复制二进制文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Copy a file(既可以是文本文件，也可以是二进制文件)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	FILE *source_fp, *dest_fp;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有给出正确的参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: fcopy source dest\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开原始文件</span></span><br><span class="line">	<span class="keyword">if</span> ((source_fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开目标文件</span></span><br><span class="line">	<span class="keyword">if</span> ((dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">"wb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open %s\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">		fclose(source_fp);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制内容(一个字符一个字符地)</span></span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(source_fp)) != EOF) &#123;</span><br><span class="line">		putc(ch, dest_fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(source_fp);</span><br><span class="line">	fclose(dest_fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./fcopy source.dat dest.dat</span><br></pre></td></tr></table></figure>
<h2 id="22-5-行的输入／输出"><a href="#22-5-行的输入／输出" class="headerlink" title="22.5    行的输入／输出"></a>22.5    行的输入／输出</h2><blockquote>
<p><strong>说明：</strong>读和写行的苦函数（虽然也可以有效地用于二进制文件流，但多数用于文本流）。</p>
</blockquote>
<h3 id="22-5-1-输出函数"><a href="#22-5-1-输出函数" class="headerlink" title="22.5.1    输出函数"></a>22.5.1    输出函数</h3><h4 id="puts函数-13-3"><a href="#puts函数-13-3" class="headerlink" title="puts函数(13.3)"></a>puts函数(<a href="">13.3</a>)</h4><blockquote>
<p><strong>说明：</strong>向标准输出流<code>stdout</code>写入一串字符（总会在后面添加一个换行符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @return &#123;char *&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">puts</span><span class="params">(chat *s)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Hi, there!"</span>); <span class="comment">// 向stdout(屏幕)输出"Hi, there!"</span></span><br></pre></td></tr></table></figure>
<h4 id="fputs函数"><a href="#fputs函数" class="headerlink" title="fputs函数"></a>fputs函数</h4><blockquote>
<p><strong>说明：</strong>向指定的流输出一串字符（不会在后面自动添加换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 要输出的字符串（首地址）</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @return &#123;int&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fput</span><span class="params">(chat *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">"Hi, there!"</span>, fp); <span class="comment">// 向fp输出"Hi. there!"</span></span><br></pre></td></tr></table></figure>
<h3 id="22-5-2-输入函数"><a href="#22-5-2-输入函数" class="headerlink" title="22.5.2    输入函数"></a>22.5.2    输入函数</h3><blockquote>
<p><strong>返回值：</strong>无论<code>gets</code>还是<code>fgets</code>，如果出现了错误，活着使在存储人和字符之前大道了输入流的末尾，都会返回空指针<code>NULL</code>;否则，返回指向读入字符串的指针。<br><strong>末尾空字符：</strong>两个函数都会在字符串的末尾存储空字符。<br><strong>技巧：</strong>大多数情况下用<code>fgets</code>而不是<code>gets</code>（只有在确保读入的字符正好适合数组大小时才使用），因为后者会超出接收数组范围的可能</p>
</blockquote>
<h4 id="gets函数（13-3）"><a href="#gets函数（13-3）" class="headerlink" title="gets函数（13.3）"></a>gets函数（<a href="">13.3</a>）</h4><blockquote>
<p><strong>说明：</strong>从标准输入流<code>stdin</code>中读取一串字符（逐个读取字符，并且把它们存储在字符串中，直到读取到换行符为止，因此不存储换行符）<br><strong>注意：</strong>只有在确保读入的字符正好适合数组大小时才使用，因为会有超出接收数组范围的可能。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 存储位置（首地址）</span><br><span class="line">* @return &#123;char *&#125; 非负的数：成功输出；`EOF`：出现错误</span><br><span class="line">*/</span></span><br><span class="line"><span class="function">chat *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h4><blockquote>
<p><strong>说明：</strong>从指定的流中读取一串字符（有时会存储换行符）<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;char *&#125; s  存储位置（首地址）</span><br><span class="line">* @param &#123;int&#125; n 限制读取字符的数量(保证不回超过s的存储能力)</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件字符（要读取的目标流）</span><br><span class="line">* @return &#123;char *&#125; 读取到的字符串</span><br><span class="line">*/</span><br><span class="line">char *fget(char *s, int n, FILE *stream));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>可以从任意流中读取信息</li>
<li>比<code>gets</code>更加安全，因为可以限制要存储的字符的数量</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个读入字符，在遇到首个换行符时或已经读入sizeof(str)-1个字符时结束操作</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-6-块的输入／输出"><a href="#22-6-块的输入／输出" class="headerlink" title="22.6    块的输入／输出"></a>22.6    块的输入／输出</h2><blockquote>
<p><strong>说明：</strong><code>fread</code>和<code>fwrite</code>允许程序在一次读和写大的数据块（任意数据类型）。<br><strong>用途：</strong>当程序在终止之前使用<code>fwrite函数</code>把数据存储到文件中，稍后，程序可以把数据从文件读入到内存。<br><strong>注意：</strong><code>Q&amp;A</code>小心使用<code>fread</code>函数和<code>fwrite</code>函数可以用于文本流，但它们主要还是用于二进制的流。</p>
</blockquote>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><blockquote>
<p><strong>说明：</strong>从流读入数据块。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 读入后数据块存储位置的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块的数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要读的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际读入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line">fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从fp指向的流位置读出数组并存储到数组a中</span></span><br><span class="line">n = fread(a, sizeof(a[<span class="number">0</span>], sizeof(a)/sizeof(a[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure>
<h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><blockquote>
<p><strong>说明：</strong>把内存中的数据块复制到流。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;void *&#125; ptr 存储数据块的地址</span><br><span class="line">* @param &#123;size_t&#125; size 数据块的大小（字节）</span><br><span class="line">* @param &#123;size_t&#125; nmemb 数据块数量</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（要写入的文件位置）</span><br><span class="line">* @return &#123;size_t&#125; 实际写入的数据块的数量，如果小于nmemb则说明达到了文件末尾或出现了错误（可用feof和ferror检测）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream );</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内存中数组a复制到fp指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(a, <span class="keyword">sizeof</span>(a[<span class="number">0</span>], sizeof(a)/sizof(a[<span class="number">0</span>]), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存中的结构体（实例）存储到指向的流（磁盘文件）中</span></span><br><span class="line">fwrite(&amp;s, sizeof(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>
<h2 id="22-7-文件的定位"><a href="#22-7-文件的定位" class="headerlink" title="22.7    文件的定位"></a>22.7    文件的定位</h2><blockquote>
<p><strong>说明：</strong><code>stdio.h</code>提供了5个函数允许程序确定当前的文件位置或者改变文件位置，通过这些函数可以实现文件的随机访问（任意访问）。<br><strong>注意：</strong>文件定为函数最适合二进制文件，处理文本流可能出现操作系统差异。<br><strong>文件位置（file position）：</strong>每个流都由文件位置，可以看作当前访问到的位置。在执行读或者写操作时，文件位置会自动推进。</p>
</blockquote>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><blockquote>
<p><strong>说明：</strong>改变指定流的文件位置，相关的宏有3个</p>
<ul>
<li>SEEK_SET：文件的起始处</li>
<li>SEEK_CUR：文件的当前位置</li>
<li>SEEK_END：文件的末尾处</li>
</ul>
<p><strong>注意：</strong>fseek函数对流是<code>文本型</code>还是<code>二进制型</code>非常敏感</p>
<ul>
<li><strong>文本型：</strong>参数必须是以下两种情景之一</li>
</ul>
<ol>
<li>offset必须为0（即只能移动到文件的起始处或末尾）</li>
<li>whence必须是<code>SEEK_SET</code>，且offset是通过<code>ftell函数</code>获取的（即返回前一次访问到的位置）</li>
</ol>
<ul>
<li><strong>二进制型：</strong>不要求支持whience是SEEK_END<br><strong>原型：</strong><code>stdio.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;long int&#125; offset 目标位置距离whence的距离，可以是负值</span><br><span class="line">* @param &#123;int&#125; whence 参照位置，值为SEEK_SET或SEEK_CUR或SEEK_END</span><br><span class="line">* @return &#123;int&#125; 0:成功；非0:产生错误（比如位置不存在）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置移动到文件起始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置移动到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置基于当前位置向后移动10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10</span>L, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><blockquote>
<p><strong>说明：</strong>以长整型返回当前文件位置<br><strong>注意：</strong><code>二进制文件</code>和<code>文本文件</code>的返回值情况有所不同</p>
<ul>
<li><strong>二进制文件：</strong>以字节计算返回当前位置</li>
<li><strong>文本文件：</strong>不一定按照字节计数</li>
</ul>
<p><strong>用途：</strong>可能会存储返回的值并且稍后将其提供给<code>fseek函数</code><br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @patam &#123;long int&#125; 当前文件位置：成功；－1L：发生错误（同时会把错误码存储到errno中）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> file_pos;</span><br><span class="line">...</span><br><span class="line">file_pos = ftell(fp); <span class="comment">// 获取当前文件位置</span></span><br><span class="line">...</span><br><span class="line">fseek(fp, file_pos, SEEK_SET); <span class="comment">// 返回到之前存储下的文件位置处</span></span><br></pre></td></tr></table></figure>
<h4 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h4><blockquote>
<p><strong>说明：</strong>把文件位置设置到文件起始处，几乎等价于<code>fseek(fp, 0L, SEEK_SET)</code>,差异是该函数没有返回值，但会为fp清除掉<code>错误指示器</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fgetpos函数"><a href="#fgetpos函数" class="headerlink" title="fgetpos函数"></a>fgetpos函数</h4><blockquote>
<p><strong>说明：</strong>将指定流的文件位置存储到fpos_t型变量中<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE * restrict&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t * restrict&#125; fpos_t型变量</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> stream, fpos_t * <span class="keyword">restrict</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsetpos函数"><a href="#fsetpos函数" class="headerlink" title="fsetpos函数"></a>fsetpos函数</h4><blockquote>
<p><strong>说明：</strong>为指定流设置文件fpos_t型位置<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针</span><br><span class="line">* @param &#123;fpos_t&#125; pos 文件位置</span><br><span class="line">* @return &#123;int&#125; 0：调用成功；非0：调用失败 （并将错误码存储到errno）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream,  <span class="keyword">const</span> fpos_t *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fpos_t</span> file_pos;</span><br><span class="line">...</span><br><span class="line">fgetpos(fp, &amp;file_pos); <span class="comment">// 获取当前文件位置并保存</span></span><br><span class="line">...</span><br><span class="line">fsetpos(fp, &amp;file_pos); <span class="comment">// 设置文件位置到之前保存的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="程序：修改零件记录文件"><a href="#程序：修改零件记录文件" class="headerlink" title="程序：修改零件记录文件"></a>程序：修改零件记录文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * modify a file of part records by setting the quantity</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NAME_LEN 25	</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"><span class="keyword">struct</span> part &#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_parts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开清单</span></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"invent.dat"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't open inventory file\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取零件(元素为结构体的数组)</span></span><br><span class="line">	num_parts = fread(inventory, sizeof(struct part), MAX_PARTS, fp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line">		inventory[i].on_hand = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动到文件开始处</span></span><br><span class="line">	rewind(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将修改后的清单数据存储到文件中</span></span><br><span class="line">	fwrite(inventory, <span class="keyword">sizeof</span>(struct part), num_parts, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-8-字符串的输入／输出"><a href="#22-8-字符串的输入／输出" class="headerlink" title="22.8    字符串的输入／输出"></a>22.8    字符串的输入／输出</h2><blockquote>
<p><strong>扩展：</strong>还有一个依赖<code>stdarg.h</code>定义<code>va_list</code>的<code>vsprintf函数</code>（<a href="">26.1.2</a>）</p>
</blockquote>
<h4 id="sprintf函数"><a href="#sprintf函数" class="headerlink" title="sprintf函数"></a>sprintf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>printf函数</code>和<code>fprintf函数</code>，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 对应格式串中的转换说明的参数</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d/%d/%d"</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">94</span>); <span class="comment">// str: 9/20/94</span></span><br></pre></td></tr></table></figure>
<h4 id="sscanf函数"><a href="#sscanf函数" class="headerlink" title="sscanf函数"></a>sscanf函数</h4><blockquote>
<p><strong>说明：</strong>类似<code>scanf函数</code>和<code>fscanf函数</code>，唯一的不同是该函数是从字符数组而不是流中读取数据。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;...*&#125; 匹配并转换后的内容对应的存储位置</span><br><span class="line">* @return &#123;int&#125; 读入并赋值给实参的数据项数量：成功；EOF：失败(找到第一个数据项之前到达)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用fgets函数来获取一行输入，然后把此行数据传递给scanf函数进一步处理</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d%d"</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串中读取日期</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str, <span class="string">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sscanf(str, <span class="string">"%d-%d-%d"</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month: %d, day: %d, year: %d\n"</span>, month, day, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/21 标准库/" itemprop="url">
                  21	标准库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:33:07+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/21 标准库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/21 标准库/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="21-1-标准库的使用"><a href="#21-1-标准库的使用" class="headerlink" title="21.1    标准库的使用"></a>21.1    标准库的使用</h2><blockquote>
<p><strong>标准头：</strong>依据C标准，一个“标准头”不需要一定是文件，有可能内置在编译器自身中。<br><strong>标准库：</strong>C语言的标准库总共划分成<code>15</code>个部分，每个部分用一个头描述。<br><strong>扩展：</strong>许多编译器会使用扩展后的库，这类库（头文件）通常提供一些针对特定畸形或特定操作系统的函数（比如更多对屏幕或键盘操作的函数，用于支持图形或窗口界面的头等）</p>
</blockquote>
<h3 id="21-1-1-包含标准头的程序中使用的名字的一些限制"><a href="#21-1-1-包含标准头的程序中使用的名字的一些限制" class="headerlink" title="21.1.1    包含标准头的程序中使用的名字的一些限制"></a>21.1.1    包含标准头的程序中使用的名字的一些限制</h3><blockquote>
<p><strong>意义：</strong>虽然这些规则并不总是强制性的，但不遵守这些规则可能会导致程序的可移植性下降。</p>
</blockquote>
<h4 id="必需遵守"><a href="#必需遵守" class="headerlink" title="必需遵守"></a>必需遵守</h4><ul>
<li><strong>宏的名字：</strong>不能再使用在头文件中定义过的宏的名字</li>
<li><strong>类型名（<code>typedef</code>）：</strong>具有文件作用域的库名（包括类型名）不可以在文件层次重新定义</li>
</ul>
<h4 id="建议遵守（避开保留字）"><a href="#建议遵守（避开保留字）" class="headerlink" title="建议遵守（避开保留字）"></a>建议遵守（避开保留字）</h4><ul>
<li>由<code>_大写字母</code>或<code>__</code>开头的标识符</li>
<li>由<code>_</code>开头的标识符（除非仅声明在函数内部）</li>
<li>标准库中所有具备外部链接的标识符，特别是所有标准库中的函数</li>
</ul>
<h3 id="21-1-2-使用宏隐藏函数"><a href="#21-1-2-使用宏隐藏函数" class="headerlink" title="21.1.2    使用宏隐藏函数"></a>21.1.2    使用宏隐藏函数</h3><blockquote>
<p><strong>说明：</strong>标准库中经常会为小的实际函数定义同名的宏函数，这是允许的，目的是提高程序的运行速度。<br><strong>取消隐藏：</strong>如果需要尽量缩小可执行代码的大小，或者需要一个指向这个库函数的指针，可以使用<code>undef</code>取消相应的红定义即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> isprint <span class="comment">// 即使isprint没定义过，也不会有负面影响</span></span></span><br></pre></td></tr></table></figure>
<p><strong>绕过宏调用：</strong>可以通过为函数名加圆括号来屏蔽个别宏调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(isptint)(); <span class="comment">// 预处理器无法分辨出带圆括号的宏，而编译器仍可认出isprint函数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-2-标准库概述"><a href="#21-2-标准库概述" class="headerlink" title="21.2    标准库概述"></a>21.2    标准库概述</h2><table>
<thead>
<tr>
<th>概述</th>
<th>标准头（15个）</th>
<th>提供的功能</th>
<th>相关章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>诊断</td>
<td>assert.h</td>
<td>仅包含<code>assert</code>宏，检查程序的状态，一旦任何检查失败，程序终止</td>
<td><a href="">24.1</a></td>
</tr>
<tr>
<td>字符处理</td>
<td>ctype.h</td>
<td>包括用于字符分类及大小写转换的函数</td>
<td><a href="">23.4</a></td>
</tr>
<tr>
<td>错误</td>
<td>errno.h</td>
<td>提供了<code>errno(&quot;errno number&quot;)</code>，errno是一个左值，可以在调用特定苦函数后进行监测，来判断调用过程中是否有错误发生</td>
<td><a href="">24.2</a></td>
</tr>
<tr>
<td>浮点型的特点</td>
<td>float.h</td>
<td>提供了用于描述浮点型特点的宏，包括值的范围及精度</td>
<td><a href="">23.1</a></td>
</tr>
<tr>
<td>整型的大小</td>
<td>limits.h</td>
<td>提供了用于描述整数类型和字符类型的宏，包括它们的最大值和最小值</td>
<td><a href="">23.2</a></td>
</tr>
<tr>
<td>本地化</td>
<td>locale.h</td>
<td>与本地化相关的行为，包括小数点的字符、货币的格式、字符集一集日期和时间的显示</td>
<td><a href="">25.1</a></td>
</tr>
<tr>
<td>数学计算</td>
<td>math.h</td>
<td>大量用于数据计算的函数，大部分使用double类型的实参，并返回一个double类型的值</td>
<td><a href="">23.3</a></td>
</tr>
<tr>
<td>非本地条转</td>
<td>setjmp.h</td>
<td>setjmp函数和longjmp函数<a href="**setjmp函数和long函数：**会“标记”程序中的一个位置，随后可以用`longjmp`返回被标记的位置，这些函数可以用来从一个函数跳转到另一个（仍然活动中的）函数中绕过正常的函数返回机制。`setjmp`函数和`longjmp`函数主要用来处理程序执行过程中的重大问题。">^21-2-7</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>信号处理</td>
<td>signal.h</td>
<td>用于异常情况（信号）处理的函数，包括终端和运行时错误<a href="**sinal函数：**可以设置一个函数，使系统会在给定信号发生后自动调用改函数；`raise函数`用来产生一个信号。">^21-2-8-signal</a></td>
<td><a href="">24.4</a></td>
</tr>
<tr>
<td>可变实际参数</td>
<td>stdarg.h</td>
<td>提供给函数可以处理不定个参数的的工具，就像<code>printf</code>和<code>scanf</code>函数</td>
<td><a href="">26.1</a></td>
</tr>
<tr>
<td>常用定义</td>
<td>stddef.h</td>
<td>提供了经常使用的类型和宏的定义</td>
<td><a href="">21.3</a></td>
</tr>
<tr>
<td>输入／输出</td>
<td>stdio.h</td>
<td>提供了大量用于输入／输出的函数，包括对顺序读写和随机读写文件的操作</td>
<td><a href="">22.1</a></td>
<td></td>
</tr>
<tr>
<td>常用实用程序</td>
<td>stdlib.h</td>
<td>包含了大量无法华贵其它头的函数[^stdlib]</td>
<td><a href="">26.2</a></td>
</tr>
<tr>
<td>字符串处理</td>
<td>string.h</td>
<td>提供了用于进行字符串操作的函数，包括肤质、拼接、比较以及搜索</td>
<td><a href="">23.5</a></td>
</tr>
<tr>
<td>日期与时间</td>
<td>time.h</td>
<td>提供相应的函数来获取日期和时间、操作时间和以多种方式显示时间等。</td>
<td><a href="">26.3</a></td>
</tr>
</tbody>
</table>
<h2 id="21-3-：常用定义"><a href="#21-3-：常用定义" class="headerlink" title="21.3    ：常用定义"></a>21.3    <stddef.h>：常用定义</stddef.h></h2><blockquote>
<p><strong>说明：</strong><code>stddef.h</code>提供了常用的类型和宏的定义，但没有声明任何函数。</p>
</blockquote>
<h3 id="21-3-1-定义的类型"><a href="#21-3-1-定义的类型" class="headerlink" title="21.3.1    定义的类型"></a>21.3.1    定义的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>原始类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptrdiff_t</td>
<td>当记性指针相减运算时，其结果的类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>size_t</td>
<td>运算符<code>sizeof</code>的返回值类型</td>
<td>整数类型</td>
</tr>
<tr>
<td>wchar_t</td>
<td>一种足够大的、可以用于表示所有支持的地区的所有字符的类型</td>
<td>整数类型</td>
</tr>
</tbody>
</table>
<h3 id="21-3-2-定义的宏"><a href="#21-3-2-定义的宏" class="headerlink" title="21.3.2    定义的宏"></a>21.3.2    定义的宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>空指针</td>
</tr>
<tr>
<td>offsetof</td>
<td>计算结构的起点到指定成员间的字节数</td>
</tr>
</tbody>
</table>
<h4 id="21-3-2-1-offsetof"><a href="#21-3-2-1-offsetof" class="headerlink" title="21.3.2.1    offsetof"></a>21.3.2.1    offsetof</h4><blockquote>
<p><strong>说明：</strong>计算结构成员的偏移量（距结构起点的距离）<br><strong>用途：</strong>对人和编译器都会返回正确的偏移量，使我们可以编写一致性更好的程序。<br><strong>结构体成员的偏移量：</strong>一些编译器会在结构中留下一些空洞（无效字节），从而影响到<code>offsetof</code>产生的值。</p>
</blockquote>
<p><code>@param {struct}</code> 结构类型本身（不是实例）<br><code>@param {*}</code> 结构的成员<br><code>@return {int}</code> 结构的起点到指定成员的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> s &#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetof(<span class="keyword">struct</span> s, a); <span class="comment">// 0，C语言确保结构的第一个成员的地址与结构自身地址相同</span></span><br><span class="line"></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, b); <span class="comment">// 1（或2）</span></span><br><span class="line">offsetof(<span class="keyword">struct</span> s, c); <span class="comment">// 5（或6）</span></span><br></pre></td></tr></table></figure>
<hr>
<p>[^stdlib]:  包含在<code>&lt;stdlib.h&gt;</code>中的函数可以将字符串转换成数、产生随机值、执行内存管理任务、域操作系统通信、执行搜索与排序以及对多字节字符及字符串进行操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/20 低级程序设计/" itemprop="url">
                  20 低级程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:05:58+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/20 低级程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/20 低级程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>位操作和其他一些低级运算在编写系统程序（包括编译器和操作系统）、加密程序、图形程序以及其他一些需要高执行速度或高效地使用空间的程序时非常有用。</p>
</blockquote>
<h2 id="20-1-按位运算符"><a href="#20-1-按位运算符" class="headerlink" title="20.1    按位运算符"></a>20.1    按位运算符</h2><blockquote>
<p><strong>说明：</strong>C语言一共提供了6个按位运算符。</p>
</blockquote>
<h3 id="20-1-1-移位运算符"><a href="#20-1-1-移位运算符" class="headerlink" title="20.1.1    移位运算符"></a>20.1.1    移位运算符</h3><blockquote>
<p><strong>说明：</strong>移位运算符可以改变数的二进制形式，将它的位向左或向右移动。<br><strong>优先级：</strong>低于算数运算符<code>i&lt;&lt;2+1 &lt;==&gt; i&lt;&lt;(2+1)</code><br><strong>操作数类型要求：</strong>可以是任意整型或字符型的<br><strong>副作用：</strong>不存在（不会改变操作数本身）<br>|运算符|名称|示例|返回值|复合移位运算符|<br>|-|-|-|-|-|<br>|<code>&lt;&lt;</code>|左位移|<code>i&lt;&lt;j</code>|<code>i</code>中的位左移<code>j</code>位的结果（左端溢出，右端补0）|<code>&lt;&lt;=</code>|<br>|<code>&gt;&gt;</code>|右位移|<code>i&gt;&gt;j</code>|<code>i</code>中的位右移<code>j</code>位的结果（右端溢出，左端补0或保存符号位而补1）|<code>&gt;&gt;=</code>|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">13</span>; <span class="comment">// 0000000000001101(16位)</span></span><br><span class="line">j = i &lt;&lt; <span class="number">2</span>; <span class="comment">// 0000000000110100(16位)</span></span><br><span class="line">j = i &gt;&gt; <span class="number">2</span>; <span class="comment">// 0000000000000011(16位)</span></span><br></pre></td></tr></table></figure>
<h3 id="20-1-2-按位求反、按位与、按位亦或、按位或"><a href="#20-1-2-按位求反、按位与、按位亦或、按位或" class="headerlink" title="20.1.2    按位求反、按位与、按位亦或、按位或"></a>20.1.2    按位求反、按位与、按位亦或、按位或</h3><blockquote>
<p><strong>优先级：</strong><code>~</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code>，都比<code>关系运算符</code>和<code>判等运算符</code>低。<br><strong>技巧：</strong>使用<code>~</code>创建在位一级具备可移植性的程序（例子）</p>
<ol>
<li>~0：所有位都为1的整数（否则就要最大的整数，但不同位的机器不同）</li>
<li>~0x001f：除了最后5位其它为都为1<br>|符号|名称|返回值|复合运算符|<br>|-|-|-|-|<br>|<code>~</code>|按位求反|将每一个0替换成1，每一个1替换成0|<code>~=</code>|<br>|<code>&amp;</code>|按位与|对两个操作数相应的位执行逻辑与运算|<code>&amp;=</code>|<br>|<code>^</code>|按位亦或|对两个操作数相应的位执行逻辑或操作，都是1时产生0|<code>^=</code>|<br>|<code>\</code>|按位或|对两个操作数相应的位执行逻辑或操作，都是1时产生1|<code>\=</code>|</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设unsigned int类型的值占16位</span></span><br><span class="line">i = <span class="number">21</span>; <span class="comment">//    0000000000010101</span></span><br><span class="line">j = <span class="number">56</span>; <span class="comment">//    0000000000111000</span></span><br><span class="line">k = ~i; <span class="comment">//    1111111111101010</span></span><br><span class="line">k = i &amp; j; <span class="comment">// 0000000000010000</span></span><br><span class="line">k = i ^ j; <span class="comment">// 0000000000101101</span></span><br><span class="line">k = i | j; <span class="comment">// 0000000000111101</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">21</span>;</span><br><span class="line">j = <span class="number">56</span>;</span><br><span class="line">i &amp;= j;</span><br><span class="line">i ^= j;</span><br><span class="line">i |= j;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-3-用按位运算符访问位"><a href="#20-1-3-用按位运算符访问位" class="headerlink" title="20.1.3    用按位运算符访问位"></a>20.1.3    用按位运算符访问位</h3><blockquote>
<p><strong>说明：</strong>通过按位运算，可以提取或修改存储在少数几个位中的数据。<br><strong>用途：</strong>比如，在编写图形程序时，可能会需要讲两个或更多的像素挤在一个字节中，从而降低空间复杂度和时间复杂度。<br><strong>方式：</strong>构造“掩码”，通过按位复合运算修改位</p>
<h4 id="设置位（为1）"><a href="#设置位（为1）" class="headerlink" title="设置位（为1）"></a>设置位（为1）</h4><p><strong>说明：</strong> 通过与“掩码”进行<code>按位或运算</code>设置某一位为1<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>0000000000001000</code>）。<br><strong>相关按位运算：</strong><code>按位或运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x0000</span>;</span><br><span class="line"><span class="comment">// 将第4位设置为1</span></span><br><span class="line"><span class="comment">// 0000000000000000 (i)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000000001000 (按位或运算结果)</span></span><br><span class="line">i |= <span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算灵活构造掩码</span></span><br><span class="line">i |= <span class="number">1</span> &lt;&lt; j; <span class="comment">// 使用移位运算构造掩码</span></span><br></pre></td></tr></table></figure>
<h4 id="将位清零"><a href="#将位清零" class="headerlink" title="将位清零"></a>将位清零</h4><blockquote>
<p><strong>说明：</strong>通过与“掩码”进行<code>按位且运算</code>设置某一位为0<br><strong>掩码：</strong>除要清零的位外都为1的掩码（可以通过<code>移位运算</code>和<code>按位非运算</code>）构造（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x00ff</span>;  <span class="comment">// 0000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000000011111111（i）</span></span><br><span class="line"><span class="comment">// 1111111111110111 (掩码)</span></span><br><span class="line"><span class="comment">// 0000000011110111 (按位且运算结果)</span></span><br><span class="line">i &amp;= ~<span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更通用的方式,通过移位运算和按位非灵活构造掩码</span></span><br><span class="line">i &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br></pre></td></tr></table></figure>
<h4 id="检测位"><a href="#检测位" class="headerlink" title="检测位"></a>检测位</h4><blockquote>
<p><strong>说明：</strong>检测某一位是否被设置过（设置为1）。<br><strong>掩码：</strong>除要设置的位外都为0（可以通过对整数1进行移位运算构造掩码）（<code>1111111111110111</code>）。<br><strong>相关按位运算：</strong><code>按位且运算</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置需要的掩码(假设在16位机器上)</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BLUE = <span class="number">1</span>, <span class="comment">// 0000000000000001</span></span><br><span class="line">	GREN = <span class="number">2</span>, <span class="comment">// 0000000000000010</span></span><br><span class="line">	RED = <span class="number">4</span>   <span class="comment">// 0000000000000100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i |= BULE; <span class="comment">// 设置BLUE bit(最后一位为1)</span></span><br><span class="line">i &amp;= ~BLUE; <span class="comment">// 抹掉BLUE bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测BLUE bit是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; BULUE) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测BLUE bit和GREEN bit是否都被设置了</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (BLUE | GREEN)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-4-用按位运算符访问位域"><a href="#20-1-4-用按位运算符访问位域" class="headerlink" title="20.1.4    用按位运算符访问位域"></a>20.1.4    用按位运算符访问位域</h3><blockquote>
<p><strong>位域：</strong>连续的几个位<br><strong>位域下标记法：</strong>最右边是最低位，记为0位</p>
<h4 id="修改位域"><a href="#修改位域" class="headerlink" title="修改位域"></a>修改位域</h4><p><strong>说明：</strong>不同于修改位，修改位域并不单纯的只是设置位或清除位，目标值中1和0可以并存，因此多了清除先清除位域的操作。<br><strong>相关按位运算：</strong><code>按位与</code>（用来清除位域）；<code>按位或</code>（用来将新的位存入域）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将二进制的值101存入变量i的第4-6位*/</span></span><br><span class="line"><span class="comment">// 0000000000000000，i的值可以使任意的16位整数</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将i的4-6位清零，然后用构造的掩码设置4-6位</span></span><br><span class="line"><span class="comment">// 0000000001110000 (0x0070)</span></span><br><span class="line"><span class="comment">// 1111111110001111 (~0x0070，掩码)</span></span><br><span class="line"><span class="comment">// 0000000001010000 (0x0050，4-6位上为要存储的二进制)</span></span><br><span class="line">i = i &amp; ~<span class="number">0x0070</span> | <span class="number">0x0050</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让上名的例子更加通用*/</span></span><br><span class="line"><span class="comment">// 0000000000000101, 包含需要存储的值</span></span><br><span class="line">j = <span class="number">5</span>;</span><br><span class="line">i = (i &amp; ~<span class="number">0x0070</span>) | (j &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取位域"><a href="#获取位域" class="headerlink" title="获取位域"></a>获取位域</h4><blockquote>
<p><strong>说明：</strong>获得指定位域上的值。<br><strong>相关按位运算：</strong><code>按位与</code><br><strong>技巧：</strong>当位域处在数的末尾区间时，获取值更加方便。如果要获取的位域不在末尾，可以先通过位移移至末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0000000000000111 (0x0007)</span></span><br><span class="line">j = i &amp; <span class="number">0x0007</span>; <span class="comment">// 获取0-2位上的位并放在j的末端</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = (i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0007</span>;</span><br></pre></td></tr></table></figure>
<h3 id="20-1-5-程序：XOR加密"><a href="#20-1-5-程序：XOR加密" class="headerlink" title="20.1.5    程序：XOR加密"></a>20.1.5    程序：XOR加密</h3><blockquote>
<p><strong>说明：</strong>将每一个字符与一个密匙进行亦或（XOR）运算；要将信息解码，只需要再次加密，即可得到原来的字符。<br><strong>注意：</strong>读或写包含控制字符的文件时会在一些操作系统中引发错误，应当避免。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------加密---------------</span><br><span class="line">		<span class="number">01111010</span> (z， 加密前)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 密匙)</span><br><span class="line">		<span class="number">01011100</span> (\, 加密后)</span><br><span class="line">-------------解密---------------</span><br><span class="line">		<span class="number">01011100</span> (\, 解密)</span><br><span class="line">^(XOR)  <span class="number">00100110</span> (&amp;, 同样的密匙)</span><br><span class="line">		<span class="number">01111010</span> (z, 解密后)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 以文件作为输入，使用XOR加密(或解密)。并将加密(或解密)后的文本输出</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> KEY <span class="string">'&amp;'</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> orig_char, new_char;</span><br><span class="line">	<span class="comment">// 遍历输入流中的每一个字符，加密后输出，直到文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> ((orig_char = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="comment">// 加密</span></span><br><span class="line">		new_char = orig_char ^ KEY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果加密（或解密）后的字符是控制字符则不加密（或解密）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">iscntrl</span>(orig_char) || <span class="built_in">iscntrl</span>(new_char)) &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(orig_char);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(new_char);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./xor &lt; msg.txt</span><br></pre></td></tr></table></figure>
<h2 id="20-2-结构中的位域"><a href="#20-2-结构中的位域" class="headerlink" title="20.2    结构中的位域"></a>20.2    结构中的位域</h2><blockquote>
<p><strong>说明：</strong>C语言提供了可以在结构中声明存储在位域中的成员。<br><strong>语法：</strong>位域的类型必需是<code>int</code>、<code>unsigned int</code>或<code>signed int</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构名 &#123;</span><br><span class="line">	&#123;<span class="keyword">int</span>|<span class="keyword">unsigned</span> <span class="keyword">int</span>|<span class="keyword">signed</span> <span class="keyword">int</span>&#125; [成员名]: 位数;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>使用<code>按位运算</code>可以达到同样的效果，而且可能更快些，当可读性不如<code>结构中的位域</code>。<br><strong>局限性：</strong>通常位域没有地址，因此C语言不允许将<code>&amp;运算符</code>或<code>scanf函数</code>用于位域。<br><strong>可移植性技巧：</strong>将所有的位域声明为<code>unsigned int</code>或<code>signed int</code>而不是<code>int</code>，因为一些编译器将位域的最高位作为符号位，而其它一些编译器则不会。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="位域是如何存储的"><a href="#位域是如何存储的" class="headerlink" title="位域是如何存储的"></a>位域是如何存储的</h3><blockquote>
<p><strong>存储单元：</strong>一个存储单元的大小是由实现定义的，通常是8位、16位或32位。<br><strong>未命名为域：</strong>将无法被赋值和使用，但正常占据空间。经常用来作为成员间的填充，以保证其它位域存储在适当的位置。<br><strong>长度为0的位域：</strong>告诉编译器将下一个位域放在一个存储单元的起始位置，即如果当前存储单元还有空间剩余，无论能否放下长度为0的成员的后面的成员，都会将其放在下一个存储单元中。</p>
</blockquote>
<ul>
<li><strong>存储顺序：</strong>当编译器处理结构实例时，会将位域逐个存入存储单元（从左向右或从右向左）</li>
<li><strong>位域型成员之间的间隙：</strong>位域之间没有间隙，直到剩下的空间不够放下一个位域（这时会跳到下一个存储单元继续存放，即<code>存在间隙</code>或跨存储单元存放，即<code>没有间隙</code>）。</li>
</ul>
<p><strong>案例</strong></p>
<blockquote>
<p><strong>说明：</strong>假设位域是<code>从右至左</code>存储，且当一个存储单元剩余的空间无法存储下一个位域成员时会<code>跨存储单元存储</code>。这时DOS系统上编译常用的方式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构实例</span></span><br><span class="line"><span class="keyword">struct</span> file_date fd;</span><br><span class="line">fd.day = <span class="number">28</span>;</span><br><span class="line">fd.month = <span class="number">12</span>;</span><br><span class="line">fd.year = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>*</th>
<th>year</th>
<th>month</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>0001000</td>
<td>1100</td>
<td>11100</td>
</tr>
<tr>
<td>大小（bit）</td>
<td>7</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>区间</td>
<td>15-9</td>
<td>8-5</td>
<td>4-0</td>
</tr>
</tbody>
</table>
<h2 id="20-3-其他低级技术"><a href="#20-3-其他低级技术" class="headerlink" title="20.3    其他低级技术"></a>20.3    其他低级技术</h2><h3 id="20-3-1-定义依赖机器的类型"><a href="#20-3-1-定义依赖机器的类型" class="headerlink" title="20.3.1    定义依赖机器的类型"></a>20.3.1    定义依赖机器的类型</h3><blockquote>
<p><strong>说明：</strong>可以将<code>char</code>作为一个字节（不一定存储字符）来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-2-用联合从多个视角看待数据"><a href="#20-3-2-用联合从多个视角看待数据" class="headerlink" title="20.3.2    用联合从多个视角看待数据"></a>20.3.2    用联合从多个视角看待数据</h3><h4 id="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"><a href="#案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。" class="headerlink" title="案例一：使用联合结合结构体（位域成员）实现文件日期和整数的转换。"></a>案例一：使用<code>联合</code>结合<code>结构体（位域成员）</code>实现文件日期和整数的转换。</h4><blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>获取：可以通过成员<code>i</code>以两个字节的形式获得日期的整数形式</li>
<li>设置：可以通过成员<code>fd</code>以结构体的方式设置文件日期（以两个字节的方式存储）</li>
</ul>
</blockquote>
<p><em>文件日期定义</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 文件创建日期信息（成员为位域的结构）</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> file_date &#123;</span><br><span class="line">	<span class="comment">// 日：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 月：5个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mounth: <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 年：7个位</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> year: <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>封装一个方便读取和设置数据结构</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> int_date &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ;</span><br><span class="line">	<span class="keyword">struct</span> file_date fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>实践</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将整数形式（两个字节）的日期以作为文件日期数据结构打印</span><br><span class="line">* @param &#123;undesigned int&#125; n 存储这日期信息的整数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_date</span> <span class="params">(undesigned <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> int_date u;</span><br><span class="line">	u.i = n;</span><br><span class="line">	<span class="comment">// 年只显示后两位（比如1990年简称90年）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d/%d/%.2d\n"</span>, u.fd.month, u.fd.day, (u.fd.year + <span class="number">1980</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="案例二：模拟对寄存器的访问（Intel-80x86）"><a href="#案例二：模拟对寄存器的访问（Intel-80x86）" class="headerlink" title="案例二：模拟对寄存器的访问（Intel 80x86）"></a>案例二：模拟对寄存器的访问（Intel 80x86）</h4><blockquote>
<p><strong>说明：</strong>需要对16位寄存器和8位寄存器进行访问，同时保留它们之间的关系。<br><strong>寄存器：</strong>Intel 80x86处理器包涵4个16位的寄存器（<code>AX(AH|AL)</code>、<code>BX(BH|BL)</code>、<code>CX(CH|CL)</code>、<code>DX(DH|DL)</code>），其中每个16位寄存器都包含2个8位寄存器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> WORD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="comment">// 16位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		WORD ax, bx, cx. dx;</span><br><span class="line">	&#125; word;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 8位寄存器的结构</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		BYTE al, ah, bl, bh, cl, ch, dl, dh;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; regs;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照8位寄存器的方式修改</span></span><br><span class="line">regs.byte.ah = <span class="number">0x12</span>;</span><br><span class="line">regs.byte.al = <span class="number">0x34</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照16位寄存器的方式观察</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"AX: %x\n"</span>, regs.word.ax);</span><br></pre></td></tr></table></figure>
<h3 id="20-3-3-将指针作为地址使用（将地址转换为指针使用）"><a href="#20-3-3-将指针作为地址使用（将地址转换为指针使用）" class="headerlink" title="20.3.3    将指针作为地址使用（将地址转换为指针使用）"></a>20.3.3    将指针作为地址使用（将地址转换为指针使用）</h3><blockquote>
<p><strong>说明：</strong>指针按照其自身的构造方式可以分为两类（以16位机器为例）<br>|分类|组成|大小(bit)|地址转换为指针|情景|<br>|-|-|-|-|<br>|近指针|偏移量||16|将整数强制转换为指针|在一些计算机中|<br>|远指针|段地址＋偏移量|32|<code>far(关键字，非标准c)</code>+<code>MK_FP</code>(dos.h中的宏)|Intel CPU的实时模式（DOS使用的模式）|</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 近指针</span></span><br><span class="line">BYTE *p;</span><br><span class="line">p = (BYTE *) <span class="number">0x1000</span>; <span class="comment">// 将16位整数地址直接转换为指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远指针</span></span><br><span class="line">BYTE far *p; <span class="comment">// 使用far声明一个远指针</span></span><br><span class="line">p = MKFP(segment, offset); <span class="comment">// 段地址， 偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="20-3-4-程序：设置Num-Lock-键"><a href="#20-3-4-程序：设置Num-Lock-键" class="headerlink" title="20.3.4    程序：设置Num Lock 键"></a>20.3.4    程序：设置Num Lock 键</h3><blockquote>
<p><strong>说明：</strong>在<code>IBM PC</code>机极其兼容机上，<code>Num Lock</code>切换涌来确定数字键盘上的按键是作为数字键使用，还是作为移动光标的方向键。<br><strong>原理：</strong><code>Num Lock</code>的状态保存在地址位地址段为40（16进制）、偏移量为17（16进制）的字节中。该字节的第5位（最低位为0位）用来控制<code>Num Lock</code>的状态。</p>
</blockquote>
<p><strong>开启Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 开启num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0000000000100000 (掩码)</span></span><br><span class="line">	*p |= <span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭Num Lock</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭num lock</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	BYTE far *p = MK_FP(<span class="number">0x0040</span>, <span class="number">0x0017</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1111111111011111 (掩码)</span></span><br><span class="line">	*p &amp;= ～<span class="number">0x20</span>; </span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-3-5-volatile类型限定符"><a href="#20-3-5-volatile类型限定符" class="headerlink" title="20.3.5    volatile类型限定符"></a>20.3.5    volatile类型限定符</h3><blockquote>
<p><strong>关键字：</strong><code>volatile</code><br><strong>说明：</strong>通常使用在用于指向易变内存空间的指针的声明中。用来防止编译器优化过程中错误地将易变内容缓存在了寄存器中，而不再读取内存中易变内容。</p>
</blockquote>
<p><em>优化前的逻辑</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前的逻辑</span></span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入; <span class="comment">// 将输入存储到*p</span></span><br><span class="line">	buffer[i] = *p;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>优化后的逻辑</em></p>
<blockquote>
<p><strong>说明：</strong>注意到这个循环中既没有改变p，也没有改变<em>p，因此对程序进行优化，使</em>p只被读取一次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在寄存器中存储*p;</span><br><span class="line"><span class="keyword">while</span> (缓冲区未满) &#123;</span><br><span class="line">	等待输入;</span><br><span class="line">	buffer[i] = 存储在寄存器中的值;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i++] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/19 程序设计/" itemprop="url">
                  19 程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T22:00:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/19 程序设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/19 程序设计/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="19-1-模块"><a href="#19-1-模块" class="headerlink" title="19.1    模块"></a>19.1    模块</h2><blockquote>
<p><strong>说明：</strong><code>模块</code>是一组功能（服务）的集合，其中一些功能可以被程序的其它部分（<code>客户</code>）使用。每个模块都有一个<code>接口</code>来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的<code>实现</code>中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td><code>模块名.h</code>(头文件)</td>
</tr>
<tr>
<td>实现</td>
<td>对应头文件<code>模块名.c</code>文件</td>
</tr>
<tr>
<td>客户</td>
<td>通过<code>#include</code>引入模块的文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>优点：</strong>将程序分割成模块有一系列好处</p>
<ul>
<li>抽象：不必了解功能的实现细节，只需对模块的接口达成一致</li>
<li>可复用：每个模块都可以在另一个程序中复用</li>
<li>可维护性（最重要）：当程序出现错误或需要升级时，通常只会影响一个模块</li>
</ul>
<p><strong>扩展：</strong><a href="">Fundamental of SoftWare Engineer</a></p>
</blockquote>
<h3 id="19-1-1-内聚性与耦合性"><a href="#19-1-1-内聚性与耦合性" class="headerlink" title="19.1.1    内聚性与耦合性"></a>19.1.1    内聚性与耦合性</h3><blockquote>
<p><strong>说明：</strong>一个好的模块接口并不是随意的一组声明，应具有下面两个性质</p>
<ul>
<li>高内聚：模块中的元素应该紧密相关</li>
<li>低耦合：模块之间应该尽可能相互独立</li>
</ul>
</blockquote>
<h3 id="19-1-2-模块的类型"><a href="#19-1-2-模块的类型" class="headerlink" title="19.1.2    模块的类型"></a>19.1.2    模块的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>举例</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据池</td>
<td>一些相关的变量或常量的集合</td>
<td><code>&lt;float.h&gt;</code>(<a href="">23.1</a>)、 <code>&lt;limits.h&gt;</code>(<a href="">23.2</a>)</td>
<td>通常不建议将变量放在头文件</td>
</tr>
<tr>
<td>库</td>
<td>一组相关函数的集合</td>
<td><code>&lt;string.h&gt;</code></td>
<td></td>
</tr>
<tr>
<td>抽象对象</td>
<td>对隐藏的数据结构进行操作的一组函数的集合</td>
<td></td>
<td>如果数据是隐藏起来的，那么这个对象那个就是“抽象的”</td>
</tr>
<tr>
<td>抽象数据类型</td>
<td>将具体数据实现方式隐藏起来的数据类型称为抽象数据类型</td>
<td></td>
<td>抽象数据类型在当今的程序设计中起着非常重要的作用</td>
</tr>
</tbody>
</table>
<h2 id="19-2-信息隐藏"><a href="#19-2-信息隐藏" class="headerlink" title="19.2    信息隐藏"></a>19.2    信息隐藏</h2><blockquote>
<p><strong>说明：</strong>一个设计良好的模块经常会对它的客户隐藏一些信息。谨慎的对客户隐藏信息的方法称为信息隐藏。<br><strong>优点：</strong></p>
<ul>
<li>安全性：<code>客户</code>只能通过<code>模块</code>自身的函数进行参数</li>
<li>灵活性：修改模块通常不必修改接口，对<code>客户</code>没有影响</li>
</ul>
<p><strong>原理：</strong>使用<code>static</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>修饰</th>
<th>链接情况</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数</td>
<td>内部链接</td>
<td>只能在只能被同一文件中被调用</td>
</tr>
<tr>
<td>变量（文件作用域）</td>
<td>内部链接</td>
<td>只能被同一文件中的其它函数访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong>使用宏定义“公有”和“私有”可以使程序含义更加清晰（尤其是<code>static</code>，因为它在c语言中有许多用法）</p>
<h3 id="栈模块-实现部分"><a href="#栈模块-实现部分" class="headerlink" title="栈模块(实现部分)"></a>栈模块(实现部分)</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC  <span class="comment">// 定义为空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIVATE static</span></span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> contents[STACK_SIZE] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PRIVATE <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PRIVATE <span class="keyword">int</span> <span class="title">is_full</span> <span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">pop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-3-抽象数据类型"><a href="#19-3-抽象数据类型" class="headerlink" title="19.3    抽象数据类型"></a>19.3    抽象数据类型</h2><blockquote>
<p><strong>说明：</strong>c语言没有设计专门用于封装类型的特性（<code>class</code>），即无法定义真正的抽象数据类型。<br><strong>案例缺陷：</strong>之前定义的栈模块提供的栈不基于一种抽象数据类型，而是仅仅提供了一个相当于“栈的实例”的数据结构。当需要多个栈实例时就无能为力了。</p>
</blockquote>
<p><em>stack.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 下面定义的Stack不是抽象数据类型，因为stack.h暴露了Stack的具体实现方式（结构体实例的成员是暴露的)</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> contents[STACK_SIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empyt</span> <span class="params">(Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span> <span class="params">(<span class="keyword">const</span> Stack *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(Stack *s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span> <span class="params">(Stack *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>客户</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 理想的使用方式</span></span><br><span class="line">	Stack s1, s2;</span><br><span class="line">	make_empty(&amp;s1);</span><br><span class="line">	make_empty(&amp;s2);</span><br><span class="line">	push(&amp;s1, <span class="number">1</span>);</span><br><span class="line">	push(&amp;s2, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!is_empty(&amp;s1)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(&amp;s1)); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不理想的方式</span></span><br><span class="line">	Stack s3;</span><br><span class="line">	s3.top = <span class="number">0</span>; <span class="comment">//直接访问了暴露出来的成员</span></span><br><span class="line">	s3.contents[top++] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-4-C-语言"><a href="#19-4-C-语言" class="headerlink" title="19.4    C++语言"></a>19.4    C++语言</h2><blockquote>
<p><strong>说明：</strong>C++语言是由<code>AT&amp;T</code>贝尔实验室的Bjqrne Stroustrup在20世纪80年代开发出来的C语言的扩展版。<br><strong>新特性（相对C）：</strong></p>
<ul>
<li>面向对象：允许从已经存在的类“派生”（继承）出新的类</li>
<li>运算符重载：为传统的C语言的运算符赋予新的含义</li>
<li>模版：可以使我们写出通用的、高度可复用的类和函数</li>
<li>异常处理：一种同一的方式用来检测并响应错误</li>
</ul>
<p><strong>兼容C：</strong>C++语言包含了标准C的全部特性，然而不是所有C语言都可以在C++的环境下编译，因为C++语言增加了更多强制限制，比C语言更加安全。</p>
</blockquote>
<h3 id="19-4-1-C语言与C-语言之间的差异"><a href="#19-4-1-C语言与C-语言之间的差异" class="headerlink" title="19.4.1    C语言与C++语言之间的差异"></a>19.4.1    C语言与C++语言之间的差异</h3><h4 id="19-4-1-1-注释"><a href="#19-4-1-1-注释" class="headerlink" title="19.4.1.1    注释"></a>19.4.1.1    注释</h4><blockquote>
<p><strong>新特性：</strong>C++语言支持单行注释</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a Comment</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-2-标记与类型名"><a href="#19-4-1-2-标记与类型名" class="headerlink" title="19.4.1.2    标记与类型名"></a>19.4.1.2    标记与类型名</h4><blockquote>
<p><strong>新特性：</strong>标记（结构、联合或枚举的名字）会自动被认为是类型名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">	<span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 相当于下列形式的c语言</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">typedef struct Complex &#123;</span><br><span class="line">	double re, im;</span><br><span class="line">&#125; Complex;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-3-不带参数的函数"><a href="#19-4-1-3-不带参数的函数" class="headerlink" title="19.4.1.3    不带参数的函数"></a>19.4.1.3    不带参数的函数</h4><blockquote>
<p><strong>新特性：</strong>在声明或定义一个不带参数的<code>C++</code>函数时，可以不使用<code>void</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span> <span class="params">()</span></span>; <span class="comment">// 和void相同</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-4-默认实际参数"><a href="#19-4-1-4-默认实际参数" class="headerlink" title="19.4.1.4    默认实际参数"></a>19.4.1.4    默认实际参数</h4><blockquote>
<p><strong>新特性：</strong>C++语言允许函数的实际参数有默认值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示任意数量的换行符，如果没有提供参数，默认为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_line</span> <span class="params">(<span class="keyword">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_line(<span class="number">3</span>); <span class="comment">// 三个换行</span></span><br><span class="line">new_line(); <span class="comment">//一个换行</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-5-引用参数"><a href="#19-4-1-5-引用参数" class="headerlink" title="19.4.1.5    引用参数"></a>19.4.1.5    引用参数</h4><blockquote>
<p><strong>新特性：</strong>允许实际参数被声明为<code>引用</code>，而不是<code>指针</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c语言的方式</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">void swap (int *a, int *b) &#123;</span><br><span class="line">	int temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;i, &amp;j);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(i, j); <span class="comment">// 不需要再参数前加&amp;运算符</span></span><br></pre></td></tr></table></figure>
<h4 id="19-4-1-6-动态存储分配"><a href="#19-4-1-6-动态存储分配" class="headerlink" title="19.4.1.6    动态存储分配"></a>19.4.1.6    动态存储分配</h4><blockquote>
<p><strong>新特性：</strong>使用运算符<code>new</code>（分配空间）、 <code>delete</code>（释放空间）<br><strong>语法：</strong></p>
<ul>
<li>分配内存：<code>new 类型说明符</code></li>
<li>释放内存： <code>delete 指针</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> *int_ptr, *int_array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">int_ptr = new <span class="keyword">int</span>; <span class="comment">// 为整数分配存储空间</span></span><br><span class="line">int_array = new <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 为数组分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="keyword">delete</span> int_ptr; <span class="comment">// 为整数空间释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] int_array; <span class="comment">// 为数组释放空间</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-2-类"><a href="#19-4-2-类" class="headerlink" title="19.4.2    类"></a>19.4.2    类</h3><blockquote>
<p><strong>类：</strong>一个类从根本上说就是一个<code>抽象数据类型</code>：一组数据以及操作这些数据的函数<br><strong>说明：</strong>这个新数据类型的功能可以同基本数据类型同样强大。<br><strong>类的不足：</strong>类的设计和实现比较复杂，这是易用性必须付出的代价，而这也是计算机领域近几年内的妥协。</p>
</blockquote>
<h3 id="19-4-3-类定义"><a href="#19-4-3-类定义" class="headerlink" title="19.4.3    类定义"></a>19.4.3    类定义</h3><blockquote>
<p><strong>类标记（class tag）：</strong>可以直接作为类型名使用，不要求类名以大写开始，但许多C++程序员尊循首字母大写的规范。<br><strong>数据成员（data memeber）：</strong>类似结构的成员（但是默认是隐藏的，即“私有的”）<br><strong>类的实例（instance）：</strong>任何类的实例就是<code>对象</code>（object）<br><strong>访问成员：</strong>使用运算符<code>.</code>或<code>-&gt;</code>来访问公有的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 默认是私有的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 公有成员</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> numeratitor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-4-成员函数"><a href="#19-4-4-成员函数" class="headerlink" title="19.4.4    成员函数"></a>19.4.4    成员函数</h3><blockquote>
<p><strong>成员函数（member function）：</strong>属于类的函数称为成员函数，特别的，那些需要访问类的私有数据成员的函数必须声明在类里面。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 将函数的定义放在类的定义之中</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> denom)</span> </span>&#123;</span><br><span class="line">			numertor = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 只声明不定义（定义部分放在类外部）</span></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		* 乘法函数</span><br><span class="line">		* @param &#123;Fraction f&#125; </span><br><span class="line">		*/</span></span><br><span class="line">		<span class="function">Fraction <span class="title">mul</span><span class="params">(Fraction f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 乘法函数的定义</span><br><span class="line">* Fraction::前缀是必需的，否则C++编译器会将mul作为一个普通函数</span><br><span class="line">* @param &#123;Fraction f&#125; 分数</span><br><span class="line">*/</span></span><br><span class="line">Fraction Fraction::mul(Fraction f) &#123;</span><br><span class="line">	Fraction result;</span><br><span class="line">	result.numerator = numerator * f.numerator;</span><br><span class="line">	result.denominator = denominator * f.denominator;</span><br><span class="line">	result.reduce();</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fraction f1;</span><br><span class="line">f1.create(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Fraction f2 = f1.mul(f1);</span><br></pre></td></tr></table></figure>
<h3 id="19-4-5-构造函数"><a href="#19-4-5-构造函数" class="headerlink" title="19.4.5    构造函数"></a>19.4.5    构造函数</h3><blockquote>
<p><strong>构造函数（controctor）：</strong></p>
<ul>
<li>通常时自动调用的（编译器安排在合适的时机自动调用）</li>
<li>定义在public成员部分，不需要指定返回值类型</li>
<li>命名和类名相同</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		Fraction(<span class="keyword">int</span> num = <span class="number">0</span>, <span class="keyword">int</span> denom = <span class="number">1</span>) &#123;</span><br><span class="line">			numerator = num;</span><br><span class="line">			denominator = denom;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 通过构造函数声明并初始化实例</span></span><br><span class="line"><span class="function">Fraction <span class="title">f2</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 等同于Fraction f2(3, 1);</span></span><br><span class="line">Fraction f3; <span class="comment">// 等同于 f3(0, 1);</span></span><br></pre></td></tr></table></figure>
<h3 id="19-4-6-构造函数和动态存储分配"><a href="#19-4-6-构造函数和动态存储分配" class="headerlink" title="19.4.6    构造函数和动态存储分配"></a>19.4.6    构造函数和动态存储分配</h3><blockquote>
<p><strong>说明：</strong>构造函数和析构函数为那些内存分配和回收函数提供了比较合适的时机。<br><strong>举例：</strong>创建自己的<code>String</code>类型<br>|比较|C++的<code>String</code>（自定义）|C语言实现方式（<code>char</code>数组）|<br>|-|-|-|<br>|字符串长度|任意长度|受限于数组的长度|<br>|获取字符串长度|O(1)|O(n)|<br>|扩展性|需要时可给String类添加操作|无法修改（就算引入<string.h>，但无法扩展）|</string.h></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">	<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="comment">// 分配足够大的空间</span></span><br><span class="line">	text = new Char[len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">	<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-7-析构函数"><a href="#19-4-7-析构函数" class="headerlink" title="19.4.7    析构函数"></a>19.4.7    析构函数</h3><blockquote>
<p><strong>析构函数（destructor）：</strong></p>
<ul>
<li>名字：<code>~类名</code></li>
<li>返回值：没有返回值</li>
<li>参数：没有</li>
</ul>
<p><strong>用途：</strong>自动存储期限的类的实例，当其生存期结束后，普通成员的内存会被释放，但在构造函数中分配内存的成员指向的内存不会被释放（内存泄漏）。所以需要析构函数在对象释放时自动调用，清理构造函数动态分配的内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 声明并定义构造函数</span></span><br><span class="line">		String(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">			<span class="comment">// 计算s所指向的字符串的长度</span></span><br><span class="line">			len = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="comment">// 分配足够大的空间</span></span><br><span class="line">			text = new Char[len + <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 将字符串复制到刚刚分配的内存中</span></span><br><span class="line">			<span class="built_in">strcpy</span>(text, s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 声明并定义析构函数</span></span><br><span class="line">		~String() &#123;</span><br><span class="line">			<span class="keyword">delete</span> [] text;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">char</span> *text;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-4-8-重载"><a href="#19-4-8-重载" class="headerlink" title="19.4.8    重载"></a>19.4.8    重载</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p><strong>说明：</strong>在同一作用域下存在两个或以上同名但参数不同的函数(包括构造函数)叫做函数的重载。<br><strong>用途：</strong>需要记住更少的函数名，编译器会根据实际参数的情况自动判断调用哪一个函数。<br><strong>默认构造函数：</strong>不带时机参数的构造函数，会在声明对象而没有制定初始值时被调用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sring &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	* 重载构造函数（默认）</span><br><span class="line">	* @overload</span><br><span class="line">	*/</span></span><br><span class="line">	String() &#123;</span><br><span class="line">		text = <span class="number">0</span>;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~String() &#123;</span><br><span class="line">		<span class="keyword">delete</span> [] text;</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *text;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s; <span class="comment">// 不带实际参数，会调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p><strong>说明：</strong>重载运算符后，根据操作数类型的不同，同样的运算符号可以代表不同的操作。<br><strong>用途：</strong>更易读，更自然（不需要定义一些难以记住的函数名）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 声明重载操作符：*</span></span><br><span class="line">	Fraction <span class="keyword">operator</span>*(Fraction f);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载操作符：*</span></span><br><span class="line">Fraction Fraction::operation*(Fraction f) &#123;</span><br><span class="line">	<span class="comment">//代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f3 = f1 * f2; <span class="comment">// 定义的*是一个二元运算符(相当于f3 = f1.operator*(f2);)</span></span><br></pre></td></tr></table></figure>
<h4 id="C-语言的输入／输出（）"><a href="#C-语言的输入／输出（）" class="headerlink" title="C++语言的输入／输出（）"></a>C++语言的输入／输出（<stdio.h>）</stdio.h></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/18 声明/" itemprop="url">
                  18 声明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T20:29:30+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/18 声明/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/18 声明/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>说明：</strong>通过声明变量和函数，可以再检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。</p>
</blockquote>
<h2 id="18-1-声明的语法"><a href="#18-1-声明的语法" class="headerlink" title="18.1    声明的语法"></a>18.1    声明的语法</h2><blockquote>
<p><strong>语法：</strong><code>声明说明符 声明符;</code></p>
</blockquote>
<h3 id="18-1-1-声明说明符"><a href="#18-1-1-声明说明符" class="headerlink" title="18.1.1    声明说明符"></a>18.1.1    声明说明符</h3><blockquote>
<p><strong>分类：</strong>分3类（可组合）</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>包括</th>
<th>位置</th>
<th>可多个</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>auto static extern register</td>
<td>声明中的首要位置</td>
<td>否</td>
</tr>
<tr>
<td>类型限定符</td>
<td>const volatile</td>
<td>存储类型的后边</td>
<td>是</td>
</tr>
<tr>
<td>类型说明符</td>
<td>void char short int long float double signed unsigned 结构 联合 枚举 typedef创建的类型名</td>
<td>存储类型的后边</td>
<td>是，出现顺序无限制</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>类型限定符和类型说明符的顺序没有限制，习惯上前者在前。</p>
</blockquote>
<h3 id="18-1-2-声明符"><a href="#18-1-2-声明符" class="headerlink" title="18.1.2    声明符"></a>18.1.2    声明符</h3><blockquote>
<p><strong>说明：</strong>一次可以声明多个声明符，彼此用<code>,</code>隔开。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>是否可跟初始化式</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单变量名</td>
<td>标识符</td>
<td>是</td>
</tr>
<tr>
<td>数组名</td>
<td>后边跟随[]的标识符</td>
<td>是</td>
</tr>
<tr>
<td>指针名</td>
<td>前放置*的标识符</td>
<td>是</td>
</tr>
<tr>
<td>函数名</td>
<td>后边跟随()的标识符</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="18-1-3-举例"><a href="#18-1-3-举例" class="headerlink" title="18.1.3    举例"></a>18.1.3    举例</h3><p><em>同时声明多个声明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.19.png" alt="Alt text"></p>
<p><em>带有初始化式</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.31.png" alt="Alt text"></p>
<p><em>同时使用多种类型说明符</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.08.57.png" alt="Alt text"></p>
<p><em>函数声明</em><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-15%20%E4%B8%8A%E5%8D%8812.09.05.png" alt="Alt text"></p>
<h2 id="18-2-存储类型"><a href="#18-2-存储类型" class="headerlink" title="18.2    存储类型"></a>18.2    存储类型</h2><blockquote>
<p><strong>说明：</strong>可以用于变量、较小范围的函数和形式参数的说明。根据声明位置的不同，在不用存储类型修饰的情况下，变量具有默认的存储类型，当默认的性质无法满足要求时，可以通过指定明确的存储类型来改变变量的性质。<br><strong>关键字：</strong><code>auto</code> <code>static</code> <code>extern</code> <code>register</code><br><strong>块（block）：</strong>表示函数体（大括号闭合的部分）或块语句（包含生命的复合语句）。</p>
</blockquote>
<h3 id="18-2-1-变量的特性"><a href="#18-2-1-变量的特性" class="headerlink" title="18.2.1    变量的特性"></a>18.2.1    变量的特性</h3><blockquote>
<p><strong>说明：</strong>变量的3个性质</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
<th>说明</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储期限</td>
<td>为变量预留和释放内存的时间</td>
<td>自动存储期限、静态存储期限</td>
</tr>
<tr>
<td>作用域</td>
<td>指引用变量的那部分程序文件</td>
<td>块作用域、文件作用域</td>
</tr>
<tr>
<td>链接</td>
<td>程序的不同部分可以共享此变量的范围</td>
<td>外部链接、内部链接、无链接</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>声明位置决定的存储特性：</strong>对许多变量而言，默认的存储期限、作用域和链接是可以符合要求的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>声明位置</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>块内部</td>
<td>自动存储期限、块作用域、无链接</td>
</tr>
<tr>
<td>程序的最外层</td>
<td>静态存储期限、文件作用域、外部链接</td>
</tr>
</tbody>
</table>
<h4 id="1-存储期限"><a href="#1-存储期限" class="headerlink" title="1. 存储期限"></a>1. 存储期限</h4><table>
<thead>
<tr>
<th>存储期限</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
<td>在所属块被执行时获得内存单元，并在块终止时释放内存单元（变量失去值）</td>
<td></td>
</tr>
<tr>
<td>静态存储期限</td>
<td>在程序运行期间占有同样的存储单元</td>
<td>可以允许变量无限期地保留它的值</td>
</tr>
</tbody>
</table>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>块作用域</td>
<td>变量从声明的地方一直到闭合块的末尾都是可见的</td>
<td></td>
</tr>
<tr>
<td>文件作用域</td>
<td>从声明的地方一直到闭合文件的末尾都时可见的</td>
</tr>
</tbody>
</table>
<h4 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h4><table>
<thead>
<tr>
<th>链接</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部链接</td>
<td>可以被程序中的几个（或者全部）文件共享</td>
<td></td>
</tr>
<tr>
<td>内部链接</td>
<td>只能属于单独一个文件</td>
<td></td>
</tr>
<tr>
<td>无链接</td>
<td>属于单独一个函数，而且根本不能被共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 静态存储期限</span><br><span class="line">* 文件作用域</span><br><span class="line">* 外部链接</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	* 自动存储期限</span><br><span class="line">	* 块作用域</span><br><span class="line">	* 无链接</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-2-auto存储类型"><a href="#18-2-2-auto存储类型" class="headerlink" title="18.2.2    auto存储类型"></a>18.2.2    auto存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>auto</code><br>注意：auto存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h3 id="18-2-3-static存储类型"><a href="#18-2-3-static存储类型" class="headerlink" title="18.2.3    static存储类型"></a>18.2.3    static存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>static</code><br><strong>可以修饰：</strong>全部变量<br><strong>特性：</strong>修饰快外部声明的变量和块内部声明的变量会有不同的效果</p>
<ul>
<li><strong>块外部</strong>：static使变量由外部链接变为内部链接（即<code>信息隐藏</code>，因为本质上隐藏了它所在声明文件内的变量，只有出现在同一文件中的函数可以看到此变量）</li>
<li><strong>块内部</strong>：static使变量的存储期限从自动变成静态的(无限期保留值)</li>
</ul>
<ol>
<li>块内的<code>static</code> 型变量只在程序执行前进行一次初始化，而<code>auto</code>型变量则会在每次变成有效时进行初始化</li>
<li>每次函数进行递归调用时，它都会获得一组新的<code>auto</code>型变量的集合。<code>static</code>修饰的变量则会被共用</li>
<li>函数不能返回<code>auto</code>型变量的指针，但可以返回指向<code>static</code>型变量的指针</li>
</ol>
<p><strong>用途：</strong></p>
<ol>
<li><strong>提升性能：</strong>修饰块内部变量，避免函数每次调用都对变量进行初始化</li>
<li><strong>信息隐藏：</strong>修饰块外部变量，用于在“隐藏”区域内的调用之间保留信息</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 内部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 无链接</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 将10进制的数字转换为16进制的</span><br><span class="line">* param &#123;int&#125; digit 10进制数字（16以内）</span><br><span class="line">* return &#123;char&#125; 表示响应16进制数字的字符</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">digit_to_hex_char</span> <span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 无论函数呗调用多少次，只会初始化一次</span></span><br><span class="line">	<span class="keyword">const</span> chat hex_chars[<span class="number">16</span>] = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">	return hex_chars[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-4-extern存储类型"><a href="#18-2-4-extern存储类型" class="headerlink" title="18.2.4    extern存储类型"></a>18.2.4    extern存储类型</h3><blockquote>
<p><strong>说明：</strong>只声明变量（不初始化）<br><strong>关键字：</strong><code>extern</code><br><strong>用途：</strong>多文件共享同一个变量<br><strong>性质：</strong></p>
<ul>
<li><strong>存储期限：</strong>使变量具有<code>静态存储期限</code>（即使在块中声明的变量）</li>
<li><strong>作用域：</strong><code>extern</code>不影响变量作用域（块内声明为块作用域，否则是文件作用域）</li>
<li><strong>链接：</strong>通常情况为<code>外部链接</code>；当同时被<code>static</code>修饰且声明位置为任何函数外部时为<code>内部链接</code></li>
</ul>
<p><strong>注意：</strong>用<code>extern</code>修饰的变量仍然可以同时初始化（但就没有了用<code>extern</code>的意义）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//等价于int i = 0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态存储期限</span></span><br><span class="line"><span class="comment">// 文件作用域</span></span><br><span class="line"><span class="comment">// 链接？</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态存储期限</span></span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	<span class="comment">// 链接？</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-5-register存储类型"><a href="#18-2-5-register存储类型" class="headerlink" title="18.2.5    register存储类型"></a>18.2.5    register存储类型</h3><blockquote>
<p><strong>关键字：</strong><code>register</code><br><strong>用途：</strong>使变量存储在寄存器而不是内存中，提高访问和更新速度。<br><strong>寄存器：</strong>使驻留在计算机CPU中的存储单元。在传统计算机架构中，存储在寄存器中的数据会比存储在普通内存中的数据访问和更新速度更快。<br><strong>特点：</strong></p>
<ul>
<li>具有和<code>auto</code>型变量一样的俄存储期限、作用域和链接</li>
<li>对<code>register</code>型变量使用取地址运动符<code>&amp;</code>使非法的（因为寄存器没有地址）</li>
</ul>
<p><strong>注意：</strong>随着编译器变得更加复杂和高效，一些编译器可以自动决定变量保存在寄存器中还是内存中来达到最优性能。因此<code>register</code>的使用不再流行了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for语句的循环控制变量应用`register`是一个很好的选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sun_array</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-6-函数的存储类型"><a href="#18-2-6-函数的存储类型" class="headerlink" title="18.2.6    函数的存储类型"></a>18.2.6    函数的存储类型</h3><blockquote>
<p><strong>说明：</strong>函数只能用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<table>
<thead>
<tr>
<th>不修饰或<code>extern</code></th>
<th><code>static</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期限</td>
<td>静态存储期限</td>
</tr>
<tr>
<td>文件作用域</td>
<td>文件作用域</td>
</tr>
<tr>
<td><code>外部链接</code></td>
<td><code>内部链接</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>技巧：</strong> 当声明不打算被其他文件调用的任意函数时，建议使用<code>static</code>修饰</p>
<ol>
<li><strong>更容易维护：</strong>稍后修改文件的人可以知道对被<code>static</code>修饰的函数的修改一般不会影响其他文件中的函数（即便该函数所在文件中其它函数将指向该函数的指针传递了出去，也可以在当前文件发现）</li>
<li><strong>减少“命名空间污染”：</strong>可以在其它文件中使用相同的名字命名函数而不会发生冲突<br><strong>注意：</strong>使用<code>extern</code>画蛇添足，不必使用但也无害。</li>
</ol>
<p><strong>扩展：</strong>函数行参的存储类型（只能用<code>register</code>修饰）</p>
</blockquote>
<table>
<thead>
<tr>
<th>默认（等同于块中的<code>auto</code>型变量）</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动存储期限</td>
</tr>
<tr>
<td>块作用域</td>
</tr>
<tr>
<td>无链接</td>
</tr>
</tbody>
</table>
<h2 id="18-3-类型限定符"><a href="#18-3-类型限定符" class="headerlink" title="18.3    类型限定符"></a>18.3    类型限定符</h2><table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const</code></td>
<td>声明只读类型（也称为常量）</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td><a href="">20.3节</a></td>
</tr>
</tbody>
</table>
<h3 id="const介绍"><a href="#const介绍" class="headerlink" title="const介绍"></a><code>const</code>介绍</h3><p><strong>用途：</strong>定义常量</p>
<blockquote>
<ol>
<li>提示阅读程序的人，对象的值不能改变</li>
<li>让编译器检查防止程序改变对象的值</li>
<li>可能的话（特别是嵌入式系统），编译器可以用让<code>const</code>修饰的变量存储到<code>ROM</code>(只读内存)中</li>
</ol>
</blockquote>
<p><code>只读（const）</code>和<code>宏（#define）</code>：如何恰当使用两者？</p>
<blockquote>
<p><strong>技巧：</strong>建议对表示数字（比如数组维数）或字符的常量使用<code>#define</code>;<code>const</code>常用于保护存储在数组中的常量数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>只读（const）</th>
<th>宏(#define)</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>数字常量、字符常量、字符串常量</td>
<td>任何类型（包括常量数组、常量指针、常量结构、常量联合）</td>
</tr>
<tr>
<td>作用域</td>
<td>遵守作用域规则</td>
<td>不遵守，不能产生具有块作用域的常量</td>
</tr>
<tr>
<td>能否在调试器观察</td>
<td>能</td>
<td>不能</td>
</tr>
<tr>
<td>能否用于常量表达式</td>
<td>不能，比如数组大小（常量表达式）不能用<code>const</code>定义的常量</td>
<td>能</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[n]; <span class="comment">// 使用错误，只读类型不能用于常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="18-4-声明符"><a href="#18-4-声明符" class="headerlink" title="18.4    声明符"></a>18.4    声明符</h2><h3 id="声明符组成"><a href="#声明符组成" class="headerlink" title="声明符组成"></a>声明符组成</h3><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>标识符</code></td>
<td>声明的变量或函数的名字</td>
<td>是</td>
</tr>
<tr>
<td><code>*</code></td>
<td>声明指针或对指针进行索引</td>
<td>否</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>声明数组</td>
<td>否</td>
</tr>
<tr>
<td><code>()</code></td>
<td>声明函数或提高优先级</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="简单的声明规则"><a href="#简单的声明规则" class="headerlink" title="简单的声明规则"></a>简单的声明规则</h3><table>
<thead>
<tr>
<th>符号(用于声明)</th>
<th>简单规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>用*开头的声明符表示指针</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>用[]结尾的声明符表示数组</td>
</tr>
<tr>
<td><code>()</code></td>
<td>用()结尾的声明符表示函数</td>
</tr>
</tbody>
</table>
<h3 id="不合法的声明符"><a href="#不合法的声明符" class="headerlink" title="不合法的声明符"></a>不合法的声明符</h3><blockquote>
<ol>
<li>函数不能返回数组</li>
<li>函数不能返回函数</li>
<li>数组不能是函数型的</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的情况：标识符就是声明符</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; <span class="comment">//extern int a[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">()</span></span>; <span class="comment">// 空括号形式使得编译器不检查函数调用的参数情况，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 明确告诉编译器没有参数，编译器会检查参数情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_largest</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>; <span class="comment">// 允许在函数声明中忽略形式参数的名字</span></span><br></pre></td></tr></table></figure>
<h3 id="18-4-1-解释复杂声明"><a href="#18-4-1-解释复杂声明" class="headerlink" title="18.4.1    解释复杂声明"></a>18.4.1    解释复杂声明</h3><blockquote>
<p><strong>规则：</strong>无论多么复杂的声明都可以被下面的两条规则解释</p>
<ol>
<li>从标识符开始，由内往外解读</li>
<li>当符号位于同一层级(一左一右)时，确定声明的是什么东西的优先级是：<code>[] &gt; () &gt; *</code>(数组 &gt; 函数 &gt; 指针)</li>
</ol>
<p><strong>技巧：</strong>作为上面规则的补充，符号<code>()</code>和<code>*</code>有存在歧义的时候，下面是甄别的依据</p>
<ol>
<li><code>()</code>：当位于声明符最右端时代表“函数”；否则是用来进行指针索引的，像这样：<code>(*其它部分)</code></li>
<li><code>*</code>：<code>(*其它部分)</code>代表指针索引，否则是定义函数的返回值类型为指针（如果是函数）或者是指针类型的定义。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则2，ap是数组（元素是int *型的指针）</span></span><br><span class="line"><span class="keyword">int</span> *ap[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，fp是函数（返回值类型为float *）</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> *<span class="title">fp</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过技巧1，(*pf)是函数，所以pf是指向函数的指针（函数的返回值为void）</span></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则2，(*x[10])是函数（返回值为int *, 参数为void），则x[10]为函数指针，所以x是存储函数指针的数组。</span></span><br><span class="line"><span class="keyword">int</span> *(*x[<span class="number">10</span>])(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="18-4-2-使用类型定义来简化声明"><a href="#18-4-2-使用类型定义来简化声明" class="headerlink" title="18.4.2    使用类型定义来简化声明"></a>18.4.2    使用类型定义来简化声明</h3><blockquote>
<p><strong>说明：</strong>利用一组类型定义拆分复杂的声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价：int *(*x[10])(void);</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">Fcn</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> Fcn *Fcn_ptr;</span><br><span class="line"><span class="keyword">typedef</span> Fcn_ptr Fcn_ptr_array[<span class="number">10</span>];</span><br><span class="line">Fcn_ptr_array x;</span><br></pre></td></tr></table></figure>
<h2 id="18-5-初始化式"><a href="#18-5-初始化式" class="headerlink" title="18.5    初始化式"></a>18.5    初始化式</h2><blockquote>
<p><strong>说明：</strong>可以在声明符的后边书写=, 后边再跟上初始化式（不同于赋值，赋值只要是合法的右值即可，而初始化式存在诸多限制）。<br><strong>变量的默认值（声明时不给初始化式）：</strong>变量的初始化值依赖于变量的存储期限</p>
<ul>
<li><em>自动存储期限</em>：没有默认的初始值，不能预测初始值</li>
<li><em>静态存储期限</em>：基于类型初始化为“零”（整型初始化为0，浮点数初始化为0.0，指针初始化为空指针）</li>
</ul>
<p><strong>技巧：</strong>推荐为静态类型的变量提供初始化式，便于阅读者确定变量的值，也便于查看初始化赋值的位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单变量的初始化：一个变量，与变量类型一样的表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型不匹配，采用和赋值运算相同的规则进行自动类型转换（7.5节）</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量的初始化：必须是具有和变量相同类型或void *类型的指针表达式</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组、结构或联合的初始化式通常是遗传封闭在大括号内的值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="额外规则"><a href="#额外规则" class="headerlink" title="额外规则"></a>额外规则</h3><ul>
<li>具有静态存储期限的变量：初始化式必须是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 100</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = LAST - FIRST + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>具有自动存储期限的变量：初始化式不必要是常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用大括号闭合的数组、结构或联合的初始化式必须只能包含常量表达式，不允许有变量或函数调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="keyword">int</span> powers[<span class="number">3</span>] = &#123;<span class="number">1</span>, N, N*N, N*N*N&#125;; <span class="comment">// N是常量，所以合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自动类型的结构或联合：初始化式可以是另外一个结构或联合</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">struct</span> <span class="keyword">complex</span> c1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">complex</span> c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/17 指针的高级应用/" itemprop="url">
                  17 指针的高级应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T19:38:12+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/17 指针的高级应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/17 指针的高级应用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="17-1-动态存储分配"><a href="#17-1-动态存储分配" class="headerlink" title="17.1    动态存储分配"></a>17.1    动态存储分配</h2><blockquote>
<p><strong>背景：</strong>c语言的数据结构通常是固定大小的，为了扩大数据结构的容量，必须修改程序并且再次编译。<br><strong>说明（行为）：</strong>在程序执行期间分配内存单元<br><strong>用途：</strong>可以根据需要设计可以扩大（和缩小）的数据结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>适用类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>数组</td>
<td></td>
</tr>
<tr>
<td>结构</td>
<td>可以链接成表、树和其它数据结构</td>
</tr>
</tbody>
</table>
<h3 id="17-1-1-内存分配函数"><a href="#17-1-1-内存分配函数" class="headerlink" title="17.1.1    内存分配函数"></a>17.1.1    内存分配函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>库</th>
<th>备注</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>malloc</code></td>
<td>分配内存快，但是不对内存块进行初始化</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>最常用，不需要对分配的内存块进行清除，所以它比<code>calloc</code>更高效</td>
<td><code>void *</code>(通用指针，本质上只是内存地址)</td>
</tr>
<tr>
<td><code>calloc</code></td>
<td>分配内存块，并且对内存块进行清除</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
<td></td>
</tr>
<tr>
<td><code>realloc</code></td>
<td>调整先前分配的内存块</td>
<td><code>&lt;stdlib.h&gt;</code></td>
<td>备注</td>
</tr>
</tbody>
</table>
<h3 id="17-1-2-空指针"><a href="#17-1-2-空指针" class="headerlink" title="17.1.2    空指针"></a>17.1.2    空指针</h3><p><strong>说明：</strong>“指向为空的指针”，这是一个区别于所有有效指针的特殊值。<code>Q&amp;A</code>用<code>NULL</code>（宏）来表示空指针。<br><strong>相关场景：</strong>当调用内存分配函数时，如果无法定位满足我们需要的足够大的内存块，函数会返回空指针（<code>null pointer</code>）。</p>
<p><strong>定义了<code>NULL</code>的库文件：</strong></p>
<ol>
<li><locale.h></locale.h></li>
<li><stddef.h></stddef.h></li>
<li><stdio.h></stdio.h></li>
<li><stdlib.h></stdlib.h></li>
<li><string.h></string.h></li>
<li><time.h></time.h></li>
</ol>
<blockquote>
<p><strong>真假：</strong>所有非空指针都为真，而只有空指针为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) ... </span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (!p) ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != NULL) ...</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">if</span> (p) ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>更酷的方式</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = malloc(<span class="number">10000</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/*分配内存失败，采取合适的措施*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-2-动态分配字符串"><a href="#17-2-动态分配字符串" class="headerlink" title="17.2    动态分配字符串"></a>17.2    动态分配字符串</h2><h3 id="17-2-1-使用malloc函数为字符串分配内存"><a href="#17-2-1-使用malloc函数为字符串分配内存" class="headerlink" title="17.2.1    使用malloc函数为字符串分配内存"></a>17.2.1    使用malloc函数为字符串分配内存</h3><blockquote>
<p><strong>注意：</strong>为字符串分配内存空间时不要忘记包含空字符串的空间。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">char</span> *p = (char *) <span class="built_in">malloc</span>(n + <span class="number">1</span>);<span class="comment">// malloc返回的通用指针会自动转化为char*型变量，因此强制类型转换的部分可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="17-2-2-在字符串函数中使用动态存储分配"><a href="#17-2-2-在字符串函数中使用动态存储分配" class="headerlink" title="17.2.2    在字符串函数中使用动态存储分配"></a>17.2.2    在字符串函数中使用动态存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 拼接两个字符串并返回一个“新字符串”（不改变原有的两个字符串）</span><br><span class="line"> * @param  s1 要拼接的字符串的第一部分</span><br><span class="line"> * @param  s2 要拼接的字符串的第二部分</span><br><span class="line"> * @return    新字符串地址</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, concat(<span class="string">"abc"</span>, <span class="string">"def"</span>)); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义指向新字符串的临时指针变量</span></span><br><span class="line">	<span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新字符串分配空间</span></span><br><span class="line">	result = <span class="built_in">malloc</span>(strlen(s1) + strlen(s2) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存失败</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in concat \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一部分复制到新字符串的空间中（会有剩余）</span></span><br><span class="line">	<span class="built_in">strcpy</span>(result, s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二部分拼接到后面</span></span><br><span class="line">	<span class="built_in">strcat</span>(result, s2);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-2-3-动态分配字符串的数组"><a href="#17-2-3-动态分配字符串的数组" class="headerlink" title="17.2.3    动态分配字符串的数组"></a>17.2.3    动态分配字符串的数组</h3><blockquote>
<p><strong>说明：</strong>在数组中存储字符串有两种方式。二维字符数组或者字符串字面量指针数组，相比之下，前者可能会浪费空间。</p>
</blockquote>
<h3 id="17-2-4-程序：显示一个月的提示列表（改进版）"><a href="#17-2-4-程序：显示一个月的提示列表（改进版）" class="headerlink" title="17.2.4    程序：显示一个月的提示列表（改进版）"></a>17.2.4    程序：显示一个月的提示列表（改进版）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Prints a one-month reminder list</span><br><span class="line"> * 程序需要读入一系列天和提示的组合，并且按照顺训进行存储（按日期排序）</span><br><span class="line"> * 额外需求：</span><br><span class="line"> * 1. 天在两个字符的域中右对齐</span><br><span class="line"> * 2. 确定用户没有输入两位以上的数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REMIND 50<span class="comment">//备忘录数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEN 60<span class="comment">//每条备忘的最大长度</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//备忘录列表</span></span><br><span class="line"> 	<span class="keyword">char</span> *reminders[MAX_REMIND];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//日期字符串和信息字符串</span></span><br><span class="line"> 	<span class="keyword">char</span> day_str[<span class="number">3</span>], msg_str[MSG_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">int</span> day, i, j, num_remind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> 		<span class="comment">//如果备忘录已满，就停止循环</span></span><br><span class="line"> 		<span class="keyword">if</span>(num_remind == MAX_REMIND)&#123;</span><br><span class="line"> 			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//输入日期和一条备忘清单</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter day and reminder:"</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//把日期读入到整形变量day中，即使输入更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止</span></span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%2d"</span>, &amp;day);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//如果日期输入0，则停止循环，不在输入任何备忘</span></span><br><span class="line"> 		<span class="keyword">if</span>(day == <span class="number">0</span>)&#123;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//把day的值转换为字符串并写到day_str中</span></span><br><span class="line"> 		<span class="built_in">sprintf</span>(day_str, <span class="string">"%2d"</span>, day);<span class="comment">//day_str会包含一个空字符结尾的合法字符串</span></span><br><span class="line"> 		read_line(msg_str, MSG_LEN);<span class="comment">//读入备忘信息</span></span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//找到备忘录的位置（根据日期从小到大排序的位置）</span></span><br><span class="line"> 		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 			<span class="comment">//确定这一天的位置</span></span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(day_str, reminders[i]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将包括该位置之后的备忘信息向后移动</span></span><br><span class="line">		<span class="keyword">for</span>(j = num_remind; j &gt; i; j--)&#123;</span><br><span class="line">			reminders[j], reminders[j<span class="number">-1</span>];</span><br><span class="line">		&#125; 	</span><br><span class="line"></span><br><span class="line">		reminders[i] = <span class="built_in">malloc</span>(<span class="number">2</span> + strlen(msg_str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (reminders[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-- No space left --\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">//将备忘信息放在空出来的位置</span></span><br><span class="line"> 		<span class="built_in">strcpy</span>(reminders[i], day_str);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//将备忘信息拼接过去</span></span><br><span class="line"> 		<span class="built_in">strcat</span>(reminders[i], msg_str);</span><br><span class="line"> 		num_remind++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//打印出当前所有备忘信息</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"\nDay Reminder\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_remind; i++)&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, reminders[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * @param  str 存储字符串的位置</span><br><span class="line"> * @param  n   字符串长度上限</span><br><span class="line"> * @return     该条字符串的长度</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> ch;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line"> 			str[i++] = ch;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	str[i] = <span class="string">'\0'</span>;</span><br><span class="line"> 	return i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-3-动态分配数组"><a href="#17-3-动态分配数组" class="headerlink" title="17.3    动态分配数组"></a>17.3    动态分配数组</h2><blockquote>
<p><strong>原理：</strong>在程序执行期间为数组分配空间，然后通过指向数组第一个元素的指针访问数组。由于c语言中数组和指针的紧密关系，指向动态分配的内存块的指针可以当作数组的名字使用。<br><strong>注意：</strong>计算数组所需的空间要使用sizeof运算符，如果分配空间不足，稍后网数组中存储时程序会出现异常。</p>
</blockquote>
<h3 id="17-3-1-使用malloc函数为数组分配存储空间"><a href="#17-3-1-使用malloc函数为数组分配存储空间" class="headerlink" title="17.3.1    使用malloc函数为数组分配存储空间"></a>17.3.1    使用malloc函数为数组分配存储空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个含n个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">a = <span class="built_in">malloc</span>(n * sizeof(int)); <span class="comment">// 计算数组所需的空间要使用sizeof运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作数组使用</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-3-2-calloc函数"><a href="#17-3-2-calloc函数" class="headerlink" title="17.3.2    calloc函数"></a>17.3.2    calloc函数</h3><blockquote>
<p><strong>函数原型（<code>stdlib.h</code>）：</strong>如果要求的空间无效，那么此函数返回空指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 分配内存空间并初始化</span><br><span class="line">* @param &#123;size_t&#125; numeb 数组的长度</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @return &#123;void *&#125; 数组第一个元素的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmeb, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当第一个参数为1时，可以为任何类型的数据项（不仅仅是数组）分配空间</li>
<li>calloc函数会清除分配的空间中的数据</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为n的int型数组，并将所有项初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(n, sizeof(int));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向结构体的指针</span></span><br><span class="line"><span class="keyword">struct</span> point &#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125; *p;</span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1</span>, sizeof(struct point)); <span class="comment">//p将指向新创建的结构体，且结构体的成员x、y都为0</span></span><br></pre></td></tr></table></figure>
<h3 id="17-3-3-realloc函数"><a href="#17-3-3-realloc函数" class="headerlink" title="17.3.3    realloc函数"></a>17.3.3    realloc函数</h3><blockquote>
<p><strong>原型(<code>stdlib.h</code>)：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 调整分配的内存的大小</span><br><span class="line">* @param &#123;void *&#125; ptr 指向内存块（通常是数组）的指针</span><br><span class="line">* @param &#123;size_t&#125; size 内存块的新尺寸</span><br><span class="line">* @return &#123;void *&#125; 新的内存块的地址</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用途：</strong>一旦为数组分配完内存，稍后可能会返现数组过大或过小。relloc函数可以调整数组的大小以使它更适合需要。<br><strong>局限：</strong>要确定传递给<code>realloc函数</code>的指针来自于先前<code>malloc函数</code>、<code>calloc函数</code>或<code>realloc函数</code>的调用获得的。否则程序会出现异常。<br><strong>规则：</strong></p>
<ul>
<li>如果无法扩大内存（后边内存被占用），会在别处分配新的内存，然后把旧块中的内容复制过去</li>
<li>当扩展内存块时，    <code>realloc函数</code>不会对添加进内存块的字节进行初始化</li>
<li>如果<code>realloc函数</code>不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。</li>
<li>如果<code>realloc函数</code>调用时以空指针作为第一个实际参数，那么它的行为就将像<code>malloc函数</code>一样</li>
<li>如果<code>realloc函数</code>调用时以0作为第二个实际参数，那么它会释放掉内存块    </li>
</ul>
<p><strong>注意：</strong>一旦<code>realloc函数</code>返回，一定要对指向内存块的所有指针进行更新（将新的地址赋值给指针），因为可能realloc函数移动到了其地方的内存块。</p>
</blockquote>
<h2 id="17-4-释放存储"><a href="#17-4-释放存储" class="headerlink" title="17.4    释放存储"></a>17.4    释放存储</h2><blockquote>
<p><strong>堆（heap）：</strong><code>malloc函数</code>和其他内存分配函数所获得的内存块都来自一个称为堆的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也会耗尽堆，这会导致函数返回空指针。<br><strong>垃圾（garbage）：</strong>对程序而言不再访问到的内存块被称为垃圾。<br><strong>内存泄漏（memroy leak）：</strong>运行中留有垃圾被称为内存泄漏。<br><strong>垃圾收集器（garbage collector）：</strong>用于垃圾的自动定位和回收，但c语言不提供。相反，每个c程序负责回收各自的垃圾（调用<code>free函数</code>）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟内存泄漏*/</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...)</span><br><span class="line">q = <span class="built_in">malloc</span>(...)</span><br><span class="line">p = q; <span class="comment">// p原本指向的内存块变成垃圾</span></span><br></pre></td></tr></table></figure>
<h3 id="17-4-1-free函数"><a href="#17-4-1-free函数" class="headerlink" title="17.4.1    free函数"></a>17.4.1    free函数</h3><blockquote>
<p><strong>用途：</strong>调用<code>free函数</code>将内存块释放返回堆。<br><strong>原型：</strong><code>stdlib.h</code><br><strong>限制：</strong><code>free函数</code>的世纪参数必须是指针，而且一定是先前<code>内存分配函数</code>返回的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 释放内存</span><br><span class="line">* @param &#123;void *&#125; ptr 指向需要释放的内存块的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-4-2-“悬空指针”问题"><a href="#17-4-2-“悬空指针”问题" class="headerlink" title="17.4.2    “悬空指针”问题"></a>17.4.2    “悬空指针”问题</h3><blockquote>
<p><strong>悬空指针（dangling pointer）：</strong>指向被<code>free</code>掉的内存块的指针。<br><strong>注意：</strong>悬空指针很难被发现，而且试图通过“悬空指针”修改被释放掉的内存块会导致程序异常。</p>
</blockquote>
<h2 id="17-5-链表"><a href="#17-5-链表" class="headerlink" title="17.5    链表"></a>17.5    链表</h2><blockquote>
<p><strong>链表（linked list）：</strong>时由一连串的结构（节点）组成的，其中每个节点都包含指向下一个链中节点的指针。<br><strong>优点：</strong>更灵活，方便扩大和缩小（插入和删除）。<br><strong>缺点：</strong>没有“随机访问”的能力</p>
</blockquote>
<h3 id="17-5-1-声明节点类型"><a href="#17-5-1-声明节点类型" class="headerlink" title="17.5.1    声明节点类型"></a>17.5.1    声明节点类型</h3><blockquote>
<p><strong>注意：</strong>结点类型只能使用标记而不能使用<code>typedef</code>定义结构，因为后者无法在节点内声明指向另一个结点的成员。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的单个节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node *first = <span class="literal">NULL</span>; <span class="comment">//链表初始为空</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-2-创建节点"><a href="#17-5-2-创建节点" class="headerlink" title="17.5.2    创建节点"></a>17.5.2    创建节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点分配内存</span></span><br><span class="line">new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点初始化值</span></span><br><span class="line">(*new_node).value = <span class="number">0</span>; <span class="comment">// .的优先级高于间接寻址运算符*，所以使用()提升后者优先级</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-3-gt-运算符"><a href="#17-5-3-gt-运算符" class="headerlink" title="17.5.3    -&gt;运算符"></a>17.5.3    -&gt;运算符</h3><blockquote>
<p><strong>右箭头选择（right arrow selection）：</strong>通过指针访问结构中的成员</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;value); <span class="comment">//scanf("%d", &amp;(*new_node).value)</span></span><br></pre></td></tr></table></figure>
<h3 id="17-5-4-在链表的开始处插入节点"><a href="#17-5-4-在链表的开始处插入节点" class="headerlink" title="17.5.4    在链表的开始处插入节点"></a>17.5.4    在链表的开始处插入节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>为节点分配内存单元</li>
<li>把数据存储在节点中</li>
<li>把节点插入到链表中</li>
</ol>
<p><strong>伏笔：</strong>在17.6节中对<code>add_to_list</code>有进一步优化。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FALURE 0</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 节点</span><br><span class="line"> * @struct</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> node *next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加节点到链表头部</span><br><span class="line"> * 需要注意的是，该函数执行后还需要将头部指向该函数返回的新的节点才能完成插入到链表头部的工作</span><br><span class="line"> * @param  list 要插入的链表（指向头部节点的指针）</span><br><span class="line"> * @param  n    要插入的节点存储的值</span><br><span class="line"> * @return      新的链表（指向新的头节点的指针）</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明新节点</span></span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配内存</span></span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_ro list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FALURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	new_node-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	return new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行完成链表的创建</span><br><span class="line"> * @return  链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">read_numbers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *first = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a series of intergers (0 to terminate):\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			return first;</span><br><span class="line">		&#125;</span><br><span class="line">		first = add_to_list(first, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个含有用户录入的数字的链表</span></span><br><span class="line">	<span class="keyword">struct</span> node *num_list;</span><br><span class="line">	num_list = read_numbers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-5-搜索链表"><a href="#17-5-5-搜索链表" class="headerlink" title="17.5.5    搜索链表"></a>17.5.5    搜索链表</h3><blockquote>
<p><strong>惯用法：</strong><code>for (p = first; p != NULL; p = p-&gt;next)</code><br><em>形式一：惯用法</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *p;</span><br><span class="line">	<span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;value == n) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式二：省略中间变量</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span>; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;value == n) &#123;</span><br><span class="line">			return <span class="built_in">list</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式三：链表到末尾和找到目标判定合并</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n; <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>形式四：使用while</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据存储的值寻找节点</span><br><span class="line">* @param &#123;struct node *&#125; list 链表（头部指针）</span><br><span class="line">* @param &#123;int&#125; n 目标节点存储的值</span><br><span class="line">* @return 目标节点的指针或NULL</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">search_list</span><span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	wile (<span class="built_in">list</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">list</span>-&gt;value != n) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-6-从链表中删除节点"><a href="#17-5-6-从链表中删除节点" class="headerlink" title="17.5.6    从链表中删除节点"></a>17.5.6    从链表中删除节点</h3><blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定位要删除的节点</li>
<li>改变前一个节点，从而使它“绕过”删除节点</li>
<li>调用<code>free函数</code>从而收回删除节点占用的内存空间</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 根据节点的值找到节点并删除之</span><br><span class="line">* @param &#123;struct node*&#125; list 所在的链表</span><br><span class="line">* @param &#123;int&#125; n 要删除的节点存储的值</span><br><span class="line">* @return &#123;struct node*&#125; 链表的头节点</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> node *<span class="title">delete_from_list</span> <span class="params">(<span class="keyword">struct</span> node *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *cur, *prev;</span><br><span class="line">	<span class="comment">// 定位要删除的节点</span></span><br><span class="line">	<span class="keyword">for</span> (cur = <span class="built_in">list</span>, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;value != n; prev = cur, cur = cur-&gt;next)</span><br><span class="line">		;</span><br><span class="line">	<span class="comment">// 没有找到要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了，要删除的节点是第一个节点</span></span><br><span class="line">	<span class="keyword">if</span> (prev == NUL) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到了， 要删除的节点不是第一个几点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		prev-&gt;next = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cur);</span><br><span class="line">	return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-5-8-程序：维护零件数据库（改进版）"><a href="#17-5-8-程序：维护零件数据库（改进版）" class="headerlink" title="17.5.8    程序：维护零件数据库（改进版）"></a>17.5.8    程序：维护零件数据库（改进版）</h3><blockquote>
<p><strong>说明：</strong>使用链表代替数组有两个主要的好处</p>
<ol>
<li>不需要事先限制数据库的大小，数据库可以扩大到没有更多内存空间存储零件为止</li>
<li>可以很容易保持用零件编号排序的数据库，当往数据库中添加新零件时，只是简单把它插入链表中的适当位置就可以了</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ tree -L 2</span><br><span class="line"> .</span><br><span class="line"> ├── invent2</span><br><span class="line"> ├── invent2.c</span><br><span class="line"> ├── invent2.o</span><br><span class="line"> ├── makefile</span><br><span class="line"> ├── readline.c</span><br><span class="line"> ├── readline.h</span><br><span class="line"> └── readline.o   └── readline.o</span><br></pre></td></tr></table></figure>
<h4 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invent2-c"><a href="#invent2-c" class="headerlink" title="invent2.c"></a>invent2.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (linked list version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * 定义零件</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number; <span class="comment">// 编号</span></span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>]; <span class="comment">// 名字长度</span></span><br><span class="line"> 	<span class="keyword">int</span> on_hand; <span class="comment">// 当前库存</span></span><br><span class="line"> 	<span class="keyword">struct</span> part *next; <span class="comment">// 指向下一个零件</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表（头节点）</span></span><br><span class="line"> <span class="keyword">struct</span> part *inventory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"> 		<span class="comment">// 跳过换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>: insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>: search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>: update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>: print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>: return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索零件</span><br><span class="line"> * @param  number 零件包含的值</span><br><span class="line"> * @return        对应零件节点的地址（没找到返回NULL）</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">struct</span> part *<span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span> &amp;&amp; number &gt; p-&gt;number; p = p -&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; number == p-&gt;number) &#123;</span><br><span class="line"> 		return p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入一种零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *cur, *prev, *new_node;</span><br><span class="line"> 	<span class="comment">// 为新节点分配空间</span></span><br><span class="line"> 	new_node = <span class="built_in">malloc</span>(sizeof(struct part));</span><br><span class="line"> 	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Database is full; can't add more parts.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 零件编号</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;number);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 根据编号寻找插入位置(按从小到大的顺序排列)</span></span><br><span class="line"> 	<span class="keyword">for</span> (cur = inventory, prev = <span class="literal">NULL</span>; cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number &gt; cur-&gt;number; prev = cur, cur = cur-&gt;next)</span><br><span class="line"> 		;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 发现编号相同的节点</span></span><br><span class="line"> 	<span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; new_node-&gt;number == cur-&gt;number) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exits.\n"</span>);</span><br><span class="line"> 		<span class="built_in">free</span>(new_node);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name:"</span>);</span><br><span class="line"> 	read_line(new_node-&gt;name, NAME_LEN);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 零件数量</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_node-&gt;on_hand);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 插入进去</span></span><br><span class="line"> 	new_node-&gt;next = cur;</span><br><span class="line"> 	<span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		inventory = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		prev-&gt;next = new_node;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 以交互的方式根据编号搜索并显示目标零件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">struct</span> part *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">	p = find_part(number);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p-&gt;name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, p-&gt;on_hand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 修改零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> number, change;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number:"</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	p = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		p-&gt;on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印所有零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">struct</span> part *p;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part number    Part Name   Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (p = inventory; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d      %-25s%11d\n"</span>, p-&gt;number, p-&gt;name, p-&gt;on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-6-指向指针的指针"><a href="#17-6-指向指针的指针" class="headerlink" title="17.6    指向指针的指针"></a>17.6    指向指针的指针</h2><blockquote>
<p><strong>说明：</strong>对17.5.4中的<code>add_to_list</code>进行优化，优化后插入链表的功能将完全由该函数提供。<br><strong>原理：</strong>通过指针的指针的副本，达到修改指针指向的目的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 向链表中插入节点</span><br><span class="line">* @param &#123;struct node **&#125; node 指向链表的头节点的指针的指针</span><br><span class="line">* @param &#123;int&#125; n 节点存储的值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span> <span class="params">(<span class="keyword">struct</span> node **<span class="built_in">list</span>,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> node *new_node;</span><br><span class="line">	new_node = <span class="built_in">malloc</span>(sizeof(struct node));</span><br><span class="line">	<span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error: malloc failed in add_to_list\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span> (EXIT_FAILURES);</span><br><span class="line">	&#125;</span><br><span class="line">	new_node-&gt;value = n;</span><br><span class="line">	<span class="comment">// 新节点的下一个节点指向链表头节点</span></span><br><span class="line">	new_node-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原本指向头节点的指针指向新节点</span></span><br><span class="line">	<span class="comment">// 详解：list的值是first这个指针本身的地址，通过*list便可以访问到first这个指针</span></span><br><span class="line">	*<span class="built_in">list</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">add_to_list(&amp;first, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="17-7-指向函数的指针"><a href="#17-7-指向函数的指针" class="headerlink" title="17.7    指向函数的指针"></a>17.7    指向函数的指针</h2><blockquote>
<p><strong>说明：</strong>毕竟函数占用内存单元，所以每个函数都有地址，就像每个变量都有地址一样。</p>
</blockquote>
<h3 id="17-7-1-函数指针作为实际参数"><a href="#17-7-1-函数指针作为实际参数" class="headerlink" title="17.7.1    函数指针作为实际参数"></a>17.7.1    函数指针作为实际参数</h3><blockquote>
<p><strong>声明：</strong>声明为指向函数的指针有两种方式，从编译器的角度看是完全一样的。</p>
<blockquote>
<p>方式一：<strong>返回值 函数名(<code>返回值 (*函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double (*f)(double), double a, double b)  &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x); // 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式二：<strong>返回值 函数名(<code>返回值 (函数名)(参数1, 参数2, ...)</code>, 参数)</strong></p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double integrate (double f(double), double a, double b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sum += (*f)(x);// 或者sum += f(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-7-2-qsort函数"><a href="#17-7-2-qsort函数" class="headerlink" title="17.7.2    qsort函数"></a>17.7.2    qsort函数</h3><blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 为数组排序</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;int (*)&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size,  int (*compar) (const void *, const void *));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 比较函数（提供给qsort函数排序规则）</span><br><span class="line"> * @param &#123;void *&#125; p 第一个零件</span><br><span class="line"> * @param &#123;void *&#125; q 第二个零件</span><br><span class="line"> * @return   正数（1）：*p &gt; *q;负数（-1）：*p &lt; *q;零（0）：*p = *q</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_parts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">const</span> <span class="keyword">void</span> *q)</span> </span>&#123;</span><br><span class="line">	return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比较函数进行排序</span></span><br><span class="line">qsort(inventory, num_parts, <span class="keyword">sizeof</span>(struct part), compare_parts);</span><br></pre></td></tr></table></figure>
<h3 id="17-7-3-函数指针的其他用途"><a href="#17-7-3-函数指针的其他用途" class="headerlink" title="17.7.3    函数指针的其他用途"></a>17.7.3    函数指针的其他用途</h3><blockquote>
<p><strong>说明：</strong>c语言对待指向函数的指针就像对待指向数据的指针一样。我们可以把函数存储在变量中，或者用做数组的元素，再或者用做结构或联合的成员，甚至可以编写返回函数指针的函数，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*存储函数的变量*/</span></span><br><span class="line"><span class="keyword">void</span> (*pf) (<span class="keyword">int</span>); <span class="comment">//声明一个可以存储指向函数的指针的变量（pf可以指向任何带有int型实际参数，且返回值为void的函数）</span></span><br><span class="line"></span><br><span class="line">pf = f; <span class="comment">// 指向函数f</span></span><br><span class="line"></span><br><span class="line">(*pf)(i); <span class="comment">// pf(i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储函数的数组*/</span></span><br><span class="line"><span class="keyword">void</span> (*file_cmd[])(<span class="keyword">void</span>) = &#123;</span><br><span class="line">	new_cmd,</span><br><span class="line">	open_cmd,</span><br><span class="line">	close_cmd,</span><br><span class="line">	close_all_cmd,</span><br><span class="line">	save_cmd,</span><br><span class="line">	ext_cmd</span><br><span class="line">&#125;;</span><br><span class="line">(*file_cmd[n])(); <span class="comment">// 或者file_cmd[n]();</span></span><br></pre></td></tr></table></figure>
<h3 id="17-7-4-程序：列三角函数表"><a href="#17-7-4-程序：列三角函数表" class="headerlink" title="17.7.4    程序：列三角函数表"></a>17.7.4    程序：列三角函数表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tabulates values of trigonometric functions</span><br><span class="line"> */</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)double, double first, double last, double incr);</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">	double final, increament, initial;</span><br><span class="line">	printf("Enter initial value: ");</span><br><span class="line">	scanf("%lf", &amp;initial);</span><br><span class="line"></span><br><span class="line">	printf("Enter final value:");</span><br><span class="line">	scanf("%lf", &amp;final);</span><br><span class="line"></span><br><span class="line">	printf("Enter increament:");</span><br><span class="line">	scanf("%lf", &amp;increament);</span><br><span class="line"></span><br><span class="line">	printf("\n     x     cos(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(cos, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     sin(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(sin, initial, final, increament);</span><br><span class="line">	</span><br><span class="line">	printf("\n     x     tan(x)\n   -------    -------\n");</span><br><span class="line">	tabulate(tan, initial, final, increament);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tabulate (double (*f)(double), double first, double last, double incr) &#123;</span><br><span class="line">	double x;</span><br><span class="line">	int i, num_intervals;</span><br><span class="line">	num_intervals = cell((last - first) / incr);</span><br><span class="line">	for (i = 0; i &lt;= num_intervals; i++) &#123;</span><br><span class="line">		x = first + i * incr;</span><br><span class="line">		printf("%10.5f %10.5f\n", x, (*f)[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/16 结构、联合和枚举/" itemprop="url">
                  16 结构、联合和枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:49:46+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/16 结构、联合和枚举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/16 结构、联合和枚举/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="16-1-结构变量"><a href="#16-1-结构变量" class="headerlink" title="16.1    结构变量"></a>16.1    结构变量</h2><blockquote>
<p><strong>结构：</strong>结构的特性与数组很不相同。</p>
<ul>
<li>结构的元素（成员）可能具有不同的类型</li>
<li>每个结构成员都有名字</li>
<li>为了选择特殊的结构成员需要知名结构成员的名字而不是它的位置</li>
</ul>
<p><strong>扩展：</strong>大多数语言都提供类似的特性，所以结构可能听起来很舒需。再其它语言中，经常把结构称为纪录（record），把结构的成员称为字段（field）。</p>
</blockquote>
<h3 id="16-1-1-结构变量的声明"><a href="#16-1-1-结构变量的声明" class="headerlink" title="16.1.1    结构变量的声明"></a>16.1.1    结构变量的声明</h3><p><strong>语法：</strong>只声明不初始化（会非配内存但成员不会初始化）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span>, 实例变量<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong>结构实例化的变量具备以下特点</p>
<ul>
<li>成员在内存中是按照顺序存储的</li>
<li>内部成员拥有单独的名字空间（name space）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//零件</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//零件编号</span></span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//零件名称</span></span><br><span class="line">	<span class="keyword">int</span> on_hand;<span class="comment">//零件现有数量</span></span><br><span class="line">&#125;part1, part2;<span class="comment">//同时用这种结构实例化了两个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//工号</span></span><br><span class="line">	<span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line">&#125;employee1, employee2;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-2-结构变量的初始化"><a href="#16-1-2-结构变量的初始化" class="headerlink" title="16.1.2    结构变量的初始化"></a>16.1.2    结构变量的初始化</h3><blockquote>
<p><strong>语法：</strong>声明的同时初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">    成员<span class="number">2</span>类型 成员<span class="number">2</span>名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;实例变量<span class="number">1</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;,   </span><br><span class="line">  实例变量<span class="number">2</span> = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ...&#125;, </span><br><span class="line">  ...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则：</strong>类似数组</p>
<ol>
<li>用于结构初始化式的表达式必须是常量</li>
<li>初始化式可以短于它所初始化的结构，任何剩余的成员都用0作为它的初始值</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> on, hand;</span><br><span class="line">&#125;part1 = &#123;<span class="number">528</span>, <span class="string">"Disk drive"</span>, <span class="number">10</span>&#125;,</span><br><span class="line"> part2 = &#123;<span class="number">914</span>, <span class="string">"Printer cable"</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-1-3-对结构的操作"><a href="#16-1-3-对结构的操作" class="headerlink" title="16.1.3    对结构的操作"></a>16.1.3    对结构的操作</h3><blockquote>
<p><strong>限制：</strong>不能用<code>==</code>或<code>!=</code>判定两个结构是否相等或不等。</p>
</blockquote>
<h4 id="16-1-3-1-访问成员"><a href="#16-1-3-1-访问成员" class="headerlink" title="16.1.3.1    访问成员"></a>16.1.3.1    访问成员</h4><blockquote>
<p><strong>左值：</strong>结构成员的值是左值</p>
<ul>
<li>可以出现在赋值运算的左侧</li>
<li>作为自增或自减表达式的操作数</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Part number %d:"</span>, part1.number);</span><br><span class="line">part1.number = <span class="number">228</span>;<span class="comment">//可以出现在赋值运算的左侧</span></span><br><span class="line">part1.on_hand++;<span class="comment">//作为自增或自减表达式的操作数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>逗号运算符：</strong><code>结构变量.成员名</code></p>
<ul>
<li>优先级和后缀++和后缀–相同（几乎高于所有其他运算符）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part1.on_hand);<span class="comment">//.运算符优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-2-赋值运算"><a href="#16-1-3-2-赋值运算" class="headerlink" title="16.1.3.2    赋值运算"></a>16.1.3.2    赋值运算</h4><blockquote>
<p><strong>说明：</strong>数组不能用=运算符实现变量间数组内容的复制，但结构变量可以。<br><strong>注意：</strong>只能用于同一个结构类型声明的的变量之间。<br><strong>技巧：</strong>把需要复制的数组嵌在结构体内（作为成员）进行复制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;a1, a2;</span><br><span class="line"></span><br><span class="line">a1 = a2;<span class="comment">//a1的存储空间中数据和a2相同，实现了复制</span></span><br></pre></td></tr></table></figure>
<h2 id="16-2-结构类型"><a href="#16-2-结构类型" class="headerlink" title="16.2    结构类型"></a>16.2    结构类型</h2><blockquote>
<p><strong>说明：</strong>上一小结重点放在结构变量而不是结构类型本身上，这一节将重点观察结构类型。<br><strong>命名结构类型：</strong>如果需要在程序的不同位置声明结构变量，上一节的“匿名结构”就行不通了。c语言提供了两种命名结构的方法</p>
<ol>
<li>声明“结构标记”(结构用语链表时，只能声明“结构标记”)</li>
<li>使用<code>typedef</code>定义类型名</li>
</ol>
</blockquote>
<h3 id="16-2-1-结构标记的声明"><a href="#16-2-1-结构标记的声明" class="headerlink" title="16.2.1    结构标记的声明"></a>16.2.1    结构标记的声明</h3><blockquote>
<p><strong>结构标记(structure tag)：</strong>结构标记用于标记某种特定结构类型的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  结构类型名&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125;[结构变量<span class="number">1</span>, ...];<span class="comment">//分号表示声明的结束，不能省略</span></span><br><span class="line"><span class="keyword">struct</span> 结构类型名 结构变量<span class="number">2</span>, ...;<span class="comment">//struct关键字不能省略，因为结构类型名不是有效的c语言类型名(原生的和typedef定义的才是)。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不仅声明了标记part，而且声明了变量</span></span><br><span class="line"><span class="keyword">struct</span> part&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> part  part1 = &#123;<span class="number">528</span>, <span class="string">"disk drive"</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> part part2;</span><br><span class="line">part2 = part1;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-2-结构类型的定义"><a href="#16-2-2-结构类型的定义" class="headerlink" title="16.2.2    结构类型的定义"></a>16.2.2    结构类型的定义</h3><blockquote>
<p><strong>说明：</strong>用typedef来定义真正的类型名。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	成员<span class="number">1</span>类型 成员<span class="number">1</span>名称;</span><br><span class="line">	 ...</span><br><span class="line">&#125; 结构类型名;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; Part;<span class="comment">//类型名的名字必须出现在定义的末尾，而不是在单词struct的后边</span></span><br><span class="line">Part part1, part2;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-3-结构类型的实际参数和返回值"><a href="#16-2-3-结构类型的实际参数和返回值" class="headerlink" title="16.2.3    结构类型的实际参数和返回值"></a>16.2.3    结构类型的实际参数和返回值</h3><blockquote>
<p><strong>缺点：</strong>带来一定系统开销，尤其是结构题很大的时候</p>
<blockquote>
<p>给函数传递结构和从函数返回结构都要求使用结构中所有成员的副本。</p>
</blockquote>
<p><strong>技巧：</strong>有时用指向结构的指针来代替传递给函数（或函数返回）的结构本身是很明智的做法。</p>
</blockquote>
<h4 id="16-2-3-1-用作参数"><a href="#16-2-3-1-用作参数" class="headerlink" title="16.2.3.1    用作参数"></a>16.2.3.1    用作参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_part</span> <span class="params">(<span class="keyword">struct</span> part p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"part number: %d\n"</span>, p.number);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, p.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Quality on hand: %d \n"</span>, p.on_hand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line">print_part(part1);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-2-用作返回值"><a href="#16-2-3-2-用作返回值" class="headerlink" title="16.2.3.2    用作返回值"></a>16.2.3.2    用作返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> part <span class="title">build_part</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> on_hand)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> part p;</span><br><span class="line">	p.number = number;</span><br><span class="line">	<span class="built_in">strcpy</span>(p.name, name);</span><br><span class="line">	p.on_hand = on_hand;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-3-数组和结构的嵌套"><a href="#16-3-数组和结构的嵌套" class="headerlink" title="16.3    数组和结构的嵌套"></a>16.3    数组和结构的嵌套</h2><h3 id="16-3-1-嵌套的结构"><a href="#16-3-1-嵌套的结构" class="headerlink" title="16.3.1    嵌套的结构"></a>16.3.1    嵌套的结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义姓名</span></span><br><span class="line"><span class="keyword">struct</span> person_name &#123;</span><br><span class="line">	<span class="keyword">char</span> first[FIRST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> middle_initial;</span><br><span class="line">	<span class="keyword">char</span> last[LAST_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">struct</span> student &#123;</span><br><span class="line">	<span class="keyword">struct</span> person_name name; <span class="comment">// 结构的成员可以是另一种结构体</span></span><br><span class="line">	int_id, age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; student1, student2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">"Fred"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-结构数组"><a href="#16-3-2-结构数组" class="headerlink" title="16.3.2    结构数组"></a>16.3.2    结构数组</h3><blockquote>
<p><strong>说明：</strong>结构可以作为数组的元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="comment">// 声明结构数组</span></span><br><span class="line"><span class="keyword">struct</span> part inventory[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问*/</span></span><br><span class="line"><span class="comment">// 访问结构数组中的结构</span></span><br><span class="line">print_part(inventory[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*操作*/</span></span><br><span class="line"><span class="comment">// 为数组中的结构的成员赋值</span></span><br><span class="line">inventory[i].number = <span class="number">883</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组中的结构的成员（字符串）置空</span></span><br><span class="line"> inventory[i].name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-3-结构数组的初始化"><a href="#16-3-3-结构数组的初始化" class="headerlink" title="16.3.3    结构数组的初始化"></a>16.3.3    结构数组的初始化</h3><blockquote>
<p><strong>语法：</strong>类似二维数组的初始化，每个结构都拥有自己的大括号。<br><strong>注意：</strong>每个结构值的内层大括号是可选项。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构：国家代码</span></span><br><span class="line"><span class="keyword">struct</span> dialog_code &#123;</span><br><span class="line">	<span class="keyword">char</span> *country;</span><br><span class="line">	<span class="keyword">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> dialog_code country_codes[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Argentina"</span>, <span class="number">54</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Bangladesh"</span>, <span class="number">66</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-4-程序：维护零件数据库"><a href="#16-3-4-程序：维护零件数据库" class="headerlink" title="16.3.4    程序：维护零件数据库"></a>16.3.4    程序：维护零件数据库</h3><h4 id="16-3-4-1-编写"><a href="#16-3-4-1-编写" class="headerlink" title="16.3.4.1    编写"></a>16.3.4.1    编写</h4><h5 id="readline-h"><a href="#readline-h" class="headerlink" title="readline.h"></a>readline.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READLINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="readline-c"><a href="#readline-c" class="headerlink" title="readline.c"></a>readline.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 读入一行</span><br><span class="line"> * 会跳过开头的空白符</span><br><span class="line"> *</span><br><span class="line"> * @param  str 读入的内容</span><br><span class="line"> * @param  n   字符串的内容</span><br><span class="line"> * @return     读入字符的个数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_line</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ch的类型为int而不是char，便于判定EOF</span></span><br><span class="line">	<span class="keyword">int</span> ch, i =<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 跳过所有空白符</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isspace</span>(ch = getchar()))</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">'\n'</span> &amp;&amp; ch != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">			str[i++] = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	str[i] = <span class="string">'\0'</span>;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invent-c"><a href="#invent-c" class="headerlink" title="invent.c"></a>invent.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maintains a parts database (array version)</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="string">"readline.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 25</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_PARTS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="keyword">struct</span> part &#123;</span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="keyword">char</span> name[NAME_LEN + <span class="number">1</span>];</span><br><span class="line"> 	<span class="keyword">int</span> on_hand;</span><br><span class="line"> &#125; inventory[MAX_PARTS];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> num_parts = <span class="number">0</span>; <span class="comment">// 当前零件的数量</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待用户操作</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> code;</span><br><span class="line"> 	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter operation code:"</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;code);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 跳过所有的换行符</span></span><br><span class="line"> 		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"> 			;</span><br><span class="line"> 		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line"> 				insert();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line"> 				search();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line"> 				update();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line"> 				print();</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line"> 				return <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 				<span class="built_in">printf</span>(<span class="string">"Illegal code\n"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 按照零件的编号查找零件在清单数组中的下标</span><br><span class="line"> * @param  number 零件的编号</span><br><span class="line"> * @return        零件在清单中的下标</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">find_part</span> <span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (inventory[i].number == number) &#123;</span><br><span class="line"> 			return i;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过命令行插入零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 输入零件号</span></span><br><span class="line"> 	<span class="keyword">int</span> part_number;</span><br><span class="line"> 	<span class="keyword">if</span> (num_parts == MAX_PARTS) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Datebase is full, can't add more parts .\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter partnumber: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;part_number);</span><br><span class="line"> 	<span class="keyword">if</span> (find_part(part_number) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part already exists.\n"</span>);</span><br><span class="line"> 		return;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	inventory[num_parts].number = part_number;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 输入零件名</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part name: "</span>);</span><br><span class="line"> 	read_line(inventory[num_parts].name, NAME_LEN);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter quantity on hand: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inventory[num_parts].on_hand);</span><br><span class="line"> 	num_parts++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 在命令行根据零件编号搜索零件</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number: "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part name: %s\n"</span>, inventory[i].name);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Quantity on hand: %d\n"</span>, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新清单中某种零件的数量</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, number, change;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Enter part number : "</span>);</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line"> 	i = find_part(number);</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Enter change in quantity on hand: "</span>);</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;change);</span><br><span class="line"> 		inventory[i].on_hand += change;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Part not found.\n"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印当前零件清单中所有种类零件的信息</span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Part Number   Part Name             "</span></span><br><span class="line"> 		   <span class="string">"Quantity on hand\n"</span>);</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_parts; i++) &#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%7d     %-25s%11d\n"</span>, inventory[i].number, inventory[i].name, inventory[i].on_hand);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-3-4-2-编译"><a href="#16-3-4-2-编译" class="headerlink" title="16.3.4.2    编译"></a>16.3.4.2    编译</h4><p>$ vim makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invent:invent.o readline.o</span><br><span class="line">	gcc -o invent invent.o readline.o</span><br><span class="line">invent.o:invent.c readline.h</span><br><span class="line">	gcc -c invent.c</span><br><span class="line">readline.o:readline.c readline.h</span><br><span class="line">	gcc -c readline.c</span><br></pre></td></tr></table></figure>
<p>$ make</p>
<h4 id="16-3-4-3-运行"><a href="#16-3-4-3-运行" class="headerlink" title="16.3.4.3    运行"></a>16.3.4.3    运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./invent </span><br><span class="line"> Enter operation code:i</span><br><span class="line"> Enter partnumber: 01</span><br><span class="line"> Enter part name: screen</span><br><span class="line"> Enter quantity on hand: 1 </span><br><span class="line"></span><br><span class="line"> Enter operation code:p</span><br><span class="line"> Part Number   Part Name             Quantity on hand</span><br><span class="line">       1     screen</span><br></pre></td></tr></table></figure>
<h2 id="16-4-联合"><a href="#16-4-联合" class="headerlink" title="16.4    联合"></a>16.4    联合</h2><h3 id="特点（和结构相比）"><a href="#特点（和结构相比）" class="headerlink" title="特点（和结构相比）"></a>特点（和结构相比）</h3><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>包含一个或多个成员</li>
<li>成员可以是不同的类型</li>
<li>声明标记和类型的方式</li>
<li>访问成员的方式</li>
<li>可以使用<code>=</code>进行复制操作</li>
<li>可以在函数间传递或作为函数的返回值</li>
<li>初始化方式</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>联合的实例所有成员共享相同的存储空间</li>
<li>联合的实例大小由最大的成员的类型决定</li>
<li>联合初始化实例时初始化的是按照第一个成员的类型来初始化值的</li>
</ul>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; u = &#123;<span class="number">0</span>&#125;; <span class="comment">// 0会按照i的类型初始化存储空间</span></span><br><span class="line"></span><br><span class="line">u.f = <span class="number">78.4</span>; <span class="comment">// 为联合赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="16-4-1-使用联合来节省空间"><a href="#16-4-1-使用联合来节省空间" class="headerlink" title="16.4.1    使用联合来节省空间"></a>16.4.1    使用联合来节省空间</h3><blockquote>
<p><strong>原理：</strong>在<code>struct</code>中使用<code>union</code>作为成员，后者使用<code>struct</code>作为成员。这种混合的结构可以实现一种数据结构应用于多种情境的效果。<br><strong>扩展：</strong>在<code>c++</code>中，<code>struct</code>中的<code>union</code>可以匿名，在<code>c</code>中则不得不指定<code>union</code>的名字。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_LEN 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTHOR_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESIGN_LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 礼品册上的商品</span><br><span class="line"> * 可以存储3种类型的商品：书籍、杯子、衬衫</span><br><span class="line"> *</span><br><span class="line"> * @type &#123;struct&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> catalog_item &#123;</span><br><span class="line">	<span class="keyword">int</span> stock_number; <span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">float</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">int</span> item_type; <span class="comment">// 分类</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 可能是书</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> title[TITLE_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">char</span> author[AUTHOR_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> num_pages;</span><br><span class="line">		&#125; book;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是杯子</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">		&#125; mug;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能是衬衫</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> design[DESIGN_LEN + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> colors;</span><br><span class="line">			<span class="keyword">int</span> sizes;</span><br><span class="line">	 	&#125; shirt;</span><br><span class="line">	&#125; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构体实例</span></span><br><span class="line">	<span class="keyword">struct</span> catalog_item bookItem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为结构体中的联合的成员赋值</span></span><br><span class="line">	<span class="built_in">strcpy</span>(bookItem.item.book.title, <span class="string">"three body"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问结构题中的联合的成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, bookItem.item.book.title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-2-使用联合来构造混合的数据结构"><a href="#16-4-2-使用联合来构造混合的数据结构" class="headerlink" title="16.4.2    使用联合来构造混合的数据结构"></a>16.4.2    使用联合来构造混合的数据结构</h3><blockquote>
<p><strong>说明：</strong>创建含有不同数据类型的混合数据结构（比如数组）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 混合数据类型，包含整型和浮点型</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;union&#125; Number</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明混合型数组</span></span><br><span class="line">	Number number_array[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	number_array[<span class="number">0</span>].i = <span class="number">5</span>; <span class="comment">// 第一个值为整型</span></span><br><span class="line">	number_array[<span class="number">1</span>].f = <span class="number">3.14</span>; <span class="comment">// 第二个值为浮点型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number_array[<span class="number">0</span>].i); <span class="comment">// 5</span></span><br><span class="line">	</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-4-3-为联合添加“标记字段”"><a href="#16-4-3-为联合添加“标记字段”" class="headerlink" title="16.4.3    为联合添加“标记字段”"></a>16.4.3    为联合添加“标记字段”</h3><blockquote>
<p><strong>用途：</strong>为联合提供额外的当前类型信息，防止获取到无意义的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_KIND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_KIND 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * @typedef &#123;struct&#125; </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> kind; <span class="comment">// 标记字段</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据数据结构的类型以不同的方式打印值</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;struct&#125; n 要打印的数据结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明结构实例</span></span><br><span class="line">	Number n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记字段</span></span><br><span class="line">	n.kind = INT_KIND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	n.u.i = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印出来</span></span><br><span class="line">	print_number(n); <span class="comment">// 82</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n.kind == INT_KIND) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n.u.i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%g\n"</span>, n.u.f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-5-枚举"><a href="#16-5-枚举" class="headerlink" title="16.5    枚举"></a>16.5    枚举</h2><blockquote>
<p><strong>说明：</strong><code>enum</code>是一种由程序员列出值的类型，而且程序员必须为每种值（枚举常量）命名。<br><strong>特点：</strong></p>
<ul>
<li>遵循到c语言的作用域规则（如果枚举声明在函数体内，那么它的常量对外部函数是不可见的）</li>
<li>声明的方式类似结构和联合</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的声明方式：定义枚举类型的同时声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-1-枚举标记和枚举类型"><a href="#16-5-1-枚举标记和枚举类型" class="headerlink" title="16.5.1    枚举标记和枚举类型"></a>16.5.1    枚举标记和枚举类型</h3><blockquote>
<p><strong>说明：</strong>类似结构和联合的标记，有两种方式。</p>
</blockquote>
<h5 id="方式1：enum-标记名-可能值"><a href="#方式1：enum-标记名-可能值" class="headerlink" title="方式1：enum 标记名 {可能值}"></a>方式1：<code>enum 标记名 {可能值}</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> suit s1, s2;</span><br></pre></td></tr></table></figure>
<h5 id="方式2：typedef-enum-可能值-类型名"><a href="#方式2：typedef-enum-可能值-类型名" class="headerlink" title="方式2：typedef enum {可能值} 类型名"></a>方式2：<code>typedef enum {可能值} 类型名</code></h5><blockquote>
<p><strong>技巧：</strong>利用<code>typedef</code>来创建布尔类型是非常好的一种方法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; Suit;</span><br><span class="line">Suit s1, s2;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-2-枚举作为整数"><a href="#16-5-2-枚举作为整数" class="headerlink" title="16.5.2    枚举作为整数"></a>16.5.2    枚举作为整数</h3><blockquote>
<p><strong>说明：</strong>在系统内部，c语言会把枚举变量和常量作为整数处理。</p>
<ul>
<li>当没有为枚举常量指定值时，它的值时一个大于前一个常量的值（默认第一个枚举常量的值为0）</li>
<li>可以为枚举常量自由选择不同的值</li>
<li>当为枚举常量指定值时，对大小顺序没有要求</li>
<li>两个或多个枚举常量具有相同的值也是合法的</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS = <span class="number">20</span>, DIAMONDS = <span class="number">10</span>, HEARTS, SPADES&#125;; <span class="comment">// 20, 10, 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>把整数用作枚举的值是非常危险的，<code>c++</code>不允许整数用作枚举的值来使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">enum</span> suit &#123;CLUBS, DIAMONDS, HEARTS, SPADES&#125; s;</span><br><span class="line">i = DIAMONDS;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">s++;</span><br><span class="line">i = s + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="16-5-3-用枚举声明“标记字段”"><a href="#16-5-3-用枚举声明“标记字段”" class="headerlink" title="16.5.3    用枚举声明“标记字段”"></a>16.5.3    用枚举声明“标记字段”</h3><blockquote>
<p><strong>说明：</strong><code>enum</code>和<code>union</code>配合实现<code>union</code>的“标记字段”。<br><strong>优点：</strong></p>
<ul>
<li>不需要额外定义宏</li>
<li>明确类型的可能值范围</li>
<li>含义更明确</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedeg <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">enum</span> &#123;INT_KIND, FLOAT_KIND&#125; kind;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">float</span> f;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/10/15 编写大规模程序/" itemprop="url">
                  15 编写大规模程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-10T10:39:04+08:00" content="2016-05-10">
              2016-05-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/10/15 编写大规模程序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/10/15 编写大规模程序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="15-1-源文件"><a href="#15-1-源文件" class="headerlink" title="15.1    源文件"></a>15.1    源文件</h2><blockquote>
<p><strong>说明：</strong>可以把程序分割成一定数量的源文件(.c文件和.h文件)。</p>
<ul>
<li>原文件的扩展名为.c，每个原文件包含程序的部分内容，主要是函数的定义和变量</li>
<li>一个原文件必须包含名为main的函数，次函数作为程序的起始点</li>
</ul>
<p><strong>优点：</strong>把程序分裂成多个源文件有许多显著的优点。</p>
<ul>
<li>（易读）把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构</li>
<li>（易维护）可以单独对每一个文件进行编译。</li>
<li>（易复用）当把函数集合在单独的源文件中时，会更容易在其他程序中重新使用这些函数。</li>
</ul>
</blockquote>
<h3 id="案例－计算器："><a href="#案例－计算器：" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h3><blockquote>
<p><strong>逆波兰符号（Reverse Polish Notation, RPN）：</strong>指运算符都跟在操作数的后边。例如：<code>30 5 - 7 *</code>。<br><strong>思路：</strong>程序逐个读入操作数和运算符，那么利用栈跟踪中间结果这样的方式计算逆波兰表达式是很容易的。</p>
<ol>
<li>读取“记号”（数或运算符）</li>
<li>如果程序读取数，就将此数压入栈</li>
<li>如果程序读取运算符，那么将从栈顶弹出两个数进行相应的计算。</li>
</ol>
</blockquote>
<h2 id="15-2-头文件"><a href="#15-2-头文件" class="headerlink" title="15.2    头文件"></a>15.2    头文件</h2><blockquote>
<p><strong>说明：</strong>如果打算几个源文件可以访问相同的信息，那么将把此信息放在文件中，扩展名为<code>.h</code>，然后利用<code>#include</code>指令把文件的内容带进每个源文件中。这样的<code>.h</code>文件就是头文件（或包含文件）。</p>
</blockquote>
<h3 id="15-2-1-include指令"><a href="#15-2-1-include指令" class="headerlink" title="15.2.1    #include指令"></a>15.2.1    #include指令</h3><p><strong>语法：</strong>有两种格式，其中的<code>文件名</code>可以包含路径或驱动器号。而且预处理器不会讲<code>&quot;文件名&quot;</code>当作字符串处理了，不然DOS路径中的某些字符有可能被当作转义字符。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>搜索目标</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>#include &lt;文件名&gt;</td>
<td>系统头文件所在的目录</td>
<td>有可能是多个，通常是/usr/include</td>
</tr>
<tr>
<td>#include “文件名”</td>
<td>搜索当前目录，然后搜索系统头文件所在的目录</td>
<td>可以通过诸如-I选项修改搜索目录</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"c:\cprogs\utils.h"</span>/*DOS path*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"/cprogs/utils.h"</span>/*UNIX path*/</span></span><br></pre></td></tr></table></figure>
<p><strong>可移植性技巧：</strong>不要在<code>#include</code>指令中包含路径或驱动器信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys\stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;..\include\utils.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-共享宏定义和类型定义"><a href="#15-2-2-共享宏定义和类型定义" class="headerlink" title="15.2.2    共享宏定义和类型定义"></a>15.2.2    共享宏定义和类型定义</h3><blockquote>
<p><strong>说明：</strong>将通用的宏定义和类型定义放在头文件中有许多明显的好处。</p>
<ul>
<li>不用频繁复制代码</li>
<li>易于修改和维护</li>
<li>避免犹豫原文件包含相同宏或类型的不同定义而导致的矛盾</li>
</ul>
</blockquote>
<p><em>boolean.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-共享函数原型"><a href="#15-2-3-共享函数原型" class="headerlink" title="15.2.3    共享函数原型"></a>15.2.3    共享函数原型</h3><blockquote>
<p><strong>说明：</strong>为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。<br><strong>技巧：</strong>为了保证函数原型声明一致，声明部分单独放在一个头文件中。然后在定义和调用的源文件中都引入该头文件。<br><strong>注意：</strong>在调用在其他文件中的函数时，要始终确保编译器在调用之前看到函数的原型。</p>
</blockquote>
<h4 id="案例－计算器：-1"><a href="#案例－计算器：-1" class="headerlink" title="案例－计算器："></a><em>案例－计算器：</em></h4><p><em>1. 头文件：<code>stack.h</code></em></p>
<blockquote>
<p><strong>说明：</strong>包含共享的函数的原型声明。<br><strong>注意：</strong>只在<code>calc.c</code>中使用的的函数不应该定义在该头文件中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>2. 函数定义：<code>stack.c</code></em></p>
<blockquote>
<p><strong>说明：</strong>实现stack.c中声明的所有函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> contents[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"what"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>3. 入口文件：<code>calc.c</code></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//编译器会通过stack.h中make_empty的原型找到对应的定义，从而正确调用</span></span><br><span class="line">	make_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>编译运行</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o calc calc.c stack.c</span><br><span class="line">$ ./calc </span><br><span class="line"> what</span><br></pre></td></tr></table></figure>
<h3 id="15-2-4-共享变量声明"><a href="#15-2-4-共享变量声明" class="headerlink" title="15.2.4    共享变量声明"></a>15.2.4    共享变量声明</h3><blockquote>
<p><strong>说明：</strong>为了共享变量<code>i</code>，首先把变量i的定义（和初始化）放置在一个文件中，而在其他文件中包含变量<code>i</code>的声明（使用关键字<code>extern</code>）。<br><strong>变量声明：</strong><code>extern</code></p>
<ul>
<li>类似函数的声明，仅声明变量名和类型（内存不会为其分配空间）</li>
<li>通常情况下我们不使用<code>extern</code>，这种情况下变量声明和定义同时完成</li>
<li>可以用于所有类型的变量</li>
<li>在数组的声明中使用<code>extern</code>时可以忽略数组的长度<code>extern int a[];</code></li>
<li>编译器无法检查<code>变量声明</code>是否和<code>变量定义</code>严格匹配，因此有可能出现和声明类型不一致的定义，这会导致程序的异常行为</li>
</ul>
<p><strong>技巧：</strong>通常把共享的变量的声明放置在头文件中，需要访问该共享变量的源文件中引入该头文件。同时如果变量的定义在其它源文件（而不是入口文件中），则也需要引入该头文件。<br><strong>扩展：</strong>虽然在文件中共享变量是<code>c</code>语言界的长期惯例，但是它有重大缺陷。<code>19.2</code>节有如何设计不需要共享变量的程序的知识。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern提示编译器变量i是在程序的其它位置定义的（同一文件或不同文件）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-5-嵌套包含"><a href="#15-2-5-嵌套包含" class="headerlink" title="15.2.5    嵌套包含"></a>15.2.5    嵌套包含</h3><blockquote>
<p><strong>说明：</strong>头文件自身可以包含<code>#include</code>指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"boolean.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Bool <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-6-保护头文件"><a href="#15-2-6-保护头文件" class="headerlink" title="15.2.6    保护头文件"></a>15.2.6    保护头文件</h3><blockquote>
<p><strong>为什么保护：</strong>如果源文件包含同一个文件两次（直接或间接），那么可能（如果包含类型定义）会产生编译错误。</p>
<ul>
<li>避免由重复的类型定义导致的编译错误</li>
<li>节约编译时间</li>
</ul>
<p><strong>如何保护：</strong>为了防止头文件多次包含导致的多次编译，将用<code>#ifndef</code>和<code>#endif</code>两个指令把文件闭合起来。在预编译阶段去重复掉引入的头文件的代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BOOLEAN_H是按照所在头文件名(BOOLEAN.h)进行命名的，目的是避免和其它头文件中的宏冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-7-头文件中的-error指令"><a href="#15-2-7-头文件中的-error指令" class="headerlink" title="15.2.7    头文件中的#error指令"></a>15.2.7    头文件中的#error指令</h3><blockquote>
<p><strong>用途：</strong>放在头文件中用来检查不应该包含头文件的条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在DOS程序中才能正常使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOS</span></span><br><span class="line">	<span class="comment">//如果非DOS程序试图包含此头文件，那么编译将在#error指令处停止</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">error</span> Grapphics supported only under DOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="15-3-把程序划分成多个文件（程序：文本格式化）"><a href="#15-3-把程序划分成多个文件（程序：文本格式化）" class="headerlink" title="15.3    把程序划分成多个文件（程序：文本格式化）"></a>15.3    把程序划分成多个文件（程序：文本格式化）</h2><blockquote>
<p><strong>功能分析：</strong>能够将输入的文本格式化的命令行工具。</p>
<ul>
<li>“删除空行、制表符”</li>
<li>“填充”：添加单词直到再多一个单词就会导致溢出时才停止</li>
<li>“调整”：除最后一行外，在单词间添加额外的空格以便每行有精确的相同长度（60个字符）</li>
</ul>
</blockquote>
<h2 id="15-4-构建多文件程序"><a href="#15-4-构建多文件程序" class="headerlink" title="15.4    构建多文件程序"></a>15.4    构建多文件程序</h2><blockquote>
<p><strong>原理：</strong>大多数编译器允许一步完成编译和链接的过程。</p>
<ol>
<li><strong>编译：</strong>对每个源文件（不包括头文件）分别进行编译</li>
<li><strong>链接：</strong>把上一步产生的目标文件和库函数的代码结合在一起生成可执行的程序。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-o告诉编译器最终的可执行文件的名字</span></span><br><span class="line">$ gcc -o fmt fmt.c line.c word.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-1-makefile"><a href="#15-4-1-makefile" class="headerlink" title="15.4.1    makefile"></a>15.4.1    makefile</h3><p><strong>命令行编译的缺点：</strong></p>
<ul>
<li>枯燥乏味（敲没有营养的编译命令）</li>
<li>浪费时间，所有源文件每次都会被重新编译</li>
<li>构建大规模程序费时费力易出错</li>
</ul>
<p><strong>说明：</strong>Unix系统发明了makefile的概念，这个文件包含构建程序的必要信息。</p>
<ol>
<li>列出了作为程序部分的文件</li>
<li>描述了文件之间的依赖性</li>
</ol>
<p><strong>基本语法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件名:依赖的文件</span><br><span class="line">[tab]命令</span><br></pre></td></tr></table></figure>
<p><strong>扩展：</strong>不是每个人都使用makefile，其它程序维护工具正变得流行，包括一些集成开发环境支持的“工程文件”。</p>
<h4 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt:fmt.o word.o line.o</span><br><span class="line">	gcc -o fmt fmt.o word.o line.o</span><br><span class="line">fmt.o:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.o:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.o:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h4 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.exe:fmt.obj word.obj line.obj</span><br><span class="line">	gcc -o fmt fmt.obj word.obj line.obj</span><br><span class="line">fmt.obj:fmt.c word.h line.h</span><br><span class="line">	gcc -c fmt.c</span><br><span class="line">word.obj:word.c word.h</span><br><span class="line">	gcc -c word.c</span><br><span class="line">line.obj:line.c line.h</span><br><span class="line">	gcc -c line.c</span><br></pre></td></tr></table></figure>
<h3 id="15-4-2-链接期间的错误"><a href="#15-4-2-链接期间的错误" class="headerlink" title="15.4.2    链接期间的错误"></a>15.4.2    链接期间的错误</h3><blockquote>
<p><strong>常见错误：</strong></p>
<ol>
<li>Undefined symbol</li>
<li>Unresollved external reference</li>
</ol>
<p><strong>起因：</strong>程序中丢失了函数定义或变量定义，那么链接器将无法解决外部引用。</p>
<ol>
<li>拼写错误</li>
<li>丢失文件</li>
<li>丢失库</li>
</ol>
</blockquote>
<h3 id="15-4-3-重新构建程序"><a href="#15-4-3-重新构建程序" class="headerlink" title="15.4.3    重新构建程序"></a>15.4.3    重新构建程序</h3><blockquote>
<p><strong>两种情况：</strong>无论哪个文件发生变化，重新编译后都需要重新链接整个程序。</p>
<ol>
<li>变化影响单独一个源文件：只对此文件进行重新编译</li>
<li>变化影响头文件：重新编译所有包含此头文件的源文件</li>
</ol>
<p><strong>使用makefile重新构建：</strong>通过检查每个文件的日期，makex可以确定从程序最后一次构建后哪些文件发生了变化。然后根据依赖关系判断如何重新编译。</p>
</blockquote>
<h3 id="15-4-4-在程序外定义宏"><a href="#15-4-4-在程序外定义宏" class="headerlink" title="15.4.4    在程序外定义宏"></a>15.4.4    在程序外定义宏</h3><blockquote>
<p><strong>意义：</strong>不需要编辑任何程序文件就对宏的值进行改变。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D</td>
<td>在命令行指定宏的值</td>
<td>大多数UNIX编译器和某些非UNIX编译器</td>
</tr>
<tr>
<td>-U</td>
<td>取消指定宏的定义</td>
<td>一些编译器</td>
</tr>
</tbody>
</table>
<p><em>foo.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br></pre></td></tr></table></figure>
<p><em>命令行</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DDEBUG=1 foo.c</span><br><span class="line"># gcc -UDEBUG foo.c</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">94</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
