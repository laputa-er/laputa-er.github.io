<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Objective-C基础教程第二版," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="14.1    代码块
说明：代码块是由C语言实现的，是对C语言中函数的扩展。支持的语言：Objective-C、C 、C++、Objective-C++用途：替代函数或实现闭包现状：代码块在Xcode的GCC和CLang工具中是有效的，但它不属于ANSI的C语言标准。关于代码块的提议已经提交给C语言标准团体。

14.1.1    代码块和函数指针
说明：代码块的语法借鉴了函数指针

返回类型可">
<meta property="og:type" content="article">
<meta property="og:title" content="14 代码块和并发行">
<meta property="og:url" content="http://laputa-er.github.io/2016/05/13/o-c基础教程第二版_14 代码块和并发性/index.html">
<meta property="og:site_name" content="Sean">
<meta property="og:description" content="14.1    代码块
说明：代码块是由C语言实现的，是对C语言中函数的扩展。支持的语言：Objective-C、C 、C++、Objective-C++用途：替代函数或实现闭包现状：代码块在Xcode的GCC和CLang工具中是有效的，但它不属于ANSI的C语言标准。关于代码块的提议已经提交给C语言标准团体。

14.1.1    代码块和函数指针
说明：代码块的语法借鉴了函数指针

返回类型可">
<meta property="og:updated_time" content="2016-05-13T10:34:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="14 代码块和并发行">
<meta name="twitter:description" content="14.1    代码块
说明：代码块是由C语言实现的，是对C语言中函数的扩展。支持的语言：Objective-C、C 、C++、Objective-C++用途：替代函数或实现闭包现状：代码块在Xcode的GCC和CLang工具中是有效的，但它不属于ANSI的C语言标准。关于代码块的提议已经提交给C语言标准团体。

14.1.1    代码块和函数指针
说明：代码块的语法借鉴了函数指针

返回类型可">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://laputa-er.github.io/2016/05/13/o-c基础教程第二版_14 代码块和并发性/"/>

  <title> 14 代码块和并发行 | Sean </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sean</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">笔记分享</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                14 代码块和并发行
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T10:41:10+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/13/o-c基础教程第二版_14 代码块和并发性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/13/o-c基础教程第二版_14 代码块和并发性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="14-1-代码块"><a href="#14-1-代码块" class="headerlink" title="14.1    代码块"></a>14.1    代码块</h2><blockquote>
<p><strong>说明：</strong><code>代码块</code>是由C语言实现的，是对C语言中函数的扩展。<br><strong>支持的语言：</strong><code>Objective-C</code>、<code>C</code> 、<code>C++</code>、<code>Objective-C++</code><br><strong>用途：</strong><code>替代函数</code>或实现<code>闭包</code><br><strong>现状：</strong><code>代码块</code>在<code>Xcode</code>的<code>GCC</code>和<code>CLang</code>工具中是有效的，但它不属于<code>ANSI</code>的<code>C</code>语言标准。关于代码块的提议已经提交给C语言标准团体。</p>
</blockquote>
<h3 id="14-1-1-代码块和函数指针"><a href="#14-1-1-代码块和函数指针" class="headerlink" title="14.1.1    代码块和函数指针"></a>14.1.1    代码块和函数指针</h3><blockquote>
<p><strong>说明：</strong><code>代码块</code>的语法借鉴了<code>函数指针</code></p>
<ul>
<li><strong>返回类型</strong>可以手动声明也可以由编译器通过代码块推导</li>
<li>具有指定类型的<strong>参数</strong>列表</li>
<li>拥有<strong>名称</strong></li>
<li>代码放在<code>{}</code>中</li>
</ul>
<p><strong>语法：</strong><code>&lt;returntype&gt; (^blockname)(list of arguments) = ^(arguments){body;}</code><br><em>实现部分推导出返回值类型</em></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现部分省略了返回值类型，没有参数列表</span></span><br><span class="line"><span class="keyword">void</span> (^theBlock)() = ^&#123;</span><br><span class="line">	printf(<span class="string">"Hello Blocks!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定义并实现代码块 square_block</span><br><span class="line">* 计算乘方</span><br><span class="line">* @param &#123;int&#125; number 数值</span><br><span class="line">* @return &#123;int&#125; number 乘方结果</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> (^square_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="keyword">return</span> (number * number);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="keyword">int</span> result = square_block(<span class="number">5</span>);</span><br><span class="line">printf(<span class="string">"Result = %d\n"</span>, result);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-1-通过代码块名调用代码块"><a href="#14-1-1-1-通过代码块名调用代码块" class="headerlink" title="14.1.1.1    通过代码块名调用代码块"></a>14.1.1.1    通过代码块名调用代码块</h4><blockquote>
<p><strong>说明：</strong>可以像调用<code>函数</code>一样调用<code>代码块</code>。<br><strong>比函数强大：</strong>代码块可以访问与它相同的有效范围内声明的变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化变量：声明时的作用域和代码块相同</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">int</span> (^multiply_block)(<span class="keyword">int</span> number) = ^(<span class="keyword">int</span> number) &#123;</span><br><span class="line">	<span class="comment">// 访问外部同作用域声明的变量</span></span><br><span class="line">	<span class="keyword">return</span> (value * number);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-2-直接调用代码块（匿名）"><a href="#14-1-1-2-直接调用代码块（匿名）" class="headerlink" title="14.1.1.2    直接调用代码块（匿名）"></a>14.1.1.2    直接调用代码块（匿名）</h4><blockquote>
<p><strong>说明：</strong>使用代码块时通常不需要创建一个代码块变量，而是在代码中内联代码块的内容。<br><strong>使用场景：</strong>作为参数传递给方法或函数</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"Amir"</span>, <span class="string">@"Mishal"</span>, <span class="string">@"Irrum"</span>, <span class="string">@"Adam"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Unsorted Array %@"</span>, array);</span><br><span class="line"><span class="comment">// 传递匿名代码块</span></span><br><span class="line"><span class="built_in">NSArray</span> *soredArray = [array sortedArrayUsingComparator: ^(<span class="built_in">NSString</span> *object1, <span class="built_in">NSString</span> *object2)] &#123;</span><br><span class="line">	<span class="keyword">return</span> [object1 compare: object2];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Sorted Array %@"</span>, sortedArray);</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-3-使用typedef关键字"><a href="#14-1-1-3-使用typedef关键字" class="headerlink" title="14.1.1.3    使用typedef关键字"></a>14.1.1.3    使用<code>typedef</code>关键字</h4><blockquote>
<p><strong>说明：</strong>将<code>代码块</code>声明定义为一种类型，更易于代码的编写。<br><strong>语法：</strong><code>typedef 代码块定义;</code><br><strong>注意：</strong><code>typedef</code>后面的<code>代码块</code>定义中的代码块名不再具备<code>代码块名</code>的功能，而是一种类型名。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将代码块定义为一种类型： MKSampleMultiply2BlockRef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 使用新类型创建代码块</span></span><br><span class="line"><span class="built_in">MKSampleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line">printf(<span class="string">"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h4 id="14-1-1-4-代码块和变量"><a href="#14-1-1-4-代码块和变量" class="headerlink" title="14.1.1.4    代码块和变量"></a>14.1.1.4    代码块和变量</h4><blockquote>
<p><strong>说明：</strong>代码块被声明后会捕捉到创建时的上下文中的变量或函数。</p>
<ul>
<li>全局变量（包括在封闭范围内声明的本地静态变量）</li>
<li>全局函数</li>
<li>封闭范围内的参数</li>
<li><code>Objective-C</code>的实例变量</li>
<li>代码块内部的本地变量</li>
</ul>
</blockquote>
<h5 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h5><blockquote>
<p><strong>说明：</strong>与代码块在同一范围内声明的变量。<br><strong>捕获情况：</strong>代码块会在定义时把本地变量当作<code>常量</code>复制并保存它们的状态。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiplyBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 本地变量</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 声明并实现代码块，复制并保存状态</span></span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	reutrn a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改本地变量</span></span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">b = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><blockquote>
<p><strong>说明：</strong>可以根据需要将变量标记为<code>静态的（全局的）</code>。<br><strong>捕获情况：</strong>同本地变量。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">MKSimpleMultiplyBlockRef</span> multiply = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, multiply());<span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h5 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h5><blockquote>
<p><strong>说明：</strong>代码块中的参数变量与函数中的参数变量具有相同的作用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义代码块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> (^<span class="built_in">MKSampleMultiply2BlockRef</span>)(<span class="keyword">double</span> c, <span class="keyword">double</span> d);</span><br><span class="line"><span class="comment">// 声明并实现代码块</span></span><br><span class="line"><span class="built_in">MKSimpleMultiply2BlockRef</span> multiply2 = ^(<span class="keyword">double</span> c, <span class="keyword">double</span> d) &#123;</span><br><span class="line">	<span class="keyword">return</span> c * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f, %f"</span>, multiply2(<span class="number">4</span>, <span class="number">5</span>), multiply2(<span class="number">5</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h5 id="block变量"><a href="#block变量" class="headerlink" title="_block变量"></a>_block变量</h5><blockquote>
<p><strong>关键字：</strong><code>_block</code><br><strong>说明：</strong><code>本地变量</code>会被<code>代码块</code>当作<code>常量</code>获取到，如果想要修改它们的值，必须通过<code>_black</code>将它们声明为<code>可修改</code>的。<br><strong>限制：</strong>由两种情况不能使用<code>_block</code>修饰</p>
<ul>
<li>长度可变数组</li>
<li>包含长度可变数组的结构体</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用_block 修饰，使变量 c 在代码块中的副本可修改</span></span><br><span class="line">_block <span class="keyword">double</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">MKSampleMultiplyBlockRef</span> multiply = ^(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">	c = a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="代码块内部的本地变量"><a href="#代码块内部的本地变量" class="headerlink" title="代码块内部的本地变量"></a>代码块内部的本地变量</h5><blockquote>
<p><strong>说明：</strong>对<code>代码块来说</code>，和<code>本地变量</code>一样使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义并实现代码块</span></span><br><span class="line"><span class="keyword">void</span> (^<span class="built_in">MKSampleBlockRef</span>)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">	<span class="keyword">double</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, a * c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用代码块</span></span><br><span class="line"><span class="built_in">MKSimpleBlockRef</span>();</span><br></pre></td></tr></table></figure>
<h3 id="14-1-2-Objective-C代码块内存管理"><a href="#14-1-2-Objective-C代码块内存管理" class="headerlink" title="14.1.2    Objective-C代码块内存管理"></a>14.1.2    Objective-C代码块内存管理</h3><blockquote>
<p><strong>说明：</strong>代码块是对象，所以可以向它发送任何与内存管理由关的信息。</p>
<ul>
<li>如果引用了一个<code>Objective-C</code>对象，必须要<code>保留</code>它</li>
<li>如果类的方法中的<code>代码块</code>通过引用访问了一个实例变量，要<code>保留</code>一次<code>self</code>（执行所在方法的对象）</li>
<li>如果通过数值访问了一个实例变量，变量需要<code>保留</code></li>
</ul>
</blockquote>
<p><em>ProcessString.h：方法中包含代码块的类</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProcessStrings</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>ProcessString.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProcessStrings</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> theString = _theString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyString</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 代码块1</span></span><br><span class="line">    <span class="built_in">NSString</span> *string1 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则2：直接通过引用（实例变量名）访问了实例变量，若没有ARC则应该保留self</span></span><br><span class="line">        <span class="keyword">return</span> [_theString stringByAppendingString:_theString];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *localObject = _theString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块2</span></span><br><span class="line">    <span class="built_in">NSString</span> *string2 = ^&#123;</span><br><span class="line">    	<span class="comment">// 规则3: 通过中间变量间接访问了实例变量，如果没有ARC则要保留localObject</span></span><br><span class="line">        <span class="keyword">return</span> [localObject stringByAppendingString:localObject];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ProcessStrings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessStrings *myStringProcessor = [[ProcessStrings alloc] init];</span><br><span class="line">        myStringProcessor.theString = <span class="string">@"Hello Objective Blocks!"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用对象中包含代码块的方法</span></span><br><span class="line">        [myStringProcessor testMyString];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>扩展：</strong>在C语言中，必须使用<code>Block_copy()</code>和<code>Block_release()</code>函数来适当地管理内存。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^<span class="built_in">MKSampleVoidBlockRef</span>)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block1 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block1"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block1();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">MKSampleVoidBlockRef</span> block2 = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Block2"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block2();</span><br><span class="line">        Block_release(block2);</span><br><span class="line">        </span><br><span class="line">        block2 = Block_copy(block1);</span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-2-并发性"><a href="#14-2-并发性" class="headerlink" title="14.2    并发性"></a>14.2    并发性</h2><blockquote>
<p><strong>说明：</strong>能够在同一时间执行多个任务的程序称为<code>并发的(concurrent)</code>程序。苹果公司提供了多种可以利用多核特性的<code>API</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>相关技术选择</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSIX线程</td>
<td>利用并发行最基础的方法是使用<code>POSIX</code>线程来处理程序的不同部分使其能够独立运行。<code>POSIX线程</code>拥有支持<code>C</code>和<code>Objective-C</code>的API。</td>
<td>因为线程是级别较低的API，必须手动管理，挑战很大</td>
</tr>
<tr>
<td>GDC(Grand Central Dipatch)</td>
<td>运行在系统级别，减少了不少线程管理的麻烦</td>
<td>可以平衡应用程序所有内同的家在，从而提高计算机或设备的运行效率</td>
</tr>
</tbody>
</table>
<h3 id="14-2-1-同步"><a href="#14-2-1-同步" class="headerlink" title="14.2.1    同步"></a>14.2.1    同步</h3><blockquote>
<p><strong>关键字：</strong><code>@synchronized</code><br><strong>说明：</strong>用来设置<code>临界区</code>，确保多个线程不会在同一时间进入<code>临界区</code>。<br><strong>相关：</strong><code>@property</code>指令的<code>atomic</code>特性会让编译器通过插入<code>@synchronize(mutex, atomic)</code>生成强制彼此互斥的<code>getter</code>和<code>setter</code>方法（降低了代码性能），而<code>nonatomic</code>特性（默认）则不会。</p>
</blockquote>
<h4 id="14-2-1-1-选择性能"><a href="#14-2-1-1-选择性能" class="headerlink" title="14.2.1.1    选择性能"></a>14.2.1.1    选择性能</h4><blockquote>
<p><strong>说明：</strong><code>NSObject</code>提供了一些可以使代码在后台以较低性能运行的方法（方法名带有<code>performSelector</code>前缀）</p>
</blockquote>
<h5 id="performSelectorInBackground实例方法"><a href="#performSelectorInBackground实例方法" class="headerlink" title="performSelectorInBackground实例方法"></a>performSelectorInBackground实例方法</h5><blockquote>
<p><strong>说明：</strong>通过创建一个线程，在后端运行一个指定的方法。<br><strong>限制：</strong>指定运行的方法（第一个参数）要遵从以下限制</p>
<ul>
<li>方法中需要<code>@autoreleasepool</code></li>
<li>方法不能有返回值，参数最多一个且必须为<code>id</code>类型</li>
</ul>
<ol>
<li><code>- (void) myMethod;</code></li>
<li><code>- (void) myMethod:(id)myObject;</code></li>
</ol>
<p><strong>原型：</strong><code>NSObject</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;SEL&#125; 希望在后台运行的方法</span><br><span class="line">* @param &#123;id&#125; object 可以传递一个对象</span><br><span class="line">*/</span></span><br><span class="line">(<span class="keyword">void</span>) performSelectorInBackground:(nonnull SEL) withObject:(nullable <span class="keyword">id</span>)&gt;</span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.h</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SelectorTester</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>SelectorTester.m</em></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SelectorTester.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SelectorTester</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  封装对性能选择器的调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) runSelectors &#123;</span><br><span class="line">    <span class="comment">// 在后端运行不带参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod1) withObject:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 在后端运行带一个参数的方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(myBackgroundMethod2:) withObject:<span class="string">@"Hello Selector"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Done performing selectors"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：不带参数</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod1 &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  @pravite</span><br><span class="line"> *  会被选择器调用的方法：只有一个参数</span><br><span class="line"> *  @param &#123;id&#125; object 一个对象</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) myBackgroundMethod2: (<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myBackgroundMethod2 %@"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="14-2-1-2-调度队列"><a href="#14-2-1-2-调度队列" class="headerlink" title="14.2.1.2    调度队列"></a>14.2.1.2    调度队列</h4><blockquote>
<p><strong>说明：</strong><code>GDC</code>可以使用<code>调度队列（dispatch queue）</code>，共有3种。</p>
</blockquote>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>说明</th>
<th>并行／串行</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>连续队列</td>
<td>根据指派的顺序执行任务</td>
<td>串行，先入先出（FIFO，栈）</td>
<td>可以创建多个<code>连续</code>队列，彼此并行</td>
</tr>
<tr>
<td>并发队列</td>
<td>并发执行一个或多个任务</td>
<td>并行，根据指派到队列的顺序开始执行</td>
<td>无法创建，只能从系统提供的并发队列中选择（一共3个）</td>
</tr>
<tr>
<td>主队列</td>
<td>应用程序的有效的主队列</td>
<td>主线程只有一个，无所谓串/并行</td>
<td>执行的应用程序的主线程任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>调度队列数据类型：</strong><code>dispatch_queue_t</code></p>
</blockquote>
<h5 id="连续队列"><a href="#连续队列" class="headerlink" title="连续队列"></a>连续队列</h5><blockquote>
<p><strong>说明：</strong>只要任务是异步提交的，队列会确保任务根据预定顺序执行，不会发生死锁。<br><strong>适用：</strong>一连串的任务需要按照一定的顺序执行的场景</p>
</blockquote>
<h6 id="dispatch-queue-create全局方法"><a href="#dispatch-queue-create全局方法" class="headerlink" title="dispatch_queue_create全局方法"></a>dispatch_queue_create全局方法</h6><blockquote>
<p><strong>说明：</strong>创建连续队列<br><strong>原型：</strong></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;const char *&#125; label 队列的名称</span><br><span class="line">* @param &#123;dispatch_queue_attr_t&#125; attr 队列的特性（可以为NULL）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明连续队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_serial_queue;</span><br><span class="line"><span class="comment">// 创建连续队列</span></span><br><span class="line">my_serial_queue = dispatch_queue_create(<span class="string">"com.apress.MySerialQueue1"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h5 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h5><blockquote>
<p><strong>说明：</strong>并发调度队列适用于那些可以并行运行的任务</p>
<ul>
<li>开始执行时间遵从FIFO</li>
<li>任务可以在前一个任务结束前就开始执行</li>
<li>一次所运行的任务数量是无法预测的（根据其它运行的任务的状况）</li>
</ul>
<p><strong>技巧：</strong>如果需要确保每次运行的任务的数量都是一样的，可以通过线程<code>API</code>来手动管理线程。</p>
</blockquote>
<h6 id="dispatch-get-global-queue全局方法"><a href="#dispatch-get-global-queue全局方法" class="headerlink" title="dispatch_get_global_queue全局方法"></a>dispatch_get_global_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取系统的并发队列。<br><strong>原型：</strong><code>/usr/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long&#125; identifier 优先级选项</span><br><span class="line">* @param &#123;unsigned long&#125; flags 标记（可以为0）</span><br><span class="line">* @return &#123;dispatch_queue_t&#125; 顺序队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">long</span> identifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> my_global_queue;</span><br><span class="line"><span class="comment">// 获取并发队列（默认优先级）</span></span><br><span class="line">my_global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h5><h6 id="dispatch-get-current-queue全局方法"><a href="#dispatch-get-current-queue全局方法" class="headerlink" title="dispatch_get_current_queue全局方法"></a>dispatch_get_current_queue全局方法</h6><blockquote>
<p><strong>说明：</strong>获取<code>当前运行的</code>队列代码块，如果在代码块的对象之外调用了这个函数，则它会返回<code>主队列</code>。<br><strong>注意：</strong>该方法在从<code>OS X 10.9</code>和<code>ios 6</code>开始被废弃，因为GCD队列本身是不可重入的，同步阻塞会导致死锁。<br><strong>用途：</strong>仍然可以作为调试手段在代码中使用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程或当前队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> theQueue = dispatch_get_current_queue();</span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-队列也要内存管理"><a href="#14-2-2-队列也要内存管理" class="headerlink" title="14.2.2    队列也要内存管理"></a>14.2.2    队列也要内存管理</h3><blockquote>
<p><strong>说明：</strong><code>调度队列</code>是引用计数对象，可以使用<code>dispatch_retain()</code>和<code>dispatch_release()</code>来修改队列的保留计数器的值。</p>
</blockquote>
<h4 id="14-2-2-1-队列的上下文"><a href="#14-2-2-1-队列的上下文" class="headerlink" title="14.2.2.1    队列的上下文"></a>14.2.2.1    队列的上下文</h4><blockquote>
<p><strong>说明：</strong>可以向<code>调度对象（包括调度队列）</code>指派<code>全局数据上下文</code>，可以在上下文中指派任意类型的数据，比如<code>Objective-C</code>对象或指针。<br><strong>内存管理：</strong>必须在需要<code>队列上下文</code>的时候分配内存并在队列销毁之前进行清理。</p>
</blockquote>
<h5 id="dispatch-set-context全局方法"><a href="#dispatch-set-context全局方法" class="headerlink" title="dispatch_set_context全局方法"></a>dispatch_set_context全局方法</h5><blockquote>
<p><strong>说明：</strong>为指定队列设置<code>全局上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_set_context(dispatch_object_t object, <span class="keyword">void</span> *context);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-get-context全局方法"><a href="#dispatch-get-context全局方法" class="headerlink" title="dispatch_get_context全局方法"></a>dispatch_get_context全局方法</h5><blockquote>
<p><strong>说明：</strong>获得<code>调度队列</code>的<code>全局数据上下文</code>。<br><strong>原型：</strong><code>/usr/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 调度队列</span><br><span class="line">* @return &#123;void *&#125; 全局数据上下文</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> * dispatch_get_context(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可变字典（作为全局数据上下文）</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *myContext = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 为全局上下文添加队列需要的数据</span></span><br><span class="line">[myContext setObject:<span class="string">@"My Context"</span> forKey:<span class="string">@"title"</span>];</span><br><span class="line">[myContext setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>] forKey:<span class="string">@"value"</span>];</span><br><span class="line"><span class="comment">// 为连续队列 my_serial_queue 设置全局数据上下文</span></span><br><span class="line">dispatch_set_context(my_serial_queue, (__bridge_retained <span class="keyword">void</span> *)myContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取全局数据上下文(桥接转换__bridge，告诉ARC不想自己来管理上下文的内存)</span></span><br><span class="line">myContext = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-2-全局数据上下文内存管理"><a href="#14-2-2-2-全局数据上下文内存管理" class="headerlink" title="14.2.2.2    全局数据上下文内存管理"></a>14.2.2.2    全局数据上下文内存管理</h4><blockquote>
<p><strong>说明：</strong>编写一个<code>终结器(finalizer)</code>函数，在<code>dealloc</code>中调用。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 终结器函数</span><br><span class="line">* @param &#123;void *&#125; context 全局数据上下文对象</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> myFinalizerFunction(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"myFinalizerFunction"</span>);</span><br><span class="line">	<span class="comment">// 桥接转换：将全局数据上下文对象桥接转换为具体类型</span></span><br><span class="line">	<span class="comment">// 其中，__bridge_transfer 将拥有权限转移到了本函数中，意味着该对象的内存管理由全局释放池换成了我们的函数</span></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *theData = (__bridge_transfer <span class="built_in">NSMutableDictionary</span>*)context;</span><br><span class="line">	<span class="comment">// 清空作为全局数据上下文的对象</span></span><br><span class="line">	[theData removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-向调度队列添加任务"><a href="#14-2-2-3-向调度队列添加任务" class="headerlink" title="14.2.2.3    向调度队列添加任务"></a>14.2.2.3    向调度队列添加任务</h4><blockquote>
<p><strong>说明：</strong>有两种方式可以向队列中添加任务，每种方式针对<code>代码块</code>和<code>函数</code>各有一个调度函数（共4个）</p>
<ul>
<li><strong>同步：</strong>队列会一直等待前面任务结束</li>
<li><strong>异步：</strong>添加任务后，不必等待任务，函数会立刻返回（推荐，因为不会阻塞其他代码的运行）</li>
</ul>
</blockquote>
<p>|<em>**</em>|同步|异步|<br>|代码块|<code>dispatch_sync</code>|<code>dispatch_async</code>|<br>|函数|<code>dispatch_sync_f</code>|<code>dispatch_async_f</code>|</p>
<h5 id="dispatch-sync全局函数"><a href="#dispatch-sync全局函数" class="headerlink" title="dispatch_sync全局函数"></a>dispatch_sync全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async全局函数"><a href="#dispatch-async全局函数" class="headerlink" title="dispatch_async全局函数"></a>dispatch_async全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;dispatch_block_t&#125; block 代码块</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步添加代码块：内联方式</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步添加代码块：非内联</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^dispatch_block_t)(<span class="keyword">void</span>);</span><br><span class="line">dispatch_block_t myBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"My Prefined block"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dispatch_async</span>(my_serial_queue, myBlock);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-sync-f全局函数"><a href="#dispatch-sync-f全局函数" class="headerlink" title="dispatch_sync_f全局函数"></a>dispatch_sync_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>同步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-async-f全局函数"><a href="#dispatch-async-f全局函数" class="headerlink" title="dispatch_async_f全局函数"></a>dispatch_async_f全局函数</h5><blockquote>
<p><strong>说明：</strong>向队列中<code>异步</code>添加<code>代码块</code>。<br><strong>原型：</strong><code>/use/include/dispatch/queue.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_queue_t&#125; queue 调度队列</span><br><span class="line">* @param &#123;void *&#125; context 需要传递的任意上下文</span><br><span class="line">* @param &#123;dispatch_function_t&#125; work 函数</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,	<span class="keyword">void</span> *context,	dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义好要添加到队列的函数</span></span><br><span class="line"><span class="keyword">void</span> myDispatchFunction (<span class="keyword">void</span> *argument) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Serial Task %@"</span>, (__bridge <span class="built_in">NSNumber</span> *)argument);</span><br><span class="line">    <span class="comment">// 获得当前队列的全局数据上下文</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *context = (__bridge <span class="built_in">NSMutableDictionary</span> *)dispatch_get_context(dispatch_get_current_queue());</span><br><span class="line">    <span class="comment">// 在字典中索引</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *value = [context objectForKey:<span class="string">@"value"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步向队列中添加函数</span></span><br><span class="line">dispatch_async_f(my_serial_queue, (__bridge <span class="keyword">void</span> *)[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>], (dispatch_function_t)myDispatchFunction);</span><br></pre></td></tr></table></figure>
<h4 id="14-2-2-3-调度队列的暂停和重启"><a href="#14-2-2-3-调度队列的暂停和重启" class="headerlink" title="14.2.2.3    调度队列的暂停和重启"></a>14.2.2.3    调度队列的暂停和重启</h4><h5 id="dispatch-suspend全局方法"><a href="#dispatch-suspend全局方法" class="headerlink" title="dispatch_suspend全局方法"></a>dispatch_suspend全局方法</h5><blockquote>
<p><strong>说明：</strong>暂停队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_suspend(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-resume全局方法"><a href="#dispatch-resume全局方法" class="headerlink" title="dispatch_resume全局方法"></a>dispatch_resume全局方法</h5><blockquote>
<p><strong>说明：</strong>重启队列<br><strong>原型：</strong><code>/use/include/dispatch/object.h</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;dispatch_object_t&#125; object 要暂停的队列</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> dispatch_resume(dispatch_object_t object);</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停队列</span></span><br><span class="line">dispatch_suspend(my_serial_queue);</span><br><span class="line"><span class="comment">// 重启队列</span></span><br><span class="line">dispatch_resume(my_serial_queue);</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-操作队列"><a href="#14-2-3-操作队列" class="headerlink" title="14.2.3    操作队列"></a>14.2.3    操作队列</h3><blockquote>
<p><strong>说明：</strong>有一些称为<code>操作（operation）</code>的<code>API</code>，可以让队列使用起来更加简单。</p>
<ol>
<li>创建一个<code>操作</code>对象</li>
<li>将其指派给<code>操作队列</code></li>
<li><code>操作</code>被队列执行</li>
</ol>
</blockquote>
<h4 id="操作的创建方式"><a href="#操作的创建方式" class="headerlink" title="操作的创建方式"></a><code>操作</code>的创建方式</h4><blockquote>
<p><strong>说明：</strong>一共有3种方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用操作（<code>NSInvocationOperation</code>）</td>
<td>前提是已经拥有一个可以完成工作的类，并且想在队列上执行</td>
</tr>
<tr>
<td>代码块操作（<code>NSBlockOperation</code>）</td>
<td>类似包含了要执行代码块的<code>dispatch_async</code>函数</td>
</tr>
<tr>
<td>自定义的<code>操作</code></td>
<td>通过继承<code>NSOperation</code>定义自己的<code>操作</code></td>
</tr>
</tbody>
</table>
<h5 id="方式一：创建调用操作"><a href="#方式一：创建调用操作" class="headerlink" title="方式一：创建调用操作"></a>方式一：创建<code>调用操作</code></h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyCustomClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span> *)operationWithData: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget: <span class="keyword">self</span> selectorL <span class="keyword">@selector</span>(myWorkerMethod:)object:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做具体工作的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)myWorkerMethod: (<span class="keyword">id</span>)data &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"My Worker Method %@"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="方式二：创建代码块操作"><a href="#方式二：创建代码块操作" class="headerlink" title="方式二：创建代码块操作"></a>方式二：创建<code>代码块操作</code></h5><blockquote>
<p><strong>说明：</strong>创建时作为参数的<code>代码块</code>的类型和在<code>调度队列</code>中使用的相同。</p>
<ul>
<li>一旦创建了第一个<code>代码块操作</code>，便可以通过<code>addExecutionBlock</code>方法继续添加更多的<code>代码块</code></li>
<li>根据<code>队列</code>的类型，代码块会分别以连续或并行的方式运行</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock: ^ &#123;</span><br><span class="line">	<span class="comment">// 具体工作内容</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过代码块操作，继续添加代码块</span></span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">	<span class="comment">// 更多要做工作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="向队列中添加操作"><a href="#向队列中添加操作" class="headerlink" title="向队列中添加操作"></a>向队列中添加操作</h4><blockquote>
<p><strong>说明：</strong>可以使用<code>NSOperationQueue</code>来取代之前使用的<code>dispatch_queue</code>函数，特点如下</p>
<ul>
<li>并发执行<code>操作</code></li>
<li>具有<code>相关性</code>，也就是说，如果某个<code>操作</code>是基于其它<code>操作</code>的，则也会先被执行</li>
</ul>
<p><strong>技巧：</strong>如果要确保添加的<code>操作</code>是连续执行（串行）的，可以设置最大并发操作数为1，这样会按照<code>先入先出</code>的规范执行</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *currentQueue = [<span class="built_in">NSOperation</span> currentQueue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line">[theQueue addOperation:blockOperation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加代码块替代操作对象</span></span><br><span class="line">[theQueue addOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"my work"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="14-3-小结"><a href="#14-3-小结" class="headerlink" title="14.3    小结"></a>14.3    小结</h2>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C基础教程第二版/" rel="tag">#Objective-C基础教程第二版</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/13/o-c基础教程第二版_13 协议/" rel="next" title="13 协议">
                <i class="fa fa-chevron-left"></i> 13 协议
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/13/o-c基础教程第二版_15 AppKit简介/" rel="prev" title="15 AppKit简介">
                15 AppKit简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/05/13/o-c基础教程第二版_14 代码块和并发性/"
           data-title="14 代码块和并发行" data-url="http://laputa-er.github.io/2016/05/13/o-c基础教程第二版_14 代码块和并发性/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sean" />
          <p class="site-author-name" itemprop="name">Sean</p>
          <p class="site-description motion-element" itemprop="description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">85</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-代码块"><span class="nav-number">1.</span> <span class="nav-text">14.1    代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-1-代码块和函数指针"><span class="nav-number">1.1.</span> <span class="nav-text">14.1.1    代码块和函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-1-1-通过代码块名调用代码块"><span class="nav-number">1.1.1.</span> <span class="nav-text">14.1.1.1    通过代码块名调用代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-1-2-直接调用代码块（匿名）"><span class="nav-number">1.1.2.</span> <span class="nav-text">14.1.1.2    直接调用代码块（匿名）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-1-3-使用typedef关键字"><span class="nav-number">1.1.3.</span> <span class="nav-text">14.1.1.3    使用typedef关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-1-4-代码块和变量"><span class="nav-number">1.1.4.</span> <span class="nav-text">14.1.1.4    代码块和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#本地变量"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">本地变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局变量"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数变量"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">参数变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#block变量"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">_block变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码块内部的本地变量"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">代码块内部的本地变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-2-Objective-C代码块内存管理"><span class="nav-number">1.2.</span> <span class="nav-text">14.1.2    Objective-C代码块内存管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-并发性"><span class="nav-number">2.</span> <span class="nav-text">14.2    并发性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-1-同步"><span class="nav-number">2.1.</span> <span class="nav-text">14.2.1    同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-1-1-选择性能"><span class="nav-number">2.1.1.</span> <span class="nav-text">14.2.1.1    选择性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#performSelectorInBackground实例方法"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">performSelectorInBackground实例方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-1-2-调度队列"><span class="nav-number">2.1.2.</span> <span class="nav-text">14.2.1.2    调度队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#连续队列"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">连续队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dispatch-queue-create全局方法"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">dispatch_queue_create全局方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#并发队列"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">并发队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dispatch-get-global-queue全局方法"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">dispatch_get_global_queue全局方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主队列"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">主队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dispatch-get-current-queue全局方法"><span class="nav-number">2.1.2.3.1.</span> <span class="nav-text">dispatch_get_current_queue全局方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-2-队列也要内存管理"><span class="nav-number">2.2.</span> <span class="nav-text">14.2.2    队列也要内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-1-队列的上下文"><span class="nav-number">2.2.1.</span> <span class="nav-text">14.2.2.1    队列的上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-set-context全局方法"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">dispatch_set_context全局方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-get-context全局方法"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">dispatch_get_context全局方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-2-全局数据上下文内存管理"><span class="nav-number">2.2.2.</span> <span class="nav-text">14.2.2.2    全局数据上下文内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-3-向调度队列添加任务"><span class="nav-number">2.2.3.</span> <span class="nav-text">14.2.2.3    向调度队列添加任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-sync全局函数"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">dispatch_sync全局函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-async全局函数"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">dispatch_async全局函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-sync-f全局函数"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">dispatch_sync_f全局函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-async-f全局函数"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">dispatch_async_f全局函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-3-调度队列的暂停和重启"><span class="nav-number">2.2.4.</span> <span class="nav-text">14.2.2.3    调度队列的暂停和重启</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-suspend全局方法"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">dispatch_suspend全局方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-resume全局方法"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">dispatch_resume全局方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-3-操作队列"><span class="nav-number">2.3.</span> <span class="nav-text">14.2.3    操作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作的创建方式"><span class="nav-number">2.3.1.</span> <span class="nav-text">操作的创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方式一：创建调用操作"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">方式一：创建调用操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方式二：创建代码块操作"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">方式二：创建代码块操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向队列中添加操作"><span class="nav-number">2.3.2.</span> <span class="nav-text">向队列中添加操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-小结"><span class="nav-number">3.</span> <span class="nav-text">14.3    小结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lapuda-er"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
