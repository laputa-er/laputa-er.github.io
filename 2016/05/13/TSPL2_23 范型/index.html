<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>23 范型 | Sean</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="do things for fun">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="23 范型 | Sean">
    <meta name="twitter:description" content="do things for fun">

    <meta property="og:type" content="article">
    <meta property="og:title" content="23 范型 | Sean">
    <meta property="og:description" content="do things for fun">

    
    <meta name="author" content="Sean">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://laputa-er.github.io/2016/05/13/TSPL2_23 范型/"/>

    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/mengxiang.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <span class="panel-arrow panel-left-arrow disabled">
        <i class="fa fa-angle-left"></i>
      </span>
      <span class="panel-arrow panel-right-arrow">
        <i class="fa fa-angle-right"></i>
      </span>

      <div class="panel-animation-container">
        <div class="panel-content panel-main__content">
            <a href="/" title="前往 Sean 的主页"><img src="/images/sean.png" width="80" alt="Sean logo" class="panel-cover__logo logo" /></a>
            <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sean">Sean</a></h1>
            
            <span class="panel-cover__subtitle panel-subtitle">笔记分享</span>
            
            <hr class="panel-cover__divider" />
            <p class="panel-cover__description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
            <hr class="panel-cover__divider panel-cover__divider--secondary" />

            <div class="navigation-wrapper">
              <div>
              <nav class="cover-navigation cover-navigation--primary">
                <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="访问笔记" class="blog-button">笔记</a></li>
                  <li style="display: none;">
                    <textarea>
                      
                        <li class="navigation__item"><a href="/projects">项目作品</a></li>
                      
                        <li class="navigation__item"><a href="/aboutme">关于我</a></li>
                      
                    </textarea>
                  </li>
                </ul>
              </nav>
              </div>
              <div>
              <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  

<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

              </div>
            </div>

          </div>
          <div class="panel-content panel-tagcloud_content">
            
              <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">笔记分类</h3>
    <div class="widget tagcloud">
      <a href="/tags/Objective-C基础教程第二版/">Objective-C基础教程第二版</a> <a href="/tags/The-Swift-Program-Language-2/">The Swift Program Language 2</a> <a href="/tags/c语言程序设计－现代方法/">c语言程序设计－现代方法</a> <a href="/tags/极客学院-ios中级/">极客学院_ios中级</a> <a href="/tags/极客学院-ios初级/">极客学院_ios初级</a> <a href="/tags/极客学院-ios高级/">极客学院_ios高级</a>
    </div>
  </div>

  
</aside>
            
          </div>
        </div>  

      </div>
      <div class="panel-cover--overlay cover-blue"></div>
  </div>
  </header>
    
    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-05-13T12:05:48.000Z" class="post-list__meta--date date">2016-05-13</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/The-Swift-Program-Language-2/">The Swift Program Language 2</a>
</span>
    </div>
    <h1 class="post-title">23 范型</h1>
  </header>

  <section class="post">
    <!-- Table of Contents -->
    
    <div id="top-toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-泛型所解决的问题"><span class="toc-number">1.</span> <span class="toc-text">23.1    泛型所解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-泛型函数"><span class="toc-number">2.</span> <span class="toc-text">23.2    泛型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-类型参数"><span class="toc-number">3.</span> <span class="toc-text">23.3    类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-命名类型参数"><span class="toc-number">4.</span> <span class="toc-text">23.4    命名类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-5-泛型类型"><span class="toc-number">5.</span> <span class="toc-text">23.5    泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-6-扩展一个泛型类型"><span class="toc-number">6.</span> <span class="toc-text">23.6    扩展一个泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-6-类型约束"><span class="toc-number">7.</span> <span class="toc-text">23.6    类型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-1-类型约束语法"><span class="toc-number">7.1.</span> <span class="toc-text">23.6.1    类型约束语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-2-类型约束实践"><span class="toc-number">7.2.</span> <span class="toc-text">23.6.2    类型约束实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-7-关联类型"><span class="toc-number">8.</span> <span class="toc-text">23.7    关联类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-1-关联类型实践"><span class="toc-number">8.1.</span> <span class="toc-text">23.7.1    关联类型实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-2-通过扩展一个存在的类型来指定关联类型"><span class="toc-number">8.2.</span> <span class="toc-text">23.7.2    通过扩展一个存在的类型来指定关联类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-8-where字句"><span class="toc-number">9.</span> <span class="toc-text">23.8    where字句</span></a></li></ol>
    </div>
    <div id="tocShell"></div>
    <div id="toc" class="toc-article">
      <div class="btn-group drag-me">
        <i class="social fa fa-ellipsis-v"></i>
      </div>
      <div class="btn-group dropup-catelog">
        <button class="btn"><i class="social fa fa-list-ol"></i></button>
        <div class="catelog-content">
          <p class="toc-title-wrap">
            <strong class="toc-title">文章目录</strong>
          </p>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-泛型所解决的问题"><span class="toc-number">1.</span> <span class="toc-text">23.1    泛型所解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-泛型函数"><span class="toc-number">2.</span> <span class="toc-text">23.2    泛型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-类型参数"><span class="toc-number">3.</span> <span class="toc-text">23.3    类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-命名类型参数"><span class="toc-number">4.</span> <span class="toc-text">23.4    命名类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-5-泛型类型"><span class="toc-number">5.</span> <span class="toc-text">23.5    泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-6-扩展一个泛型类型"><span class="toc-number">6.</span> <span class="toc-text">23.6    扩展一个泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-6-类型约束"><span class="toc-number">7.</span> <span class="toc-text">23.6    类型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-1-类型约束语法"><span class="toc-number">7.1.</span> <span class="toc-text">23.6.1    类型约束语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-2-类型约束实践"><span class="toc-number">7.2.</span> <span class="toc-text">23.6.2    类型约束实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-7-关联类型"><span class="toc-number">8.</span> <span class="toc-text">23.7    关联类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-1-关联类型实践"><span class="toc-number">8.1.</span> <span class="toc-text">23.7.1    关联类型实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-2-通过扩展一个存在的类型来指定关联类型"><span class="toc-number">8.2.</span> <span class="toc-text">23.7.2    通过扩展一个存在的类型来指定关联类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-8-where字句"><span class="toc-number">9.</span> <span class="toc-text">23.8    where字句</span></a></li></ol>
        </div>
      </div>
    </div>
    
    <blockquote>
<p><strong>说明：</strong>泛型代码可以让你编写<code>适用自定义需求以及任意类型</code>的<code>灵活可重用</code>的<code>函数</code>和<code>类型</code>。<br><strong>意义：</strong>它的可以让你<code>避免重复的代码</code>，用一种清晰和抽象的方式来表达代码的意图。</p>
</blockquote>
<h2 id="23-1-泛型所解决的问题"><a href="#23-1-泛型所解决的问题" class="headerlink" title="23.1    泛型所解决的问题"></a>23.1    泛型所解决的问题</h2><blockquote>
<p><strong>说明：</strong>有了泛型，就不必为各种不同类型重复创建类似的<code>函数</code>或<code>类型</code>。</p>
</blockquote>
<h2 id="23-2-泛型函数"><a href="#23-2-泛型函数" class="headerlink" title="23.2    泛型函数"></a>23.2    泛型函数</h2><blockquote>
<p><strong>说明：</strong><code>泛型函数</code>可以适用于<code>任何类型</code><br><strong>语法：</strong><code>func 函数名&lt;T&gt;(){...}</code></p>
<ul>
<li>函数名后面跟着<code>&lt;占位类型名&gt;</code>（比如字母 <code>T</code>）来代替实际类型名</li>
<li>函数被调用时，<code>T</code> 所代表的类型都会<code>由传入的值的类型推断出来</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************** 不使用泛型的方法 ****************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 交换两个值</span><br><span class="line">* @param &#123;String&#125; inout a 第一个值</span><br><span class="line">* @param &#123;String&#125; inout b 第二个值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwStrings</span><span class="params">(<span class="keyword">inout</span> a: String, <span class="keyword">inout</span> <span class="number">_</span> b: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 交换两个值</span><br><span class="line"> * @param &#123;Double&#125; inout a 第一个值</span><br><span class="line"> * @param &#123;Double&#125; inout b 第二个值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="keyword">inout</span> a: Double, <span class="keyword">inout</span> <span class="number">_</span> b: Double)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************** 使用泛型的方法 ******************/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型（自动推断 T 占位符的类型）</span></span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br></pre></td></tr></table></figure>
<h2 id="23-3-类型参数"><a href="#23-3-类型参数" class="headerlink" title="23.3    类型参数"></a>23.3    类型参数</h2><blockquote>
<p><strong>说明：</strong>类型参数指定并命名一个<code>占位类型</code>，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。<code>类型参数</code>会在函数调用时被实际类型所替换。在<code>泛型函数体</code>中可以用来</p>
<ul>
<li>定义一个函数的<code>参数类型</code></li>
<li>作为函数的<code>返回类型</code></li>
<li>用作函数主体中的<code>注释类型</code></li>
</ul>
</blockquote>
<h2 id="23-4-命名类型参数"><a href="#23-4-命名类型参数" class="headerlink" title="23.4    命名类型参数"></a>23.4    命名类型参数</h2><blockquote>
<p><strong>说明：</strong>下面是一些指导性的意见。</p>
<ul>
<li>在大多数情况下，类型参数具有一个<code>描述性名字</code></li>
<li>当它们之间的关系没有意义时，通常使用<code>单一的字母</code>来命名</li>
</ul>
<p><strong>注意：</strong>始终使用<code>大写字母开头的驼峰式命名法</code>来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<h2 id="23-5-泛型类型"><a href="#23-5-泛型类型" class="headerlink" title="23.5    泛型类型"></a>23.5    泛型类型</h2><blockquote>
<p><strong>说明：</strong>除了泛型函数，<code>Swift</code> 还允许你定义泛型类型。这些自定义<code>类</code>、<code>结构体</code>和<code>枚举</code>可以适用于<code>任何类型</code>。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************** 不使用泛型的结构体 ******************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="comment">// 入栈：变异方法,需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈：变异方法，需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************** 使用泛型的机构体 ******************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="comment">// 入栈：变异方法,需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈：变异方法，需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串栈实例</span></span><br><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br></pre></td></tr></table></figure>
<h2 id="23-6-扩展一个泛型类型"><a href="#23-6-扩展一个泛型类型" class="headerlink" title="23.6    扩展一个泛型类型"></a>23.6    扩展一个泛型类型</h2><blockquote>
<p><strong>说明：</strong>扩展泛型类型和扩展普通类型类似，特别的地方在于</p>
<ul>
<li><code>不需要</code>在扩展的定义中提供<code>类型参数列表</code></li>
<li>原始类型定义中声明的类型参数列表在扩展中可以直接使用</li>
<li>这些来自原始类型中的参数名称会被用作<code>原始定义中类型参数的引用</code></li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型结构体：栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="comment">// 入栈：变异方法,需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈：变异方法，需要修改自身的属性</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展泛型类型(原始类型定义中声明的类型参数列表在扩展中可以直接使用)</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串栈实例</span></span><br><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br></pre></td></tr></table></figure>
<h2 id="23-6-类型约束"><a href="#23-6-类型约束" class="headerlink" title="23.6    类型约束"></a>23.6    类型约束</h2><blockquote>
<p><strong>说明：</strong>类型约束可以指定一个<code>类型参数</code>必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
</blockquote>
<h3 id="23-6-1-类型约束语法"><a href="#23-6-1-类型约束语法" class="headerlink" title="23.6.1    类型约束语法"></a>23.6.1    类型约束语法</h3><blockquote>
<p><strong>说明：</strong>在一个<code>类型参数名</code>后面放置一个<code>类名</code>或者<code>协议名</code>，通过<code>:</code>分隔，从而定义类型约束，它们将作为类型参数列表的一部分。<br><strong>语法：</strong>以<code>泛型函数</code>为例（<code>泛型类型</code>与此类似）</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-6-2-类型约束实践"><a href="#23-6-2-类型约束实践" class="headerlink" title="23.6.2    类型约束实践"></a>23.6.2    类型约束实践</h3><blockquote>
<p><strong>注意：</strong>不是所有的 <code>Swift</code> 类型都可以用等式符<code>==</code>进行比较。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何符合该协议的类型必须实现等式符<code>==</code>。<br><strong>扩展：</strong>所有的 <code>Swift 标准类型</code>自动支持 <code>Equatable</code> 协议</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************  非泛型   ************/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findStringIndex</span><span class="params">(array: [String], <span class="number">_</span> valueToFind: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"llama"</span>, <span class="string">"parakeet"</span>, <span class="string">"terrapin"</span>]</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex = findStringIndex(strings, <span class="string">"llama"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The index of llama is \(foundIndex)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********  泛型（带有约束）  *********/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 获得相应值在数组中的位置</span><br><span class="line">* @desc 为了保证证支持等式操作符，T 必需实现 Equatable 协议</span><br><span class="line">* @param &#123;[T]&#125; 目标数组</span><br><span class="line">* @param &#123;T&#125; 目标值</span><br><span class="line">* @reutrn &#123;Int?&#125; 下标</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;T: Equatable&gt;<span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-7-关联类型"><a href="#23-7-关联类型" class="headerlink" title="23.7    关联类型"></a>23.7    关联类型</h2><blockquote>
<p><strong>用途：</strong><code>定义一个协议时</code>，有的时候声明<code>一个或多个</code>关联类型作为协议定义的一部分将会，作为一种用来<code>占位</code>的类型，实现协议是会推断出<code>实际类型</code>。<br><strong>说明：</strong>关联类型作为协议的一部分，为某个类型提供了一个<code>占位名</code>（或者说别名），其代表的<code>实际类型在协议被采纳时才会被指定</code>。<br><strong>语法：</strong>你可以通过 <code>typealias</code> 关键字来指定关联类型。</p>
</blockquote>
<h3 id="23-7-1-关联类型实践"><a href="#23-7-1-关联类型实践" class="headerlink" title="23.7.1    关联类型实践"></a>23.7.1    关联类型实践</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义关联类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="comment">// 必须可以通过 append(_:) 方法添加一个新元素到容器里</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="comment">// 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 必须可以通过接受 Int 索引值的下标检索到每一个元素。</span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现协议（非泛型）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自身部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span><span class="comment">// 可以省略（因为类型推断）</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现协议（泛型）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-7-2-通过扩展一个存在的类型来指定关联类型"><a href="#23-7-2-通过扩展一个存在的类型来指定关联类型" class="headerlink" title="23.7.2    通过扩展一个存在的类型来指定关联类型"></a>23.7.2    通过扩展一个存在的类型来指定关联类型</h3><blockquote>
<p><strong>说明：</strong>扩展让一个已存在的类型符合一个协议，其中就包括使用了关联类型的协议。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协议：容器</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义关联类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="comment">// 必须可以通过 append(_:) 方法添加一个新元素到容器里</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="comment">// 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 必须可以通过接受 Int 索引值的下标检索到每一个元素。</span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 本身就具备 Container 指定的实现</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-8-where字句"><a href="#23-8-where字句" class="headerlink" title="23.8    where字句"></a>23.8    where字句</h2><blockquote>
<p><strong>说明：</strong>可以在<code>参数列表</code>中通过 <code>where</code> 子句为<code>关联类型</code>定义约束</p>
<ul>
<li>使一个<code>关联类型</code>符合某个特定的协议</li>
<li>使某个特定的类型参数和<code>关联类型</code>必须类型相同</li>
</ul>
<p><strong>语法：</strong>将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句</p>
<ul>
<li><code>where</code> 子句后跟<code>一个或者多个</code>针对关联类型的约束</li>
<li>以及<code>一个或多个</code>类型参数和关联类型间的相等关系</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协议：容器</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义关联类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="comment">// 必须可以通过 append(_:) 方法添加一个新元素到容器里</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="comment">// 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 必须可以通过接受 Int 索引值的下标检索到每一个元素。</span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 检查两个 Container 实例是否包含相同顺序的相同元素</span><br><span class="line">* @param &#123;C1&#125; someContainer</span><br><span class="line">* @param &#123;C2&#125; anotherContainer</span><br><span class="line">* @return &#123;Bool&#125; true 匹配，false 不匹配</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allItemsMatch</span>&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;</span><br><span class="line">    <span class="params">(someContainer: C1, <span class="number">_</span> anotherContainer: C2)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </section>

</article>


<section class="post-comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="http://laputa-er.github.io/2016/05/13/TSPL2_23 范型/" data-title="23 范型" data-url="http://laputa-er.github.io/2016/05/13/TSPL2_23 范型/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"laputa-er"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2016 - 
        本站修改自<a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">hexo-theme-vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     
</body>
</html>
