<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>14 预处理器 | Sean</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="do things for fun">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="14 预处理器 | Sean">
    <meta name="twitter:description" content="do things for fun">

    <meta property="og:type" content="article">
    <meta property="og:title" content="14 预处理器 | Sean">
    <meta property="og:description" content="do things for fun">

    
    <meta name="author" content="Sean">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/sean.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://laputa-er.github.io/2016/05/10/14 预处理器/"/>

    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/mengxiang.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <span class="panel-arrow panel-left-arrow disabled">
        <i class="fa fa-angle-left"></i>
      </span>
      <span class="panel-arrow panel-right-arrow">
        <i class="fa fa-angle-right"></i>
      </span>

      <div class="panel-animation-container">
        <div class="panel-content panel-main__content">
            <a href="/" title="前往 Sean 的主页"><img src="/images/sean.png" width="80" alt="Sean logo" class="panel-cover__logo logo" /></a>
            <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sean">Sean</a></h1>
            
            <span class="panel-cover__subtitle panel-subtitle">笔记分享</span>
            
            <hr class="panel-cover__divider" />
            <p class="panel-cover__description">整理了一批过去一段时间ios相关的笔记，其它的笔记也整理下？源码分享出来？再说吧...反正也只有自己会看吧...</p>
            <hr class="panel-cover__divider panel-cover__divider--secondary" />

            <div class="navigation-wrapper">
              <div>
              <nav class="cover-navigation cover-navigation--primary">
                <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="访问笔记" class="blog-button">笔记</a></li>
                  <li style="display: none;">
                    <textarea>
                      
                        <li class="navigation__item"><a href="/projects">项目作品</a></li>
                      
                        <li class="navigation__item"><a href="/aboutme">关于我</a></li>
                      
                    </textarea>
                  </li>
                </ul>
              </nav>
              </div>
              <div>
              <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  

<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

              </div>
            </div>

          </div>
          <div class="panel-content panel-tagcloud_content">
            
              <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">笔记分类</h3>
    <div class="widget tagcloud">
      <a href="/tags/Objective-C基础教程第二版/">Objective-C基础教程第二版</a> <a href="/tags/The-Swift-Program-Language-2/">The Swift Program Language 2</a> <a href="/tags/c语言程序设计－现代方法/">c语言程序设计－现代方法</a> <a href="/tags/极客学院-ios中级/">极客学院_ios中级</a> <a href="/tags/极客学院-ios初级/">极客学院_ios初级</a> <a href="/tags/极客学院-ios高级/">极客学院_ios高级</a>
    </div>
  </div>

  
</aside>
            
          </div>
        </div>  

      </div>
      <div class="panel-cover--overlay cover-blue"></div>
  </div>
  </header>
    
    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-05-10T02:28:50.000Z" class="post-list__meta--date date">2016-05-10</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/c语言程序设计－现代方法/">c语言程序设计－现代方法</a>
</span>
    </div>
    <h1 class="post-title">14 预处理器</h1>
  </header>

  <section class="post">
    <!-- Table of Contents -->
    
    <div id="top-toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-预处理器的工作方式"><span class="toc-number">1.</span> <span class="toc-text">14.1    预处理器的工作方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-预处理指令"><span class="toc-number">2.</span> <span class="toc-text">14.2    预处理指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-宏定义"><span class="toc-number">3.</span> <span class="toc-text">14.3    宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-简单的宏"><span class="toc-number">3.1.</span> <span class="toc-text">14.3.1    简单的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-带参数的宏"><span class="toc-number">3.2.</span> <span class="toc-text">14.3.2    带参数的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-3-运算符"><span class="toc-number">3.3.</span> <span class="toc-text">14.3.3    #运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-4-运算符"><span class="toc-number">3.4.</span> <span class="toc-text">14.3.4    ##运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-5-宏的通用属性"><span class="toc-number">3.5.</span> <span class="toc-text">14.3.5    宏的通用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-6-宏定义中的圆括号"><span class="toc-number">3.6.</span> <span class="toc-text">14.3.6    宏定义中的圆括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-7-创建较长的宏"><span class="toc-number">3.7.</span> <span class="toc-text">14.3.7    创建较长的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-7-1-逗号运算符"><span class="toc-number">3.7.1.</span> <span class="toc-text">14.3.7.1    逗号运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-7-2-复合语句"><span class="toc-number">3.7.2.</span> <span class="toc-text">14.4.7.2        复合语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式"><span class="toc-number">3.7.3.</span> <span class="toc-text">14.4.7.3    在只循环一次的do-while中包含语句和表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-8-预定义宏"><span class="toc-number">3.8.</span> <span class="toc-text">14.3.8    预定义宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-条件编译"><span class="toc-number">4.</span> <span class="toc-text">14.4    条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-if指令和-endif指令"><span class="toc-number">4.1.</span> <span class="toc-text">14.4.1    #if指令和#endif指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-defined运算符"><span class="toc-number">4.2.</span> <span class="toc-text">14.4.2    defined运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-ifdef指令和-ifndef指令"><span class="toc-number">4.3.</span> <span class="toc-text">14.4.3    #ifdef指令和#ifndef指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3-1-ifdef指令"><span class="toc-number">4.3.1.</span> <span class="toc-text">14.4.3.1    #ifdef指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3-2-ifndef指令"><span class="toc-number">4.3.2.</span> <span class="toc-text">14.4.3.2    #ifndef指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-elif指令和-else指令"><span class="toc-number">4.4.</span> <span class="toc-text">14.4.4    #elif指令和#else指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-5-使用条件编译"><span class="toc-number">4.5.</span> <span class="toc-text">14.4.5    使用条件编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-其他指令"><span class="toc-number">5.</span> <span class="toc-text">14.5    其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-1-error指令"><span class="toc-number">5.1.</span> <span class="toc-text">14.5.1    #error指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-2-line指令"><span class="toc-number">5.2.</span> <span class="toc-text">14.5.2    #line指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-3-pragma指令"><span class="toc-number">5.3.</span> <span class="toc-text">14.5.3    #pragma指令</span></a></li></ol></li></ol>
    </div>
    <div id="tocShell"></div>
    <div id="toc" class="toc-article">
      <div class="btn-group drag-me">
        <i class="social fa fa-ellipsis-v"></i>
      </div>
      <div class="btn-group dropup-catelog">
        <button class="btn"><i class="social fa fa-list-ol"></i></button>
        <div class="catelog-content">
          <p class="toc-title-wrap">
            <strong class="toc-title">文章目录</strong>
          </p>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-预处理器的工作方式"><span class="toc-number">1.</span> <span class="toc-text">14.1    预处理器的工作方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-预处理指令"><span class="toc-number">2.</span> <span class="toc-text">14.2    预处理指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-宏定义"><span class="toc-number">3.</span> <span class="toc-text">14.3    宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-简单的宏"><span class="toc-number">3.1.</span> <span class="toc-text">14.3.1    简单的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-带参数的宏"><span class="toc-number">3.2.</span> <span class="toc-text">14.3.2    带参数的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-3-运算符"><span class="toc-number">3.3.</span> <span class="toc-text">14.3.3    #运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-4-运算符"><span class="toc-number">3.4.</span> <span class="toc-text">14.3.4    ##运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-5-宏的通用属性"><span class="toc-number">3.5.</span> <span class="toc-text">14.3.5    宏的通用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-6-宏定义中的圆括号"><span class="toc-number">3.6.</span> <span class="toc-text">14.3.6    宏定义中的圆括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-7-创建较长的宏"><span class="toc-number">3.7.</span> <span class="toc-text">14.3.7    创建较长的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-7-1-逗号运算符"><span class="toc-number">3.7.1.</span> <span class="toc-text">14.3.7.1    逗号运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-7-2-复合语句"><span class="toc-number">3.7.2.</span> <span class="toc-text">14.4.7.2        复合语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式"><span class="toc-number">3.7.3.</span> <span class="toc-text">14.4.7.3    在只循环一次的do-while中包含语句和表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-8-预定义宏"><span class="toc-number">3.8.</span> <span class="toc-text">14.3.8    预定义宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-条件编译"><span class="toc-number">4.</span> <span class="toc-text">14.4    条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-if指令和-endif指令"><span class="toc-number">4.1.</span> <span class="toc-text">14.4.1    #if指令和#endif指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-defined运算符"><span class="toc-number">4.2.</span> <span class="toc-text">14.4.2    defined运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-ifdef指令和-ifndef指令"><span class="toc-number">4.3.</span> <span class="toc-text">14.4.3    #ifdef指令和#ifndef指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3-1-ifdef指令"><span class="toc-number">4.3.1.</span> <span class="toc-text">14.4.3.1    #ifdef指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3-2-ifndef指令"><span class="toc-number">4.3.2.</span> <span class="toc-text">14.4.3.2    #ifndef指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-elif指令和-else指令"><span class="toc-number">4.4.</span> <span class="toc-text">14.4.4    #elif指令和#else指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-5-使用条件编译"><span class="toc-number">4.5.</span> <span class="toc-text">14.4.5    使用条件编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-其他指令"><span class="toc-number">5.</span> <span class="toc-text">14.5    其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-1-error指令"><span class="toc-number">5.1.</span> <span class="toc-text">14.5.1    #error指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-2-line指令"><span class="toc-number">5.2.</span> <span class="toc-text">14.5.2    #line指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-3-pragma指令"><span class="toc-number">5.3.</span> <span class="toc-text">14.5.3    #pragma指令</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>
    
    <blockquote>
<p><strong>说明：</strong>预处理器是一个小软件，它可以在编译前编辑c程序<br><strong>弊端：</strong></p>
<ul>
<li>造成那一发现的错误的根源</li>
<li>经常被错误地用来编写一些几乎不可能读懂的程序</li>
</ul>
<p><strong>技巧：</strong>适度使用预处理功能，减少对于处理器的依赖。<br><strong>扩展：</strong>c++中可以进一步限制预处理器的使用。</p>
</blockquote>
<h2 id="14-1-预处理器的工作方式"><a href="#14-1-预处理器的工作方式" class="headerlink" title="14.1    预处理器的工作方式"></a>14.1    预处理器的工作方式</h2><blockquote>
<p><strong>说明：</strong>预处理器的输入是一个c语言程序，程序中可能会包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。</p>
</blockquote>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-31%20%E4%B8%8B%E5%8D%884.28.36.png" alt="Alt text"></p>
<blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>不检查错误</li>
<li>不删除包含指令的行，而是简单地将它们替换为空</li>
<li>将每一处注视替换为空格字符（有些与编译器会进一步删除不必要的空白字符，并在每一行开始使用缩进的空格符和制表符）</li>
</ul>
<p><strong>注意：</strong>预处理器仅知道少量的c语言规则，因此，它在执行指令时非常有可能产生非法的程序。</p>
</blockquote>
<h2 id="14-2-预处理指令"><a href="#14-2-预处理指令" class="headerlink" title="14.2    预处理指令"></a>14.2    预处理指令</h2><p><strong>分类：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>包括</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义</td>
<td><code>#define</code> <code>#undef</code></td>
</tr>
<tr>
<td>文件包含</td>
<td><code>#include</code></td>
</tr>
<tr>
<td>条件编译</td>
<td><code>#if</code> <code>ifdef</code> <code>ifindef</code> <code>elif</code> <code>#else</code> <code>#endif</code></td>
</tr>
<tr>
<td>其他</td>
<td><code>#error</code> <code>#line</code> <code>#pragma</code></td>
</tr>
</tbody>
</table>
<p><strong>语法：</strong></p>
<ul>
<li>指令都以<code>#</code>开始：<code>空白符 #指令名 指令所需要的其他信息</code></li>
<li>在指令的符号之间可以插入任意树龄的空格或横向制表符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#		<span class="meta-keyword">define</span>		N 		100<span class="comment">// 这样写也是合法的</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>指令总是在第一个换行符处结束，除非明确地指明要继续（通过在行末尾使用<code>\</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISK_CAPACITY (SIDES *  \</span><br><span class="line">                        TRACK_PER_SIDE * \)</span></span><br><span class="line">				    	  SECTORS_PER_TRACK * \</span><br><span class="line">						  BYTES_PER_SECTOR)</span><br></pre></td></tr></table></figure>
<ul>
<li>指令可以出现在程序种任何地方（<code>#define</code>和<code>#include</code>通常放在文件开始）</li>
<li>注释可以和指令放在同一行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREEZING_PT 32.0	<span class="comment">/* Freezing point of water */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-3-宏定义"><a href="#14-3-宏定义" class="headerlink" title="14.3    宏定义"></a>14.3    宏定义</h2><blockquote>
<p><strong>说明：</strong>除了简单的宏，与编译器也支持带参数的宏。</p>
</blockquote>
<h3 id="14-3-1-简单的宏"><a href="#14-3-1-简单的宏" class="headerlink" title="14.3.1    简单的宏"></a>14.3.1    简单的宏</h3><p><strong>语法：</strong><code>#define 表示符 替换列表</code><br><strong>替换列表：</strong>一系列c语言记号，包括表示符、关键字、数、字符常量、字符串字面量、运算符和标点符号。<br><strong>原理：</strong>当预处理器遇到一个宏定义时，会做一个<code>标识符</code>代表<code>替换列表</code>的记录。再文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。<br><strong>注意（常见错误）：</strong></p>
<ol>
<li>不要在宏定义中放置任何额外的符号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N = 1000<span class="comment">//不能使用=</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会成为int a[= 100]，导致错误</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不能在宏定义的末尾添加分号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;<span class="comment">//这里添加的分号会被作为替换列表的一部分</span></span></span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//会变成int a[100;]</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>简单的宏主要用来定义那些被<code>Kernighan</code>和<code>Ritchie</code>称为明示常量（<code>manifest constant</code>）的东西。优点如下</p>
<ol>
<li>程序更易读</li>
<li>易于修改</li>
<li>帮助避免前后不一致或键盘输入错误</li>
<li>可以对c语法做小的修改</li>
<li>对类型重命名</li>
<li>控制条件编译</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE_LEN 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR <span class="string">'R'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOS <span class="string">'\0'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-带参数的宏"><a href="#14-3-2-带参数的宏" class="headerlink" title="14.3.2    带参数的宏"></a>14.3.2    带参数的宏</h3><blockquote>
<p><strong>语法：</strong><code>#define 标识符(x1, x2, ..., xn) 替换列表</code></p>
<ul>
<li>宏的<code>(</code>和<code>标识符</code>之间必须没有空格（否则会被当作简单宏处理）</li>
</ul>
<p><strong>原理：</strong>当预处理器遇到一个带参数的宏，会将定义存储起来以便后面使用。在后面的程序中，宏调用<code>标识符(y1,y2,...,yn)</code>会被<code>替换列表</code>替换，且参数也会依据<code>宏定义</code>对应到替换列表中。<br><strong>用途：</strong></p>
<ul>
<li>经常被用来作为一些简单的函数使用（模拟函数调用）</li>
<li>经常被作为模版，替换经常重复书写的代码段（替换语句）<br><strong>优点：</strong>相比实际的函数</li>
<li>程序可能会稍快些（没有存储上下文、复制参数等的开销）</li>
<li>宏会更“通用”（没有对参数类型的限制）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>编译后的代码通常会变大</li>
<li>宏参数没有类型检查</li>
<li>无法用一个指针指向一个宏</li>
<li>宏可能会不止一次地计算它的参数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果宏使用带有副作用的参数，多次进行宏调用带来的副作用可能导致不易察觉的错误。</li>
</ul>
<p><strong>技巧：</strong>避免使用带有副作用的宏。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y)	((x) &gt; (y) ? (x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EVEN(n) ((n)%2 == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTINT_INT(x) printf(<span class="string">"%d\n"</span>, x)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">i = MAX(j+k, m-n);<span class="comment">//会被修改为i = ((j+k) &gt; (m-n) ? (j+k):(m-n));</span></span><br><span class="line"><span class="keyword">if</span>(IS_EVEN(i)) i++;<span class="comment">//if(((i)%2 == 0)) i++;</span></span><br><span class="line"></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("%d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-运算符"><a href="#14-3-3-运算符" class="headerlink" title="14.3.3    #运算符"></a>14.3.3    <code>#</code>运算符</h3><blockquote>
<p><strong>说明：</strong>将带参数的宏的参数转换为字符串字面量<br><strong>语法：</strong><code>#define 标识符(x1...) 替换列表</code></p>
<ul>
<li><code>#参数</code>仅允许出现在带参数的宏的替换列表中</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(x) printf(#x <span class="string">" = %%d"</span>, x)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//c语言中相邻的字符串字面量会被合并</span></span><br><span class="line">PRINT_INT(i/j);<span class="comment">//printf("i/j = %d\n", i/j);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-4-运算符"><a href="#14-3-4-运算符" class="headerlink" title="14.3.4    ##运算符"></a>14.3.4    <code>##</code>运算符</h3><blockquote>
<p><strong>说明：</strong>可以将两个记号（例如标识符）“粘”在一起，成为一个记号。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#define MK_ID(n) i##n</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">//int i1, i2, i3;</span><br><span class="line">int MK_ID(1), MK_ID(2), MK_ID(3);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>求最大值的函数模版（针对不同类型）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERIC_MAX(type)		\</span><br><span class="line">type type##_max(type x, type y)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return x &gt; y ? x : y;		\</span><br><span class="line">&#125;	</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* float float_max(float x, float y)&#123;</span><br><span class="line">*	return x &gt; y ? x : y;</span><br><span class="line">* &#125;</span><br><span class="line">*/</span></span><br><span class="line">GENERIC_MAX(<span class="keyword">float</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-5-宏的通用属性"><a href="#14-3-5-宏的通用属性" class="headerlink" title="14.3.5    宏的通用属性"></a>14.3.5    宏的通用属性</h3><ul>
<li>宏的替换列表可以包含对另一个宏的调用</li>
<li>预处理器智慧替换完整的记号，而不会替换记号的片段</li>
<li>一个宏定义的作用范围通常到出现这个宏的文件末尾</li>
<li>宏不可以被定义两遍，除非新的定义和旧的定义是一样的</li>
<li>宏可以使用<code>#undef</code>指令取消定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N<span class="comment">//取消对N的定义以便给出新的定义</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-6-宏定义中的圆括号"><a href="#14-3-6-宏定义中的圆括号" class="headerlink" title="14.3.6    宏定义中的圆括号"></a>14.3.6    宏定义中的圆括号</h3><blockquote>
<p><strong>说明：</strong>在宏定义中缺少圆括号会导致c语言最让人讨厌的错误（比如优先级问题）。<br><strong>哪里要添加圆括号：</strong></p>
<ol>
<li>如果宏的替换列表中又运算符，那么始终要讲替换列表放在括号中</li>
<li>当宏有参数时，仅给替换列表添加圆括号是不够的，参数的每一次出现都要添加圆括号</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE(x) (x*10)<span class="comment">//需要给x添加括号</span></span></span><br><span class="line">...</span><br><span class="line">j = SCALE(i+<span class="number">1</span>);<span class="comment">//j = ((i+1)*10);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-7-创建较长的宏"><a href="#14-3-7-创建较长的宏" class="headerlink" title="14.3.7    创建较长的宏"></a>14.3.7    创建较长的宏</h3><h4 id="14-3-7-1-逗号运算符"><a href="#14-3-7-1-逗号运算符" class="headerlink" title="14.3.7.1    逗号运算符"></a>14.3.7.1    逗号运算符</h4><blockquote>
<p><strong>说明：</strong>创建较长的宏的一个办法是使用<code>逗号运算符</code>，特别是可以使用逗号运算符来使替换列表包含一系列表达式。<br><strong>限制：</strong><code>逗号运算符</code>只能连接<code>表达式</code>，不能连接<code>语句</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-2-复合语句"><a href="#14-4-7-2-复合语句" class="headerlink" title="14.4.7.2        复合语句"></a>14.4.7.2        复合语句</h4><blockquote>
<p><strong>说明：</strong>除了使用逗号表达式，还可以将<code>语句</code>或<code>表达式</code>放在<code>{}</code>内形成复合语句。<br><strong>缺点：</strong>不能在<code>替换列表</code>为复合语句的宏调用的末尾使用分号结尾，因为在<code>if</code>语句中会调用会导致错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ECHO(str);<span class="comment">//(gets(str); puts(str););</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="14-4-7-3-在只循环一次的do-while中包含语句和表达式"><a href="#14-4-7-3-在只循环一次的do-while中包含语句和表达式" class="headerlink" title="14.4.7.3    在只循环一次的do-while中包含语句和表达式"></a>14.4.7.3    在只循环一次的do-while中包含语句和表达式</h4><blockquote>
<p><strong>说明：</strong>加入一个宏需要包含一系列的语句，而不仅仅是一些列的表达式，可以将语句放在<code>do</code>循环中，并将条件设置为假。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s)		\</span><br><span class="line">	do&#123;				\</span><br><span class="line">		gets(s); 	\</span><br><span class="line">		puts(s);	\</span><br><span class="line">	&#125;while(0)		</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//do&#123;gets(s); puts(s);&#125;while(0)</span></span><br><span class="line">ECHO(str);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-3-8-预定义宏"><a href="#14-3-8-预定义宏" class="headerlink" title="14.3.8    预定义宏"></a>14.3.8    预定义宏</h3><blockquote>
<p><strong>说明：</strong>在c语言中预定义了一些有用的宏，这些宏主要是提供当前编译的信息。<br><strong>扩展：</strong>c语言提供了一个通用的、用于错误检测的宏—assert宏。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>LINE</em></td>
<td>被编译的文件的行数</td>
</tr>
<tr>
<td><em>FILE</em></td>
<td>被编译的文件的名字</td>
</tr>
<tr>
<td><em>DATE</em></td>
<td>编译的日期（格式”Mmm dd yyyy”）</td>
</tr>
<tr>
<td><em>TIME</em></td>
<td>编译的时间（格式”hh:mm:ss”）</td>
</tr>
<tr>
<td><em>STDC</em></td>
<td>如果编译器接受标准c，那么值为1</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测被零除的错误</span></span><br><span class="line"><span class="comment">//该宏应该在除法之前被调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ZERO(divisor)	\</span><br><span class="line">	<span class="meta-keyword">if</span>(divisor == 0)&#123;		\</span><br><span class="line">		printf(<span class="string">"**** Attempt to divide by zero on line %d "</span> \</span><br><span class="line">				<span class="string">"of file $s ***\n"</span>, _LINE_, _FILE_);		\\</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">CHECK_ZERO(j);</span><br><span class="line">k = i / j;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="14-4-条件编译"><a href="#14-4-条件编译" class="headerlink" title="14.4    条件编译"></a>14.4    条件编译</h2><blockquote>
<p><strong>说明：</strong>条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段。</p>
</blockquote>
<h3 id="14-4-1-if指令和-endif指令"><a href="#14-4-1-if指令和-endif指令" class="headerlink" title="14.4.1    #if指令和#endif指令"></a>14.4.1    #if指令和#endif指令</h3><blockquote>
<p><strong>语法：</strong>当预处理器遇到<code>if</code>指令时，会计算常量表达式。如果表达式的值为0，那么<code>#if</code>与<code>#endif</code>之间的行将在预处理过程中删除。<br><strong>注意：</strong>对于没有定义过的标识符，<code>#if</code>指令会把它当作是值为0的宏对待。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">&gt;	语句</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of i: %d\n"</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of j: %d\n"</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-defined运算符"><a href="#14-4-2-defined运算符" class="headerlink" title="14.4.2    defined运算符"></a>14.4.2    defined运算符</h3><blockquote>
<p><strong>说明：</strong>如果标识符是一个定义过的宏返回1，否则返回0。<br><strong>用途：</strong>判断宏某个标识符是否被定义的宏，通常和<code>#if</code>指令结合使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-3-ifdef指令和-ifndef指令"><a href="#14-4-3-ifdef指令和-ifndef指令" class="headerlink" title="14.4.3    #ifdef指令和#ifndef指令"></a>14.4.3    #ifdef指令和#ifndef指令</h3><blockquote>
<p><strong>说明：</strong>严格说来，这里要介绍的两种指令都不是必须的，因为都可以用其他指令模拟。</p>
</blockquote>
<h4 id="14-4-3-1-ifdef指令"><a href="#14-4-3-1-ifdef指令" class="headerlink" title="14.4.3.1    #ifdef指令"></a>14.4.3.1    #ifdef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>if defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="14-4-3-2-ifndef指令"><a href="#14-4-3-2-ifndef指令" class="headerlink" title="14.4.3.2    #ifndef指令"></a>14.4.3.2    #ifndef指令</h4><blockquote>
<p><strong>语法：</strong>等价于<code>#if !defined(标识符)</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">&gt;  当标识符被定义为宏时需要包含的代码</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="14-4-4-elif指令和-else指令"><a href="#14-4-4-elif指令和-else指令" class="headerlink" title="14.4.4    #elif指令和#else指令"></a>14.4.4    #elif指令和#else指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 表达式1</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 表达式2</span></span><br><span class="line">	语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<h3 id="14-4-5-使用条件编译"><a href="#14-4-5-使用条件编译" class="headerlink" title="14.4.5    使用条件编译"></a>14.4.5    使用条件编译</h3><p><strong>常见应用：</strong></p>
<ul>
<li>编写在多台机器或多种操作系统之间可移植的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WINDOWS)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(DOS)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS2)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写可以使用不同的编译器进行编译的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC__</span></span><br><span class="line">标准c函数原型</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">经典c函数声明</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>为宏提供默认定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUFFER_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时屏蔽包含注释的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">包含注释的代码行</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="14-5-其他指令"><a href="#14-5-其他指令" class="headerlink" title="14.5    其他指令"></a>14.5    其他指令</h2><h3 id="14-5-1-error指令"><a href="#14-5-1-error指令" class="headerlink" title="14.5.1    #error指令"></a>14.5.1    #error指令</h3><blockquote>
<p><strong>语法：</strong><code>#error 消息</code><br><strong>说明：</strong>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，这个消息一定会包含<code>消息</code>，然后大多数编译器会立即终止编译而不去找出其他错误。<br><strong>用途：</strong>通常与条件编译指令一起用于检测正常编译过程中不应出现的情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if INT_MAX &lt; 1000000</span><br><span class="line">#error int type is too small//Error directive:int type is too small</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="14-5-2-line指令"><a href="#14-5-2-line指令" class="headerlink" title="14.5.2    #line指令"></a>14.5.2    #line指令</h3><blockquote>
<p><strong>说明：</strong>用来改变程序行编号的方式以及使编译器认为所在文件是另一个文件。<br><strong>语法：</strong><code>#line 行号 [文件名]</code></p>
<ul>
<li><code>行号</code>是大小介于1-32767之间的整数</li>
<li><code>行号</code>会影响<code>__LINE__</code>宏的值，<code>文件名</code>影响<code>__FILE__</code>的值</li>
</ul>
<p><strong>用途：</strong>主要用于那些产生c代码作为输入的程序，因为出错信息都指向程序员编写的文件，而不是（更复杂）由一些工具生成的文件。</p>
</blockquote>
<h3 id="14-5-3-pragma指令"><a href="#14-5-3-pragma指令" class="headerlink" title="14.5.3    #pragma指令"></a>14.5.3    #pragma指令</h3><blockquote>
<p><strong>语法：</strong><code>#pragma 记号</code></p>
<ul>
<li>＃pragma指令通常只跟着一个记号，这个记号表示了一条编译器需要服从的命令</li>
<li>一些编译器允许#pragma指令所包含的不仅是简单的命令（特别是有些编译器允许#pragma指令带参数）</li>
<li>如果#pragma指令包含了无法识别的命令，编译器必须忽略这些#pragma指令，不允许产生出错信息</li>
</ul>
<p><strong>注意：</strong>#pragma指令中出现的命令集在不同的编译器上是不一样的，需要查阅相关编译器的文档。</p>
</blockquote>

  </section>

</article>


<section class="post-comments">
  <!-- 多说评论框 start -->
  <div id="ds-thread" class="ds-thread" data-thread-key="http://laputa-er.github.io/2016/05/10/14 预处理器/" data-title="14 预处理器" data-url="http://laputa-er.github.io/2016/05/10/14 预处理器/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"lapuda-er"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2016 - 
        本站修改自<a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">hexo-theme-vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     
</body>
</html>
