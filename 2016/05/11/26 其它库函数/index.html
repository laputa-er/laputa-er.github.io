<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>26 其他库函数 | Sean</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="do things for fun">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="26 其他库函数 | Sean">
    <meta name="twitter:description" content="do things for fun">

    <meta property="og:type" content="article">
    <meta property="og:title" content="26 其他库函数 | Sean">
    <meta property="og:description" content="do things for fun">

    
    <meta name="author" content="Sean">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://laputa-er.github.io/2016/05/11/26 其它库函数/"/>

    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/mengxiang.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <span class="panel-arrow panel-left-arrow disabled">
        <i class="fa fa-angle-left"></i>
      </span>
      <span class="panel-arrow panel-right-arrow">
        <i class="fa fa-angle-right"></i>
      </span>

      <div class="panel-animation-container">
        <div class="panel-content panel-main__content">
            <a href="/" title="前往 Sean 的主页"><img src="/images/sean.png" width="80" alt="Sean logo" class="panel-cover__logo logo" /></a>
            <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sean">Sean</a></h1>
            
            <span class="panel-cover__subtitle panel-subtitle">笔记分享</span>
            
            <hr class="panel-cover__divider" />
            <p class="panel-cover__description">整理了一批过去一段时间ios相关的笔记，把前端的笔记也整理下？再说吧...反正也只有自己会看吧</p>
            <hr class="panel-cover__divider panel-cover__divider--secondary" />

            <div class="navigation-wrapper">
              <div>
              <nav class="cover-navigation cover-navigation--primary">
                <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="访问笔记" class="blog-button">笔记</a></li>
                  <li style="display: none;">
                    <textarea>
                      
                        <li class="navigation__item"><a href="/projects">项目作品</a></li>
                      
                        <li class="navigation__item"><a href="/aboutme">关于我</a></li>
                      
                    </textarea>
                  </li>
                </ul>
              </nav>
              </div>
              <div>
              <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  

<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

              </div>
            </div>

          </div>
          <div class="panel-content panel-tagcloud_content">
            
              <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">笔记分类</h3>
    <div class="widget tagcloud">
      <a href="/tags/Objective-C基础教程第二版/">Objective-C基础教程第二版</a> <a href="/tags/The-Swift-Program-Language-2/">The Swift Program Language 2</a> <a href="/tags/c语言程序设计－现代方法/">c语言程序设计－现代方法</a> <a href="/tags/极客学院-ios中级/">极客学院_ios中级</a> <a href="/tags/极客学院-ios初级/">极客学院_ios初级</a> <a href="/tags/极客学院-ios高级/">极客学院_ios高级</a>
    </div>
  </div>

  
</aside>
            
          </div>
        </div>  

      </div>
      <div class="panel-cover--overlay cover-blue"></div>
  </div>
  </header>
    
    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-05-11T13:25:08.000Z" class="post-list__meta--date date">2016-05-11</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/c语言程序设计－现代方法/">c语言程序设计－现代方法</a>
</span>
    </div>
    <h1 class="post-title">26 其他库函数</h1>
  </header>

  <section class="post">
    <!-- Table of Contents -->
    
    <div id="top-toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-1-stdarg-h：可变实参"><span class="toc-number">1.</span> <span class="toc-text">26.1    stdarg.h：可变实参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#va-arg宏（函数）"><span class="toc-number">1.0.1.</span> <span class="toc-text">va_arg宏（函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#va-start宏（函数）"><span class="toc-number">1.0.2.</span> <span class="toc-text">va_start宏（函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#va-end宏（函数）"><span class="toc-number">1.0.3.</span> <span class="toc-text">va_end宏（函数）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-1-调用可变实参列表的函数"><span class="toc-number">1.1.</span> <span class="toc-text">26.1.1    调用可变实参列表的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-2-v…printf类函数"><span class="toc-number">1.2.</span> <span class="toc-text">26.1.2    v…printf类函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vfprintf函数"><span class="toc-number">1.2.1.</span> <span class="toc-text">vfprintf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vprintf函数"><span class="toc-number">1.2.2.</span> <span class="toc-text">vprintf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vsprintf函数"><span class="toc-number">1.2.3.</span> <span class="toc-text">vsprintf函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-2-stdlib-h-通用的使用工具"><span class="toc-number">2.</span> <span class="toc-text">26.2    stdlib.h:    通用的使用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-1-字符串转换函数"><span class="toc-number">2.1.</span> <span class="toc-text">26.2.1    字符串转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#atof函数（c89之前）"><span class="toc-number">2.1.1.</span> <span class="toc-text">atof函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atoi函数（c89之前）"><span class="toc-number">2.1.2.</span> <span class="toc-text">atoi函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atol函数（c89之前）"><span class="toc-number">2.1.3.</span> <span class="toc-text">atol函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtod函数（c89）"><span class="toc-number">2.1.4.</span> <span class="toc-text">strtod函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtol函数（c89）"><span class="toc-number">2.1.5.</span> <span class="toc-text">strtol函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoul函数（c89）"><span class="toc-number">2.1.6.</span> <span class="toc-text">strtoul函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtold函数-C99"><span class="toc-number">2.1.7.</span> <span class="toc-text">strtold函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atoll函数-c99"><span class="toc-number">2.1.8.</span> <span class="toc-text">atoll函数(c99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtof函数-C99"><span class="toc-number">2.1.9.</span> <span class="toc-text">strtof函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoll函数-C99"><span class="toc-number">2.1.10.</span> <span class="toc-text">strtoll函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoull函数-C99"><span class="toc-number">2.1.11.</span> <span class="toc-text">strtoull函数(C99)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：测试数值转换函数"><span class="toc-number">2.2.</span> <span class="toc-text">程序：测试数值转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-3-伪随机序列生成函数"><span class="toc-number">2.3.</span> <span class="toc-text">26.2.3    伪随机序列生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rand函数"><span class="toc-number">2.3.1.</span> <span class="toc-text">rand函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#srand函数"><span class="toc-number">2.3.2.</span> <span class="toc-text">srand函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-3-与环境的通信"><span class="toc-number">2.4.</span> <span class="toc-text">26.2.3    与环境的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exit函数"><span class="toc-number">2.4.1.</span> <span class="toc-text">exit函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atexit函数"><span class="toc-number">2.4.2.</span> <span class="toc-text">atexit函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exit函数（c99）"><span class="toc-number">2.4.3.</span> <span class="toc-text">_Exit函数（c99）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort函数"><span class="toc-number">2.4.4.</span> <span class="toc-text">abort函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getenv函数"><span class="toc-number">2.4.5.</span> <span class="toc-text">getenv函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system函数"><span class="toc-number">2.4.6.</span> <span class="toc-text">system函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-4-搜索和排序使用工具"><span class="toc-number">2.5.</span> <span class="toc-text">26.2.4    搜索和排序使用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bsearch函数"><span class="toc-number">2.5.1.</span> <span class="toc-text">bsearch函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qsort函数"><span class="toc-number">2.5.2.</span> <span class="toc-text">qsort函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：确定航空里程"><span class="toc-number">2.6.</span> <span class="toc-text">程序：确定航空里程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-5-整数运算函数"><span class="toc-number">2.7.</span> <span class="toc-text">26.2.5    整数运算函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abs函数"><span class="toc-number">2.7.1.</span> <span class="toc-text">abs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#labs函数"><span class="toc-number">2.7.2.</span> <span class="toc-text">labs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#llabs函数"><span class="toc-number">2.7.3.</span> <span class="toc-text">llabs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#div函数"><span class="toc-number">2.7.4.</span> <span class="toc-text">div函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ldiv函数（c99）"><span class="toc-number">2.7.5.</span> <span class="toc-text">ldiv函数（c99）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lldiv函数（c99）"><span class="toc-number">2.7.6.</span> <span class="toc-text">lldiv函数（c99）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-3-time-h：日期和时间"><span class="toc-number">3.</span> <span class="toc-text">26.3    time.h：日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3-1-时间处理函数"><span class="toc-number">3.1.</span> <span class="toc-text">26.3.1    时间处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#clock函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">clock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">time函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#difftime函数"><span class="toc-number">3.1.3.</span> <span class="toc-text">difftime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mktime函数"><span class="toc-number">3.1.4.</span> <span class="toc-text">mktime函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3-2-时间转换函数"><span class="toc-number">3.2.</span> <span class="toc-text">26.3.2    时间转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gmtime函数"><span class="toc-number">3.2.1.</span> <span class="toc-text">gmtime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localtime函数"><span class="toc-number">3.2.2.</span> <span class="toc-text">localtime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asctime函数"><span class="toc-number">3.2.3.</span> <span class="toc-text">asctime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctime函数"><span class="toc-number">3.2.4.</span> <span class="toc-text">ctime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strftime函数"><span class="toc-number">3.2.5.</span> <span class="toc-text">strftime函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：显示日期和时间"><span class="toc-number">3.3.</span> <span class="toc-text">程序：显示日期和时间</span></a></li></ol></li></ol>
    </div>
    <div id="tocShell"></div>
    <div id="toc" class="toc-article">
      <div class="btn-group drag-me">
        <i class="social fa fa-ellipsis-v"></i>
      </div>
      <div class="btn-group dropup-catelog">
        <button class="btn"><i class="social fa fa-list-ol"></i></button>
        <div class="catelog-content">
          <p class="toc-title-wrap">
            <strong class="toc-title">文章目录</strong>
          </p>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-1-stdarg-h：可变实参"><span class="toc-number">1.</span> <span class="toc-text">26.1    stdarg.h：可变实参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#va-arg宏（函数）"><span class="toc-number">1.0.1.</span> <span class="toc-text">va_arg宏（函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#va-start宏（函数）"><span class="toc-number">1.0.2.</span> <span class="toc-text">va_start宏（函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#va-end宏（函数）"><span class="toc-number">1.0.3.</span> <span class="toc-text">va_end宏（函数）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-1-调用可变实参列表的函数"><span class="toc-number">1.1.</span> <span class="toc-text">26.1.1    调用可变实参列表的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-2-v…printf类函数"><span class="toc-number">1.2.</span> <span class="toc-text">26.1.2    v…printf类函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vfprintf函数"><span class="toc-number">1.2.1.</span> <span class="toc-text">vfprintf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vprintf函数"><span class="toc-number">1.2.2.</span> <span class="toc-text">vprintf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vsprintf函数"><span class="toc-number">1.2.3.</span> <span class="toc-text">vsprintf函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-2-stdlib-h-通用的使用工具"><span class="toc-number">2.</span> <span class="toc-text">26.2    stdlib.h:    通用的使用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-1-字符串转换函数"><span class="toc-number">2.1.</span> <span class="toc-text">26.2.1    字符串转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#atof函数（c89之前）"><span class="toc-number">2.1.1.</span> <span class="toc-text">atof函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atoi函数（c89之前）"><span class="toc-number">2.1.2.</span> <span class="toc-text">atoi函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atol函数（c89之前）"><span class="toc-number">2.1.3.</span> <span class="toc-text">atol函数（c89之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtod函数（c89）"><span class="toc-number">2.1.4.</span> <span class="toc-text">strtod函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtol函数（c89）"><span class="toc-number">2.1.5.</span> <span class="toc-text">strtol函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoul函数（c89）"><span class="toc-number">2.1.6.</span> <span class="toc-text">strtoul函数（c89）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtold函数-C99"><span class="toc-number">2.1.7.</span> <span class="toc-text">strtold函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atoll函数-c99"><span class="toc-number">2.1.8.</span> <span class="toc-text">atoll函数(c99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtof函数-C99"><span class="toc-number">2.1.9.</span> <span class="toc-text">strtof函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoll函数-C99"><span class="toc-number">2.1.10.</span> <span class="toc-text">strtoll函数(C99)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtoull函数-C99"><span class="toc-number">2.1.11.</span> <span class="toc-text">strtoull函数(C99)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：测试数值转换函数"><span class="toc-number">2.2.</span> <span class="toc-text">程序：测试数值转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-3-伪随机序列生成函数"><span class="toc-number">2.3.</span> <span class="toc-text">26.2.3    伪随机序列生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rand函数"><span class="toc-number">2.3.1.</span> <span class="toc-text">rand函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#srand函数"><span class="toc-number">2.3.2.</span> <span class="toc-text">srand函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-3-与环境的通信"><span class="toc-number">2.4.</span> <span class="toc-text">26.2.3    与环境的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exit函数"><span class="toc-number">2.4.1.</span> <span class="toc-text">exit函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atexit函数"><span class="toc-number">2.4.2.</span> <span class="toc-text">atexit函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exit函数（c99）"><span class="toc-number">2.4.3.</span> <span class="toc-text">_Exit函数（c99）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort函数"><span class="toc-number">2.4.4.</span> <span class="toc-text">abort函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getenv函数"><span class="toc-number">2.4.5.</span> <span class="toc-text">getenv函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system函数"><span class="toc-number">2.4.6.</span> <span class="toc-text">system函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-4-搜索和排序使用工具"><span class="toc-number">2.5.</span> <span class="toc-text">26.2.4    搜索和排序使用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bsearch函数"><span class="toc-number">2.5.1.</span> <span class="toc-text">bsearch函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qsort函数"><span class="toc-number">2.5.2.</span> <span class="toc-text">qsort函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：确定航空里程"><span class="toc-number">2.6.</span> <span class="toc-text">程序：确定航空里程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-5-整数运算函数"><span class="toc-number">2.7.</span> <span class="toc-text">26.2.5    整数运算函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abs函数"><span class="toc-number">2.7.1.</span> <span class="toc-text">abs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#labs函数"><span class="toc-number">2.7.2.</span> <span class="toc-text">labs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#llabs函数"><span class="toc-number">2.7.3.</span> <span class="toc-text">llabs函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#div函数"><span class="toc-number">2.7.4.</span> <span class="toc-text">div函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ldiv函数（c99）"><span class="toc-number">2.7.5.</span> <span class="toc-text">ldiv函数（c99）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lldiv函数（c99）"><span class="toc-number">2.7.6.</span> <span class="toc-text">lldiv函数（c99）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-3-time-h：日期和时间"><span class="toc-number">3.</span> <span class="toc-text">26.3    time.h：日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3-1-时间处理函数"><span class="toc-number">3.1.</span> <span class="toc-text">26.3.1    时间处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#clock函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">clock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">time函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#difftime函数"><span class="toc-number">3.1.3.</span> <span class="toc-text">difftime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mktime函数"><span class="toc-number">3.1.4.</span> <span class="toc-text">mktime函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3-2-时间转换函数"><span class="toc-number">3.2.</span> <span class="toc-text">26.3.2    时间转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gmtime函数"><span class="toc-number">3.2.1.</span> <span class="toc-text">gmtime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localtime函数"><span class="toc-number">3.2.2.</span> <span class="toc-text">localtime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asctime函数"><span class="toc-number">3.2.3.</span> <span class="toc-text">asctime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctime函数"><span class="toc-number">3.2.4.</span> <span class="toc-text">ctime函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strftime函数"><span class="toc-number">3.2.5.</span> <span class="toc-text">strftime函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序：显示日期和时间"><span class="toc-number">3.3.</span> <span class="toc-text">程序：显示日期和时间</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>
    
    <h2 id="26-1-stdarg-h：可变实参"><a href="#26-1-stdarg-h：可变实参" class="headerlink" title="26.1    stdarg.h：可变实参"></a>26.1    stdarg.h：可变实参</h2><blockquote>
<p><strong>带有可变参数的函数：</strong>带有可变数量参数的函数必须至少有一个“正常的”形式参数，在最后一个正常参数的后边始终会有省略号出现在参数列表的末尾。<br><strong>可变部分实参提升：</strong>当调用带有可变实参列表的函数时，编译器会在匹配省略号的全部参数上执行默认的<code>实参提升</code>（<a href="">9.3</a>）</p>
<ul>
<li>char -&gt; int</li>
<li>short -&gt; int</li>
<li>float -&gt; double</li>
</ul>
</blockquote>
<h4 id="va-arg宏（函数）"><a href="#va-arg宏（函数）" class="headerlink" title="va_arg宏（函数）"></a>va_arg宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>获得所在函数的可变参数中的下一个参数<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 指向可变参数列表的某个位置</span><br><span class="line">* @param &#123;类型&#125; 期待相应位置实参的类型</span><br><span class="line">* @return &#123;类型&#125; 相应位置(下一个)实参</span><br><span class="line">*/</span></span><br><span class="line">类型 va_arg(va_list ap, 类型);</span><br></pre></td></tr></table></figure>
<h4 id="va-start宏（函数）"><a href="#va-start宏（函数）" class="headerlink" title="va_start宏（函数）"></a>va_start宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过支持实参列表中可变长度部分开始的位置初始化<code>va_list</code>类型的实参列表。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 存储参数列表的变量</span><br><span class="line">* @param &#123;*&#125; paramN 可变参数前的最后一个正常实参</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(va_list ap, paramN)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="va-end宏（函数）"><a href="#va-end宏（函数）" class="headerlink" title="va_end宏（函数）"></a>va_end宏（函数）</h4><hr>
<blockquote>
<p><strong>说明：</strong>执行对<code>va_list</code>类型变量的清理，使其无法被继续使用。<br><strong>原型：</strong><code>stdarg.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;va_list&#125; ap 可变实参部分的列表</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; n 后面可变参数的数量</span><br><span class="line">* @param &#123;*&#125; ... 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 可变实参中的最大值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span> <span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明存储可变实参列表的变量</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">int</span> i, current, largest;</span><br><span class="line">	<span class="comment">// 初始化存储可变部分的实参的列表</span></span><br><span class="line">	va_start(ap, n);</span><br><span class="line">	<span class="comment">// 遍历寻找最大值</span></span><br><span class="line">	largest = va_arg(ap, int);</span><br><span class="line">	<span class="keyword">for</span> (i = i; i &lt; n; i ++) &#123;</span><br><span class="line">		current = va_arg(ap, int);</span><br><span class="line">		<span class="keyword">if</span> (current &gt; largest) &#123;</span><br><span class="line">			largest = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清理存储可变实参的列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	return largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-1-1-调用可变实参列表的函数"><a href="#26-1-1-调用可变实参列表的函数" class="headerlink" title="26.1.1    调用可变实参列表的函数"></a>26.1.1    调用可变实参列表的函数</h3><blockquote>
<p><strong>说明：</strong>调用带有可变实参列表的函数带有一定风险，需要一些措施规避</p>
<ul>
<li><p>确定可变参数数量</p>
<blockquote>
<p><strong>例子：</strong>max_int函数依靠第一个是惨知名跟随其后的其他参数的数量</p>
</blockquote>
</li>
<li><p>确定每种参数的类型</p>
<blockquote>
<p><strong>例子：</strong>像printf函数和scanf函数依靠格式化字符串来描述其他的参数的数量和每种参数的类型</p>
</blockquote>
</li>
<li><p>特别处理<code>NULL</code>作为参数：当把<code>NULL</code>(0)传递给带有可变实参列表的函数时，编译器会假定它表示的是一个整数</p>
<blockquote>
<p><strong>强制类型转换：</strong><code>(void *) NULL</code>代替<code>NULL</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="26-1-2-v…printf类函数"><a href="#26-1-2-v…printf类函数" class="headerlink" title="26.1.2    v…printf类函数"></a>26.1.2    v…printf类函数</h3><blockquote>
<p><strong>说明：</strong>和<code>...printf类函数</code>相比，由一个<code>va_list</code>类型的参数取代了可变参数部分。<br><strong>用途：</strong>编写“包装”函数。外部的包装函数接受可变数量的实参，并且稍后把这些参数传递给<code>v...printf类函数</code>。</p>
</blockquote>
<h4 id="vfprintf函数"><a href="#vfprintf函数" class="headerlink" title="vfprintf函数"></a>vfprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向第一个参数说明的流（任何输出流）中写输出。<br><strong>关联的函数：</strong><code>vfprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;FILE *&#125; stream 文件指针（流）</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE * <span class="keyword">restrict</span> stream, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vprintf函数"><a href="#vprintf函数" class="headerlink" title="vprintf函数"></a>vprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>向stdout输出，利用格式串控制输出的形式<br><strong>关联的函数：</strong><code>vprintf函数</code>(<a href="">22.3.1</a>)<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @param &#123;int&#125; 写入的字符数：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list rga)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vsprintf函数"><a href="#vsprintf函数" class="headerlink" title="vsprintf函数"></a>vsprintf函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>类似printf函数和fprintf函数，唯一的不同是该函数会把输出写入指定字符数组而不是流中（会在末尾添加一个空字符）。<br><strong>原型：</strong><code>stdio.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 字符数组</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;va_list&#125; arg 可变参数数组</span><br><span class="line">* @return &#123;int&#125; 写入的字符数（不包括空字符）：成功；负值：写入出错</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 定制错误输出</span><br><span class="line">* @param &#123;char *&#125; format 格式化字符串</span><br><span class="line">* @param &#123;...*&#125; 可变参数部分</span><br><span class="line">* @return &#123;int&#125; 输出的字符数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">errorf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num_errors = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 声明可变数组列表</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	num_errors++;</span><br><span class="line">	<span class="comment">// 打印需要增强的部分</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"** Error %d: "</span>, num_errors);</span><br><span class="line">	<span class="comment">// 初始化可变数组列表</span></span><br><span class="line">	va_start(ap, format);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入字符串（打印到屏幕）</span></span><br><span class="line">	n = <span class="built_in">vfprintf</span>(stderr, format, ap);</span><br><span class="line">	<span class="comment">// 清理可变参数列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="comment">// 按照格式串向stderr写入“换行”</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-2-stdlib-h-通用的使用工具"><a href="#26-2-stdlib-h-通用的使用工具" class="headerlink" title="26.2    stdlib.h:    通用的使用工具"></a>26.2    stdlib.h:    通用的使用工具</h2><blockquote>
<p><strong>说明：</strong>涵盖累全部不适合于任何其他头的函数。</p>
<ul>
<li>字符串转换函数</li>
<li>伪随机序列生成函数</li>
<li>内存管理函数</li>
<li>与外部环境的通信</li>
<li>搜索与排序使用工具</li>
<li>整数算术运算函数(<a href="">17</a>)</li>
<li>多子节字符和字符串函数(<a href="">25.2</a>)</li>
</ul>
</blockquote>
<h3 id="26-2-1-字符串转换函数"><a href="#26-2-1-字符串转换函数" class="headerlink" title="26.2.1    字符串转换函数"></a>26.2.1    字符串转换函数</h3><blockquote>
<p><strong>字符串中的特殊子串：</strong></p>
<ul>
<li><strong>十六进制浮点数</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>0x(X)</code></th>
<th>一个或多个<code>十六进制数字</code>（可能包括<code>小数点</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>无穷数</strong>：<code>INF</code>（不要求大小写）或`INFINITY（不要求大小写）</li>
<li><strong>NaN</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th><code>NAN</code></th>
<th><code>(</code></th>
<th><code>空</code>或<code>一系列字符</code></th>
<th><code>)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>不要求大小写</td>
<td></td>
<td>可以包含字母、数组或下划线，用于<code>为NaN值的二进制表示指定某些位</code>或被<code>nan函数</code>(<a href="">23.4</a>)调用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="atof函数（c89之前）"><a href="#atof函数（c89之前）" class="headerlink" title="atof函数（c89之前）"></a>atof函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>double</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;double&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoi函数（c89之前）"><a href="#atoi函数（c89之前）" class="headerlink" title="atoi函数（c89之前）"></a>atoi函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span><br><span class="line">int atoi (const chat *nptr)；</span><br></pre></td></tr></table></figure>
<h4 id="atol函数（c89之前）"><a href="#atol函数（c89之前）" class="headerlink" title="atol函数（c89之前）"></a>atol函数（c89之前）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为相应的<code>long int</code>类型</p>
<ul>
<li>会跳过字符串开始处的空白字符</li>
<li>可以以<code>+</code>、<code>-</code>开头</li>
<li>把每个字符看作相应的数字，比如<code>&quot;234&quot;</code>会被看作<code>234</code></li>
<li>在遇到第一个不属于数的字符处停止</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>不能支持转换过程中处理了字符串中的多少字符</li>
<li>不能支持转换失败的具体情况（不能保证会修改<code>errno</code>变量的值）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtod函数（c89）"><a href="#strtod函数（c89）" class="headerlink" title="strtod函数（c89）"></a>strtod函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>double</code>，相比<code>atof函数（c89之前）</code></p>
<ul>
<li>返回值为<code>double</code>而不是<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtold</code>、<code>strtof</code>)</li>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回正或负的<code>HUGE_VAL</code>(<a href="">23.3</a>)</li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）<br><strong>原型：</strong><code>stdlib.h</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">strtod</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtol函数（c89）"><a href="#strtol函数（c89）" class="headerlink" title="strtol函数（c89）"></a>strtol函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code>，相比<code>atol函数（c89之前）</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoul函数（c89）"><a href="#strtoul函数（c89）" class="headerlink" title="strtoul函数（c89）"></a>strtoul函数（c89）</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long int</code></p>
<ul>
<li><strong>可以检测超出范围：</strong>如果转换得到的值超出了函数返回类型的表示范围，那么会在<code>errno</code>变量中存储<code>ERANGE</code>，且返回<code>LONG_MIN</code>或<code>LONG_MAX</code></li>
<li><strong>更复杂：</strong>第二个参数指定停止转换的位置（当传递NULL是将不会指定）</li>
<li><strong>可以检测转换失败的细节：</strong>如果不能转换，将把要转换的字符串赋值给第二个参数指向的变量（前提是该参数非<code>NULL</code>）</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtold函数-C99"><a href="#strtold函数-C99" class="headerlink" title="strtold函数(C99)"></a>strtold函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long double</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>long double</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtof</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;long double&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">strtold</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atoll函数-c99"><a href="#atoll函数-c99" class="headerlink" title="atoll函数(c99)"></a>atoll函数(c99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，和<code>atol函数（c89之前）</code>相比</p>
<ul>
<li>转换为<code>long long int</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code></li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @return &#123;long int&#125; 相应的数字：成功；0：不能执行转换（字符串为空或镇前导空白之后的字符的形式不符合函数的要求）</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtof函数-C99"><a href="#strtof函数-C99" class="headerlink" title="strtof函数(C99)"></a>strtof函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>float</code>，相比<code>strtod函数（c89）</code></p>
<ul>
<li>转换为<code>float</code></li>
<li>字符串可以<code>包含16进制的浮点数</code>、<code>无穷数</code>或<code>NaN</code>(同<code>strtod</code>、<code>strtold</code>)</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @return &#123;float&#125; 正或负的HUGE_VAL(23.3)：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">strtof</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoll函数-C99"><a href="#strtoll函数-C99" class="headerlink" title="strtoll函数(C99)"></a>strtoll函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>long long int</code>，类似<code>strtol函数（c89）</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;long int&#125; LONG_MIN或LONG_MAX：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoll</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strtoull函数-C99"><a href="#strtoull函数-C99" class="headerlink" title="strtoull函数(C99)"></a>strtoull函数(C99)</h4><hr>
<blockquote>
<p><strong>说明：</strong>将字符串转换为<code>unsigned long long int</code>，类似<code>strtoul函数(c89)</code><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @param &#123;char *&#125; nptr 字符串</span><br><span class="line">* @param &#123;char **&#125; endptr 转换停止的位置</span><br><span class="line">* @param &#123;int&#125; base 待转换数的基数（进制，2~36）</span><br><span class="line">* @return &#123;unsigned long long int&#125; ULONG_MAX或ULONG_MIN：转换得到的值超过反回类型范围（并在errno中存储RANGE）；浮点数：成功转换；0：不能转换</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoull</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> nptr, <span class="keyword">char</span> ** <span class="keyword">restrict</span> endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序：测试数值转换函数"><a href="#程序：测试数值转换函数" class="headerlink" title="程序：测试数值转换函数"></a>程序：测试数值转换函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Test c89 numeric conversion functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHK_VALID printf(<span class="string">"    %s        %s\n"</span>, \</span><br><span class="line"> 					     errno != ERANGE ? <span class="string">"Yes"</span> : <span class="string">"No "</span>, \</span><br><span class="line"> 					     *ptr == <span class="string">'\0'</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="comment">/* 检测程序启动方式是否正确 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: tnumconv string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使用c89之前的3个旧转换函数 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function Return Value\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------    --------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atof        %g\n"</span>, atof(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atoi        %d\n"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"atol        %ld\n"</span>, atol(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Function    Return Value    Valid?    "</span></span><br><span class="line">		   <span class="string">"String Consumed?\n"</span></span><br><span class="line">		   <span class="string">"--------    ------------    ------    "</span></span><br><span class="line">		   <span class="string">"------------------\n"</span>);</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtod    %-12g\n"</span>, strtod(argv[<span class="number">1</span>], &amp;ptr));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtol    %-12ld\n"</span>, strtol(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtoul    %-12lu\n"</span>, strtoul(argv[<span class="number">1</span>], &amp;ptr, <span class="number">10</span>));</span><br><span class="line">    CHK_VALID;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-24%20%E4%B8%8A%E5%8D%8810.36.50.png" alt="Alt text"></p>
<h3 id="26-2-3-伪随机序列生成函数"><a href="#26-2-3-伪随机序列生成函数" class="headerlink" title="26.2.3    伪随机序列生成函数"></a>26.2.3    伪随机序列生成函数</h3><h4 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>返回一个<code>0～RAND_MAX(stdlib.h)</code>的随机数。<br><strong>说明：</strong><code>rand函数</code>返回的数事实上不是随机的，这些数是由“种子”值（默认为1）产生的，但对于偶然的观察者而言，rand函数似乎能能够产生不相关的数值序列。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;int&#125; `0～RAND_MAX(stdlib.h)`的随机数</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="srand函数"><a href="#srand函数" class="headerlink" title="srand函数"></a>srand函数</h4><blockquote>
<p><strong>描述：</strong>在<code>rand函数</code>执行前执行该函数来为<code>rand函数</code>提供种子值。<br><strong>注意：</strong>同一个种子值对应着一组特定的随机序列<br><strong>技巧：</strong>把<code>time函数</code>的返回值传递给<code>srand函数</code>设置“随机化”的种子值，这样可以使<code>rand函数</code>在每次运行时的行为都不相同。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Tests the pseudo-random sequence generation functions</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This program displays the first five value of "</span></span><br><span class="line">		   <span class="string">"rand.\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter new seed value (0 to terminate):"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;seed);</span><br><span class="line">		<span class="keyword">if</span> (seed == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		srand(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-3-与环境的通信"><a href="#26-2-3-与环境的通信" class="headerlink" title="26.2.3    与环境的通信"></a>26.2.3    与环境的通信</h3><blockquote>
<p><strong>说明：</strong>一组简单的操作系统接口。</p>
<ol>
<li>正常或不正常地终止程序，并且想操作系统反悔一个状态码</li>
<li>从用户的外部环境获取信息</li>
<li>执行操作系统的命令</li>
</ol>
</blockquote>
<h4 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统。<br><strong>细节：</strong>通常还会在后台做一些最后的动作</p>
<ul>
<li>清洗包好未输出数据的输出缓冲区</li>
<li>关闭打开的流</li>
<li>删除临时文件</li>
<li>调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
</ul>
<p><strong>说明：</strong>通常等价于在<code>main函数</code>中执行<code>return n</code>，具有可移植性的状态码包括</p>
<ul>
<li><strong>EXIT_SUCCESS宏：</strong>正常退出(整数0)</li>
<li><strong>EXIT_FAILURE宏：</strong>非正常退出</li>
</ul>
<p><strong>注意：</strong><code>exit函数</code>和<code>return语句</code>的不同表现在</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>exit函数</th>
<th>return语句</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main函数</code>中局部变量的生命周期</td>
<td>不结束</td>
<td>结束（如果用<code>atexit函数</code>注册的函数或<code>清洗输出流的缓冲区</code>访问这些变量就会出现问题）</td>
</tr>
<tr>
<td>使用<code>int</code>之外的类型</td>
<td>可以</td>
<td>必须和<code>mian函数</code>的返回类型保持一致，否则</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>当把函数指针传递给<code>aexit函数</code>时，它会把指针保存起来，当程序正常终止时会被调用。</p>
<ul>
<li>通过<code>exit函数</code>被调用或<code>main函数</code>中的<code>return</code>语句触发</li>
<li>如果注册了两个或更多函数，那么将按照与注册顺序<code>相反</code>的顺序调用它们</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void (*func)(void)&#125; func 函数指针</span><br><span class="line">* @return &#123;int&#125; 未知</span><br><span class="line">*/</span><br><span class="line">int atexit (void (*func)(void));</span><br></pre></td></tr></table></figure>
<h4 id="Exit函数（c99）"><a href="#Exit函数（c99）" class="headerlink" title="_Exit函数（c99）"></a>_Exit函数（c99）</h4><hr>
<blockquote>
<p><strong>描述：</strong>终止程序，并返回状态码给操作系统<br><strong>说明：</strong>类似<code>exit函数</code></p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
<li>不会调用通过<code>atexit函数</code>注册的在程序终止时要调用的函数</li>
<li>不回发送信号触发<code>signal函数</code>（<a href="">24.3</a>）注册的函数</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; status 状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">void</span> _Exit (<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>通常会导致异常的程序终止，长生<code>SIGABRT信号</code>并向系统返回一个表示“不成功”的状态码。<br><strong>注意：</strong>有一种情况下不会导致程序终止，那就是通过<code>signal函数</code>为<code>SIGABRT信号</code>注册处理函数，且处理函数调用了<code>longjmp函数</code>恢复到之前的执行环境。<br><strong>说明：</strong>类似<code>exit</code>函数，特点是</p>
<ul>
<li>不一定会清洗输出缓冲区（由实现定义）</li>
<li>不一定会关闭打开的流</li>
<li>不一定会删除临时文件</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a>getenv函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>提供了访问用户环境中的任意字符串（环境变量）的功能。<br><strong>说明：</strong>获得的指针指向的字符串是静态的，有可能会被其它函数调用或系统自身修改。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; name 环境变量名</span><br><span class="line">* @return &#123;char *&#125; 指向静态分配的字符串的指针</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* "/usr/local/bin:/bin:/usr/bin:." */</span></span><br><span class="line"><span class="keyword">char</span> *p = getenv(<span class="string">"PATH"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>运行另一个c程序（可以是操作系统命令）<br><strong>说明：</strong>类似在操作系统终端使用命令行</p>
<ul>
<li><strong>参数：</strong>以<code>NULL</code>作为参数有特殊含义</li>
<li><strong>返回值</strong>：（由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</li>
</ul>
<p><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; string 命令</span><br><span class="line">* @return &#123;int&#125; 由实现定义）通常情况下返回要求它运行的那个程序的终止状态码</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用UNIX(Linux)的ls命令，并将结果存入myfiles</span></span><br><span class="line">system(<span class="string">"ls &gt;myfiles"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="26-2-4-搜索和排序使用工具"><a href="#26-2-4-搜索和排序使用工具" class="headerlink" title="26.2.4    搜索和排序使用工具"></a>26.2.4    搜索和排序使用工具</h3><h4 id="bsearch函数"><a href="#bsearch函数" class="headerlink" title="bsearch函数"></a>bsearch函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>根据键在<code>有序数组</code>中搜索一个特定的值。<br><strong>说明：</strong>通常会使用<code>二分搜索算法</code>来搜索在数组中搜索<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; key 指向键（匹配依据）的指针</span><br><span class="line">* @param &#123;void *&#125; base 数组</span><br><span class="line">* @param &#123;size_t&#125; size 每个元素的大小（字节）</span><br><span class="line">* @param &#123;Function *&#125; compar 指向比较函数的指针</span><br><span class="line">* @return &#123;void *&#125; 指向与键匹配的指针：匹配到；NULL：没匹配到</span><br><span class="line">*/</span><br><span class="line">void *bsearch (const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h4 id="qsort函数"><a href="#qsort函数" class="headerlink" title="qsort函数"></a>qsort函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>为数组进行排序<br><strong>相关：</strong><a href="">17.1</a><br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;void *&#125; base 指向数组需要排序的部分的第一个元素</span><br><span class="line">* @param &#123;size_t&#125; nmemb 要排序的元素的数量</span><br><span class="line">* @param &#123;Function *&#125; compare 指向排序函数的指针</span><br><span class="line">*/</span><br><span class="line">void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</span><br></pre></td></tr></table></figure>
<h3 id="程序：确定航空里程"><a href="#程序：确定航空里程" class="headerlink" title="程序：确定航空里程"></a>程序：确定航空里程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine air mileage from New York City.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> city_info &#123;</span><br><span class="line">	<span class="keyword">char</span> *city;</span><br><span class="line">	<span class="keyword">int</span> miles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> city_name[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">struct</span> city_info *ptr;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> city_info mileage[] = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Berlin"</span>, <span class="number">3965</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Buenos Aires"</span>, <span class="number">5297</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cairo"</span>, <span class="number">5602</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Calcutta"</span>, <span class="number">7918</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"Cape Town"</span>, <span class="number">7764</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter city name:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%80[^\n]"</span>, city_name);</span><br><span class="line">	ptr = bsearch(city_name, mileage, sizeof(mileage) / sizeof(mileage[<span class="number">0</span>]), sizeof(mileage[<span class="number">0</span>]), compare_cityes);</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is %d miles from New York City.\n"</span>, city_name, ptr-&gt;miles);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s wasn't found."</span>, city_name);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cityes</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key_ptr, <span class="keyword">const</span> <span class="keyword">void</span> *element_ptr)</span> </span>&#123;</span><br><span class="line">	return <span class="built_in">strcmp</span>((char *) key_ptr, ((struct city_info *) element_ptr)-&gt;city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-5-整数运算函数"><a href="#26-2-5-整数运算函数" class="headerlink" title="26.2.5    整数运算函数"></a>26.2.5    整数运算函数</h3><h4 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; j 需要求绝对值的整数</span><br><span class="line">* @return &#123;int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="labs函数"><a href="#labs函数" class="headerlink" title="labs函数"></a>labs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="llabs函数"><a href="#llabs函数" class="headerlink" title="llabs函数"></a>llabs函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回<code>long long int</code>类型的绝对值。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; j 需要求绝对值的long int值</span><br><span class="line">* @return &#123;long long int&#125; 绝对值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="div函数"><a href="#div函数" class="headerlink" title="div函数"></a>div函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>ldiv</code><br>|比较|<code>div(ldiv)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>div（ldiv）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;int&#125; number 除数</span><br><span class="line">* @param &#123;int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> div (<span class="keyword">int</span> number, <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="ldiv函数（c99）"><a href="#ldiv函数（c99）" class="headerlink" title="ldiv函数（c99）"></a>ldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>优点（相比<code>%</code>和<code>/</code>）：</strong>同<code>div</code><br>|比较|<code>ldiv(div)函数</code>|<code>%</code>和<code>/</code>|<br>|-|-|-|<br>|效率|可能更高，许多计算机可以在一条语句中计算出商和余数|效率低，需要多个指令|<br>|负操作数舍入方式|商：向零舍入；余数：<code>n(原始数) = q(商) x d(除数) + r(余数)</code>|c89中由实现定义，c99中同<code>ldiv（div）函数</code>|<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long int&#125; number 除数</span><br><span class="line">* @param &#123;long  int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h4 id="lldiv函数（c99）"><a href="#lldiv函数（c99）" class="headerlink" title="lldiv函数（c99）"></a>lldiv函数（c99）</h4><hr>
<blockquote>
<p><strong>说明：</strong>用第一个参数除以第二个参数，返回含有<code>商</code>和<code>余数</code>的结构体。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;long long int&#125; number 除数</span><br><span class="line">* @param &#123;long long int&#125; denom 被除数</span><br><span class="line">* @return &#123;div_t&#125; 含有商（quot）和余数（rem）的结构体</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">div_t</span> ldiv (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> number, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<h2 id="26-3-time-h：日期和时间"><a href="#26-3-time-h：日期和时间" class="headerlink" title="26.3    time.h：日期和时间"></a>26.3    time.h：日期和时间</h2><blockquote>
<p><strong>说明：</strong>存储时间的数据结构。</p>
<ul>
<li><code>clock_t</code>：按照“时钟滴答”进行度量的时间值。</li>
<li><code>time_t</code>：紧凑的时间和日期编码（日历时间）</li>
<li><code>struct tm</code>：包含分解的时间的结构体<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-02%20%E4%B8%8B%E5%8D%889.40.49.png" alt="Alt text"><br>❶ 允许两个额外的“闰秒”。c99中最大值为60。<br>❷ 如果夏令时有效，就为正数；如果无效，为零；如果这一信息未知，就为负数。</li>
</ul>
</blockquote>
<h3 id="26-3-1-时间处理函数"><a href="#26-3-1-时间处理函数" class="headerlink" title="26.3.1    时间处理函数"></a>26.3.1    时间处理函数</h3><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回程序从开始执行到当前时刻的处理器时间（时钟数）。<br><strong>原型：</strong><code>stdlib.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @return &#123;clock_t&#125; 程序从此启动到当前经过的处理器时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">clock_t</span> clock (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>技巧：</strong></p>
<ul>
<li>为了将处理器时间转换为秒，将其除以<code>CLOCK_PER_SEC</code>(定义在<code>time.h</code>)。</li>
<li>当用<code>clock</code>函数来确定程序已经运行多长时间时（不包括到达<code>main函数</code>之前的时间），习惯做法时调用<code>clock函数</code>两次：一次在<code>main函数</code>开始处，一次在程序要终止之前。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 第一次调用 */</span></span><br><span class="line">	<span class="keyword">clock_t</span> start_clock = clock();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* 第二次调用 */</span></span><br><span class="line">	<span class="comment">/* CLOCK_PER_SEC：类型由实现定义，c99指定其为clock_t类型 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Processor time used: %g sec.\n"</span>, (clock() - start_clock / (double) CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>返回当前的日历时间。</p>
<ul>
<li>如果参数不为<code>NULL</code>,那么<code>time函数</code>还会把日历时间存储在实参指向的空间中。</li>
</ul>
<p><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t *&#125; timer 指向存储当前日历时间的存储空间（可以为NULL）</span><br><span class="line">* @return &#123;time_t&#125; 当前的日历时间 </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">time_t</span> time (<span class="keyword">time_t</span> *timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用返回值</span></span><br><span class="line">cur_time = time(NULL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过参数指定存储的位置</span></span><br><span class="line">time(&amp;cur_time);</span><br></pre></td></tr></table></figure>
<h4 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>通过两个时间点的日历时间，返回两个时间点之间的时间差（秒）<br><strong>用途：</strong>计算程序的运行时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; 日历时间</span><br><span class="line">* @param &#123;time_t&#125; 日历时间（较早的时间）</span><br><span class="line">* @return &#123;double&#125; time0和time1之间按秒衡量的差值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(time_t time1, time_t time0)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第一个日历时间</span></span><br><span class="line">	<span class="keyword">time_t</span> start_time = time(NUULL);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 第二个日历时间，并计算时间差</span></span><br><span class="line">	ptintf(<span class="string">"Return time: %g sec.\n"</span>, difftime(NULL), start_time);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>把<code>struct tm</code>(分解时间)类型的时间转换为日历时间并返回。<br><strong>用途：</strong>对于和时间、日期相关的计算非常有用。<br><strong>副作用：</strong>会按照一定规则调整结构的成员</p>
<ul>
<li><strong>改变值不在合法范围内的成员：</strong>一个成员的数值的调整可能会导致接连对其它成员的调整，直到全部合法。</li>
<li>初始化<code>tm_wday</code>（一星期的第几天）和<code>tm_yday</code>（一年中的第几天）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明分解时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化分解时间 */</span></span><br><span class="line">t.tm_mday = <span class="number">27</span>;<span class="comment">/* 日 */</span></span><br><span class="line">t.tm_mon = <span class="number">6</span>;<span class="comment">/* 月 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保证其他成员被正确初始化 */</span></span><br><span class="line">t.tm_sec = <span class="number">0</span>;</span><br><span class="line">t.tm_min = <span class="number">0</span>;</span><br><span class="line">t.tm_hour = <span class="number">0</span>;</span><br><span class="line">t.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 制造超出取值范围的情况 */</span></span><br><span class="line">t.tm_mday = += <span class="number">16</span>; <span class="comment">/* 43 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将分解时间转为日历时间，将导致原本的分解时间成员被修改 */</span></span><br><span class="line">mktime(&amp;t);</span><br></pre></td></tr></table></figure>
<p><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.42.02.png" alt="Alt text"></p>
<h3 id="26-3-2-时间转换函数"><a href="#26-3-2-时间转换函数" class="headerlink" title="26.3.2    时间转换函数"></a>26.3.2    时间转换函数</h3><blockquote>
<p><strong>说明：</strong>转换示意图<br> <img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%886.44.39.png" alt="Alt text"><br><strong>注意：</strong>其中的<code>mktime函数</code>被C标准定义为<code>处理函数</code>而不是<code>转换函数</code>。</p>
</blockquote>
<h4 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是<code>UTC</code>(协调世界时间)。<br><strong>注意：</strong>返回值指向的是一个静态分配的结构，会被后续的<code>getime函数</code>或<code>localtime函数</code>调用修改。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; timer 日历时间</span><br><span class="line">* @return &#123;struct tm&#125; 分解时间</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为分解时间，是本地时间。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;&#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span> <span class="params">(<span class="keyword">const</span> time_t *timer)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="asctime函数"><a href="#asctime函数" class="headerlink" title="asctime函数"></a>asctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将分解时间转换为字符串格式。</p>
<blockquote>
<p><code>Sun Jun 3 17:48:34 2007\n</code></p>
</blockquote>
<p><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 指向分解时间结构体的指针</span><br><span class="line">* @return &#123;char *&#125; 字符串形式的时间(ASCII时间)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="ctime函数"><a href="#ctime函数" class="headerlink" title="ctime函数"></a>ctime函数</h4><hr>
<blockquote>
<p><strong>说明：</strong>将日历时间转换为字符串格式。<br><strong>注意：</strong>返回的字符串是一个静态分配的结构，会被后续的<code>asctime函数</code>或<code>strftime函数</code>调用修改。<br><strong>原型：</strong><code>time.h</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;time_t&#125; time 日历时间</span><br><span class="line">* @return &#123;char *&#125; 描述本地时间的字符串</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span> <span class="params">(<span class="keyword">const</span> time_t *time)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="strftime函数"><a href="#strftime函数" class="headerlink" title="strftime函数"></a>strftime函数</h4><hr>
<blockquote>
<p><strong>描述：</strong>把分解时间转换成字符串格式。<br><strong>注意：</strong>函数对地区敏感，改变<code>LC_TIME</code>可能会影响转换说明符的行为。<br><strong>转换说明符：</strong></p>
<ul>
<li>针对<code>&quot;C&quot;</code>地区（c89~c99），支持<code>ISO 8601</code><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.54.27.png" alt="Alt text"><br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.55.24.png" alt="Alt text"></li>
<li>一些转换说明符在<code>&quot;C&quot;</code>地区的替换字符串（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8810.58.53.png" alt="Alt text"></li>
<li><code>E</code>或<code>O</code>修饰符：修改特定的转换说明符，替换为依赖当前地区的备选格式（<code>&quot;C&quot;</code>地区忽略<code>E</code>或<code>O</code>）（c99）<br><img src="http://o6ul1xz4z.bkt.clouddn.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-11-03%20%E4%B8%8B%E5%8D%8811.04.15.png" alt="Alt text"></li>
</ul>
<p><strong>说明：</strong>类似<code>asctime函数</code>，但提供了大量对时间进行格式化的控制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @param &#123;char *&#125; s 指向用来存储字符串形式的时间的空间</span><br><span class="line">* @param &#123;size_t&#125; maxsize 存储在s中的字符数量上限</span><br><span class="line">* @param &#123;char *&#125; format 格式串</span><br><span class="line">* @param &#123;struct tm *&#125; timeptr 分解时间</span><br><span class="line">* @return &#123;size_t&#125; </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">size_t</span> strftime (<span class="keyword">char</span> * <span class="keyword">restrict</span> s, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> format, <span class="keyword">const</span> <span class="keyword">struct</span> tm * restricy timeptr);</span><br></pre></td></tr></table></figure>
<h3 id="程序：显示日期和时间"><a href="#程序：显示日期和时间" class="headerlink" title="程序：显示日期和时间"></a>程序：显示日期和时间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Display the current date and time in three formats</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 1. 获得日历时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> current = time(NULL);</span><br><span class="line">	<span class="keyword">struct</span> tm *ptr;</span><br><span class="line">	<span class="keyword">char</span> date_time[<span class="number">21</span>];</span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="keyword">char</span> am_or_pm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：ctime默认的的字符串形式 */</span></span><br><span class="line">	<span class="built_in">puts</span>(ctime(&amp;current));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期时间：strftime默认的字符串形式 */</span></span><br><span class="line">	strftime(date_time, <span class="keyword">sizeof</span>(date_time), <span class="string">"%m-%d-%Y %I:%M%p\n"</span>, localtime(&amp;current));</span><br><span class="line">	<span class="built_in">puts</span>(date_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打印日期和时间：使用printf结合分解时间 */</span></span><br><span class="line">	ptr = localtime(&amp;current);</span><br><span class="line">	hour = ptr-&gt;tm_hour;</span><br><span class="line">	<span class="keyword">if</span> (hour &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">		am_or_pm = <span class="string">'a'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hour -= <span class="number">12</span>;</span><br><span class="line">		am_or_pm = <span class="string">'p'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour == <span class="number">0</span>) &#123;</span><br><span class="line">		hour = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2d-%.2d-%.2d %2d:%.2d%c\n"</span>, ptr-&gt;tm_mon + <span class="number">1</span>, ptr-&gt;tm_mday, ptr-&gt;tm_year + <span class="number">1900</span>, hour, ptr-&gt;tm_min, am_or_pm);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./datetime</span><br><span class="line"> Wed Nov  4 10:41:12  2015</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41AM</span><br><span class="line"></span><br><span class="line"> 11-04-2015 10:41a</span><br></pre></td></tr></table></figure>

  </section>

</article>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2016 - 
        本站修改自<a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">hexo-theme-vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     
</body>
</html>
